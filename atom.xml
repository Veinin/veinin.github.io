<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Veinin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://veinin.com/"/>
  <updated>2018-08-01T14:39:59.893Z</updated>
  <id>https://veinin.com/</id>
  
  <author>
    <name>Veinin Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开发笔记：游戏 UI 半自动化开发流程</title>
    <link href="https://veinin.com/2018/07/31/dev_notes-game-UI-semi-automated-development/"/>
    <id>https://veinin.com/2018/07/31/dev_notes-game-UI-semi-automated-development/</id>
    <published>2018-07-31T12:10:00.000Z</published>
    <updated>2018-08-01T14:39:59.893Z</updated>
    
    <content type="html"><![CDATA[<p>最近着手试了下我们客户端 UI 开发，发现整个流程对于开发人员来说并不是很友好，我们游戏客户端代码基本使用 Lua 语言进行，引擎则采用 Unity。对于 UI 模块目前有一套基本的 MVC 模式的开发流程，但这个开发模式的边界并没有处理很好，导致开发过程中异常艰难。编写代码的人员有时也会很懵逼，因为实现的方式可以有多种多样。</p><p>在了解了整个旧有的开发流程后，我发现个问题，其中由UI编辑到代码编写，这个流程中，大部分过程都是重复行工作，而针对这一部分重复行工作通过一些小工具可以让UI开发流程实现半自动化。</p><p>所谓半自动化，无非就是，开发人员不需要编写基本的UI代码，基础UI代码可以自动生成，包括整个开发流程中使用的各个UI窗口的组件都可以自动生成代码。</p><p>另外，因为UI编写过程中进程资源修改、代码修改，我希望都可以在修改完后立刻可以看到效果，而不是重启游戏。</p><p>下面是我对于一个半自动化的UI开发流程整理笔记。</p><a id="more"></a><h2 id="UI-编辑流程"><a href="#UI-编辑流程" class="headerlink" title="UI 编辑流程"></a>UI 编辑流程</h2><p>我们的 UI 编辑是一个独立的项目工程，通常一个功能的 UI 编辑会由策划完成一部分工作，程序人员拿过来，按需求再整理 UI 资源、编写代码即可。</p><ol><li>编辑器项目结构</li></ol><p>在UI编辑器中，其文件结构看起来是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">UIProject</span><br><span class="line">    -&gt; Assert</span><br><span class="line">        -&gt; PublicPrefabs - 公共UI</span><br><span class="line">        -&gt; PulibcResources - 公共资源</span><br><span class="line">        -&gt; Texture - 纹理</span><br><span class="line">        -&gt; UI</span><br><span class="line">            -&gt; LoginWindow - 登陆窗口UI</span><br><span class="line">                -&gt; Prefabs</span><br><span class="line">            -&gt; EquipWinodw - 装备窗口UI</span><br><span class="line">                -&gt; Prefabs</span><br><span class="line">            -&gt; TeamWindow  - 组队窗口UI</span><br><span class="line">                -&gt; Prefabs</span><br><span class="line">                    -&gt; TeamCreateView - 队伍创建窗口</span><br><span class="line">                    -&gt; TeamMemberView - 队员窗口</span><br><span class="line">                    -&gt; TeamMemberItem - 队员窗口队伍信息</span><br><span class="line">                    -&gt; ...</span><br><span class="line">                -&gt;  UI资源1.png</span><br><span class="line">                -&gt;  UI资源2.png</span><br><span class="line">                -&gt;  ...</span><br><span class="line">            -&gt; ...</span><br></pre></td></tr></table></figure><p>比如在一个组队功能UI里面，其他包含一个文件夹（TeamWindow），该文件夹下包含了多个UI用到的私有美术资源图片、纹理等。Window 文件夹下，有一个 Prefabs 文件夹，用来保存该功能所用到的所有子UI。</p><p>比如上面队伍窗口（TeamWindow）在UI设计中看起来是这样的：</p><p><img src="/images/mvc/mvc_ui_design.png" alt="mvc"></p><p>其包含3个View文件，两个主要窗口，CreateView用来创建队伍窗口，MemberView用来显示队伍成员窗口，而MemberItem用来显示队伍成员窗口下的队员详细。</p><p>2.UI文件打包</p><p>编辑好的UI会统一打包成一个文件，方便使用代码做资源一次性加载。比如上面TeamWindow，打包后一个统一的资源包文件，包含了上面所示的队伍UI下面的所有子窗口。</p><h2 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h2><p>原有的UI开发流程是使用 MVC 设计模式的，采用这个模式，如果能处理好，开发起来也是会很顺畅的。</p><p>对于 MVC，我们先用一张图来展示：</p><p><img src="/images/mvc/mvc_pattern.png" alt="mvc"></p><p>在 Unity UI 开发中引入 MVC 设计模式，它看起来是这样的：</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><ul><li>其只是用来保存数据用的，其不能访问 View 或 Controller。</li><li>它可以被 Controller 和 View 直接访问。</li></ul><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><ul><li>其只是游戏中能用户看到的 UI 布局。</li><li>View 可以处理 UI 点击逻辑、处理外面传进来的数据，可以访问和修改 Model。</li><li>在 Unity 中，每个 UI 资源的 Prefab 文件都会生成一个与之对应的 View 源代码文件。</li></ul><h3 id="Conroller"><a href="#Conroller" class="headerlink" title="Conroller"></a>Conroller</h3><ul><li>负责控制单个模块内所有 View 资源的加载、显示、关闭、数据更新、分组、层级控制等。</li><li>其持有所有 View 和 Model 对象。</li><li>其销毁后，所有View 和 Model 都会自动销毁。</li></ul><h2 id="MVC-实现"><a href="#MVC-实现" class="headerlink" title="MVC 实现"></a>MVC 实现</h2><p>对于上面所示的MVC模式，我们结合相关MVC特性，用实际代码来展示，下面实例统一采用 Lua 语言，并使用面向对象概念来设计。</p><h3 id="实现一个-Controller-接口"><a href="#实现一个-Controller-接口" class="headerlink" title="实现一个 Controller 接口"></a>实现一个 Controller 接口</h3><p>Controller 是一个UI功能的控制中心，其控制当前Window下的所有UI的加载、显示、隐藏，以及数据保存、清理、传递工作。<br>默认情况下所有子UI（UIView子类）都是会自动被其销毁的，其资源、数据都会在最后一个窗口关闭后自动清理掉。</p><p>Controller 接口完整生命周期示例图如下：</p><p><img src="/images/mvc/mvc_controller_life_cycle.png" alt="mvc"></p><p>实现的 Controller 接口代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIController = Class(<span class="string">'UIController'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.isInit         = <span class="literal">false</span></span><br><span class="line">    self.isPersistent   = opts.isPersistent <span class="comment">-- 是否持久化 model 数据，如果为 true，不会销毁 model 数据</span></span><br><span class="line">    self.prefabsName    = opts.prefabsName  <span class="comment">-- UI 打包后的资源名称</span></span><br><span class="line">    self.assets         = &#123;&#125;                <span class="comment">-- 已经加载的资源</span></span><br><span class="line"></span><br><span class="line">    self.model          = &#123;&#125;                <span class="comment">-- model 数据</span></span><br><span class="line"></span><br><span class="line">    self.viewClasses    = &#123;&#125;                <span class="comment">-- view 资源对应的子类，未实例化</span></span><br><span class="line">    self.openViews      = &#123;&#125;                <span class="comment">-- 已经打开的 view</span></span><br><span class="line">    self.openViewCount  = &#123;&#125;                <span class="comment">-- 已经打开的 view 数量</span></span><br><span class="line">    self.lastOpenData   = <span class="literal">nil</span>               <span class="comment">-- 上次打开 view 时的数据（未初始化时需要先保存打开时数据，初始化完成后再打开）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:IsInit</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> self.isInit</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">OnLoad</span><span class="params">(self, assets)</span></span></span><br><span class="line">    <span class="keyword">for</span> _, asset <span class="keyword">in</span> <span class="built_in">ipairs</span>(assets) <span class="keyword">do</span></span><br><span class="line">        self.assets[asset.name] = asset</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self.isInit = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">next</span>(self.viewClasses) <span class="keyword">then</span></span><br><span class="line">        self:OnInitView()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.lastOpenData <span class="keyword">then</span></span><br><span class="line">        self.Open(<span class="built_in">unpack</span>(self.lastOpenData))</span><br><span class="line">        self.lastOpenData = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        self:OnDefaultOpen()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Init</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> self:IsInit() <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    LoadManager:LoadPrefab(self.prefabsName, <span class="function"><span class="keyword">function</span><span class="params">(assets)</span></span></span><br><span class="line">        OnLoad(self, assets)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:OnInitView</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:RegisterView</span><span class="params">(class)</span></span></span><br><span class="line">    <span class="built_in">assert</span>(self.viewClasses[class.name] == <span class="literal">nil</span>)</span><br><span class="line">    self.viewClasses[class.name] = class</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">CreateView</span><span class="params">(self, name)</span></span></span><br><span class="line">    <span class="keyword">local</span> class = self.viewClasses[name]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> class <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> view = class.New()</span><br><span class="line">    view.controller = self</span><br><span class="line">    view.model      = self.model</span><br><span class="line"></span><br><span class="line">    self.openViews[name] = view</span><br><span class="line">    self.openViewCount = self.openViewCount + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">GetView</span><span class="params">(self, name)</span></span></span><br><span class="line">    <span class="keyword">local</span> view = self.openViews[name]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> view <span class="keyword">then</span></span><br><span class="line">        view = CreateView(self, name)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> view <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> view:IsState(UIConst.LIFESTATE.NONE) <span class="keyword">then</span></span><br><span class="line">        UIHelper.InitView(self, view)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Open</span><span class="params">(name, ...)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self:IsInit() <span class="keyword">then</span></span><br><span class="line">        self.lastOpenData = &#123;name, ...&#125;</span><br><span class="line">        self:Init()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> view = GetView(self, name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> view <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> view:IsState(UIConst.LIFESTATE.SHOW) <span class="keyword">then</span></span><br><span class="line">        view:Update(...)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        view:Open(...)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Close</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> view <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    GameObject.Destroy(view.gameObject)</span><br><span class="line"></span><br><span class="line">    self.openViews[name] = <span class="literal">nil</span></span><br><span class="line">    self.openViewCount = self.openViewCount - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.openViewCount == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        self:Dispose()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Dispose</span><span class="params">()</span></span></span><br><span class="line">    self.isInit = <span class="literal">false</span></span><br><span class="line">    self.assets = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    LoadManager:RemovePrefab(self.prefabsName)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.isPersistent <span class="keyword">then</span></span><br><span class="line">        self.model = &#123;&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self:OnDispose()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:OnDispose</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIController</span><br></pre></td></tr></table></figure><p>根据上面生命周期实例图和代码实现，我们可以看到 Contoller 入口有两个，一个是外部打开指定 View，一个是外部关闭指定 View。</p><p>当外部需要打开指定 View 时，我们先检查当前 Controller 是否初始化完成，如果未初始化，则先临时保存打开时的数据，然后再走初始化 Controller 逻辑，加载 UI 资源。</p><p>当加载 UI 资源完成后，我们通过 View 的名称，调用 <code>GetView()</code> 函数获取一个 View 对象，如果 View 对象未创建，则走创建对象逻辑 <code>CreateView()</code>，并调用 View 初始化逻辑（下一节详解）。</p><p>获取到 View 对象后，如果 View 是打开状态则调用 <code>UIView.Update(...)</code> 函数更新，关闭状态则调用 <code>UIView:Open(...)</code> 函数打开。</p><p>UIController 对外暴露一个公共接口：</p><ul><li><code>UIController.Open(name, ...)</code>，用于外部打开指定 View 。</li><li><code>UIController.RegisterView(class)</code>，用于注册一个 View 子类，通过其来实例化相应的 UI 窗口。</li><li><code>UIController.Close(view)</code>，用于关闭一个 View，这个接口用于 View 为了关闭自己而调用。</li></ul><p>UIController 作为一个父类，需要子类重写以下接口：</p><ul><li><code>UIController.OnInitView()</code>，初始化所有View，调用 <code>RegisterView</code> 注册指定 View。</li><li><code>UIController.OnDispose()</code>，销毁整个 Controller 的后续处理。</li></ul><h3 id="实现一个-View-接口"><a href="#实现一个-View-接口" class="headerlink" title="实现一个 View 接口"></a>实现一个 View 接口</h3><p>View 接口是所有UI资源窗口的父类，子类通过继承方式实现一个UI子窗口显示。<br>View 子类可以直接访问和修改 model 数据，另外，我希望在 View 中能间接调用 Controller 打开其他窗口。</p><p>View 接口完整生命周期示例图如下：</p><p><img src="/images/mvc/mvc_view_life_cycle.png" alt="mvc"></p><p>根据上面生命周期实例图，我们可以看出整个 View 对象从初始化到关闭的完整生命周期流程。我们把 View 生命周期状态分为3部分：</p><ul><li>NONE，未初始化状态</li><li>HIDE，隐藏状态</li><li>SHOW，打开状态</li></ul><p>根据上面的状态图，我们先实现 View 接口代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIView = Class(<span class="string">'UIView'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Ctor</span><span class="params">()</span></span></span><br><span class="line">    self.controller    = <span class="literal">nil</span> <span class="comment">-- 持有 View 的 UIController 对象</span></span><br><span class="line">    self.model         = <span class="literal">nil</span> <span class="comment">-- View 持有的 Model 数据，与 UIController 共享</span></span><br><span class="line"></span><br><span class="line">    self.gameObject    = <span class="literal">nil</span>   <span class="comment">-- 引擎对象，该对象保存着UI资源</span></span><br><span class="line">    self.isAutoDestroy = <span class="literal">false</span> <span class="comment">-- 是否自动销毁，默认关闭时直接销毁对象，如果不自动销毁，关闭动作时隐藏</span></span><br><span class="line">    self.layer         = UIConst.LAYER.MIDDLE   <span class="comment">-- UI 层级（高、中、低）</span></span><br><span class="line">    self.lifeState     = UIConst.LIFESTATE.NONE <span class="comment">-- UI 生命周期状态</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:IsState</span><span class="params">(state)</span></span></span><br><span class="line">    <span class="keyword">return</span> self.lifeState == state</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Init</span><span class="params">()</span></span></span><br><span class="line">    self.gameObject:SetActive(<span class="literal">false</span>)</span><br><span class="line">    self.lifeState = UIConst.LIFESTATE.HIDE</span><br><span class="line">    self:OnInit()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OpenView</span><span class="params">(name, ...)</span></span></span><br><span class="line">    self.controller:Open(name, ...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Open</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self:IsState(UIConst.LIFESTATE.HIDE) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self.lifeState = UIConst.LIFESTATE.SHOW</span><br><span class="line">    self.gameObject:SetActive(<span class="literal">true</span>)</span><br><span class="line">    self:OnShow(...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Update</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self:IsState(UIConst.LIFESTATE.SHOW) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self:OnUpdate(...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Close</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self:IsState(UIConst.LIFESTATE.SHOW) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self:OnHide()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.isAutoDestroy <span class="keyword">then</span></span><br><span class="line">        self.controller:Close(self)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        self.gameObject:SetActive(<span class="literal">false</span>)</span><br><span class="line">        self.lifeState = UIConst.LIFE_STATE.HIDE</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OnInit</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OnShow</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OnUpdate</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OnHide</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIView</span><br></pre></td></tr></table></figure><p>View 初始化时，会从引擎底层加载 UI 编辑器指定的 UI 组件到 View 对象，这一步是 Contoller 在创建 View 时执行的，我们可以看到 <code>UIContoller.GetView()</code> 函数调用时，判断当前 View 对象如果是未初始化状态则调用帮助函数 <code>UIHelper.InitView()</code> 加载所有 UI 组件对象，其加载代码看起来时这样的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIHelper = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Lua 封装的 UI 组件对象</span></span><br><span class="line"><span class="keyword">local</span> UI_TYPES = &#123;</span><br><span class="line">    [<span class="string">'UIButton'</span>]        = <span class="built_in">require</span>(<span class="string">"game.ui.component.UIButton"</span>),</span><br><span class="line">    [<span class="string">'UILabel'</span>]         = <span class="built_in">require</span>(<span class="string">"game.ui.component.UILabel"</span>),</span><br><span class="line">    [<span class="string">'UIInputField'</span>]    = <span class="built_in">require</span>(<span class="string">"game.ui.component.UIInputField"</span>),</span><br><span class="line">    <span class="comment">-- 其他 UI 组件...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建引擎 UI 对象</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">CreateCSObject</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- TODO 创建引擎UI对象，设置其层级关系</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化所以 UI 组件Lua对象</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">InitComponents</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="keyword">local</span> components = view.gameObject.components</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, component <span class="keyword">in</span> <span class="built_in">ipairs</span>(components) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> uiLuaClass = UI_TYPES[component.typeName]</span><br><span class="line">        <span class="keyword">if</span> uiLuaClass <span class="keyword">then</span></span><br><span class="line">            view[component.key] = uiLuaClass.New(component.value)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化 UIView 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIHelper.InitView</span><span class="params">(view)</span></span></span><br><span class="line">    view.gameObject = CreateCSObject(view)</span><br><span class="line"></span><br><span class="line">    InitComponents(view)</span><br><span class="line"></span><br><span class="line">    view:Init()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIHelper</span><br></pre></td></tr></table></figure><p>在我们可以看到所有 UI 组件都在 Lua 层有一个简单的封装对象，我们在 UI 编辑器指定 UI 组件名称和类型后，在加载完 View 对象后，其 UI 组件就被赋予给了 View 对象。下面给出了一个按钮组件的简单封装实例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIButton = Class(<span class="string">'UIButton'</span>, UIBehaviour)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIButton:SetText</span><span class="params">(name)</span></span></span><br><span class="line">    self.core.text = name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIButton:SetEnable</span><span class="params">(isEnable)</span></span></span><br><span class="line">    self.core:SetEnable(isEnable)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIButton:AddListener</span><span class="params">(callback, delayTime)</span></span></span><br><span class="line">    delayTime = delayTime <span class="keyword">or</span> <span class="number">0.3</span></span><br><span class="line">    self.event.onClickLua = callback</span><br><span class="line">    self.event.clickDelayTime = delayTime</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIButton</span><br></pre></td></tr></table></figure><p>View 初始化完成后，每次打开时，都会传入打开时需要的数据，我们根据状态，把数据传给不同的处理函数。当前 UI 处于打开状态时调用 <code>UIView.Open()</code>；处于显示状态，则调用 <code>UIView.Update()</code>。最后可以使用 <code>UIView.Close()</code> 关闭 View。</p><p>UIView 对外暴露一个公共接口：</p><ul><li><code>UIView.Init()</code>，初始化 View，初始化完成后调用一次 <code>UIView.OnInit()</code>。</li><li><code>UIView.Open(...)</code>，当 View 处于隐藏状态时，打开 View，最终会调用 <code>UIView.OnShow()</code> 处理。</li><li><code>UIView.Update(...)</code>，当 View 处于打开状态时，更新 View 数据，最终会调用 <code>UIView.OnUpdate()</code> 处理。</li><li><code>UIView.Close(...)</code>，用于关闭当前 UI，并调用 <code>UIView.OnHide()</code> 处理 View 隐藏后逻辑，其资源清理逻辑最终会交给 Controller 执行。</li><li><code>UIView.OpenView(name)</code>，用于打开其他 View，其打开逻辑会交给 Controller 执行。</li></ul><p>UIView 作为一个父类，需要子类重写以下接口：</p><ul><li><code>UIView.OnInit()</code>，初始化View，我们需要做一些 UI 组件事件注册逻辑处理，如果某个按钮点击后的逻辑，因为这些逻辑固定不变的，整个 View 生命周期只会调用过一次。</li><li><code>UIView.OnShow()</code>，如果 View 隐藏状态，在打开 View 时，会调用此函数，并传入打开 UI 时需要处理的数据。</li><li><code>UIView.OnUpdate()</code>，如果 View 打开状态，在打开 View 时，会调用此函数，并传入打开 UI 时需要处理的数据。</li><li><code>UIView.OnHide()</code>，当 View 被调用 UIView.Close(…) 时，在销毁前，会被调用，需要在此函数内处理关闭 View 时的逻辑。</li></ul><h2 id="View-分组"><a href="#View-分组" class="headerlink" title="View 分组"></a>View 分组</h2><p>在复杂的游戏 UI 功能开发时，常常遇到这些的问题：</p><ul><li>同一个 UI 窗口内，我们希望某一组 UI 是互斥的，即同一时间内，Controller 只能打开该组内的某一个 View，如果同组有其他 View 打开则先关闭一打开的 View。</li><li>有一些 UI 分组，在某个指定 UI 关闭后，其分组内的任何 UI 只要打开都会自动关闭。</li></ul><p>看到这些需求后，我们很快想到使用一颗树来管理这些 UI View 分组。其分组示例图如下：</p><p><img src="/images/mvc/mvc_view_group.png" alt="mvc"></p><p>从图中我们可以看到，这是一个树形结构的 UI 分组，有一个根节点，子节点之间是分层的，每一层节点之间可以设置未互斥状态，即同一时间内，只能被打开一个。<br>有了这个树形结构，当某个节点被关闭后，我们可以很快获取到这个节点的所有子节点，并关闭它们。</p><p>于是可以设计一个 UI 分组代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Tree = <span class="built_in">require</span> <span class="string">"game.foundation.Tree"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> UIGroupTree = Class(<span class="string">'UIGroupTree'</span>, Tree)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIGroupTree:Ctor</span><span class="params">()</span></span></span><br><span class="line">    self.isExclusion = <span class="literal">true</span> <span class="comment">-- 子节点是否互斥，默认未互斥</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIGroupTree:SetExclusion</span><span class="params">(isExclusion)</span></span></span><br><span class="line">    self.isExclusion = isExclusion</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIGroupTree:IsExclusion</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> self.isExclusion</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIGroupTree:AddChildUI</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="keyword">return</span> self.NewChild(view.name)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIGroupTree</span><br></pre></td></tr></table></figure><p>代码中树形结构 <code>Tree</code> 实现请参考外部 <a href="https://gist.github.com/Veinin/a9fbf71f6a82938100dff7fbff501495" target="_blank" rel="noopener">链接</a>。</p><p>然后我们拓展 Contoller 接口实现：</p><ul><li>加入新的成员变量 group (UIGroupTree类型)</li><li>加入创建 UI 分组对象函数，<code>UIController.NewGroup(view)</code>，用于创建一个分组。</li><li>加入新的抽象函数 <code>UIController.OnInitGroup()</code>，子类如需要UI分组，则重写该函数，该函数在 Controller 初始化时被调用。</li><li>打开某个 UI 时检查 View 对象是否分组、分组是否互斥、是否有互斥 View 已打开，如果打开则关闭互斥 View。</li><li>关闭某个 UI 时检查 View 对象是否分组，当前节点是否存在子节点，子节点是否有打开情况，如果打开则关闭 View。</li></ul><p>扩展 Controller 的代码实现如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIGroupTree = <span class="built_in">require</span> <span class="string">"game.ui.group.UIGroupTree"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> UIController:Ctor()</span><br><span class="line">    <span class="comment">-- 上面已实现代码省略...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">OnLoad</span><span class="params">(self, assets)</span></span></span><br><span class="line">    <span class="comment">-- 上面已实现代码省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">next</span>(self.viewClasses) <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- ...</span></span><br><span class="line">        self:OnInitGroup()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:OnInitGroup</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- 子类实现</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个UI分组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:NewGroup</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="built_in">assert</span>(self.group == <span class="literal">nil</span>, <span class="string">"不允许创建多个分组"</span>)</span><br><span class="line">    self.group = UIGroupTree.New(view.name)</span><br><span class="line">    <span class="keyword">return</span> self.group</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查互斥</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">CheckExclusion</span><span class="params">(self, view)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.group <span class="keyword">or</span> self.openViewCount == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> name = view.name</span><br><span class="line">    <span class="keyword">local</span> node = self.group:FindChild(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> parent = node:GetParent()</span><br><span class="line">    <span class="keyword">if</span> #parent == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> parent:IsExclusion() <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> childName</span><br><span class="line">    <span class="keyword">local</span> childView</span><br><span class="line">    <span class="keyword">for</span> _, child <span class="keyword">in</span> <span class="built_in">ipairs</span>(parent) <span class="keyword">do</span></span><br><span class="line">        childName = child.name</span><br><span class="line">        childView = self.openViews[childName]</span><br><span class="line">        <span class="keyword">if</span> childName ~= name <span class="keyword">and</span> childView <span class="keyword">then</span> <span class="comment">-- 如果打开则关闭</span></span><br><span class="line">            self:Close(childView)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Open</span><span class="params">(name, ...)</span></span></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 打开前检查分组互斥</span></span><br><span class="line">    CheckExclusion(self, view)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> view:IsState(UIConst.LIFESTATE.SHOW) <span class="keyword">then</span></span><br><span class="line">        view:Update(...)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        view:Open(...)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查子节点关闭</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">CheckCloseChild</span><span class="params">(self, view)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.group <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> name = view.name</span><br><span class="line">    <span class="keyword">local</span> node = self.group:FindChild(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> childView</span><br><span class="line">    node:IterativeChildren(<span class="function"><span class="keyword">function</span><span class="params">(child)</span></span></span><br><span class="line">        childView = self.openViews[child.value]</span><br><span class="line">        <span class="keyword">if</span> childView <span class="keyword">then</span>  <span class="comment">-- 如果子节点打开则关闭</span></span><br><span class="line">            self:Close(childView)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Close</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.openViewCount == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        self:Dispose()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">-- 还有打开的 View，检查是否其子节点，并关闭</span></span><br><span class="line">        CheckCloseChild(self, view)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIController</span><br></pre></td></tr></table></figure><p>有了上面扩展实现的代码，我们就实现分组示例图中展示的分组结构：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyTestController:OnInitGroup</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> root = self:NewGroup(UIView1)</span><br><span class="line">    root:AddChild(UIView2)</span><br><span class="line">    root:AddChild(UIView3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> child = root:AddChild(UIView4)</span><br><span class="line">    child:AddChild(UIView5)</span><br><span class="line">    child:AddChild(UIView6)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="UI-开发半自动化"><a href="#UI-开发半自动化" class="headerlink" title="UI 开发半自动化"></a>UI 开发半自动化</h2><p>我们知道，游戏 UI 开发，很多固定的流程其实是可以省略的：</p><ul><li>UI 编辑完成后，开始写业务代码时，可以将所有基础代码全部生成，比如上面的 Controller 子类和每个窗口的 View 子类。</li><li>每个 View 类型，我们设计时其会对应 UI 编辑器的一个界面，且 UI 编辑器里面的所有组件，都是可以读取到的，在 Unity 中，我们保存为 Prefab 文件，而这个文件可以帮助我们设计一个自动生成代码的工具。</li><li>每次修改 UI 增加了新的组件后，我们希望原有的已经编辑的代码可以保留，在编辑器中刷新一下代码，能将新增加的控件基础代码直接加入到相应的代码文件里面。</li><li>每次修改完 UI 资源后，然后对应改完代码后，不希望在游戏中重启客户端才能看到效果，所以，我们加入了热更机制，任何代码都是可以热更新的，那么 UI 开发人员编码阶段将会非常方便。</li></ul><p>综上考虑，因为我们项目很多人使用 <strong>IntelliJ IDEA</strong> 配合一个不错的 Lua 插件 <strong>EmmyLua</strong>， 相对来说使用 Lua 开发还是比较顺畅的。所以决定在 <strong>IntelliJ IDEA</strong> 平台上开发一个为项目定制的 UI 开发插件（当然现在一些主流的代码编辑器都支持插件编写，你可以很容易在其他编辑器中实现这些内容）。</p><p>在UI编辑完成后，开发人员，建立 UI 功能开发文件夹后，右键菜单点击生成代码，插件自动生成 UIController 和 UIView 对应子类。</p><p>比如一个组队功能包含以下 UI 文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> TeamWindow</span><br><span class="line">    -&gt; Prefabs</span><br><span class="line">        -&gt; CreateView.prefab</span><br><span class="line">        -&gt; MemberView.prefab</span><br><span class="line">        -&gt; MemberItem.prefab</span><br></pre></td></tr></table></figure><p>生成的代码文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> team</span><br><span class="line">    -&gt; contoller</span><br><span class="line">        -&gt; TeamController.lua</span><br><span class="line">    -&gt; views</span><br><span class="line">        -&gt; CreateView.lua</span><br><span class="line">        -&gt; MemberView.lua</span><br><span class="line">    -&gt; protocol</span><br><span class="line">        -&gt; TeamProtocol.lua -- 协议文件，项目定制</span><br></pre></td></tr></table></figure><p>下面是 Contoller 实例 <code>TeamController.lua</code> 文件内容，该文件自动生成了很多基础的代码，需要填写的地方只剩下分组（如需要）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIController = <span class="built_in">require</span> <span class="string">"game.ui.core.UIController"</span></span><br><span class="line"><span class="keyword">local</span> CreateView = <span class="built_in">require</span> <span class="string">"game.ui.team.views.CreateView"</span></span><br><span class="line"><span class="keyword">local</span> MemberView = <span class="built_in">require</span> <span class="string">"game.ui.team.views.MemberView"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> TeamController = Class(<span class="string">'TeamController'</span>, UIController)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TeamController:OnInitView</span><span class="params">()</span></span></span><br><span class="line">    self:RegisterView(CreateView)</span><br><span class="line">    self:RegisterView(MemberView)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">funciton TeamController:OnInitGroup()</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TeamController</span><br></pre></td></tr></table></figure><p>下面是一个 View 实例 CreateView.lua 文件内容，其基本的组件代码全部通过编辑器UI文件自动生成，开发人员只需要在对应的 UI 组件填入相对于的业务逻辑即可：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIView = <span class="built_in">require</span> <span class="string">"game.ui.core.UIView"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> CreateView = Class(<span class="string">'CreateView'</span>, UIView)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:Ctor</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:OnInit</span><span class="params">()</span></span></span><br><span class="line">    self.closeButton:AddListener(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        self:Close()</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    self.cofirmButton:AddListener(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="comment">-- 开发人员实现创建队伍逻辑</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:OnShow</span><span class="params">(...)</span></span></span><br><span class="line">    self.nameInputField:SetText()</span><br><span class="line">    self.fightINputField:SetText()</span><br><span class="line">    self.levelInputField:SetText()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:OnUpdate</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:OnHide</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CreateView</span><br></pre></td></tr></table></figure><p>为了对比，下面展示以下 <code>CreateView.lua</code> 对应 <code>CreateView.prefab</code> 文件结构：</p><p><img src="/images/mvc/create_view.png" alt="mvc"></p><p>可以看出这个 UI 有5个需要处理的组件，两个按钮（关闭、确定），3个输入文本框（队伍名称、队伍战力、最低等级）。我们可以很容易从编辑的 prefab 文件中提取到里面的 UI 组件，然后通过插件直接生成代码文件。</p><p>有了上面的这些自动生成的代码，剩下的工作，其实就是填写一些基础的业务逻辑，那些重复性的工作工具已经可以帮你很好的完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文阐述了一个半自动化工作的游戏 UI 编写流程，并给出了实现步骤。<br>游戏 UI 开发流程存在大部分重复工作，我们稍微花点时间，其实是可以把这些重复工作自动化的，剩下的工作，无非就是填写下业务逻辑代码。<br>可以预见的是，开发这么一套半自动化的工具其实不到一周时间，其实是可以很容易搞定的，并且后续的 UI 开发效率其实是提升了一个档次。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近着手试了下我们客户端 UI 开发，发现整个流程对于开发人员来说并不是很友好，我们游戏客户端代码基本使用 Lua 语言进行，引擎则采用 Unity。对于 UI 模块目前有一套基本的 MVC 模式的开发流程，但这个开发模式的边界并没有处理很好，导致开发过程中异常艰难。编写代码的人员有时也会很懵逼，因为实现的方式可以有多种多样。&lt;/p&gt;
&lt;p&gt;在了解了整个旧有的开发流程后，我发现个问题，其中由UI编辑到代码编写，这个流程中，大部分过程都是重复行工作，而针对这一部分重复行工作通过一些小工具可以让UI开发流程实现半自动化。&lt;/p&gt;
&lt;p&gt;所谓半自动化，无非就是，开发人员不需要编写基本的UI代码，基础UI代码可以自动生成，包括整个开发流程中使用的各个UI窗口的组件都可以自动生成代码。&lt;/p&gt;
&lt;p&gt;另外，因为UI编写过程中进程资源修改、代码修改，我希望都可以在修改完后立刻可以看到效果，而不是重启游戏。&lt;/p&gt;
&lt;p&gt;下面是我对于一个半自动化的UI开发流程整理笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://veinin.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="半自动化，游戏UI开发，Unity" scheme="https://veinin.com/tags/%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%8C%E6%B8%B8%E6%88%8FUI%E5%BC%80%E5%8F%91%EF%BC%8CUnity/"/>
    
      <category term="MVC" scheme="https://veinin.com/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-线程同步精要</title>
    <link href="https://veinin.com/2018/06/25/programming_with_posix_pthreads_08/"/>
    <id>https://veinin.com/2018/06/25/programming_with_posix_pthreads_08/</id>
    <published>2018-06-25T06:11:13.000Z</published>
    <updated>2018-07-12T14:44:50.554Z</updated>
    
    <content type="html"><![CDATA[<p>本章节摘录自陈硕 《Linux多线程服务端编程:使用muduoC++网络库》 第二章关于线程同步笔记。</p><h2 id="线程同步四项原则"><a href="#线程同步四项原则" class="headerlink" title="线程同步四项原则"></a>线程同步四项原则</h2><p>线程同步的四项原则，按重要性排列：</p><ul><li>首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑 <code>immutable</code> 对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。</li><li>其次是使用高级的并发编程构件，如 <code>TaskQueue</code>、<code>Producer-ConsumerQueue</code>、<code>CountDownLatch</code> 等等。</li><li>最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。</li><li>除了使用 <code>atomic</code> 整数之外，不自己编写 <code>lock-free</code> 代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如<code>spin lock</code> vs <code>mutex</code>。</li></ul><a id="more"></a><h2 id="互斥器（mutex）"><a href="#互斥器（mutex）" class="headerlink" title="互斥器（mutex）"></a>互斥器（mutex）</h2><p>互斥器（mutex）是使用得最多的同步原语，粗略地说，它保护了临界区，任何一个时刻最多只能有一个线程在此 mutex 划出的临界区内活动。单独使用 mutex 时，我们主要为了保护共享数据。</p><p>主要原则：</p><ul><li>在C++中，应该使用用<code>RAII</code>手法封装<code>mutex</code>的创建、销毁、加锁、解锁这四个操作。Java里的 <code>synchronized</code> 语句和C#的 <code>using</code> 语句也有类似的效果，即保证锁的生效期间等于一个作用域（scope），不会因异常而忘记解锁。</li><li>只用非递归的 <code>mutex</code>（即不可重入的mutex）。</li><li>不手工调用 <code>lock()</code> 和 <code>unlock()</code> 函数，</li><li>在每次构造 <code>Guard</code> 对象的时候，思考一路上（调用栈上）已经持有的锁，防止因加锁顺序不同而导致死锁（deadlock）。</li></ul><p>次要原则：</p><ul><li>不使用跨进程的 <code>mutex</code>，进程间通信只用 TCPsockets。</li><li>加锁、解锁在同一个线程，线程a不能去 <code>unlock</code> 线程b已经锁住的 <code>mutex</code>（RAII自动保证）。 别忘了解锁（RAII自动保证）。</li><li>不重复解锁（RAII自动保证）。</li><li>必要的时候可以考虑用 <code>PTHREAD_MUTEX_ERRORCHECK</code> 来排错。</li></ul><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>互斥器（mutex）是加锁原语，用来排他性地访问共享数据，它不是等待原语。在使用 mutex 的时候，我们一般都会期望加锁不要阻塞，总是能立刻拿到锁。然后尽快访问数据，用完之后尽快解锁，这样才能不影响并发性和性能。</p><p>如果需要等待某个条件成立，我们应该使用条件变量（conditionvariable）。条件变量顾名思义是一个或多个线程等待某个布尔表达式为真，即等待别的线程“唤醒”它。条件变量只有一种正确使用的方式，几乎不可能用错。</p><p>对于wait端：</p><ul><li>必须与 <code>mutex</code> 一起使用，该布尔表达式的读写需受此mutex保护。</li><li>在 <code>mutex</code> 已上锁的时候才能调用 <code>wait()</code>。</li><li>把判断布尔条件和 <code>wait()</code> 放到 <code>while</code> 循环中。</li></ul><p>对于 signal/broadcast 端：</p><ul><li>不一定要在 <code>mutex</code> 已上锁的情况下调用 <code>signal</code>（理论上）。</li><li>在 <code>signal</code> 之前一般要修改布尔表达式。</li><li>修改布尔表达式通常要用 <code>mutex</code> 保护（至少用作fullmemorybarrier）。</li><li>注意区分 <code>signal</code> 与 <code>broadcast</code>： <code>broadcast</code> 通常用于表明状态变化，<code>signal</code> 通常用于表示资源。</li></ul><p>条件变量是非常底层的同步原语，很少直接使用，一般都是用它来实现高层的同步措施，如 <code>BlockingQueue&lt;T&gt;</code> 或 <code>CountDownLatch</code>。</p><p>倒计时（CountDownLatch）是一种常用且易用的同步手段。它主要有两种用途：</p><ul><li>主线程发起多个子线程，等这些子线程各自都完成一定的任务之后，主线程才继续执行。通常用于主线程等待多个子线程完成初始化。</li><li>主线程发起多个子线程，子线程都等待主线程，主线程完成其他一些任务之后通知所有子线程开始执行。通常用于多个子线程等待主线程发出“起跑”命令。</li></ul><h2 id="不要使用读写锁和信号量"><a href="#不要使用读写锁和信号量" class="headerlink" title="不要使用读写锁和信号量"></a>不要使用读写锁和信号量</h2><p>读写锁（Readers-Writerlock，简写为rwlock）是个看上去很美的抽象，它明确区分了 read 和 write 两种行为。</p><p>初学者常干的一件事情是，一见到某个共享数据结构频繁读而很少写，就把 mutex 替换为 rwlock。甚至首选 rwlock 来保护共享状态，这不见得是正确的。</p><ul><li>从正确性方面来说，一种典型的易犯错误是在持有 readlock 的时候修改了共享数据。这通常发生在程序的维护阶段，为了新增功能，程序员不小心在原来 readlock 保护的函数中调用了会修改状态的函数。这种错误的后果跟无保护并发读写共享数据是一样的。</li><li>从性能方面来说，读写锁不见得比普通 mutex 更高效。无论如何 readerlock 加锁的开销不会比 mutexlock 小，因为它要更新当前 reader 的数目。如果临界区很小，锁竞争不激烈，那么 mutex 往往会更快。</li><li>readerlock 可能允许提升为 writerlock，也可能不允许提升。如果处理不好容易导致程序崩溃和死锁。</li><li>通常 readerlock 是可重入的，writerlock 是不可重入的。但是为了防止 writer 饥饿，writerlock通常会阻塞后来的readerlock，因此 readerlock 在重入的时候可能死锁。另外，在追求低延迟读取的场合也不适用读写锁。</li></ul><p>对于信号量（Semaphore），陈硕认为信号量不是必备的同步原语，因为条件变量配合互斥器可以完全替代其功能，而且更不易用错。<br>信号量的另一个问题在于它有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能。</p><h2 id="归纳与总结"><a href="#归纳与总结" class="headerlink" title="归纳与总结"></a>归纳与总结</h2><p>作者认为，应该先把程序写正确（并尽量保持清晰和简单），然后再考虑性能优化，如果确实还有必要优化的话。这在多线程下仍然成立。让一个正确的程序变快，远比“让一个快的程序变正确”容易得多。</p><p>“效率”并不是我的主要考虑点，我提倡正确加锁而不是自己编写 <code>lock-free</code>算法（使用原子整数除外），更不要想当然地自己发明同步设施。在没有实测数据支持的情况下，妄谈哪种做法效率更高是靠不住的，不能听信传言或凭感觉“优化”。很多人误认为用锁会让程序变慢，其实真正影响性能的不是锁，而是锁争用（lockcontention）。</p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章节摘录自陈硕 《Linux多线程服务端编程:使用muduoC++网络库》 第二章关于线程同步笔记。&lt;/p&gt;
&lt;h2 id=&quot;线程同步四项原则&quot;&gt;&lt;a href=&quot;#线程同步四项原则&quot; class=&quot;headerlink&quot; title=&quot;线程同步四项原则&quot;&gt;&lt;/a&gt;线程同步四项原则&lt;/h2&gt;&lt;p&gt;线程同步的四项原则，按重要性排列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑 &lt;code&gt;immutable&lt;/code&gt; 对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。&lt;/li&gt;
&lt;li&gt;其次是使用高级的并发编程构件，如 &lt;code&gt;TaskQueue&lt;/code&gt;、&lt;code&gt;Producer-ConsumerQueue&lt;/code&gt;、&lt;code&gt;CountDownLatch&lt;/code&gt; 等等。&lt;/li&gt;
&lt;li&gt;最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。&lt;/li&gt;
&lt;li&gt;除了使用 &lt;code&gt;atomic&lt;/code&gt; 整数之外，不自己编写 &lt;code&gt;lock-free&lt;/code&gt; 代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如&lt;code&gt;spin lock&lt;/code&gt; vs &lt;code&gt;mutex&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-线程扩展</title>
    <link href="https://veinin.com/2018/06/20/programming_with_posix_pthreads_07/"/>
    <id>https://veinin.com/2018/06/20/programming_with_posix_pthreads_07/</id>
    <published>2018-06-20T14:12:24.000Z</published>
    <updated>2018-07-12T14:44:39.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栅栏（Barriers）"><a href="#栅栏（Barriers）" class="headerlink" title="栅栏（Barriers）"></a>栅栏（Barriers）</h2><p>barrier 字面意思时栅栏，barrier 是将一组成员保持在一起的一种方式，它可以实现让一组线程等待至某个状之后再全部同时执行。一个 barrier 通常被用来确保某些井行算法中的所有合作线程在任何线程可以继续运行之前到达算法中的一个特定点。</p><p>barrier 的核心是一个计数器，我们可以称之为“阈值”，即在一个 barrier 上必须等待的线程数。计时器计算着当前线程的返回数量，如果数量未达到指定点，那么之前返回的线程都必须继续等待，直到最后一个线程返回，才能开始下一步。</p><a id="more"></a><p>你可以查看源文件 <code>barrier.h</code> 、<code>barrier.c</code>、<code>barrier_main.c</code>，这是一个比较容易理解的实现。</p><p>另外 Pthreads 在 POSIX.14 草案标准（一个 “POSIX 标准子集”）中新增加了 Barriers 变量，其 API 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(<span class="keyword">pthread_barrier_t</span> * <span class="keyword">restrict</span> barrier, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br></pre></td></tr></table></figure><p>源文件 <code>pthread_barrier.c</code> 是一个 Pthreads barrier 的简单实例。</p><h2 id="读-写锁（Read-Write-Lock）"><a href="#读-写锁（Read-Write-Lock）" class="headerlink" title="读/写锁（Read-Write Lock）"></a>读/写锁（Read-Write Lock）</h2><p>读/写锁很像一个互斥量，它是阻止多个线程同时修改共享数据的另外一种方。但是不同于互斥量的是它区分读数据和写数据。一个互斥量排除所有的其他线程，而一个读/写锁如果线程不需要改变数据，则允许多个线程同时读数据。当一个线程需要更新缓存数据是，则必须以独占的方式进行，其他只读线程都不能继续占有锁。</p><p>读/写锁被用来保护经常需要读但是通常不需要修改的信息（读多写少）。当写锁被释放时，如果读数据者和写数据者同时正在等待存取，则读数据者被优先给予访问权。因为潜在地允许许多线程同时完成工作，读访问优先有利于并发。</p><p>文件 <code>rwlock.h</code> 、<code>rwlock.c</code>、<code>rwlock_main.c</code> 演示了如何使用标准的 Pthreads 互斥量和状况变量实现读写锁， 这是相对容易理解的可移植的实现。</p><p>另外，在最新版本的 <code>X/Open XSH5 [UNIX98]</code> 标准中，Pthreads 增加了读写锁的支持，读写锁的数据类型为 <code>pthread_rwlock_t</code>，如果需要静态分配该类型数据，那么可通过<code>PTHREAD_RWLOCK_INITIALIZER</code> 宏来初始化它。Pthreads 读写锁 API 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> lock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * <span class="keyword">restrict</span> lock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> * <span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * <span class="keyword">restrict</span> lock, <span class="keyword">const</span> struct timespec * <span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * <span class="keyword">restrict</span> lock, <span class="keyword">const</span> struct timespec * <span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br></pre></td></tr></table></figure><p>你可以查看源文件 <code>pthread_rwlock.c</code>，这是简单的 Pthread 读写锁的使用实例。</p><h2 id="自旋锁（Spin-Locks）"><a href="#自旋锁（Spin-Locks）" class="headerlink" title="自旋锁（Spin Locks）"></a>自旋锁（Spin Locks）</h2><p>自旋锁（Spinlock）也是一种锁，自旋锁在线程尝试获取它时，会在一个循环中不停等待（旋转），同时反复检查锁是否可用。由于线程始终保持活动状态且并没有执行有用的任务，因此使用这种锁时将产生一种忙碌的等待情况。</p><p>因为在一些多线程场景中我们需要避免操作系统进程的重新调度或者上下文的切换开销，所以如果线程仅仅只是短时间内被阻塞，那么使用自旋锁将是一种非常有效的方式。但是，如果你的程序需要比较长的时间保持锁的使用，那么自旋锁将会变的浪费，因为它会阻止其他线程运行。线程持有锁的时间越长，操作系统调度程序在保持锁定时中断线程的风险就越大。在这种情况下，其他线程将会不停“旋转”（反复尝试获取锁定），而持有锁的线程没有进行释放。结果将是无限期推迟，直到持有锁的线程完成并释放它。</p><p>下面是一个自旋锁的实现方式，该实现中使用了 GCC 提供的原子操作的相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> lock;</span><br><span class="line">&#125; <span class="keyword">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spinlock_init</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sl-&gt;lock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spinlock_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;sl-&gt;lock, <span class="number">1</span>)) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">spinlock_trylock</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __sync_lock_test_and_set(&amp;sl-&gt;lock, <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spinlock_unlock</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __sync_lock_release(&amp;sl-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spinlock_destroy</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) sl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以查看源文件 <code>spinlock.h</code> 和 <code>spinlock_main.c</code>，这是一个自旋锁的简单使用实例，演示了10个线程并发使用自旋锁修改单一数据流程。</p><p>另外，Pthreads 也提供了自旋锁的实现，其 API 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock, <span class="keyword">int</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br></pre></td></tr></table></figure><p>你可以在源文件 <code>pthread_spinlock.c</code> 中查看对自旋锁的使用实例。</p><h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><p>信号量是由 EW Dijkstra 在20世纪60年代后期设计的编程结构。Dijkstra 的模型是铁路运营。考虑一段铁路，其中存在单个轨道，在该轨道上一次只允许一列火车。</p><p>信号量同步此轨道上的行程。火车必须在进入单轨之前等待，直到信号量处于允许旅行的状态。当火车进入轨道时，信号量改变状态以防止其他列车进入轨道。离开这段赛道的火车必须再次改变信号量的状态，以允许另一列火车进入。</p><p>在计算机版本中，信号量似乎是一个简单的整数。线程等待许可继续，然后通过对信号量执行<code>P操作</code>来发出线程已经继续的信号。</p><p>线程必须等到信号量的值为正，然后通过从值中减去1来更改信号量的值。完成此操作后，线程执行<code>V操作</code>，通过向该值加1来更改信号量的值。这些操作必须以原子方式进行。在<code>P操作</code>中，信号量的值必须在值递减之前为正，从而产生一个值，该值保证为非负值，并且比递减之前的值小1。</p><h3 id="信号量-API"><a href="#信号量-API" class="headerlink" title="信号量 API"></a>信号量 API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure><p>信号量初始化函数中，pshared的值为零，则不能在进程之间共享信号量。如果pshared的值非零，则可以在进程之间共享信号量。值 value 之名，<br>其中，<code>sem_post</code> 以原子方式递增sem指向的信号量。调用后，当信号量上的任何线程被阻塞时，其中一个线程被解除阻塞。<br>使用 <code>sem_wait</code> 来阻塞调用线程，直到sem指向的信号量计数变为大于零，然后原子地减少计数。</p><h3 id="信号量解决生产者与消费者问题"><a href="#信号量解决生产者与消费者问题" class="headerlink" title="信号量解决生产者与消费者问题"></a>信号量解决生产者与消费者问题</h3><p>生产者和消费者问题是并发编程中标准的，众所周知的一个小问题。在一个缓冲区中，分为将项目放入缓冲区生产者，从缓冲区中取出项目的消费者。</p><p>在缓冲区有可用空间之前，生产者不能在缓冲区中放置东西。在生产者写入缓冲区之前，消费者不能从缓冲区中取出东西。</p><p>你可以查看源文件 <code>pthread-semaphore.c</code>，这是一个使用信号量解决生产者、消费者问题的实例。</p><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p>工作队列是一组线程间分派工作的方法，创建工作队列时，可以指定需要的最大并发级别（最大线程数量）。</p><p>依据工作量的要求，线程将被开始或停止。没有发现任何请求的一个线程将等待一段时间后终止。最优的时间段取决于在你的系统上创建一个新线程的开销、维护一个不做任何工作的线程的系统资源的开销，以及你将再次需要线程的可能性。</p><p>源文件 <code>workq.h</code> 、<code>workq.c</code> 和 <code>workq_main.c</code> 显示了一个工作队列管理器的实现。</p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栅栏（Barriers）&quot;&gt;&lt;a href=&quot;#栅栏（Barriers）&quot; class=&quot;headerlink&quot; title=&quot;栅栏（Barriers）&quot;&gt;&lt;/a&gt;栅栏（Barriers）&lt;/h2&gt;&lt;p&gt;barrier 字面意思时栅栏，barrier 是将一组成员保持在一起的一种方式，它可以实现让一组线程等待至某个状之后再全部同时执行。一个 barrier 通常被用来确保某些井行算法中的所有合作线程在任何线程可以继续运行之前到达算法中的一个特定点。&lt;/p&gt;
&lt;p&gt;barrier 的核心是一个计数器，我们可以称之为“阈值”，即在一个 barrier 上必须等待的线程数。计时器计算着当前线程的返回数量，如果数量未达到指定点，那么之前返回的线程都必须继续等待，直到最后一个线程返回，才能开始下一步。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-POSIX 针对线程的调整</title>
    <link href="https://veinin.com/2018/06/17/programming_with_posix_pthreads_06/"/>
    <id>https://veinin.com/2018/06/17/programming_with_posix_pthreads_06/</id>
    <published>2018-06-17T11:38:12.000Z</published>
    <updated>2018-07-12T14:44:36.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程与fork"><a href="#多线程与fork" class="headerlink" title="多线程与fork"></a>多线程与fork</h2><p>多线程进程调用 <code>fork</code> 创造的子进程，只有调用 <code>fork</code> 的线程在子进程内存在，除了当前调用的线程，其他线程在子进程中都会消失，但消失的线程状态仍然保留为调用 <code>fork</code> 时的相同状态，线程会拥有与在父进程内当前调用线程的相同状态，拥有相同的互斥量，同样的线程私有数据键值等。</p><p>在 <code>forked</code> 的进程中只有一个线程，消失的其他线程并不会调用诸如 <code>pthread_exit</code> 退出，线程也不会再运用线程私有数据 <code>destructors</code> 或清除处理函数。<br>这里就存在一个很危险的局面，其他线程可能正好位于临界区之内，持有了某个锁，而它突然死亡，也就再也没有机会去解锁了。而如果子进程试图去对某个 <code>mutex</code> 加锁，那么马上就会造成死锁的局面。</p><p>综上所述，除非你打算很快地在子进程中调用 <code>exec</code> 执行一个新程序， 否则应避免在一个多线程的程序中使用 <code>fork</code>。</p><a id="more"></a><p>如果你不能避免，那么你应该注意在子进程中不能调用以下这些函数（参考《Linux多线程服务端编程》）：</p><ul><li><code>malloc</code>,会访问全局状态，肯定会加锁。</li><li>任何分配和释放内存的函数，诸如<code>new</code>、<code>delete</code>……</li><li>任何 Pthreads 函数。</li><li><code>printf</code> 系列函数。其他线程可能持有了stdout/stderr的锁。</li><li><code>sigle</code> 中除了“sigle安全”之外的任何函数，应避免在信号处理函数内使用 <code>fork</code>。</li></ul><p>另外，Pthreads 增加了 <code>pthread_atfork</code> “fork 处理器” 机制以允许你的代码越过 <code>fork</code> 调用保护数据和不变量。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));</span><br></pre></td></tr></table></figure><p>该函数中，<code>prepare fork</code> 处理器以正确的顺序锁住所有的由相关代码使用的互斥量以阻止死锁的发生。<code>parent fork</code> 处理器只需要开锁所有互斥量即可，以允许父进程和所有线程继续正常工作。<code>child fork</code> 处理器经常可以与 parent fork 处评器一样； 但是有时需要重置程序或库的状态。</p><p>在程序 <code>atfork.c</code> 中展示了如何使用 <code>fork</code> 处理器。</p><h2 id="多线程与exec"><a href="#多线程与exec" class="headerlink" title="多线程与exec"></a>多线程与exec</h2><p><code>exec</code> 函数功能是消除当前程序的环境并且用一个新程序代替它，所以并没有受线程的影响。</p><h2 id="多线程与signal"><a href="#多线程与signal" class="headerlink" title="多线程与signal"></a>多线程与signal</h2><p>在多线程程序中，使用 signal 的第一原则就是 <strong>不要使用 signal</strong>。</p><p>尽管修改进程信号行为本身是线程安全的，但是不能防止其他线程随后很快地设置一个新的信号行为。任何印象线程的信号同样也会影响整个进程，这意味着向进程或进程内的任何线程传送一个 <code>SIGKILL</code> 信号，将终止进程。传送一个 <code>SIGSTOP</code> 停止命令时，将导致所有的线程停止直到收到 <code>SIGCOUNT</code> 信号。</p><h2 id="多线程与stdio"><a href="#多线程与stdio" class="headerlink" title="多线程与stdio"></a>多线程与stdio</h2><p>Pthreads 要求 ANSI C 标准 I/O (stdio) 函数是线程安全的。因为 stdio 包需要为输出缓冲区和文件状态指定静态存储区，stdio 实现将使用互斥量或信号灯等同步机制。</p><h3 id="flockfile-和-funlockfile"><a href="#flockfile-和-funlockfile" class="headerlink" title="flockfile 和 funlockfile"></a>flockfile 和 funlockfile</h3><p>在一些情况里，一系列 stdio 操作以不被中断的顺序执行是重要的。例如，一个提示符后面跟着一个从终端的读操作。为了不让其他线程在两个操作之间读 stdin 或者写<br>stdout，你应该在两个调用前后锁住 stdin 和 stdou。你可以使用使用 <code>flockfile</code> 和 <code>funlockfile</code> 以及 <code>ftrylockfile</code> 函数来确保一系列写操作不会被从其他线程的文件存取打断。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> flock <span class="title">file</span><span class="params">(FILE *file)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">ftrylockfile</span><span class="params">(FILE *file)</span></span></span><br><span class="line">void funlockfile(FILE *file)；</span><br></pre></td></tr></table></figure><p>你可以参考程序 <code>flock.c</code> 实例。</p><h3 id="getchar-unlocked-和-putchar-unlocked"><a href="#getchar-unlocked-和-putchar-unlocked" class="headerlink" title="getchar_unlocked 和 putchar_unlocked"></a>getchar_unlocked 和 putchar_unlocked</h3><p>函数 <code>getchar</code> 和 <code>putchar</code> 分别操作 stdin 和 stdout，而 <code>getc</code> 和 <code>putc</code> 能在任何stdio 文件流上被使用。Pthreads 要求这些函数锁住 stdio 流数据来防止代码对 stdio 缓冲区的偶然破坏。</p><p>Phtread 提供了函数 <code>getc_unlocked</code>、<code>putc_unlocked</code>、 <code>getchar_unlocked</code> 和 <code>putchar_unlocked</code>，但它们不执行任何锁操作，因此你必须在这些操作附近使用 <code>flockfile</code> 和 <code>fimlockfili</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar_unlocked</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc_unlocked</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar_unlocked</span> <span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>程序 <code>putchar.c</code> 显示了使用 <code>putchar</code> 和在一个文件锁内调用一系列 <code>putchar_unlocked</code>之间的差异。</p><h2 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h2><p>在一个多线程程序中，主函数是”进程主线程的启动函数”，从主函数返回将终止整个进程。与进程相关的所有内存（和线程）将消失。线程也不会执行清除处理器或线程私有数据 <code>destructors</code> 函数。调用 <code>exit</code> 具有同样的效果，你可以调用 <code>exit</code> 来很快地停止所有的线程。</p><p>当你不想使用起始线程或让它等待其他线程结束时，可以通过调用 <code>pthread_exit</code> 而非返回或调用 <code>exit</code> 退出主函数。从主函数中调用 <code>pthread_exit</code> 将在不影响进程内其他线程的前提下终止起始线程，允许其他线程继续运作，直到正常完成。</p><h2 id="线程安全函数"><a href="#线程安全函数" class="headerlink" title="线程安全函数"></a>线程安全函数</h2><p>Pthreads 定义了现存函数的线程安全的变体，它们在相应函数名结尾处添加后缀 <code>_r</code>：</p><ul><li>用户和终端ID，<code>getlogin_r</code>、<code>ctermid</code>、<code>ttyname_r</code>。</li><li>目录搜索，<code>readdir_r</code>。</li><li>字符串 token，<code>strtok_r</code>。</li><li>时间表示，<code>asctime_r</code>、<code>ctime_r</code>、<code>gmtime_r</code>、<code>localtime_r</code>。</li><li>随机数产生，<code>read_r</code>。</li><li>组和用户数据库，<code>getgrgid_r</code>、<code>getgrnam_r</code>、<code>getpwuid_r</code>、<code>getpwnam_r</code>。</li></ul><p>程序 <code>getlogin.c</code> 是一个如何调用获取用户和终端ID的实例。</p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多线程与fork&quot;&gt;&lt;a href=&quot;#多线程与fork&quot; class=&quot;headerlink&quot; title=&quot;多线程与fork&quot;&gt;&lt;/a&gt;多线程与fork&lt;/h2&gt;&lt;p&gt;多线程进程调用 &lt;code&gt;fork&lt;/code&gt; 创造的子进程，只有调用 &lt;code&gt;fork&lt;/code&gt; 的线程在子进程内存在，除了当前调用的线程，其他线程在子进程中都会消失，但消失的线程状态仍然保留为调用 &lt;code&gt;fork&lt;/code&gt; 时的相同状态，线程会拥有与在父进程内当前调用线程的相同状态，拥有相同的互斥量，同样的线程私有数据键值等。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;forked&lt;/code&gt; 的进程中只有一个线程，消失的其他线程并不会调用诸如 &lt;code&gt;pthread_exit&lt;/code&gt; 退出，线程也不会再运用线程私有数据 &lt;code&gt;destructors&lt;/code&gt; 或清除处理函数。&lt;br&gt;这里就存在一个很危险的局面，其他线程可能正好位于临界区之内，持有了某个锁，而它突然死亡，也就再也没有机会去解锁了。而如果子进程试图去对某个 &lt;code&gt;mutex&lt;/code&gt; 加锁，那么马上就会造成死锁的局面。&lt;/p&gt;
&lt;p&gt;综上所述，除非你打算很快地在子进程中调用 &lt;code&gt;exec&lt;/code&gt; 执行一个新程序， 否则应避免在一个多线程的程序中使用 &lt;code&gt;fork&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-线程高级编程</title>
    <link href="https://veinin.com/2018/06/12/programming_with_posix_pthreads_05/"/>
    <id>https://veinin.com/2018/06/12/programming_with_posix_pthreads_05/</id>
    <published>2018-06-12T15:12:32.000Z</published>
    <updated>2018-07-12T14:44:32.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一次性初始化"><a href="#一次性初始化" class="headerlink" title="一次性初始化"></a>一次性初始化</h2><p>一些事情仅仅需要做一次，不管是什么。在主函数中并且在调用任何其他依赖于初始化的事物之前，这时初始化应用最容易，特别是在创造任何线程之前初始化它需要的数据，如互斥量、线程特定数据键等。</p><p>在传统的顺序编程中，一次性初始化经常通过使用布尔变量来管理。控制变量被静态地初始化为 0,而任何依赖于初始化的代码都能测试该变量。如果变量值仍然为 0, 则它能实行初始化，然后将变量置为 1，以后检查的代码将跳过初始化。如下面代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialized)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    initialized = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>但在使用多线程时，上述操作就不是那么容易了。如果多个线程并发地执行初始化序列代码， 2 个线程可能都发现 <code>initialized</code> 为0，并且都执行初始化，而且该过程本该仅仅执行一次，那么上面代码就会立马发生不可预估的错误。</p><p>对于多线程环境下初始化的状态有两种方式：</p><ul><li>使用一个静态初始化的互斥量来编写一次性初始化代码。</li><li>无法静态初始化一个互斥量时，使用 <code>pthread_once</code>。</li></ul><p>对于 <code>pthread_once</code> 初始化，需要声明类型为 <code>pthread_once_t</code> 的一个控制变量，且该控制变量必须使用 <code>PTHREAD_ONCE_INIT</code> 宏进行静态初始化。<code>pthread_once</code> 首先检查控制变量，以判断是否已经完成初始化，如果完成，则什么都不做并立刻返回；否则，<code>pthread_once</code> 会调用初始化函数，并且记录初始化完成。如果在一个线程初始化时，另外一个线程也调用了<code>pthread_once</code>，则调用线程会阻塞等待，直到正在初始化的线程返回，这样就确保了所以状态一定会正确初始化完成。</p><p>下面是一个使用 <code>pthread_once</code> 来初始化的实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_once_t</span> once_block = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">once_init_routine</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_once(&amp;once_block, once_init_routine);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Once init"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread_toutine has locked the mutex.\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Destroy mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_once(&amp;once_block, once_init_routine);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Once init"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Main has locked the mutex.\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Destroy mutex"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序，唯一的临界共享数据实际是 <code>once_block</code>，主线程和线程 <code>thread_routine</code> 都会调用 <code>pthread_once</code> 进行初始化，但只会有一个线程会执行初始化函数。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>当我们创建线程或动态初始化互斥量和条件变量时，通常使用空指针作为第二个参数，这个参数实际上是指向一个属性对象的指针。空指针表明，Pthreads 应该为所有属性假定默认值，就像静态初始化互斥量或条件变量时一样。</p><p>一个属性对象是当初始化一个对象时提供的一个扩展参数表，可以提供更加高级的功能。类型 <code>pthread_attr_t</code> 代表一个属性对象，线程、 互斥置和条件变量都有自己特殊的属性对象类型， 分别是 <code>pthread_attr_t</code>、 <code>pthread_mutexattr_t</code> 和 <code>pthread_condattr_t</code>。</p><h3 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h3><p>Pthreads 为互斥量创建定义下列属性：<code>pshared</code>、<code>pratocol</code> 和 <code>prioceiling</code>。通过调用 <code>pthread_mutexattr_init</code> 初始化互斥量属性，指定一个指向类型 <code>pthread_mutexattr_t</code> 变量的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutexattr_t</span> mutex_attr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> *pshared)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure><p>下面程序显示了如何设置属性对象来创建使用 <code>pshared</code> 属性的互斥量，并且获取 <code>pshared</code> 值，打印输出 1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> pshared;</span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> mutex_attr;</span><br><span class="line"></span><br><span class="line">    status = pthread_mutexattr_init(&amp;mutex_attr);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex attr"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutexattr_setpshared(&amp;mutex_attr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Set pshared"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_init(&amp;mutex, &amp;mutex_attr);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutexattr_getpshared(&amp;mutex_attr, &amp;pshared);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Get pshared"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pshared: %d\n"</span>, pshared);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h3><p>Pthreads 为条件变量的创建仅定义了一个属性 <code>pshared</code>。使用 <code>pthread_condattr_init</code> 初始化条件变量属性对象，设置一个指向类型 <code>pthread_condattr_t</code> 变量的指针。可以通过调用 <code>pthread_condattr_setpshared</code> 设置 <code>pshared</code>。</p><p>该属性默认值时 <code>PTHREAD_PROCESS_PRIVATE</code>，如果条件变量属性需要被多个线程使用，可以设置值为 <code>PTHREAD_PROCESS_SHAREAD</code>。</p><p>下面程序演示了如何使用条件变量的 <code>pshared</code> 属性来创建设置一个条件变量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pthread_condattr_t</span> cond_attr;</span><br><span class="line"></span><br><span class="line">    status = pthread_condattr_init(&amp;cond_attr);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create attr"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_condattr_setpshared(&amp;cond_attr, PTHREAD_PROCESS_PRIVATE);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Set pshared"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cond_init(&amp;cond, &amp;cond_attr);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init cond"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>POSIX 为线程创建定义下列属性：detachstate、stacksize、stackaddr、scope、inheritsched、schedpolicy 和 schedparam。并不是所有系统都支持以上所有的属性，因此需要在使用前检查系统文档。</p><p>所有的 Pthreads 系统都支持 <code>detachstate</code> 属性 ，该属性的值可以是 <code>PTHREAD_CREATE_JOINABLE</code> 或 <code>PTHREAD_CREATE_DETACHED</code>。<br>默认的线程被创建为可连接的(joinable)，即意味着由 <code>pthread_create</code> 创建的该线程ID 能被用来与线程连接并获得它的返回值，或取消它。<br>如果设置为 <code>PTHREAD_CREATE_DETACHED</code>，则该属性对象创建的线程 ID 不能被使用，线程终止时，线程的所有资源都会被系统立刻回收。所以，在创建已经知道不需要取消或连接的线程时，应该以可分离的方式创建它们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br></pre></td></tr></table></figure><p>如果系统定义了标志 <code>_POSIX_THREAD_ATTR_STACKSIZE</code>，就可以设置 <code>stacksize</code> 属性，指定使用属性对象创建的线程栈的最小值。但栈大小不是可移植的，你应该小心使用它。<br>如果系统定义了标志 <code>_POSIX_THREAD_ATTR_STACKADDR</code>，就可以设置 <code>stackaddr</code> 属性，为指定线程指定一个存储器区域来作为堆栈使用。</p><p>下面程序演示了实际中的某些属性对象的使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The thread is here\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> thread_attr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">thread_param</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> stack_size;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_attr_init(&amp;thread_attr);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create attr"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_attr_setdetachstate(&amp;thread_attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Set detach"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _POSIX_THREAD_ATTR_STACKSIZE</span></span><br><span class="line">    status = pthread_attr_getstacksize(&amp;thread_attr, &amp;stack_size);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Get stack size"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Default stack size is %d; minimum is %d\n"</span>, stack_size, PTHREAD_STACK_MIN);</span><br><span class="line"></span><br><span class="line">    status = pthread_attr_setstacksize(&amp;thread_attr, PTHREAD_STACK_MIN*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Set stack size"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, &amp;thread_attr, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Main exiting\n"</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h2><p>大部分时间每个线程独立地运行着，完成一个特定的工作，并且自己退出。但是有时一个线程被创建并不需要一定完成某件事情。例如用户可以单击按钮取消停止长时间的搜索操作。取消一个线程就像告诉一个人停止他正在做的工作一样。Pthreads 允许每个线程控制自己的结束，它能恢复程序不变量并解锁互斥量。当线程完成一些重要的操作时它甚至能推迟取消。</p><p>以下是常用的线程取消函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">void pthread_cleanup_push(void (*routine)(void *), void *arg);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br></pre></td></tr></table></figure><p>Pthread 支持三种取消模式，模式为两位二进制编码，称为“取消状态”和“取消类型”。每种模式实质上包括开、关两种状态。取消状态可以是“启用”（ enable)或“禁用”（disable)，取消类型可以是被“推迟” 或 “异步。如果取消状态被禁用，那么其他取消模式都会失效，相反则可以执行“推迟”或“异步”模式。</p><table><thead><tr><th>模式</th><th>状态</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>Off（关）</td><td>禁用</td><td>二者之一</td><td>取消被推迟，直到启动取消模式</td></tr><tr><td>Deferred（推迟）</td><td>启用</td><td>推迟</td><td>在下一个取消点执行取消</td></tr><tr><td>Asynchronous（异步）</td><td>启用</td><td>异步</td><td>可以随时执行取消</td></tr></tbody></table><p>为取消一个线程， 你需要线程的标识符 ID， 即由 <code>pthread_create</code> 返回给创建者或由 <code>pthread_self</code> 返回给线程自己的 <code>pthread_t</code> 值。如果没有一个线程的标识符 TD， 就不能取消线程。</p><p>取消一个线程是异步的， 当 <code>pthread_cancel</code> 调用返回时， 线程未必已经被取消，可能仅仅被通知有一个针对它的未解决的取消请求。如果需要知道线程在何时实际终止，就必须在取消它之后调用 <code>pthread_join</code> 与它连接。</p><p>也有被称为 <code>pthread_testcancel</code> 的特殊函数， 该函数仅仅是一个推迟的取消点。如果线程没被要求终止，它将很快返回，这允许你将任何函数转变为取消点。</p><p>下面是一个在循环内调用 <code>pthread_testcancel</code> 来对一个延迟取消反应的线程实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread_routine starting\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (counter == <span class="number">0</span>; ; counter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((counter % <span class="number">1000</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"calling testcancel\n"</span>);</span><br><span class="line">            pthread_testcancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"callling cancel\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cancel(thread_id);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Cancel thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling join\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread_id, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == PTHREAD_CANCELED)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread canceled at iteration %d\n"</span>, counter);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread was not canceled\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推迟取消"><a href="#推迟取消" class="headerlink" title="推迟取消"></a>推迟取消</h3><p>“推迟取消”意味着线程的取消类型被设置为 <code>PTHREAD_DEFERRED</code>，线程的取消使能属性被设置为 <code>PTHREAD_CANCEL_ENABLE</code>，线程将仅仅在到达取消点时才响应取消请求。</p><p>大多数取消点包含可以“无限”时间阻塞线程的 I/O 操作，它们是可取消的，以便等待能被打断，比如 <code>wait</code>、<code>read</code> 这样的函数函数。<br>你可以在下面这个链接中查找到所有可能的取消点：<br><a href="http://man7.org/linux/man-pages/man7/pthreads.7.html" target="_blank" rel="noopener">Pthreads-Cancellation-points</a></p><p>如果需要保证取消不能在一个特别的取消点或取消点的一些顺序期间发生，可以暂时在代码的那个区域停用取消。下面程序是一个实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread_routine starting\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (counter == <span class="number">0</span>;; counter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((counter % <span class="number">755</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            status = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &amp;state);</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Disable cancel"</span>);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            status = pthread_setcancelstate(state, &amp;state);</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Restore cancel"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((counter % <span class="number">1000</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"calling testcancel\n"</span>);</span><br><span class="line">            pthread_testcancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"callling cancel\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cancel(thread_id);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Cancel thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling join\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread_id, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == PTHREAD_CANCELED)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread canceled at iteration %d\n"</span>, counter);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread was not canceled\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步取消"><a href="#异步取消" class="headerlink" title="异步取消"></a>异步取消</h3><p>如果目标线程不需要使用取消点来査询取消请求。对于运行一个紧密计算循环的线程（例如，在找一个素数因素）而言是非常珍贵的，因为那种情况下调用 <code>pthread_testcancel</code> 的开销在可能是严重的。</p><p>异步取消线程很难确保目标线程安全的执行取消，例如当你调用 <code>malloc</code> 时，系统为你分配一些堆内存，但 <code>malloc</code> 可能在很多地方被异步取消打断，可能在分配内存前，或可能在分配内存后、也可能在保存地址返回前被打断。无论哪种情况，你的代码保存的内存地址变量将是未初始化的，这就很可能造成内存泄漏。</p><p>所以，在你的任何代码里面应该 <strong>避免异步的取消</strong> ！我们很难正确使用异步取消，并且很少有用。</p><p>除非当函数被记录为“异步取消安全”的，否则当异步取消被启用时你不该调用任何函数。Pthreads 建议所有的库函数应该记录它们是否是异步取消安全的。如果函数的描述没有具体的说明，则你应该总是假定它不是异步取消安全的。</p><p>下面是一个计算密集的循环中异步取消的使用实例，但是如果在循环内有任何函数调用，程序将变得不可靠，而推迟取消的版本将能继续正确工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> matrixa[SIZE][SIZE];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> matrixb[SIZE][SIZE];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> matrixc[SIZE][SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cancel_type, status;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; SIZE; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrixa[i][j] = i;</span><br><span class="line">            matrixb[i][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        status = pthread_setcancelstate(PTHREAD_CANCEL_ASYNCHRONOUS, &amp;cancel_type);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Set cancel type"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; SIZE; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrixc[i][j]= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; SIZE; k++)</span><br><span class="line">                    matrixc[i][j] += matrixa[i][k] * matrixb[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        status = pthread_setcancelstate(cancel_type, &amp;cancel_type);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Set cancel type"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; SIZE; j++)</span><br><span class="line">                matrixa[i][j] = matrixc[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"callling cancel\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cancel(thread_id);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Cancel thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling join\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread_id, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == PTHREAD_CANCELED)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread canceled\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread was not canceled\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h3><p>当一个代码段被取消时，需要恢复一些状态，必须使用清除处理器。例如当线程在等待一个条件变量时被取消，它将被唤醒，并保持互斥量加锁状态。在线程终止前，通常需要恢复不变量，且它总是需要释放互斥量。</p><p>可以把每个线程考虑为有一个活动的清除处理函数的栈。 调用 <code>pthread_cleanup_push</code> 将清除处理函数加到栈中， 调用 <code>pthread_cleanup_pop</code> 删除最近增加的处理函数。当线程被取消时或当它调用 <code>pthread_exit</code> 退出时，Pthreads 从最近增加的清除处理函数幵始，依次调用各个活动的清除处理函数，当所有活动的清除处理函数返回时，线程被终止。</p><p>下面程序演示了当一个条件变量等待被取消时，使用清除处理函数来释放互斥量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADS 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">control_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> counter, bysy;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cv;</span><br><span class="line">&#125; <span class="keyword">control_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">control_t</span> control = &#123;<span class="number">0</span>, <span class="number">1</span>, PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">control_t</span> *st = (<span class="keyword">control_t</span> *)arg;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    st-&gt;counter--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cleaup_handler: counter == %d\n"</span>, st-&gt;counter);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_unlock(&amp;st-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Unlock in cleanup handler"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_push(cleanup_handler, (<span class="keyword">void</span> *)&amp;control);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_lock(&amp;control.mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Mutex lock"</span>);</span><br><span class="line"></span><br><span class="line">    control.counter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (control.bysy)</span><br><span class="line">    &#123;</span><br><span class="line">        status = pthread_cond_wait(&amp;control.cv, &amp;control.mutex);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Wait on condition"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id[THREADS];</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; THREADS; count++)</span><br><span class="line">    &#123;</span><br><span class="line">        status = pthread_create(&amp;thread_id[count], <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; THREADS; count++)</span><br><span class="line">    &#123;</span><br><span class="line">        status = pthread_cancel(thread_id[count]);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Cancel thread"</span>);</span><br><span class="line"></span><br><span class="line">        status = pthread_join(thread_id[count], &amp;result);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Join thread"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == PTHREAD_CANCELED)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Thread %d canceled\n"</span>, count);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Thread %d was not canceled\n"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的一个线程创建了一套线程来“转包”一些功能（如并行算术运算），并且当分包线程在进行中时“承包线程”被取消，你可能不希望留着分包线程继续运行。相反，可以把取消操作“传递”到每个“分包线程”，让它们独立地处理自己的终止过程。当“承包线程”取消它们时，不应该连接分包线程来推迟取消，相反，可以取消每个线程并且使用 <code>pthread_detach</code> 很快地分离它。当它们完成时，分包线程的资源就能够很快被重用， 而“承包线程” 同时能独立地完成一些事情。</p><p>以下程序演示了同时独立取消“分包线程”的一个方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADS 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">team_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>         join_i;</span><br><span class="line">    <span class="keyword">pthread_t</span>   workers[THREADS];</span><br><span class="line">&#125; <span class="keyword">team_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">worker_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(counter = <span class="number">0</span>; ; counter++)</span><br><span class="line">        <span class="keyword">if</span> ((counter % <span class="number">1000</span>) == <span class="number">0</span>)</span><br><span class="line">            pthread_testcancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">team_t</span> *team = (<span class="keyword">team_t</span> *)arg;</span><br><span class="line">    <span class="keyword">int</span> count, status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (count = team-&gt;join_i; count &lt; THREADS; count++) &#123;</span><br><span class="line">        status = pthread_cancel(team-&gt;workers[count]);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Cancel worker"</span>);</span><br><span class="line"></span><br><span class="line">        status = pthread_detach(team-&gt;workers[count]);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Detach worker"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cleanup: canceled %d\n"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">team_t</span> team;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; THREADS; count++) &#123;</span><br><span class="line">        status = pthread_create(&amp;team.workers[count], <span class="literal">NULL</span>, worker_routine, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Create worker"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_push(cleanup, (<span class="keyword">void</span> *)&amp;team);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (team.join_i = <span class="number">0</span>; team.join_i &lt; THREADS; team.join_i++) &#123;</span><br><span class="line">        status = pthread_join(team.workers[team.join_i], &amp;result);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Join worker"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create team"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cancel(thread_id);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Cancel team"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join team"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程私有数据"><a href="#线程私有数据" class="headerlink" title="线程私有数据"></a>线程私有数据</h2><p>在进程内的所有线程共享相同的地址空间，即意味着任何声明为静态或外部的变量，或在进程堆声明的变量，都可以被进<br>程内所有的线程读写。</p><p>当线程需要一个私有变量时，必须首先决定所有的线程是否共享相同的值，或者线程是否应该有它自己的值。如果它们共享变量，则可以使用静态或外部数据，就像你能在一个单线程程序做的那样；然而，必须同步跨越多线程对共享数据的存取， 运通常通过增加一个或多个互斤量来完成。</p><p>如果每个线程都需要一个私有变量值，则必须在某处存储所有的值。线程私有数据允许每个线程保有一份变量的拷贝，好像每个线程有一连串通过公共的“键”值索引的私有数据值。</p><h3 id="建立和使用线程私有数据"><a href="#建立和使用线程私有数据" class="headerlink" title="建立和使用线程私有数据"></a>建立和使用线程私有数据</h3><p>线程私有数据键在程序中是由类型 <code>pthread_key_t</code> 来表示的。</p><p>在任何线程试图使用键以前，创建线程私有数据键最容易的方法是调用 <code>pthread_key_create</code>，但必须保证 <code>pthread_key_create</code> 对于每个 <code>pthread_key_t</code> 变童仅仅调用一次。如果将一个键创建两次，其实是在创建两个不同的键。第二个键将覆盖第一个，第一个键与任何线程为其设置的值一起将永远地丢失。所以，最容易一次性创建一个键的方法是使用 <code>pthread_once</code>。</p><p>当程序不再需要时，你可以调用 <code>pthread_key_delete</code> 释放一个线程私有数据键。</p><p>在私有数据创建后，你可以使用 <code>pthread_getspecific</code> 函数来获得线程当前的键值，或调用 <code>pthread_setspecific</code> 来改变当前的键值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_key_t</span> key;</span><br><span class="line">int pthread_key_create(pthread_key_t *key, void (*destructor)(void *));</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>下面是一个建立和使用线程私有数据的实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tsd_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span>   thread_id;</span><br><span class="line">    <span class="keyword">char</span>        *<span class="built_in">string</span>;</span><br><span class="line">&#125; <span class="keyword">tsd_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> tsd_key;</span><br><span class="line"><span class="keyword">pthread_once_t</span> key_one = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">once_routine</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"initializing key\n"</span>);</span><br><span class="line">    status = pthread_key_create(&amp;tsd_key, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create key"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">tsd_t</span> *value;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_once(&amp;key_one, once_routine);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Once init"</span>);</span><br><span class="line"></span><br><span class="line">    value = (<span class="keyword">tsd_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">tsd_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>)</span><br><span class="line">        errno_abort(<span class="string">"Allocate key value"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_setspecific(tsd_key, value);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Set tsd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s set tsd value %p\n"</span>, (<span class="keyword">char</span>*)arg, value);</span><br><span class="line"></span><br><span class="line">    value-&gt;thread_id = pthread_self();</span><br><span class="line">    value-&gt;<span class="built_in">string</span> = (<span class="keyword">char</span>*)arg;</span><br><span class="line"></span><br><span class="line">    value = (<span class="keyword">tsd_t</span>*)pthread_getspecific(tsd_key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s starting...\n"</span>, value-&gt;<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    value = (<span class="keyword">tsd_t</span>*)pthread_getspecific(tsd_key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s done...\n"</span>, value-&gt;<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread1, <span class="literal">NULL</span>, thread_routine, <span class="string">"thread 1"</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread 1"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread2, <span class="literal">NULL</span>, thread_routine, <span class="string">"thread 2"</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread 2"</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-destructor-函数"><a href="#使用-destructor-函数" class="headerlink" title="使用 destructor 函数"></a>使用 destructor 函数</h3><p>当一个线程退出时，它有一些为线程私有数据键定义的值，通常需要处理它们。当你创建一个线程私有数据键时，Pthreads 允许你定义 <code>destructor</code> 函数。当具有非空的私有数据键值的一个线程终止时，键的 <code>destructor</code> (如果存在） 将以键的当前值为参数被调用。</p><p>下列程序表明了当一个线程终止时使用线程私有数据的 <code>destructors</code> 释放存储器。 它还跟踪有多少线程正在使用线程私有数据， 并且当最后线程的 <code>destructor</code> 被调用时， 删除线程私有数据键。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">private_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span>   thread_id;</span><br><span class="line">    <span class="keyword">char</span>        *<span class="built_in">string</span>;</span><br><span class="line">&#125; <span class="keyword">private_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> identity_key;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> identity_key_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">long</span> identity_key_counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">identity_key_destructor</span><span class="params">(<span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">private_t</span> *<span class="keyword">private</span> = (<span class="keyword">private_t</span>*)value;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread \"%s\" exiting...\n"</span>, <span class="keyword">private</span>-&gt;<span class="built_in">string</span>);</span><br><span class="line">    <span class="built_in">free</span>(value);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_lock(&amp;identity_key_mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Lock key mutex"</span>);</span><br><span class="line"></span><br><span class="line">    identity_key_counter--;</span><br><span class="line">    <span class="keyword">if</span> (identity_key_counter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        status = pthread_key_delete(identity_key);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Delete key"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"key delete...\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_unlock(&amp;identity_key_mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Unlock key mutex"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">identity_key_get</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    value = pthread_getspecific(identity_key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">private_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">NULL</span>)</span><br><span class="line">            errno_abort(<span class="string">"Allocate key value"</span>);</span><br><span class="line"></span><br><span class="line">        status = pthread_setspecific(identity_key, value);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Set TSD"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">private_t</span> *value;</span><br><span class="line"></span><br><span class="line">    value = (<span class="keyword">private_t</span>*) identity_key_get();</span><br><span class="line">    value-&gt;thread_id = pthread_self();</span><br><span class="line">    value-&gt;<span class="built_in">string</span> = (<span class="keyword">char</span>*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread \"%s\" starting...\n"</span>, value-&gt;<span class="built_in">string</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_1, thread_2;</span><br><span class="line">    <span class="keyword">private_t</span> *value;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_key_create(&amp;identity_key, identity_key_destructor);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Create key"</span>);</span><br><span class="line"></span><br><span class="line">    identity_key_counter = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    value = (<span class="keyword">private_t</span>*)identity_key_get();</span><br><span class="line">    value-&gt;thread_id = pthread_self();</span><br><span class="line">    value-&gt;<span class="built_in">string</span> = <span class="string">"Main thread"</span>;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_1, <span class="literal">NULL</span>, thread_routine, <span class="string">"thread 1"</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread 1"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_2, <span class="literal">NULL</span>, thread_routine, <span class="string">"thread 2"</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread 2"</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程实时调度"><a href="#线程实时调度" class="headerlink" title="线程实时调度"></a>线程实时调度</h2><p>“受限制”的响应时间不一定是“快”的反应，而是确实意味着“可预知”的响应速度。必须有一些方法来定义一个时间跨度，在该时间段内一系列操作保证被完成。例如控制一个核反应堆的系统比你将写的大多数程序有更严格的响应要求，并且没能满足反应堆要求的后果是更严重的。</p><p>很多代码将需要在“确定的反应时间”内提供一些“达到要求水平的服务”，我们称为实时编程。</p><p>实时编程分为“硬实时”和“软实时”。“硬实时”是不可原谅的，如燃料干的调整被推迟几微妙，你的核反应堆将会很危险；“软实时”意味着你大部分时间需要满足调度要求，但是如果不能能满足，后果也不是很严重。</p><h3 id="POSIX-实时选项"><a href="#POSIX-实时选项" class="headerlink" title="POSIX 实时选项"></a>POSIX 实时选项</h3><p>优先级调度允许程序员给系统提供了任何两个线程间相。无论何时当多个线程准备好执行时，系统将选择最高优先级的线程。</p><h4 id="调度策略和优先级。"><a href="#调度策略和优先级。" class="headerlink" title="调度策略和优先级。"></a>调度策略和优先级。</h4><p>调度策略允许设置各个调度策略的最小和最大优先级。POXIS 标准提供两种调度策略（<code>SCHED_FIFO</code> 和 <code>SCHED_RR</code>)。</p><ul><li><code>SCHED_FIFO</code>(先入先出）策略允许一个线程运行直到有更高优先级的线程准备好，或者直到它自愿阻塞自己。</li><li><code>SCHED_RR</code>(轮循），和先入先出策略是基本相同的，不同之处在于：如果有一个 <code>SCHED_RR</code>策略的线程执行了超过一个固定的时期（时间片间隔）没有阻塞，而另外的<code>SCHED_RR</code> 或 <code>SCHED_FIFO</code> 策略的相同优先级的线程准备好时，运行的线程将被抢占以使准备好的线程可以执行。</li></ul><p>程序 <code>sched_attr.c</code> 显示了如何使用属性对象来创建一个具有显式的调度策略和优先级的线程。<br>程序 <code>sched_thread.c</code> 显示了如何为一个正在运行的线程修改实时调度策略和参数。</p><h4 id="竞争范围和分配域。"><a href="#竞争范围和分配域。" class="headerlink" title="竞争范围和分配域。"></a>竞争范围和分配域。</h4><p>如果你正在写一个实时的应用程序，应该知道系统对这些控制量设置的支持，否则它们可能没有什么关系。</p><ul><li><strong>竞争范围</strong>，它描述了线程为处理器资源而竞争的方式。系统竞争范围意味着线程与进程之外的线程竞争处理器资源。一个进程内的髙优先级系统竞争范围线程能阻止其他进程内的系统竞争范围线程运行。进程竞争范围指线程仅仅在同一进程内相互竞争。可以使用 <code>pthread_attr_setscope</code> 设置竞争范围。</li><li><strong>分配域</strong>，分配域是系统内线程可以为其竞争的处理器的集合。一个系统叫以有一个以上的分配领域，每个包含一个以上的处理器。在一个单处理机系统内，分配域将只包含一个处理器，但是你仍然可以有多个分配域。在一台多处理机上，各个分配领域可以包含从一个处理器到系统中所有的处理器。</li></ul><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一次性初始化&quot;&gt;&lt;a href=&quot;#一次性初始化&quot; class=&quot;headerlink&quot; title=&quot;一次性初始化&quot;&gt;&lt;/a&gt;一次性初始化&lt;/h2&gt;&lt;p&gt;一些事情仅仅需要做一次，不管是什么。在主函数中并且在调用任何其他依赖于初始化的事物之前，这时初始化应用最容易，特别是在创造任何线程之前初始化它需要的数据，如互斥量、线程特定数据键等。&lt;/p&gt;
&lt;p&gt;在传统的顺序编程中，一次性初始化经常通过使用布尔变量来管理。控制变量被静态地初始化为 0,而任何依赖于初始化的代码都能测试该变量。如果变量值仍然为 0, 则它能实行初始化，然后将变量置为 1，以后检查的代码将跳过初始化。如下面代码示例：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; initialized = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (initialized)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// TODO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initialized = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-使用线程方式</title>
    <link href="https://veinin.com/2018/06/09/programming_with_posix_pthreads_04/"/>
    <id>https://veinin.com/2018/06/09/programming_with_posix_pthreads_04/</id>
    <published>2018-06-09T13:15:44.000Z</published>
    <updated>2018-07-12T14:44:26.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程编程模型"><a href="#线程编程模型" class="headerlink" title="线程编程模型"></a>线程编程模型</h2><p>线程变成模型主要有以下3种：</p><ul><li>流水线。每个线程反复地在数据系列集上执行冋一种操作，并把操作结果传递给下一步驟的其他线程。</li><li>工作组。每个线程在自己的数据上执行操作，工作组中的线程可能执行同样的操作，也可能执行不同的操作，但是它们一定独立地执行。</li><li>客户端/服务器。一个客户为每一件工作与一个独立的服务器“订契约”。通常“订契约”是匿名的，即一个请求通过某种接提交。</li></ul><a id="more"></a><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>在流水线（pipeline) 方式中，“数据元素”流串行地被一组线程顺序处理。每个线程依次在每个元素上执行一个特定的操作，并将结果传递给流<br>水线中的下一个线程。</p><p><img src="/images/pthreads/pipeline.png" alt="pipeline"></p><p>例如， 数据可能是扫描的图像，线程 A 可能处理一个图像数组，线程 B 可能在处理的数据中搜索某个特定的属性集，而线程 C 可能控制从线程 B 中收集连续的搜索结果流井做出报告。或者每个线程可能执行某个数据修改序列中的一步。</p><h2 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h2><p>在工作组模式中，数据由一组线程分别独立地处理。循环的“并行分解” 通常就是属于这种模式。</p><p><img src="/images/pthreads/working_group.png" alt="working_group"></p><p>例如，可能建立一组线程，每个线程负责处理数组的某些行或列。单一数据集合在线程间分离成不同部分，且结果是一个数据集。<br>由于所有的工作线程在不同的数据部分上执行相同的操作，这种模式通常被称为 SIMD (single instruction, multiple data, 单指令多数据流）并行处理。</p><h2 id="客户-服务器"><a href="#客户-服务器" class="headerlink" title="客户/服务器"></a>客户/服务器</h2><p>在客户服务器系统中，客户请求服务器对一组数据执行某个操作。服务器独立地执行操作——客户端或者等待服务器执行，或者并行地执行并在后面需要时査找结果。尽管让客户等待是最简单的，但这种方式很少有用，因为它不会为客户带来性能上的提高。另一方面，这又是一种对某些公共资源同步管理的简单方式。</p><p><img src="/images/pthreads/clinet_server.png" alt="clinet_server"></p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程编程模型&quot;&gt;&lt;a href=&quot;#线程编程模型&quot; class=&quot;headerlink&quot; title=&quot;线程编程模型&quot;&gt;&lt;/a&gt;线程编程模型&lt;/h2&gt;&lt;p&gt;线程变成模型主要有以下3种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流水线。每个线程反复地在数据系列集上执行冋一种操作，并把操作结果传递给下一步驟的其他线程。&lt;/li&gt;
&lt;li&gt;工作组。每个线程在自己的数据上执行操作，工作组中的线程可能执行同样的操作，也可能执行不同的操作，但是它们一定独立地执行。&lt;/li&gt;
&lt;li&gt;客户端/服务器。一个客户为每一件工作与一个独立的服务器“订契约”。通常“订契约”是匿名的，即一个请求通过某种接提交。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-同步</title>
    <link href="https://veinin.com/2018/06/07/programming_with_posix_pthreads_03/"/>
    <id>https://veinin.com/2018/06/07/programming_with_posix_pthreads_03/</id>
    <published>2018-06-07T12:16:55.000Z</published>
    <updated>2018-07-12T14:44:21.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不变量、临界区和谓词"><a href="#不变量、临界区和谓词" class="headerlink" title="不变量、临界区和谓词"></a>不变量、临界区和谓词</h2><p>不变量（invariant) 是由程序作出的假设， 特别是有关变量组间关系的假设。不变量可能会被破坏， 而且会经常被独立的代码段破坏。<br>临界区（critical section）有时称为“串行区域”，是指影响共享数据的代码段，临界区总能够对应到一个数据不变量。例如，你从队列中删除数据时， 你可以将删除数据的代码视为临界区。<br>谓词（Predicate) 是描述代码所需不变量的状态的语句。在英语中，谓词可以是如“队列为空”、 “资源可用” 之类的陈述。</p><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>大部分多线程程序需要在线程间共享数据。如果两个线程同时访问共享数据就可能会有问，因为一个线程可能在另一个线程修改共享数据的过程中使用该数据，并认为共享数据保持末变。<br>使线程同步最通用和常用的方法就是确保对相同数据的内存访问“互斥地”进行，即一次只能允许一个线程写数据，其他线程必须等待。<br>同步不仅仅在修改数据时重要， 当线程需要读取其他线程写入的数据时，而且数据写入的顺序也有影响时，同样需要同步。</p><a id="more"></a><h3 id="创建和销毁互斥量"><a href="#创建和销毁互斥量" class="headerlink" title="创建和销毁互斥量"></a>创建和销毁互斥量</h3><p>Pthreads 的互斥量用 <code>pthread_mutex_t</code> 类型的变量来表示。不能拷贝互斥量，拷贝的互斥量是不确定的，但可以拷贝指向互斥量的指针。</p><p>大部分时间互斥量在函数体外，如果有其他文件使用互斥量，声明为外部类型，如果仅在本文将内使用，则将其声明为静态类型。可以使用宏 <code>PTHREAD_WTEX_INZTIALIZER</code> 来声明具有默认属性的静态互斥量，静态初始化的互斥量不需要主动释放。</p><p>下面程序演示了一个静态创建互斥量的程序，该程序 <code>main</code> 函数为空，不会产生任何结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_struct_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">int</span>             value;</span><br><span class="line">&#125; <span class="keyword">my_struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my_struct_t</span> data = &#123;PTHREAD_MUTEX_INITIALIZER, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要初始化一个非缺省属性的互斥量， 必须使用动态初始化。如当使用 <code>malloc</code> 动态分配一个包含互斥量的数据结构时，应该使用 <code>pthread_nutex_init</code> 调用来动态的初始化互斥量。当不需要互斥量时，应该调用 <code>pthread_mutex_destory</code> 来释放它。另外，如果想保证每个互斥量在使用前被初始化，而且只被初始化一次。可以在创建任何线程之前初始化它，如通过调用 <code>pthread_once</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>下面程序演示了动态地初始化一个互斥量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_struct_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">int</span>             value;</span><br><span class="line">&#125; <span class="keyword">my_struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">my_struct_t</span> *data;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">my_struct_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>)</span><br><span class="line">        errno_abort(<span class="string">"Allocate structure"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_init(&amp;data-&gt;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_destroy(&amp;data-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Destroy mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加锁和解锁互斥量"><a href="#加锁和解锁互斥量" class="headerlink" title="加锁和解锁互斥量"></a>加锁和解锁互斥量</h3><p>最简单的情况下使用互斥量通过调用 <code>pthread_mutex_lock</code> 或 <code>pthread_mutex_trylock</code> 锁住互斥量，处理共享数据，然后调用 <code>pthread_mutex_unlock</code> 解锁互斥量。为确保线程能够读取一组变量的一致的值，需要在任何读写这些变量的代码段周围锁住互斥量。<br>当调用线程己经锁住互斥量之后，就不能再加锁一个线程己经锁住互斥量之后，试图这样做的结果可能是返回错误(EDEADLK)，或者可能陷入“自死锁”，使线程永远等待下去。同样，你也不能解锁一个已经解锁的互斥量，不能解锁一个由其他线程锁住的互斥量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>下面程序 alarm_mutex.c 是 alarm_thread.c 的一个改进版本，该程序效果如下：</p><ul><li>所有的闹钟按时间顺序存储在一个链表结构 <code>alarm_list</code> 中。</li><li>互斥量 <code>alarm_mutex</code> 负责协调对闹铃请求列表 <code>alarm_list</code> 的头节点的访问。</li><li>主线程，获取闹钟请求，将去按时间顺序插入到 <code>alarm_list</code> 中。</li><li>子线程，检查最新的闹铃列表，如果列表为空，则并阻塞住一段时间（1秒），解锁互斥量，以便主线程添加新的闹铃请求。否则获取下一个请求的差值，阻塞指定时间后，产生闹铃。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">alarm_tag</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alarm_tag</span>    *<span class="title">link</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                 seconds;</span><br><span class="line">    <span class="keyword">time_t</span>              time;</span><br><span class="line">    <span class="keyword">char</span>                message[<span class="number">64</span>];</span><br><span class="line">&#125; <span class="keyword">alarm_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> alarm_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">alarm_t</span> *alarm_list = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">alarm_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">alarm_t</span> *alarm;</span><br><span class="line">    <span class="keyword">int</span> sleep_time;</span><br><span class="line">    <span class="keyword">time_t</span> now;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        status = pthread_mutex_lock(&amp;alarm_mutex);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line"></span><br><span class="line">        alarm = alarm_list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alarm == <span class="literal">NULL</span>)</span><br><span class="line">            sleep_time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            alarm_list = alarm_list-&gt;link;</span><br><span class="line">            now = time(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (alarm-&gt;time &lt;= now)</span><br><span class="line">                sleep_time = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sleep_time = alarm-&gt;time - now;</span><br><span class="line"></span><br><span class="line">        status = pthread_mutex_unlock(&amp;alarm_mutex);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Unlock mutex"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sleep_time &gt; <span class="number">0</span>)</span><br><span class="line">            sleep(sleep_time);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sched_yield();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alarm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(%d) %s\n"</span>, alarm-&gt;seconds, alarm-&gt;message);</span><br><span class="line">            <span class="built_in">free</span>(alarm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">alarm_t</span> *alarm, **last, *next;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread, <span class="literal">NULL</span>, alarm_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create alarm thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Alarm&gt; "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fgets(line, <span class="keyword">sizeof</span>(line), <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(line) &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        alarm = (<span class="keyword">alarm_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">alarm_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (alarm == <span class="literal">NULL</span>)</span><br><span class="line">            errno_abort(<span class="string">"Allocate alarm"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">"%d %64[^\n]"</span>, &amp;alarm-&gt;seconds, alarm-&gt;message) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Bad command\n"</span>);</span><br><span class="line">            <span class="built_in">free</span>(alarm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status = pthread_mutex_lock(&amp;alarm_mutex);</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line"></span><br><span class="line">            alarm-&gt;time = time(<span class="literal">NULL</span>) + alarm-&gt;seconds;</span><br><span class="line"></span><br><span class="line">            last = &amp;alarm_list;</span><br><span class="line">            next = *last;</span><br><span class="line">            <span class="keyword">while</span> (next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next-&gt;time &gt;= alarm-&gt;time) &#123;</span><br><span class="line">                    alarm-&gt;link = next;</span><br><span class="line">                    *last = alarm;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = &amp;next-&gt;link;</span><br><span class="line">                next = next-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                *last = alarm;</span><br><span class="line">                alarm-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            status = pthread_mutex_unlock(&amp;alarm_mutex);</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Unlock mutex"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实例具有占用更少资源的优势，但它的响应性能不够。一旦 <code>alarm_thread</code> 线程从列表中接收了一个闹铃请求，它就进入睡眠直到闹铃到期。当它发现列表中没有闹铃请求时，也会睡眠 1 秒，以允许主线程接收新的用户请求。 当 <code>alarm_thread</code> 线程睡眠时，直到它从睡眠中返回，它都不能注意到由主线程添加到请求列表中的任何闹铃请求。这种情况下最好的办法是使用条件变量来通知共享数据的状态变化（后面章节内容）。</p><h3 id="非阻塞式互斥量锁"><a href="#非阻塞式互斥量锁" class="headerlink" title="非阻塞式互斥量锁"></a>非阻塞式互斥量锁</h3><p>当调用 <code>pthread_mutex_lock</code> 加锁互斥量时，如果此时互斥量己经被锁住，则调用线程将被阻塞。通常这是你希望的结果，但有时你可能希望如果互斥量己被锁住，则执行另外的代码路线，你的程序可能做其他一些有益的工作而不仅仅是等待。为此，Pthreads 提供了 <code>pthread_mutex_trylock</code> 函数，当调用互斥量己被锁住时调用该函数将返回错误代码 <code>EBUSY</code>。</p><p>下列实例程序 <code>trylock.c</code> 使用 <code>pthread_mutex_trylock</code> 函数来间歇性地报告计数器的值， 不过仅当它对计数器的访问与计数线程没有发生冲突时才报告：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPIN 10000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">long</span> counter;</span><br><span class="line"><span class="keyword">time_t</span> end_time;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">counter_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> spin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (time(<span class="literal">NULL</span>) &lt; end_time) </span><br><span class="line">    &#123;</span><br><span class="line">        status = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (spin = <span class="number">0</span>; spin &lt; SPIN; spin++)</span><br><span class="line">            counter++;</span><br><span class="line"></span><br><span class="line">        status = pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Unlock mutex"</span>);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Counter is %ld\n"</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">monitor_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> misses = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (time(<span class="literal">NULL</span>) &lt; end_time)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        status = pthread_mutex_trylock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (status != EBUSY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Trylock mutex"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Counter is %ld\n"</span>, counter/SPIN);</span><br><span class="line"></span><br><span class="line">            status = pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Unlock mutex"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            misses++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Monitor thread missed update %d times.\n"</span>, misses);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pthread_t</span> counter_thread_id;</span><br><span class="line">    <span class="keyword">pthread_t</span> monitor_thread_id;</span><br><span class="line"></span><br><span class="line">    end_time = time(<span class="literal">NULL</span>) + <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;counter_thread_id, <span class="literal">NULL</span>, counter_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create counter thread"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;monitor_thread_id, <span class="literal">NULL</span>, monitor_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create monitor thread"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(counter_thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join counter thread"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(monitor_thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join monitor thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个互斥量与死锁"><a href="#多个互斥量与死锁" class="headerlink" title="多个互斥量与死锁"></a>多个互斥量与死锁</h3><p>有时，一个互斥量是不够的，特别是当你的代码需要跨越软件体系内部的界限时。例如，当多个线程同时访问一个队列结构时，你需要两个互斥量，一个用来保护队列头，一个用来保护队列元素内的数据。当为多线程建立一个树型结构时，你可能需要为每个节点设置一个互斥量。</p><p>使用多个互斥量会导致复杂度的增加。最坏的情况就是死锁的发生，即两个线程分别锁住了一个互斥量而等待对方的互斥量。一个线程锁住了互斥量 A 后，加锁互斥量 B；同时另一个线程锁住了 B 而等待互斥量 A，则你的代码就产生了经典的死锁现象。</p><table><thead><tr><th>第一个线程</th><th>第二个线程</th></tr></thead><tbody><tr><td>pthread_mutex_lock(&amp;mutex_a)</td><td>pthread_mutex_lock(&amp;mutex_b)</td></tr><tr><td>pthread_mutex_lock(&amp;mutex_b)</td><td>pthread_mutex_lock(&amp;mutex_a)</td></tr></tbody></table><p>针对死锁，考虑以下两种通用的解决方法：</p><ul><li>固定加锁顺序。所有需要同时加锁互斥量A和互斥量B的代码，必须首先加锁互斥量A，然后锁互斥量B。</li><li>试加锁和回退。在锁住某个集合中的第一个互斥量后，使用以 <code>pthread_mutex_trylock</code> 来加锁集合中的其他互斥量，如果失败则将集合中所有己加锁互斥量释放，并重新锁。</li><li>如果代码不变量允许先释放互斥量 1,然后再加锁互斥量 2,就可以避免同时拥有两个互斥量的需要。但是，如果存在被破坏的不变置需要锁住不变量 1，则互斥量 1 就不能被释放，直到不变量被恢复为止。在这种情况下， 你应该考虑使用回退（或者试锁-回退 ）算法。</li></ul><p>以下程序 <code>backoff.c</code> 演示了如何使用回退算法避免互斥量死锁。程序建立了两个线程线程，一个运行函数 <code>lock_forward</code>,一个个运行函数 <code>lock_backward</code>。程序每次循环都会试图锁住三个互斥量，<code>lock_forward</code> 依次锁住互斥量1、2、3，<code>lock_backward</code>则按相反顺序加锁互斥量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITERATIONS 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex[<span class="number">3</span>] = &#123;</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> backoff = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> yield_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">lock_forward</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, iterate, backoffs;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (iterate = <span class="number">0</span>; iterate &lt; ITERATIONS; iterate++)</span><br><span class="line">    &#123;</span><br><span class="line">        backoffs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                status = pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">                <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                    err_abort(status, <span class="string">"First lock"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"forward lock got %d\n"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (backoff)</span><br><span class="line">                    status = pthread_mutex_trylock(&amp;mutex[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    status = pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (status == EBUSY)</span><br><span class="line">                &#123;</span><br><span class="line">                    backoffs++;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"forward locker backing of at %d\n"</span>, i);</span><br><span class="line">                    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                    &#123;</span><br><span class="line">                        status = pthread_mutex_unlock(&amp;mutex[i]);</span><br><span class="line">                        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                            err_abort(status, <span class="string">"Backoff"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                        err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"forward locker got %d\n"</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (yield_flag)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (yield_flag &gt; <span class="number">0</span>)</span><br><span class="line">                    sched_yield();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lock forward got all locks, %d backoffs\n"</span>, backoffs);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[<span class="number">1</span>]);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[<span class="number">2</span>]);</span><br><span class="line">        sched_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">lock_backward</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, iterate, backoffs;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (iterate = <span class="number">0</span>; iterate &lt; ITERATIONS; iterate++)</span><br><span class="line">    &#123;</span><br><span class="line">        backoffs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                status = pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">                <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                    err_abort(status, <span class="string">"First lock"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"backward lock got %d\n"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (backoff)</span><br><span class="line">                    status = pthread_mutex_trylock(&amp;mutex[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    status = pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (status == EBUSY)</span><br><span class="line">                &#123;</span><br><span class="line">                    backoffs++;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"backward locker backing of at %d\n"</span>, i);</span><br><span class="line">                    <span class="keyword">for</span> (; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        status = pthread_mutex_unlock(&amp;mutex[i]);</span><br><span class="line">                        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                            err_abort(status, <span class="string">"Backoff"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                        err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"backward locker got %d\n"</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (yield_flag)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (yield_flag &gt; <span class="number">0</span>)</span><br><span class="line">                    sched_yield();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lock backward got all locks, %d backoffs\n"</span>, backoffs);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[<span class="number">2</span>]);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[<span class="number">1</span>]);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">        sched_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> forward, backward;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        backoff = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>)</span><br><span class="line">        yield_flag = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;forward, <span class="literal">NULL</span>, lock_forward, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create forward"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;backward, <span class="literal">NULL</span>, lock_backward, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create backward"</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有特殊防范机制，这个程序很快就会死锁，如果上面程序运行 <code>backoff 0</code>，就会看到死锁现象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/backoff 0</span></span><br><span class="line">backward lock got 2</span><br><span class="line">backward locker got 1</span><br><span class="line">forward lock got 0</span><br></pre></td></tr></table></figure><p>上面两个线程都调用 <code>pthread_mutex_lock</code> 来加锁每个互斥量，由于线程从不同的端开始，所以它们在中间遇到时就会死锁。<br>而使用回退算法的程序，不管运行多少次循环，上面的程序都会正常执行，而不会发生死锁现象。</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量是用来通知共享数据状态信息的。可以使用条件变量来通知队列已空、或队列非空、或任何其他需要由线程处理的共享数据状态。</p><p>当一个线程互斥地访问其享状态时，它可能发现在其他线程改变状态之前它什么也做不了。即没有破坏不变量，但是线程就是对当前状态不感兴趣。例如，一个处理队列的线程发现队列为空时，它只能等恃，直到有一个节点被添加进队列中。</p><p>条件变置不提供互斥，需要一个互斥量来同步对共享数据的访问。</p><p>一个条件变量应该与一个谓词相关，如果试图将一个条件变量与多个谓词相关，或者将多个条件变量与一个谓词相关，就有陷入死锁或者竞争问题的危险。</p><h3 id="创建和释放条件变量"><a href="#创建和释放条件变量" class="headerlink" title="创建和释放条件变量"></a>创建和释放条件变量</h3><p>程序中由 <code>pthread_cond_t</code> 类型的变量来表示条件变量。如果声明了一个使用默认属性值的静态条件变量，则需要要使用 <code>PTHREAD_COND_TNTTIALIZER</code> 宏初始化，这样初始化的条件变量不必主动释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_tcond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure><p>下面时一个静态初始化条件变量的实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_struct_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  cond;</span><br><span class="line">    <span class="keyword">int</span>             value;</span><br><span class="line">&#125; <span class="keyword">my_struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my_struct_t</span> data = &#123;PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时无法静态地初始化一个条件变量，例如，当使用 <code>malloc</code> 分配一个包含条件变量的结构时，这时，你需要调用 <code>pthread_cond_init</code> 来动态地初始化条件变量。当动态初始化条件变量时，应该在不需要它时调用 <code>pthread_cond_destory</code> 来释放它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *condattr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p>下面是一个动态初始化条件变量的实例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_struct_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  cond;</span><br><span class="line">    <span class="keyword">int</span>             value;</span><br><span class="line">&#125; <span class="keyword">my_struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">my_struct_t</span> *data;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"> </span><br><span class="line">    data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">my_struct_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>)</span><br><span class="line">        errno_abort(<span class="string">"Allocate structure"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_init(&amp;data-&gt;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cond_init(&amp;data-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init condition"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cond_destroy(&amp;data-&gt;cond);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Destroy condition"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_destroy(&amp;data-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Destroy mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等待条件变量和唤醒等待线程"><a href="#等待条件变量和唤醒等待线程" class="headerlink" title="等待条件变量和唤醒等待线程"></a>等待条件变量和唤醒等待线程</h3><p>每个条件变量必须与一个特定的互斥量、一个谓词条件相关联。当线程等待条件变量时，它必须轉相关互斥量锁住。记住，在阻寒线程之前，条件变量等待操作将解锁互斥量；而在重新返回线程之前，会再次锁住互斥量。</p><p>所有并发地（同时）等待同一个条件变量的线程心须指定同一个相关互斥量。例如，Pthreads不允许线程1使用互斥量 A 等待条件变量 A，而线程2使用互斥量 B 等待条件变量 A。不过，以下情况是十分合理的：线程1使用互斥量 A 等待条件变量 A，而线程2使用互斥量 A 等待条件变量 B。即，任何条件变量在特定时刻只能与一个互斥量相关联，而互斥量则可以同时与多个条件变过关联。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(pthread_cond *cond, <span class="keyword">pthread_mutex_t</span> *mutex, struct timespec *expiration)</span></span>;</span><br></pre></td></tr></table></figure><p>一旦有线程为某个谓词在等待一个条件变量，你可能需要唤醒它。Pthreads 提供了两种方式唤醒等待的线程：一个是“发信号”，一个是“广播”。发信号只唤醒一个等待该条件变量的线程，而广播将唤醒所有等待该条件变量的线程。</p><p>广播与发信号真正的区别是效率：广播将唤醒额外的等待线程，而这些线程会检测自己的谓词然后继续等待，通常，不能用发信号代替广播。“当有什么疑惑的时候，就使用广播”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p>下面实例展示了如何等待条件变量，唤醒正在睡眠的等待线程。<br>线程 <code>wait_thread</code> 等待指定时间后，设置 <code>value</code> 值后，发送信号给条件变量。<br>主线程调用 <code>pthread_cond_timedwait</code> 函数等待最多2秒，如果 <code>hibernation</code> 大于2秒则条件变量等待将会超时，返回 <code>ETIMEOUT</code>;<br>如果 <code>hibernation</code> 设置为2秒，则主线程与 <code>wait_thread</code> 线程发生竞争，每次运行结果可能不同；<br>如果 <code>hibertnation</code> 设置少于2秒，则条件变量等待永远不会超时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_struct_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  cond;</span><br><span class="line">    <span class="keyword">int</span>             value;</span><br><span class="line">&#125; <span class="keyword">my_struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my_struct_t</span> data = &#123;PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hibernation = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">wait_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    sleep(hibernation);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_lock(&amp;data.mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line"></span><br><span class="line">    data.value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    status = pthread_cond_signal(&amp;data.cond);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Signal condition"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_unlock(&amp;data.mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Unlock mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pthread_t</span> wait_thread_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        hibernation = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;wait_thread_id, <span class="literal">NULL</span>, wait_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create wait thread"</span>);</span><br><span class="line"></span><br><span class="line">    timeout.tv_sec = time(<span class="literal">NULL</span>) + <span class="number">2</span>;</span><br><span class="line">    timeout.tv_nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_lock(&amp;data.mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (data.value == <span class="number">0</span>) &#123;</span><br><span class="line">        status = pthread_cond_timedwait(&amp;data.cond, &amp;data.mutex, &amp;timeout);</span><br><span class="line">        <span class="keyword">if</span> (status == ETIMEDOUT) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Condition wait time out.\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Wait on condition"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_unlock(&amp;data.mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Unlock mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闹钟实例最终版本"><a href="#闹钟实例最终版本" class="headerlink" title="闹钟实例最终版本"></a>闹钟实例最终版本</h3><p>之前采用 <code>mutex</code> 实现的闹钟版本并不完美，它必须在处理完当前闹铃后，才能检测其他闹铃请求是否已经被加入了列表，即使新的请求<br>的到期时间比当前请求早。例如， 首先输入命令行 <code>10 message1</code>， 然后输入 <code>5 message2</code>，那么程序是无法预知后面5秒的闹钟加入到列表中来了，只能先处理完10秒的闹钟，才能继续处理后面的内容。</p><p>我们可以增加条件变量的使用来解决这个问题，新的版本使用一个超时条件变量操作代替睡眠操作，以等待闹钟到时。<br>当主线程在列表中添加了一个新的请求时，将发信号给条件变量，立刻唤醒 <code>alarm_thread</code> 线程。<code>alarm_thread</code> 线程可以重排等待的闹铃请求，然后重新等待。</p><p>你可以在 <code>alarm_cond.c</code> 获取源代码实现。</p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不变量、临界区和谓词&quot;&gt;&lt;a href=&quot;#不变量、临界区和谓词&quot; class=&quot;headerlink&quot; title=&quot;不变量、临界区和谓词&quot;&gt;&lt;/a&gt;不变量、临界区和谓词&lt;/h2&gt;&lt;p&gt;不变量（invariant) 是由程序作出的假设， 特别是有关变量组间关系的假设。不变量可能会被破坏， 而且会经常被独立的代码段破坏。&lt;br&gt;临界区（critical section）有时称为“串行区域”，是指影响共享数据的代码段，临界区总能够对应到一个数据不变量。例如，你从队列中删除数据时， 你可以将删除数据的代码视为临界区。&lt;br&gt;谓词（Predicate) 是描述代码所需不变量的状态的语句。在英语中，谓词可以是如“队列为空”、 “资源可用” 之类的陈述。&lt;/p&gt;
&lt;h2 id=&quot;互斥量&quot;&gt;&lt;a href=&quot;#互斥量&quot; class=&quot;headerlink&quot; title=&quot;互斥量&quot;&gt;&lt;/a&gt;互斥量&lt;/h2&gt;&lt;p&gt;大部分多线程程序需要在线程间共享数据。如果两个线程同时访问共享数据就可能会有问，因为一个线程可能在另一个线程修改共享数据的过程中使用该数据，并认为共享数据保持末变。&lt;br&gt;使线程同步最通用和常用的方法就是确保对相同数据的内存访问“互斥地”进行，即一次只能允许一个线程写数据，其他线程必须等待。&lt;br&gt;同步不仅仅在修改数据时重要， 当线程需要读取其他线程写入的数据时，而且数据写入的顺序也有影响时，同样需要同步。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-线程</title>
    <link href="https://veinin.com/2018/06/05/programming_with_posix_pthreads_02/"/>
    <id>https://veinin.com/2018/06/05/programming_with_posix_pthreads_02/</id>
    <published>2018-06-05T14:22:01.000Z</published>
    <updated>2018-07-12T14:44:14.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立和使用线程"><a href="#建立和使用线程" class="headerlink" title="建立和使用线程"></a>建立和使用线程</h2><h3 id="线程标识符"><a href="#线程标识符" class="headerlink" title="线程标识符"></a>线程标识符</h3><p>程序中使用线程标识符 ID 来表示线程。线程 ID 属于封装的 pthreadLt 类型。<br>为建立线程，你需要在程序中声明一个 <code>pthread_t</code> 类型的变量。 如果只需在某个函数中使用线程 ID，或者函数直到线程终止时才返回，则可以将线程 ID 声明为自动存储变量，不过大部分时间内， 线程 ID 保存在共享变量中（静态或外部）， 或者保存在堆空间的结构体中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> thread;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>通过向 <code>pthread_create</code> 函数传送线程函数地址和线程函数调用的参数来创建线程。线程函数应该只有一个 <code>void *</code> 类型参数，并返回相同的类型值。<br>当创建线程时，<code>pthread_create</code> 函数返回一个 <code>pthread_t</code> 类型的线程 ID, 并保存在 thread 参数中。 通过这个线程 ID， 程序可以引用该线程。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread, const pthreae_attr_t *attr, void *(*start)(void *), void *arg);</span><br></pre></td></tr></table></figure><h3 id="获得自己的线程ID"><a href="#获得自己的线程ID" class="headerlink" title="获得自己的线程ID"></a>获得自己的线程ID</h3><p>线程可以通过调用 <code>pthread_self</code> 来获得自身的 ID。除非线程的创建者或者线程本身将线程 ID 保存于某处，否则不可能获得一个线程的 ID。要对线程进行任何操作都必须通过线程 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><h3 id="比较线程"><a href="#比较线程" class="headerlink" title="比较线程"></a>比较线程</h3><p>可以使用 <code>pthread_equal</code> 函数来比较两个线程 ID,只能比较二者是否相同。比较两个线程 ID 谁大谁小是没有任何意义的，因为线程 ID 之间不存在顺序。如果两个线程 ID 表示同一个线程，则 <code>pthread_equal</code> 函数返回非零值，否则返回零值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tl, <span class="keyword">pthread_t</span> t2)</span></span>;  <span class="comment">// 相等返回非0值</span></span><br></pre></td></tr></table></figure><h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>如果要创建一个从不需要控制的线程，可以是用属性（attribute）来建立线程以使它可分离的。如果不想等待创建的某个线程，而且知道不再需要控制它，可以使用 <code>pthread_detach</code> 函数来分离它。<br>分离一个正在运行的线程不会对线程带来任何影响，仅仅是通知系统当该线程结束时，其所属资源可以被回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h3><p>当 C 程序运行时，首先运行 <code>main</code> 函数。在线程代码中， 这个特殊的执行流被称为 “<strong>初始线程</strong>” 或 “<strong>主线程</strong>”。 你可以在初始线程中做任何你能在普通线程中做的事情。也可以调用 <code>pthread_exit</code> 来终止自己。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *value_ptr)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="取消线程"><a href="#取消线程" class="headerlink" title="取消线程"></a>取消线程</h3><p>外部发送终止信号给指定线程，如果成功则返回0，否则返回非0。发送成功并不意味着线程会终止。<br>另外，如果一个线程被回收，终止线程的 ID 可能被分配给其他新的线程，使用该 ID 调用 <code>pthread_cancel</code> 可能就会取消一个不同的线程， 而不是返回 ESRCH 错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h3><p>如果需要获取线程的返回值，或者需要获知其何时结束，应该调用 <code>pthread_join</code> 函数。 <code>pthread_join</code> 函数将阻塞其调用者直到指定线程终止。然后，可以选择地保存线程的返回值。调<br>用 <code>pthread_join</code> 函数将自动分离指定的线程。线程会在返回时被回收，回收将释放所有在线程终止时未释放的系统和进程资源，包栝保存线程返回值的内存空间、堆栈、保存寄存器状态的内存空间等。所以，在线程终止后上述资源就不该被访问了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **value_ptr)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程有四种基本状态：</p><ul><li>就绪（Ready）状态。线程能够运行，但在等待可用的处理器，可能刚刚启动，或刚刚从阻塞中恢复，或者被其他线程抢占。</li><li>运行（Running）状态。线程正在运行，在多处器系统中，可能有多个线程处于运行态线程由于等待处理器外的其他条件无法运行，如条件变量的改变、加锁互斥量或 I/O 操作结束。</li><li>阻塞（Blocked）状态。线程由于等待处理器外的其他条件无法运行，如条件变量的改变、加锁互斥量或 I/O 操作结束。</li><li>终止（Terminated）状态。线程从起始函数中返回，或调用 pthread_exit，或者被取消，终止自己并完成所有资源清理。不是被分离，也不是被连接，一且线程被分离或者连接，它就可以被收回。</li></ul><p>下面是线程的状态转换图：</p><p><img src="/images/pthreads/lifecycle.png" alt="pipeline"></p><p>下面程序展示了一个线程使用的完整生命周期实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">void</span> *thread_result;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread_id, &amp;thread_result);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread_result == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序中 <code>pthread_create</code> 创建线程后，线程处于就绪状态。受调度机制的限制，新线程可能在就绪状态下停留一段时间才被执行。<br>当处理器选中一个就绪线程执行它时，该线程进入运行态。通常这意味着某个其他线程被阻塞或者被时间片机制抢占，处理器会保存被阻塞（或抢占）线程的环境并恢复下二个就绪线程的环境。<br>主线程在调用 <code>pthread_join</code> 进入阻塞状态，等待它创建的线程运行结束。<br>当调用 <code>pthread_exit</code> 退出线程或调用 <code>pthread_cancel</code> 取消线程时， 线程在调用完清理过程后也将进入终止态。而主线程等到创建的线程终止后重新运行直到结束。</p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;建立和使用线程&quot;&gt;&lt;a href=&quot;#建立和使用线程&quot; class=&quot;headerlink&quot; title=&quot;建立和使用线程&quot;&gt;&lt;/a&gt;建立和使用线程&lt;/h2&gt;&lt;h3 id=&quot;线程标识符&quot;&gt;&lt;a href=&quot;#线程标识符&quot; class=&quot;headerlink&quot; title=&quot;线程标识符&quot;&gt;&lt;/a&gt;线程标识符&lt;/h3&gt;&lt;p&gt;程序中使用线程标识符 ID 来表示线程。线程 ID 属于封装的 pthreadLt 类型。&lt;br&gt;为建立线程，你需要在程序中声明一个 &lt;code&gt;pthread_t&lt;/code&gt; 类型的变量。 如果只需在某个函数中使用线程 ID，或者函数直到线程终止时才返回，则可以将线程 ID 声明为自动存储变量，不过大部分时间内， 线程 ID 保存在共享变量中（静态或外部）， 或者保存在堆空间的结构体中。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pthread_t&lt;/span&gt; thread;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-概述</title>
    <link href="https://veinin.com/2018/06/01/programming_with_posix_pthreads_01/"/>
    <id>https://veinin.com/2018/06/01/programming_with_posix_pthreads_01/</id>
    <published>2018-06-01T11:32:05.000Z</published>
    <updated>2018-07-12T14:43:46.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步（synchronous）意味着同时在一起工作。例如聊天室和在线会议就是同步的好例子，在聊天室中，人们对彼此的对话会立即得到反应。<br>同步相对来说比较简单，但开销相对较大。</p><p>异步（asynchronous) 表明事情相互独立地发生， 异步双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送。例如论坛和电子邮件就是采用异步通信的一个好例子，这样沟通的双方都会有足够的时间去思考。<br>异步增加了复杂性以及更加麻烦的调试过程。如果你没有同时执行多个活动， 那么异步就没有什么优势。 如果你开始了一个异步活动， 然后什么也不做等待它结束， 则你并没有从异步那儿获得太多好处。</p><a id="more"></a><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发（concurrency ) 的意思是指事情同时发生。 也是指让实际上可能串行发生的事情好像同时发生一样。 并发描述了单处理器系统中线程或进程的行为特点。在 POSIX 中，并发的定义要求“延迟调用线程的函数不应<br>该导致其他线程的无限期延迟。</p><p>并行（parallelism) 指并发序列同时执行， 换言之，软件中的“并行”语言中的“并发”是相同的意思， 而区別于软件中的“并发”。指事情在相同的方向上独立进行（没有交错）。</p><p>真正的并行只能在多处理器系统中存在， 但是并发可以在单处理器系统和多处理器系统中都存在。<br>并发能够在单处理器系统中存在是因为并发实际上是并行的假象。 并行要求程序能够同时执行多个操作，而并发只要求程序能够假装同时执行多个操作。</p><h3 id="单处理器和多处理器"><a href="#单处理器和多处理器" class="headerlink" title="单处理器和多处理器"></a>单处理器和多处理器</h3><p>单处理器是指一台计算机只有一个编程人员可见的执行单元（处理器）。对于拥有超标量体系结构、向量或者其他数学或 I/O 协处理器的单一通用处理器，我们仍然把它当成单处理器。</p><p>多处理器是指一台计算机拥有多个处理器，它们共享同一个指令集和相同的物理内存。虽然处理器不必同等地访问所有物理内存，但是每一个应该都能访问大部分内存。</p><h3 id="线程安全和可重入"><a href="#线程安全和可重入" class="headerlink" title="线程安全和可重入"></a>线程安全和可重入</h3><p>线程安全是指代码能够被多个线程调用而不会产生灾难性的结果。它补要求代码在多个线程中高效的运行，只要求能够安全的运行。人部分现行函数可以利用 Pthreads 提供的互斥量、 条件变量和线程私有数据来实现线程的安全。比如，在进入函数时加锁，在退出函数时解锁。这样的函数可以被多个线程调用，但一次只能有一个线程调用它。</p><p>“可重入”有时用来表示”有效的线程安全”。意味着函数不在连续的调用中保存静态数据，也不返回指向静态数据的指针。所有的数据都是由函数的调用程序提供的。重入函数不得调用非重入函数。</p><h2 id="线程的好处"><a href="#线程的好处" class="headerlink" title="线程的好处"></a>线程的好处</h2><p>多线程编程模型具有以下优点：</p><ul><li>在多处理器系统中开发程序的并行性，除了并行性这一优点是需要特殊硬件支持外， 其他优点对硬件不做要求。</li><li>在等待慢速外设 I/O 操作结束的同时， 程序可以执行其他计算， 为程序的并发提供更有效、 更自然的开发方式。</li><li>一种模块化编程模型， 能清晰地表达程序中独立事件间的相互关系。</li></ul><h2 id="线程的代价"><a href="#线程的代价" class="headerlink" title="线程的代价"></a>线程的代价</h2><p>任何事情都有代价，线程也不例外。在很多情形下好处超过了代价，在其他情形下则相反。</p><ul><li>计算负荷。比如线程间同步会直接影响运行时间，对于两个总是同时使用的变量分别加以保护，这意味着你在同步上花费太多的时间而损失了并发。</li><li>编程规则。尽管线程编程模型的基本思想简单，但是编写实际的代码不是件容易的事。编写能够在多个线程中良好工作的代码需要认真的思考和计划。你需要明白同步协议和程序中的不变量（invariant), 你不得不避免死锁、竞争和优先级倒置。</li><li>更难以调试。调试不可避免地要改变事件的时序。在调试串行代码时不会有什么大问题，但是在调试异步代码时却是致命的。如果一个线程因调试陷阱而运行得稍微慢了，则你要跟踪的问题就可能不会出现。每个程序员都会遇到此类在调试时无法再现的错误，这在线程编程中会更加普遍。</li></ul><h2 id="选择线程还是不用线程"><a href="#选择线程还是不用线程" class="headerlink" title="选择线程还是不用线程"></a>选择线程还是不用线程</h2><p>线程并非总是容易使用，而且并非总是可达到最好的性能。一些问题本身就是非并发的，添加线程线程只能降低程序的性能并使程序复杂。如果程序中的每一步都需要上一步的结果，则使用线程不会有任何帮助。每个线程不得不等待其他线程的结束。</p><p>最适合使用线程的应用包括以下这些：</p><ul><li>计算密集型应用，为了能在多处理器系统上运行，将这些计算分解到多个线程中实现。</li><li>I/O 密集型应用，为提高性能，将 I/O 操作重叠。很多线程可以同时等待不同的 I/O 操作。分布式服务器应用就是很好的实例，它们必须响应多个客户的请求，必须为通过慢速网络的连接主动提供 I/O 准备。</li></ul><h2 id="POSIX线程概念"><a href="#POSIX线程概念" class="headerlink" title="POSIX线程概念"></a>POSIX线程概念</h2><p>POSIX 线程线程 API 遵循国际正式标准 POSIX 1003.1c-1995, 我们将使用非正式的术语 “Pthreads” 代表 “POSIX 1003.1c-1995”。</p><p>线程系统包含三个基本要素：</p><ul><li>执行环境，是并发实体的状态。 并发系统必须提供建立、 删除执行环境和独立维护它们状态的方式。</li><li>调度，决定在某个给定时刻该执行哪个环境（或环境组）， 并在不同的环境中切换。</li><li>同步，为并发执行的环境提供了协调访问共享资源的一种机制。</li></ul><p>下表列出了上述三方面的几个不同的实例：</p><table><thead><tr><th>环境</th><th>执行环境</th><th>调度</th><th>同步</th></tr></thead><tbody><tr><td>交通</td><td>汽车</td><td>红绿灯</td><td>转变信号和刹车灯</td></tr><tr><td>UNIX ( 无线程 )</td><td>进程</td><td>优先级</td><td>等待和管道</td></tr><tr><td>Pthreads</td><td>线程</td><td>策略、 优先级</td><td>条件变量和互斥量</td></tr></tbody></table><h3 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h3><p>使用 Pthreads, 通过调用 <code>pthread_create</code> 来创建执行环境（线程）。 创建一个线程同样也调度了该线程的执行，这将通过调用指定的 “<strong>线程启动</strong>” 函数开始。Pthreads 允许在创建线程时指定调度参数，或者在线程运行时设定。<br>当线程调用 <code>pthread_exit</code> 时退出，或者也可以从线程启动函数中返回时退出。</p><p>基本的 Pthreads 同步模型使用 <strong>互斥量</strong> 来保护共享数据，使用 <strong>条件变量</strong> 来通信，还可以使用其他的同步机制，如 <strong>信号量</strong>、<strong>管道</strong> 和 <strong>消息队列</strong>。<br>互斥量允许线程在访问共享数据时锁定它，以避免其他线程的干扰。条件变量允许线程等待共享数据到达某个期望的状态（例如队列非空或者资源可用）。</p><h3 id="类型和接口"><a href="#类型和接口" class="headerlink" title="类型和接口"></a>类型和接口</h3><p>POSIX 线程数据类型：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>pthread_t</td><td>线程标识符</td></tr><tr><td>pthreae_mutex_t</td><td>互斥量</td></tr><tr><td>pthread_code_t</td><td>条件变量</td></tr><tr><td>pthread_key_t</td><td>线程私有权握访问键</td></tr><tr><td>pthread_attr_t</td><td>线程属性对象</td></tr><tr><td>pthread_mutexattr_t</td><td>互斥量属性对</td></tr><tr><td>pthread_condattr_t</td><td>条件变属性对象</td></tr><tr><td>pthread_once_t</td><td>“一次性初始化”控制变量</td></tr></tbody></table><h3 id="错误检查"><a href="#错误检查" class="headerlink" title="错误检查"></a>错误检查</h3><p>在传统的UNIX系统和原来的标准中．errno 是一个外部整型变量。由于该变量一次只能有一个值，所以只能支持进程中的单一执行流程。<br>传统的报错机制有许多问题，包括很难创建在报错的同时返回一个有用的 -1 值的函数。当引入多线程时会有更严重的问题。<br>Pthreads 修订版是 POSIX 中第一个与传统的 UNIX 和 C 语言报错机制相分离的部分。<br>Pthreads 中的新函数通过返回值来表示错误状态，而不是用变量。当成功时，Pthreads 函数返回 0, 并包含一个额外的输出参数来指向存有“有用结果”<br>的地址。当发生错误时，函数返回一个包含在 <code>errno</code> 变量以支持其他使用 <code>&lt;errao.h&gt;</code> 文件中的错误代码。</p><p>下面程序是一个典型的线程错误检查代码，因为 <code>pthread_t</code> 变量拥有一个无效的值，所以在使用 <code>pthread_join</code> 在遇到无效线程ID时会返回错误代码 <code>ESRCH</code>。<br>运行下面程序将显示错误消息：<code>error 3: No such process</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error %d: %s\n"</span>, status, strerror(status));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免在实例代码的每个函数调用中都增加报错和退出的代码段，我们需要写两个报错宏使用 err_abort 检测标准的 Pthreads 错误， 使用 errno_abort 检测传统的 errno 错误变量方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> err_abort(code, text) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;\</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s at \"%s\":%d: %s\n"</span>,\</span><br><span class="line">            text, __FILE__, __LINE__, strerror(code));\</span><br><span class="line">        <span class="built_in">abort</span>();\</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> errno_abort(text) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;\</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s at \"%s\":%d: %s\n"</span>,\</span><br><span class="line">            text, __FILE__, __LINE__, strerror(errno));\</span><br><span class="line">        <span class="built_in">abort</span>();\</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="异步编程举例"><a href="#异步编程举例" class="headerlink" title="异步编程举例"></a>异步编程举例</h2><p>下面使用一个简单的闹钟实例程序来演示基本的异歩编程方法。该程序循环接受用户输入信息，直到出错或者输入完毕，用户输入的每行信息中，第一部分是闹钟等待的时间（ 以秒为单位），第二部分是闹钟时间到迖时显示的文本消息。</p><h3 id="同步版本"><a href="#同步版本" class="headerlink" title="同步版本"></a>同步版本</h3><p>一直同步等待 <code>fgets</code> 产生输入，然后根据输入的秒数进行等待指定时间，最后输出闹钟响起的消息。该程序的问题是一次只能处理一个闹钟请求，如果你的程序设置了一个10分钟闹钟，就不能再继续让它在5分钟时响起另外一个闹钟。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seconds;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Alarm&gt; "</span>);</span><br><span class="line">        <span class="keyword">if</span> (fgets(line, <span class="keyword">sizeof</span>(line), <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(line) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">"%d %64[^\n]"</span>, &amp;seconds, message) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Bad command\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sleep(seconds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(%d) %s\n"</span>, seconds, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多进程版本"><a href="#多进程版本" class="headerlink" title="多进程版本"></a>多进程版本</h3><p>为每个命令使用 <code>fork</code> 调用生成一个独立的子进程来处理闹钟。<code>fork</code> 版本是异步方式的的一种实现，该程序可以随时输入命令行，它们被彼此独立地执行。 新版本并不比同步版本复杂多少。<br>该版本的主要难点在于对所有己终止子进程的 <code>reap</code>。如果程序不做这个工作，则要等到程序退出的时候由系统回收，通常回收子进程的方法是调用某个 <code>wait</code> 系列函数。在本例中，我们调用 waitpid 函数，并设置 WNOHANG（父进程不必挂等待子进程的结束）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> seconds;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Alarm&gt; "</span>);</span><br><span class="line">        <span class="keyword">if</span> (fgets(line, <span class="keyword">sizeof</span>(line), <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(line) &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">"%d %64[^\n]"</span>, &amp;seconds, message) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Bad command\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">                errno_abort(<span class="string">"Fork"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pid == (<span class="keyword">pid_t</span>)<span class="number">0</span>) &#123;</span><br><span class="line">                sleep(seconds);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"(%d) %s\n"</span>, seconds, message);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    pid = waitpid((<span class="keyword">pid_t</span>)<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">                    <span class="keyword">if</span> (pid == (<span class="keyword">pid_t</span>) <span class="number">-1</span>)</span><br><span class="line">                        errno_abort(<span class="string">"Wait for child"</span>);</span><br><span class="line">                &#125; <span class="keyword">while</span>(pid != (<span class="keyword">pid_t</span>)<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程版本"><a href="#多线程版本" class="headerlink" title="多线程版本"></a>多线程版本</h3><p>多线程版本与多进程十分相似，只是使用线程而非子进程来实现异步闹钟。本例中用到了以下三个Pthread函数：</p><ul><li><code>pthread_create</code> 函数建立一个线程， 运行由第三个参数 <code>alarm_thread</code> 指定的例程，并返回线程标识符 ID (保存在 <code>thread</code> 引用的变量中）</li><li><code>pthread_self</code> 获取当前线程标识符 ID。</li><li><code>pthread_detach</code> 函数允许在当线程终止时立刻回收线程资源。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">alarm_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  seconds;</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">64</span>];</span><br><span class="line">&#125; <span class="keyword">alarm_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">alarm_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">alarm_t</span> *alarm = (<span class="keyword">alarm_t</span>*)arg;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Detach thread"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(alarm-&gt;seconds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%d) %s\n"</span>, alarm-&gt;seconds, alarm-&gt;message);</span><br><span class="line">    <span class="built_in">free</span>(alarm);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> seconds;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">alarm_t</span> *alarm;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Alarm&gt; "</span>);</span><br><span class="line">        <span class="keyword">if</span> (fgets(line, <span class="keyword">sizeof</span>(line), <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(line) &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        alarm = (<span class="keyword">alarm_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">alarm_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (alarm == <span class="literal">NULL</span>)</span><br><span class="line">            errno_abort(<span class="string">"Allocate alarm"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">"%d %64[^\n]"</span>, &amp;alarm-&gt;seconds, alarm-&gt;message) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Bad command\n"</span>);</span><br><span class="line">            <span class="built_in">free</span>(alarm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status = pthread_create(&amp;thread, <span class="literal">NULL</span>, alarm_thread, alarm);</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Create alarm thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;术语定义&quot;&gt;&lt;a href=&quot;#术语定义&quot; class=&quot;headerlink&quot; title=&quot;术语定义&quot;&gt;&lt;/a&gt;术语定义&lt;/h2&gt;&lt;h3 id=&quot;同步与异步&quot;&gt;&lt;a href=&quot;#同步与异步&quot; class=&quot;headerlink&quot; title=&quot;同步与异步&quot;&gt;&lt;/a&gt;同步与异步&lt;/h3&gt;&lt;p&gt;同步（synchronous）意味着同时在一起工作。例如聊天室和在线会议就是同步的好例子，在聊天室中，人们对彼此的对话会立即得到反应。&lt;br&gt;同步相对来说比较简单，但开销相对较大。&lt;/p&gt;
&lt;p&gt;异步（asynchronous) 表明事情相互独立地发生， 异步双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送。例如论坛和电子邮件就是采用异步通信的一个好例子，这样沟通的双方都会有足够的时间去思考。&lt;br&gt;异步增加了复杂性以及更加麻烦的调试过程。如果你没有同时执行多个活动， 那么异步就没有什么优势。 如果你开始了一个异步活动， 然后什么也不做等待它结束， 则你并没有从异步那儿获得太多好处。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>Windows 10 子系统安装指南</title>
    <link href="https://veinin.com/2018/05/09/windows-10-bash-linux-subsystem-setup/"/>
    <id>https://veinin.com/2018/05/09/windows-10-bash-linux-subsystem-setup/</id>
    <published>2018-05-09T14:50:00.000Z</published>
    <updated>2018-05-09T16:03:07.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-Windows-的-Linux-子系统"><a href="#安装-Windows-的-Linux-子系统" class="headerlink" title="安装 Windows 的 Linux 子系统"></a>安装 Windows 的 Linux 子系统</h2><h3 id="步骤1-开启开发者模式"><a href="#步骤1-开启开发者模式" class="headerlink" title="步骤1 开启开发者模式"></a>步骤1 开启开发者模式</h3><p>菜单栏搜索 -&gt; 设置 -&gt; 针对开发人员 -&gt; 开发者模式 -&gt; 等待下载相关软件<br><img src="/images/win_bash/01.png" alt=""></p><a id="more"></a><h3 id="步骤2-开启-Windows-子系统功能"><a href="#步骤2-开启-Windows-子系统功能" class="headerlink" title="步骤2 开启 Windows 子系统功能"></a>步骤2 开启 Windows 子系统功能</h3><p>菜单栏搜索 -&gt; 控制面板 -&gt; 程序 -&gt; 勾选 “启动或关闭 Windows 功能” -&gt; 确定 -&gt; 重启电脑<br><img src="/images/win_bash/02.png" alt=""></p><h3 id="步骤3-查看-Bash-程序"><a href="#步骤3-查看-Bash-程序" class="headerlink" title="步骤3 查看 Bash 程序"></a>步骤3 查看 Bash 程序</h3><p>菜单栏搜索 -&gt; Bash -&gt; 打开后提示可以通过 Windows 应用商店来安装分发版<br><img src="/images/win_bash/03.png" alt=""></p><h3 id="步骤4-安装-ubuntu-子系统"><a href="#步骤4-安装-ubuntu-子系统" class="headerlink" title="步骤4 安装 ubuntu 子系统"></a>步骤4 安装 ubuntu 子系统</h3><p>打开 Windows 应用商店 -&gt; 搜索 ubuntu -&gt; 点击进入并选择安装 -&gt; 等待安装完成<br><img src="/images/win_bash/04.png" alt=""></p><h3 id="步骤5-设置用户名、密码"><a href="#步骤5-设置用户名、密码" class="headerlink" title="步骤5 设置用户名、密码"></a>步骤5 设置用户名、密码</h3><p>从 Windows 商店或菜单栏搜索 Ubuntu 程序启动 -&gt; 等待几分钟后 -&gt; 输入子系统的用户名和密码 -&gt; 完成安装<br><img src="/images/win_bash/05.png" alt=""></p><h2 id="升级到最新版本子系统"><a href="#升级到最新版本子系统" class="headerlink" title="升级到最新版本子系统"></a>升级到最新版本子系统</h2><p>终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure></p><h2 id="Hyper-整合-Bash"><a href="#Hyper-整合-Bash" class="headerlink" title="Hyper 整合 Bash"></a>Hyper 整合 Bash</h2><p>在终端你可以使用 bash 命令直接进入ubuntu子系统，但是 Windows 终端对于开发人员来说还是很难用的，更加推荐第三方的终端软件，比如以下两个软件：</p><ul><li><a href="https://hyper.is/" target="_blank" rel="noopener">hyper</a></li><li><a href="http://cmder.net/" target="_blank" rel="noopener">cmder</a></li></ul><p>这里推荐的是 <code>hyper</code> 终端软件，它是一个非常漂亮且实用的终端软件，并且提供了一大堆漂亮的插件和主题。</p><p>Hyper 设置直接启动 bash 终端步骤：<br>设置按钮 -&gt; Editor -&gt; Preferences -&gt; 设置文本中找到 shell 一栏 -&gt; 填入 <code>bash.exe</code> 路径</p><p>设置完毕后，重新打开 <code>hyper</code>，会自动执行 bash 命令进入 Linux 子系统。</p><p><img src="/images/win_bash/06.png" alt=""></p><h2 id="VS-Code-集成-Bash"><a href="#VS-Code-集成-Bash" class="headerlink" title="VS Code 集成 Bash"></a>VS Code 集成 Bash</h2><p>VS Code 终端默认使用的终端是 <code>PowwerShell</code>，你可以设置终端使用 Bash，这样你就可以在 VS Code 编辑代码后，直接在 Bash 终端里面编译、运行查看结果了。</p><p>VS Code 设置默认终端步骤：<br>文件菜单 -&gt; 首选项 -&gt; 设置 -&gt; 将 <code>&quot;terminal.integrated.shell.windows&quot;: &quot;C:\\Windows\\System32\\bash.exe&quot;,</code> 加入到用户设置 -&gt; 保存</p><p>设置完毕后，重新打开终端，可以看到默认打开的是 bash 终端了。</p><p><img src="/images/win_bash/07.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装-Windows-的-Linux-子系统&quot;&gt;&lt;a href=&quot;#安装-Windows-的-Linux-子系统&quot; class=&quot;headerlink&quot; title=&quot;安装 Windows 的 Linux 子系统&quot;&gt;&lt;/a&gt;安装 Windows 的 Linux 子系统&lt;/h2&gt;&lt;h3 id=&quot;步骤1-开启开发者模式&quot;&gt;&lt;a href=&quot;#步骤1-开启开发者模式&quot; class=&quot;headerlink&quot; title=&quot;步骤1 开启开发者模式&quot;&gt;&lt;/a&gt;步骤1 开启开发者模式&lt;/h3&gt;&lt;p&gt;菜单栏搜索 -&amp;gt; 设置 -&amp;gt; 针对开发人员 -&amp;gt; 开发者模式 -&amp;gt; 等待下载相关软件&lt;br&gt;&lt;img src=&quot;/images/win_bash/01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="System" scheme="https://veinin.com/categories/System/"/>
    
    
      <category term="Windows 10 Bash" scheme="https://veinin.com/tags/Windows-10-Bash/"/>
    
      <category term="Linux Subsystem Setup" scheme="https://veinin.com/tags/Linux-Subsystem-Setup/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 文件</title>
    <link href="https://veinin.com/2018/04/19/python-practice-files/"/>
    <id>https://veinin.com/2018/04/19/python-practice-files/</id>
    <published>2018-04-19T13:35:00.000Z</published>
    <updated>2018-04-19T14:51:39.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="os-path-模块"><a href="#os-path-模块" class="headerlink" title="os.path 模块"></a>os.path 模块</h2><p>os.path 模块包含了许多与文件名和文件路径相关的有用函数。<br>例如， 你已经使用了 os.path.join()来构建所有操作系统上都有效的路径。<br>因为 os.path 是 os 模块中的模块， 所以只要执行 import os 就可以导入它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br></pre></td></tr></table></figure><h2 id="文件与文件路径"><a href="#文件与文件路径" class="headerlink" title="文件与文件路径"></a>文件与文件路径</h2><p>在 Windows 上， 路径书写使用倒斜杠作为文件夹之间的分隔符。但在 OS X 和Linux 上， 使用正斜杠作为它们的路径分隔符。<br>如果想要程序运行在所有操作系统上，在编写 Python 脚本时， 就必须处理这两种情况。<br>Python 使用 <code>os.path.join()</code> 函数来做这件事很简单。<br>如果将单个文件和路径上的文件夹名称的字符串传递给它， <code>os.path.join()</code> 就会返回一个文件路径的字符串</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;usr&apos;, &apos;bin&apos;, &apos;spam&apos;)</span><br><span class="line">&apos;usr\\bin\\spam&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; myFiles = [&apos;a.txt&apos;, &apos;b.txt&apos;, &apos;c.txt&apos;]</span><br><span class="line">&gt;&gt;&gt; for fileName in myFiles:</span><br><span class="line">        print(os.path.join(&apos;C:\\Users\\App&apos;, fileName))</span><br><span class="line"></span><br><span class="line">C:\Users\App\a.txt</span><br><span class="line">C:\Users\App\b.txt</span><br><span class="line">C:\Users\App\c.txt</span><br></pre></td></tr></table></figure><h2 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h2><p>每个运行在计算机上的程序， 都有一个“ 当前工作目录”， 或 cwd。<br>利用 <code>os.getcwd()</code> 函数，可以取得当前工作路径的字符串， 并可以利用 <code>os.chdir()</code> 改变它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.getcwd()</span><br><span class="line">&apos;C:\\Users\\Ansh&apos;</span><br><span class="line">&gt;&gt;&gt; os.chdir(&apos;C:\\App&apos;)</span><br><span class="line">&gt;&gt;&gt; os.getcwd()</span><br><span class="line">&apos;C:\\App&apos;</span><br></pre></td></tr></table></figure><h2 id="创建新文件夹"><a href="#创建新文件夹" class="headerlink" title="创建新文件夹"></a>创建新文件夹</h2><p>可以用 <code>os.makedirs()</code> 函数创建新文件夹（ 目录）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(&apos;C:\\Users\\Ansh\\Desktop\\Test&apos;)</span><br></pre></td></tr></table></figure></p><h2 id="处理绝对路径和相对路径"><a href="#处理绝对路径和相对路径" class="headerlink" title="处理绝对路径和相对路径"></a>处理绝对路径和相对路径</h2><p>有两种方法指定一个文件路径。</p><ul><li>“绝对路径”， 总是从根文件夹开始。</li><li>“相对路径”，它相对于程序的当前工作目录。<br>还有点（ .）和点点（ ..）文件夹。它们不是真正的文件夹，而是可以在路径中使用的特殊名称。</li></ul><p>os.path 模块提供了一些函数， 返回一个相对路径的绝对路径， 以及检查给定的路径是否为绝对路径。</p><ul><li>调用 <code>os.path.abspath(path)</code> 将返回参数的绝对路径的字符串。</li><li>调用 <code>os.path.isabs(path)</code> ，如果参数是一个绝对路径，就返回 True，如果参数是一个相对路径，就返回 False。</li><li>调用 <code>os.path.relpath(path, start)</code> 将返回从 start 路径到 path 的相对路径的字符串。如果没有提供 start，就使用当前工作目录作为开始路径。</li><li>调用 <code>os.path.dirname(path)</code> 将返回一个字符串，它包含 path 参数中最后一个斜杠之前的所有内容。</li><li>调用 <code>os.path.basename(path)</code> 将返回一个字符串，它包含 path 参数中最后一个斜杠之后的所有内容。</li><li>调用 <code>os.path.split()</code> 获得一个路径的目录名称和基本名称， 会返回两个字符串的元组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)</span><br><span class="line">&apos;C:\\App&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.\\Scripts&apos;)</span><br><span class="line">&apos;C:\\App\\Scripts&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.isabs(&apos;.&apos;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; os.path.isabs(os.path.abspath(&apos;.&apos;))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; os.path.relpath(&apos;C:\\Windows&apos;, &apos;C:\\&apos;)</span><br><span class="line">&apos;Windows&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.relpath(&apos;C:\\Windows&apos;, &apos;C:\\spam\\eggs&apos;)</span><br><span class="line">&apos;..\\..\\Windows&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; path = &apos;C:\\Windows\\System32\\calc.exe&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.basename(path)</span><br><span class="line">&apos;calc.exe&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.dirname(path)</span><br><span class="line">&apos;C:\\Windows\\System32&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.split(path)</span><br><span class="line">(&apos;C:\\Windows\\System32&apos;, &apos;calc.exe&apos;)</span><br><span class="line">&gt;&gt;&gt; path.split(os.path.sep)</span><br><span class="line">[&apos;C:&apos;, &apos;Windows&apos;, &apos;System32&apos;, &apos;calc.exe&apos;]</span><br></pre></td></tr></table></figure><h2 id="文件大小和文件夹内容"><a href="#文件大小和文件夹内容" class="headerlink" title="文件大小和文件夹内容"></a>文件大小和文件夹内容</h2><p>一旦有办法处理文件路径， 就可以开始搜集特定文件和文件夹的信息。</p><ul><li>调用 <code>os.path.getsize(path)</code> 将返回 path 参数中文件的字节数。</li><li>调用 <code>os.listdir(path)</code> 将返回文件名字符串的列表，包含 path 参数中的每个文件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.getsize(&apos;C:\\Windows\\System32\\calc.exe&apos;)</span><br><span class="line">26112L</span><br><span class="line">&gt;&gt;&gt; os.listdir(&apos;C:\\App\\Python27&apos;)</span><br><span class="line">[&apos;DLLs&apos;, &apos;Doc&apos;, &apos;include&apos;, &apos;Lib&apos;, &apos;libs&apos;, &apos;LICENSE.txt&apos;, &apos;NEWS.txt&apos;, &apos;python.exe&apos;, &apos;pythonw.exe&apos;, &apos;README.txt&apos;, &apos;Scripts&apos;, &apos;tcl&apos;, &apos;Tools&apos;, &apos;w9xpopen.exe&apos;]</span><br></pre></td></tr></table></figure><h2 id="检查路径有效性"><a href="#检查路径有效性" class="headerlink" title="检查路径有效性"></a>检查路径有效性</h2><p>如果你提供的路径不存在， 许多 Python 函数就会崩溃并报错。 <code>os.path</code> 模块提供了一些函数，用于检测给定的路径是否存在，以及它是文件还是文件夹。</p><ul><li>调用 <code>os.path.exists(path)</code> ，返回所指的文件或文件夹是否存在。</li><li>调用 <code>os.path.isfile(path)</code> ，返回目标是否一个文件。</li><li>调用 <code>os.path.isdir(path)</code> ，返回目标是否一个文件夹。</li></ul><h2 id="打开并读写文件"><a href="#打开并读写文件" class="headerlink" title="打开并读写文件"></a>打开并读写文件</h2><p>在 Python 中， 读写文件有 3 个步骤：</p><ul><li>调用 <code>open()</code> 函数， 返回一个 File 对象。</li><li>调用 File 对象的 <code>read()</code> 或 <code>write()</code> 方法。</li><li>调用 File 对象的 <code>close()</code> 方法，关闭该文件。</li></ul><p>打开文件 <code>open()</code> 方法，“读模式”、“ 写模式” 和 “添加模式”。如果打开文件时用读模式，就不能写入文件。而写模式将覆写原有的文件。添加模式将在已有文件的末尾添加文本。<br><code>open</code> 方法有第二个可选参数，如果不传则是读模式打开， 参数 ‘w’ 将使用写模式打开，而参数 ‘a’ 将以添加模式打开。</p><p>对于读取文件，还可以使用 <code>readlines()</code> 方法， 从该文件取得一个字符串的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; helloFile = open(&apos;C:\\Users\\Ansh\\Desktop\\hello.txt&apos;)</span><br><span class="line">&gt;&gt;&gt; helloContent = helloFile.read()</span><br><span class="line">&gt;&gt;&gt; helloContent</span><br><span class="line">&apos;Hello, World!&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; textFile = open(&apos;C:\\Users\\Ansh\\Desktop\\text.txt&apos;)</span><br><span class="line">&gt;&gt;&gt; for line in textFile.readlines():</span><br><span class="line">        print(line.strip())</span><br><span class="line"></span><br><span class="line">When, in disgrace with fortune and men&apos;s eyes,</span><br><span class="line">I all alone beweep my outcast state,</span><br><span class="line">And trouble deaf heaven with my bootless cries,</span><br><span class="line">And look upon myself and curse my fate,</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; baconFile = open(&apos;bacon.txt&apos;, &apos;w&apos;)</span><br><span class="line">&gt;&gt;&gt; baconFile.write(&apos;Hello world!\n&apos;)</span><br><span class="line">&gt;&gt;&gt; baconFile.close()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; baconFile = open(&apos;bacon.txt&apos;, &apos;a&apos;)</span><br><span class="line">&gt;&gt;&gt; baconFile.write(&apos;Bacon is not a vegetable.&apos;)</span><br><span class="line">&gt;&gt;&gt; baconFile.close()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; baconFile = open(&apos;bacon.txt&apos;)</span><br><span class="line">&gt;&gt;&gt; print(baconFile.read())</span><br><span class="line">Hello world!</span><br><span class="line">Bacon is not a vegetable.</span><br><span class="line">&gt;&gt;&gt; baconFile.close()</span><br></pre></td></tr></table></figure><h2 id="使用-shelve-模块保存变量"><a href="#使用-shelve-模块保存变量" class="headerlink" title="使用 shelve 模块保存变量"></a>使用 shelve 模块保存变量</h2><p>你可以将 Python 程序中的变量保存到二进制的 shelf 文件中。这样， 程序就可以从硬盘中恢复变量的数据。 shelve 模块让你在程序中添加“ 保存”和“ 打开” 功能。</p><p>要利用 shelve 模块读写数据，首先要导入它。<br>调用函数 <code>shelve.open()</code> 并传入一个文件名，然后将返回的值保存在一个变量中。可以对这个变量的 shelf 值进行修改，就像它是一个字典一样。<br>当你完成时，在这个值上调用 close()。最后，在当前的工作目录下会生成一个对应的二进制文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shelfFile = shelve.open(&apos;mydata&apos;)</span><br><span class="line">cats = [&apos;Zophie&apos;, &apos;Pooka&apos;, &apos;Simon&apos;]</span><br><span class="line">shelfFile[&apos;cats&apos;] = cats</span><br><span class="line">shelfFile.close()</span><br></pre></td></tr></table></figure><p>然后，可以使用 shelve 模块， 重新打开这些文件并取出数据。<br>shelf 值不必用读模式或写模式打开，因为它们在打开后，既能读又能写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shelfFile = shelve.open(&apos;mydata&apos;)</span><br><span class="line">print(shelfFile[&apos;cats&apos;])    # [&apos;Zophie&apos;, &apos;Pooka&apos;, &apos;Simon&apos;]</span><br><span class="line">shelfFile.close()</span><br></pre></td></tr></table></figure><h3 id="shutil-模块"><a href="#shutil-模块" class="headerlink" title="shutil 模块"></a>shutil 模块</h3><p>shutil（或称为 shell 工具）模块中包含一些函数，让你在 Python 程序中复制、移动、改名和删除文件。<br>要使用 shutil 的函数，首先需要 <code>import shutil</code>。</p><h3 id="复制文件和文件夹"><a href="#复制文件和文件夹" class="headerlink" title="复制文件和文件夹"></a>复制文件和文件夹</h3><p>调用 <code>shutil.copy(source, destination)</code>，将路径 source 处的文件复制到路径 destination处的文件夹。<br>如果 destination 是一个文件名，它将作为被复制文件的新名字。该函数返回一个字符串，表示被复制文件的路径。<br>另外，可以使用 <code>shutil.copytree()</code> 复制整个文件夹里面包含的文件夹和文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import shutil, os</span><br><span class="line"></span><br><span class="line">os.chdir(&apos;C:\\&apos;)</span><br><span class="line">shutil.copy(&apos;C:\\Users\\Ansh\\Desktop\\hello.txt&apos;, &apos;C:\\temp&apos;)</span><br><span class="line">shutil.copy(&apos;C:\\temp\\hello.txt&apos;, &apos;C:\\temp\\hello2.txt&apos;)</span><br><span class="line"></span><br><span class="line">shutil.copytree(&apos;C:\\temp&apos;, &apos;C:\\Users\\Ansh\\Desktop\\temp_backup&apos;)</span><br></pre></td></tr></table></figure><h3 id="移动或改名文件和文件夹"><a href="#移动或改名文件和文件夹" class="headerlink" title="移动或改名文件和文件夹"></a>移动或改名文件和文件夹</h3><p>调用 <code>shutil.move(source, destination)</code>， 将路径 source 处的文件夹移动到路径 destination。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutil.move(&apos;C:\\temp&apos;, &apos;C:\\Users\\Ansh\\Desktop&apos;)</span><br><span class="line">shutil.move(&apos;C:\\text.txt&apos;, &apos;C:\\Users\\Ansh\\Desktop\\temp&apos;)</span><br></pre></td></tr></table></figure><h3 id="永久删除文件和文件夹"><a href="#永久删除文件和文件夹" class="headerlink" title="永久删除文件和文件夹"></a>永久删除文件和文件夹</h3><p>利用 os 模块中的函数，可以删除一个文件或一个空文件夹。但利用 shutil 模块，可以删除一个文件夹及其所有的内容。</p><ul><li>调用 <code>os.unlink(path)</code> 将删除 path 处的文件。</li><li>调用 <code>os.rmdir(path)</code> 将删除 path 处的文件夹。</li><li>调用 <code>shutil.rmtree(path)</code> 将删除 path 处的文件夹，它包含的所有文件和文件夹都会被删除。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for filename in os.listdir(&apos;C:\\Users\\Ansh\\Desktop&apos;):</span><br><span class="line">    if filename.endswith(&apos;.txt&apos;):</span><br><span class="line">        os.unlink(filename)</span><br><span class="line"></span><br><span class="line">os.makedirs(&apos;Test&apos;)</span><br><span class="line">os.rmdir(&apos;Test&apos;)</span><br><span class="line"></span><br><span class="line">shutil.rmtree(&apos;temp_back&apos;)</span><br></pre></td></tr></table></figure><h2 id="遍历目录树"><a href="#遍历目录树" class="headerlink" title="遍历目录树"></a>遍历目录树</h2><p>如果你需要对某个文件夹中的所有文件改名， 包括该文件夹中所有子文件夹中的所有文件。也就是说， 你希望遍历目录树， 处理遇到的每个文件。<br>写程序完成这件事，可能需要一些技巧。 好在， Python 提供了一个 <code>os.walk()</code> 函数， 替你处理这个过程。<br><code>os.walk()</code> 函数被传入一个字符串值，即一个文件夹的路径。你可以在一个 for循环语句中使用 os.walk()函数，遍历目录树。</p><p><code>os.walk()</code> 在循环的每次迭代中，返回 3 个值：</p><ul><li>当前文件夹名称的字符串。</li><li>当前文件夹中子文件夹的字符串的列表。</li><li>当前文件夹中文件的字符串的列表。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">path = &apos;C:\\Users\\Ansh\\Desktop\\Source\\lua-5.3.4&apos;</span><br><span class="line"></span><br><span class="line">for folderName, subFolders, fileNames in os.walk(path):</span><br><span class="line">    print(&apos;The current folder is &apos; + folderName)</span><br><span class="line"></span><br><span class="line">    for subFolder in subFolders:</span><br><span class="line">        print(&apos;Sub folder of &apos; + folderName + &apos; : &apos; + subFolder)</span><br><span class="line"></span><br><span class="line">    for fileName in fileNames:</span><br><span class="line">        print(&apos;File inside &apos; + folderName + &quot; : &quot; + fileName)</span><br></pre></td></tr></table></figure><h2 id="使用-zipfile-模块压缩文件"><a href="#使用-zipfile-模块压缩文件" class="headerlink" title="使用 zipfile 模块压缩文件"></a>使用 zipfile 模块压缩文件</h2><p>我们经常需要对一组文件进行压缩，减少它的大小，然后在网络上进行传输。ZIP 文件（ 带有.zip 文件扩展名）， 它可以包含许多其他文件的压缩内容。<br>在 Python 程序可以利用 <code>zipfile</code> 模块中的函数创建和打开（或解压） ZIP 文件。</p><h3 id="创建和添加到-ZIP-文件"><a href="#创建和添加到-ZIP-文件" class="headerlink" title="创建和添加到 ZIP 文件"></a>创建和添加到 ZIP 文件</h3><p>要创建你自己的压缩 ZIP 文件， 必须以“写模式”打开 ZipFile 对象，即传入’w’作为第二个参数。<br>如果向 ZipFile 对象的 <code>write()</code> 方法传入一个路径， Python 就会压缩该路径所指的文件， 将它加到 ZIP 文件中。<br><code>write()</code> 方法的第一个参数是一个字符串， 代表要添加的文件名。第二个参数是“压缩类型”参数，它告诉计算机使用怎样的算法来压缩文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import zipfile</span><br><span class="line"></span><br><span class="line">newZip = zipfile.ZipFile(&apos;new.zip&apos;, &quot;w&quot;)</span><br><span class="line">newZip.write(&apos;myCats.py&apos;, compress_type=zipfile.ZIP_DEFLATED)</span><br><span class="line">newZip.close()</span><br></pre></td></tr></table></figure><h3 id="读取-ZIP-文件"><a href="#读取-ZIP-文件" class="headerlink" title="读取 ZIP 文件"></a>读取 ZIP 文件</h3><p>可以使用 <code>zipfile.ZipFile()</code> 函数读取要给 ZIP 文件， 向它传入一个字符串， 表示.zip 文件的文件名。<br>ZipFile 对象有一个 <code>namelist()</code> 方法，返回 ZIP 文件中包含的所有文件和文件夹的字符串的列表。<br>可以把文件或文件夹名称传递给 ZipFile 对象的 <code>getinfo()</code> 方法来返回一个关于特定文件的 ZipInfo 对象。<br>通过 ZipInfo 对象可以读取到保存的归档文件的有用信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">readZip = zipfile.ZipFile(&apos;new.zip&apos;)</span><br><span class="line">print(readZip.namelist())</span><br><span class="line"></span><br><span class="line">catsFileInfo = readZip.getinfo(&apos;myCats.py&apos;)</span><br><span class="line">print(catsFileInfo.file_size)</span><br><span class="line">print(catsFileInfo.compress_size)</span><br><span class="line"></span><br><span class="line">readZip.close()</span><br></pre></td></tr></table></figure><h3 id="加压缩-ZIP-文件"><a href="#加压缩-ZIP-文件" class="headerlink" title="加压缩 ZIP 文件"></a>加压缩 ZIP 文件</h3><p>ZipFile 对象的 <code>extractall()</code> 方法从 ZIP 文件中解压缩所有文件和文件夹， 放到当前工作目录中。<br>可以使用 <code>extractall()</code> 方法从 ZIP 文件中解压缩所有文件。<br>也可以使用 <code>extract()</code> 方法从 ZIP 文件中解压缩单个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extractZip = zipfile.ZipFile(&apos;new.zip&apos;)</span><br><span class="line">extractZip.extractall()</span><br><span class="line">extractZip.extract(&apos;myCats.py&apos;, &apos;.\\temp&apos;)</span><br><span class="line">extractZip.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;os-path-模块&quot;&gt;&lt;a href=&quot;#os-path-模块&quot; class=&quot;headerlink&quot; title=&quot;os.path 模块&quot;&gt;&lt;/a&gt;os.path 模块&lt;/h2&gt;&lt;p&gt;os.path 模块包含了许多与文件名和文件路径相关的有用函数。&lt;br&gt;例如， 你已经使用了 os.path.join()来构建所有操作系统上都有效的路径。&lt;br&gt;因为 os.path 是 os 模块中的模块， 所以只要执行 import os 就可以导入它。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import os&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;文件与文件路径&quot;&gt;&lt;a href=&quot;#文件与文件路径&quot; class=&quot;headerlink&quot; title=&quot;文件与文件路径&quot;&gt;&lt;/a&gt;文件与文件路径&lt;/h2&gt;&lt;p&gt;在 Windows 上， 路径书写使用倒斜杠作为文件夹之间的分隔符。但在 OS X 和Linux 上， 使用正斜杠作为它们的路径分隔符。&lt;br&gt;如果想要程序运行在所有操作系统上，在编写 Python 脚本时， 就必须处理这两种情况。&lt;br&gt;Python 使用 &lt;code&gt;os.path.join()&lt;/code&gt; 函数来做这件事很简单。&lt;br&gt;如果将单个文件和路径上的文件夹名称的字符串传递给它， &lt;code&gt;os.path.join()&lt;/code&gt; 就会返回一个文件路径的字符串&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python 文件" scheme="https://veinin.com/tags/Python-%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Git 教程 - 分支</title>
    <link href="https://veinin.com/2018/04/01/git-tutorial-branching/"/>
    <id>https://veinin.com/2018/04/01/git-tutorial-branching/</id>
    <published>2018-04-01T06:26:00.000Z</published>
    <updated>2018-04-01T13:18:44.374Z</updated>
    
    <content type="html"><![CDATA[<p>有人把 Git 的分支模型称为它的”必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。</p><h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>前面提过，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。在进行提交操作时，Git 会保存一个提交对象（commit object）。</p><p>该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。</p><p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向<strong>最后</strong>那个提交对象的 master 分支。它会在每次的提交操作中自动向前移动。</p><p><img src="/images/git/branch-and-history.png" alt=""></p><a id="more"></a><h2 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h2><p>Git 使用命令 <code>git branch</code> 创建一个新分支，创建新分支后，会在当前所在的提交对象上创建一个新指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure><p><img src="/images/git/head-to-master.png" alt=""></p><p>如图，分支会有一个名为 HEAD 的特殊指针，用来标明当前所处的分支。</p><p>可以使用 <code>git log</code> 查看各个分支当前所指的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --decorate</span><br><span class="line">2f2ff67 (HEAD -&gt; master, origin/master, testing) modify the theme</span><br></pre></td></tr></table></figure><h2 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h2><p><code>git branch</code> 命令仅仅是创建一个新分支，并不会自动切换到新分支中去。如果要切换到一个已存在的分支，你需要使用 git checkout 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$git checkout testing</span><br><span class="line">Switched to branch &apos;testing&apos;</span><br><span class="line"></span><br><span class="line">$ git log --oneline --decorate</span><br><span class="line">2f2ff67 (HEAD -&gt; testing, origin/master, master) modify the theme</span><br></pre></td></tr></table></figure><p>通过 <code>git log</code> 再次查看后，我们可以看到 HEAD 指针已经指向了刚刚创建的新分支 <code>testing</code>。</p><p><img src="/images/git/head-to-testing.png" alt=""></p><p>如果我们在当前所处分支进行提交，那么 HEAD 分支随着提交操作自动向前移动，HEAD 仍然指向运行 git checkout 时所指的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim README.md</span><br><span class="line">$ git commit -a -m &apos;made a change&apos;</span><br></pre></td></tr></table></figure><p><img src="/images/git/advance-testing.png" alt=""></p><p>这是如果我们再切换回 master 分支，并且更改后提交，那么在 master 分支也会产生新的提交对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">$ vim README.md</span><br><span class="line">$ git commit -a -m &apos;made other changes&apos;</span><br></pre></td></tr></table></figure><p><img src="/images/git/advance-master.png" alt=""></p><p>以上各个分支切换工作，你只需要熟悉 <code>branch</code>、<code>checkout</code> 和 <code>commit</code> 命令，就可以在不同分支间来回切换和工作，并在时机成熟后合并它们。</p><p>最后，你可以通过 <code>git log</code> 来查看分叉历史，他会输出你提交的历史、各个分支指向的分支分叉情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">λ git log --oneline --decorate --graph --all</span><br><span class="line">* 92cd086 (HEAD -&gt; master) made other changes</span><br><span class="line">| * b5c6792 (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* 2f2ff67 (origin/master) modify the theme</span><br></pre></td></tr></table></figure><h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>Git 在当前所处分支中使用 <code>git merge</code> 命令来合并其他分支。</p><p>实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p><ul><li><p>开发某个网站。为实现某个新的需求，创建一个分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch &quot;iss53&quot;</span><br></pre></td></tr></table></figure></li><li><p>在这个分支上开展工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &apos;added a new footer [issue 53]&apos;</span><br></pre></td></tr></table></figure></li></ul><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p><ul><li><p>切换到你的线上分支（production branch）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure></li><li><p>为这个紧急任务新建一个分支，并在其中修复它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix</span><br><span class="line">Switched to a new branch &apos;hotfix&apos;</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &apos;fixed the broken email address&apos;</span><br></pre></td></tr></table></figure></li><li><p>在测试通过之后，切换回线上分支，然后合并这个修补分支，并将改动推送到线上分支,最后删除 <code>hotfix</code> 分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure></li><li><p>切换回你最初工作的分支上，继续工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout iss53</span><br><span class="line">Switched to branch &quot;iss53&quot;</span><br></pre></td></tr></table></figure></li></ul><p>在上面这个典型的使用 Git 分支的工作流中，我们使用了一个带有 -b 参数的 git checkout 命令来创建一个新分支，它等价于执行了<code>git branch</code> 和 <code>git checkout</code> 两个命令。</p><h2 id="分支合并冲突解决"><a href="#分支合并冲突解决" class="headerlink" title="分支合并冲突解决"></a>分支合并冲突解决</h2><p>在分支合并的适合，如果涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure></p><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br></pre></td></tr></table></figure></p><p>Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line"> please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure></p><p>冲突的地方使用<code>=======</code>来区分，你所处的 HEAD 指向的版本在这个区段的上半部分，合并过来的分支在这个区段的下半部分。</p><p>你可以修改冲突的地方，保留你认为何时的内容，并且删除冲突的其余部分，如上面例子，我们需要保留下半部分提交内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line"> please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>在所有冲突解决完成后，你可以再次输入 <code>git commit</code> 来完成这次合并提交。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表，其中 <code>master</code> 分支前的 <code>*</code> 号代表当前 HEAD 所指向的分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure></p><p>如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">* master  92cd086 made other changes</span><br><span class="line">  testing b5c6792 made a change</span><br></pre></td></tr></table></figure></p><p>使用 -merged 与 –no-merged 这两个选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支，。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --no-merged</span><br><span class="line">  testing</span><br><span class="line">$ git merge testing</span><br><span class="line">$ git branch --merged</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure></p><p>包含未合并的分支时，尝试使用 git branch -d 命令删除它时会失败，如果你确定要删除并丢弃那些工作，你可以使用 <code>-D</code> 选项强制删除。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有人把 Git 的分支模型称为它的”必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。&lt;/p&gt;
&lt;h2 id=&quot;分支简介&quot;&gt;&lt;a href=&quot;#分支简介&quot; class=&quot;headerlink&quot; title=&quot;分支简介&quot;&gt;&lt;/a&gt;分支简介&lt;/h2&gt;&lt;p&gt;前面提过，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。在进行提交操作时，Git 会保存一个提交对象（commit object）。&lt;/p&gt;
&lt;p&gt;该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。&lt;/p&gt;
&lt;p&gt;Git 的分支，其实本质上仅仅是指向提交对象的可变指针。Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向&lt;strong&gt;最后&lt;/strong&gt;那个提交对象的 master 分支。它会在每次的提交操作中自动向前移动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/git/branch-and-history.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://veinin.com/categories/Git/"/>
    
    
      <category term="Git 教程" scheme="https://veinin.com/tags/Git-%E6%95%99%E7%A8%8B/"/>
    
      <category term="Git 安装" scheme="https://veinin.com/tags/Git-%E5%AE%89%E8%A3%85/"/>
    
      <category term="Git 分支" scheme="https://veinin.com/tags/Git-%E5%88%86%E6%94%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git 教程 - 基础操作</title>
    <link href="https://veinin.com/2018/04/01/git-tutorial-basics/"/>
    <id>https://veinin.com/2018/04/01/git-tutorial-basics/</id>
    <published>2018-04-01T02:25:00.000Z</published>
    <updated>2018-04-02T16:45:24.344Z</updated>
    
    <content type="html"><![CDATA[<p>在获得 Git 后你需要学会使用 Git 完成各种<strong>工作中</strong>将要使用的各种基本命令。<br>例如配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改。<br>更进一步，你应该学会如何配置 Git 来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。</p><h2 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h2><p>取得 Git 项目仓库有两种方法。</p><ul><li>在现有项目或目录下导入所有文件到 Git 中。</li><li>从一个服务器克隆一个现有的 Git 仓库。</li></ul><h3 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h3><p>如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><a id="more"></a><p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。但你的项目里的文件还没有被跟踪。</p><p>如果你已经有一些文件需要让 Git 仓库来进行版本控制的话，你可使用 <code>git add</code> 命令来追踪指定文件，然后用 <code>git commit</code> 提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m &apos;initial project version&apos;</span><br></pre></td></tr></table></figure><p>如果你需要追踪指定某一类型的文件，<code>git add</code> 是支持通配符的，例如所有 <code>.c</code> 的文件：<code>git add *.c</code>；当然你也可以指定添加某些文件。</p><h2 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h2><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，你可以使用到 <code>git clone</code> 命令。<br>与其他 VCS 系统（如 Subversion）的 <code>checkout</code> 不同，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。<br>当 <code>git clone</code> 执行完后，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p><p>克隆仓库的命令格式是 git clone [url]，比如克隆一个 blog 项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:Veinin/blog.git</span><br></pre></td></tr></table></figure><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:Veinin/blog.git myblog</span><br></pre></td></tr></table></figure><p>克隆命令除了支持 <code>https://</code> 协议外，你还可以使用 <code>git://</code> 协议或者使用 SSH 传输协议 <code>user@host:path/to/repo.git</code></p><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>你工作目录下的每一个文件都不外乎这两种状态：</p><ul><li>已跟踪，是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。</li><li>未跟踪，已跟踪文件以外的所有其它文件都属于未跟踪文件。</li></ul><p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：</p><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>可以用 <code>git status</code> 命令来查看当前文件状态。刚克隆下来的项目，你的工作目录是相当干净的。如果你使用该命令，会得到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>此时，你的所有追踪文件都是未修改的，该明显显示了当前所在分支，分支名为 <code>master</code>。</p><p>随后，你可能想创建新文件，比如 README 文件，创建完后，如果你使用 <code>git status</code>，你讲看到一个未跟踪的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;My Project&apos; &gt; README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">    README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>上面的 <code>Untracked files</code> 为未跟踪文件列表，未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件。</p><h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure><p>然后使用 <code>git status</code> 命令，你会看到 README 文件已被追踪，且处于暂存状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure><p>只要在 <code>Changes to be committed</code> 这行下面的文件，就说明是已暂存状态。</p><h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><p>如果你修改了一个名为 CONTRIBUTING.md 的已被跟踪的文件，然后运行 git status 命令，会看到下面内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>文件 CONTRIBUTING.md 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。<br>要暂存这次更新，需要运行 <code>git add</code> 命令。这是个多功能命令：</p><ul><li>可以用它开始跟踪新文件。</li><li>把已跟踪的文件放到暂存区。</li><li>用于合并时把有冲突的文件标记为已解决状态等。</li></ul><p>我们运行 git add 将”CONTRIBUTING.md”放到暂存区，文件又会变成已暂存状态，然后再看看 git status 的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>假设此时，你想要在 CONTRIBUTING.md 里再加条注释， 重新编辑存盘后，准备好提交。 不过且慢，再运行 git status 看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ vim CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>现在 CONTRIBUTING.md 文件同时出现在暂存区和非暂存区。实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本。<br>如果你现在提交，CONTRIBUTING.md 的版本是你最后一次运行 git add 命令时的那个版本，而不是你运行 git commit 时，在工作目录中的当前版本。<br>所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p>git status 命令的输出十分详细，但其用语有些繁琐。你可以使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M README</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure><p>简介标识分为 5 种：</p><ul><li><code>M</code>，出现在右边表示该文件被修改了但是还没放入暂存区。</li><li><code>M</code>，出现在靠左边表示该文件被修改了并放入了暂存区。 </li><li><code>MM</code>，表示被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</li><li><code>??</code>，新增未追踪文件。</li><li><code>A</code> ，新添加到暂存区的文件。</li></ul><h3 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h3><p><code>git status</code> 命令显示可能还过于模块，但你可以用 <code>git diff</code> 命令来查看你具体修改了什么地方。</p><p>查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 4464ea4..83bfa15 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br></pre></td></tr></table></figure><p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --cached</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git add README.md</span><br><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 4464ea4..83bfa15 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br></pre></td></tr></table></figure><p>如果对上面暂存 <code>README.md</code> 文件再编辑，运行 <code>git status</code> 会看到暂存前后的两个版本。运行 <code>git diff</code> 将看到暂存前后的变化，而用 <code>git diff --cached</code> 将查看已经暂存起来的变化。</p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。<br>可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。 </p><p>文件 .gitignore 的格式规范如下：</p><ul><li>所有空行或者以 # 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob（shell 正则表达式） 模式匹配。例如星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符等等。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.a</span><br><span class="line">!lib.a</span><br><span class="line">/TODO</span><br><span class="line">build/</span><br><span class="line">doc/*.txt</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>如果暂存区域已经准备妥当可以提交了。准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><p>这种方式会启动文本编辑器以便输入本次提交的说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#new file:   README</span><br><span class="line">#modified:   CONTRIBUTING.md</span><br><span class="line">#</span><br><span class="line">~</span><br><span class="line">&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C</span><br></pre></td></tr></table></figure><p>默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。</p><p>另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;modify the README file&quot;</span><br><span class="line">[master 463dc4f] modify the README file</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后再提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ rm PROJECTS.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    PROJECTS.md</span><br></pre></td></tr></table></figure><p>然后再运行 git rm 记录此次移除文件的操作。注意，如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git rm PROJECTS.md</span><br><span class="line">rm &apos;PROJECTS.md&apos;</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    deleted:    PROJECTS.md</span><br></pre></td></tr></table></figure><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。为达到这一目的，使用 –cached 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached README</span><br></pre></td></tr></table></figure><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。 比方说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm log/\*.log</span><br></pre></td></tr></table></figure><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么。</p><p>要在 Git 中对文件改名，可以使用 <code>git mv</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git mv README.md README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure><p>它会恰如预期般正常工作。但实际上运行 <code>git mv</code> 相当于运行了以下 3 条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure><h2 id="Git-查看提交历史"><a href="#Git-查看提交历史" class="headerlink" title="Git 查看提交历史"></a>Git 查看提交历史</h2><p>你也许想回顾下提交历史，可以使用 <code>git log</code> 命令来查看。默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 2f2ff67cb4e8731dad9bb1b8ec4f0963c0368870</span><br><span class="line">Author: Veinin Guo &lt;Veinin@users.noreply.github.com&gt;</span><br><span class="line">Date:   Fri Mar 30 00:46:23 2018 +0800</span><br><span class="line"></span><br><span class="line">    modify the theme</span><br><span class="line"></span><br><span class="line">commit 633e5f7e0cbf87fba2e922956667c9cb627bd4a0</span><br><span class="line">Author: Veinin Guo &lt;Veinin@users.noreply.github.com&gt;</span><br><span class="line">Date:   Fri Mar 30 00:39:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    initialize commit</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>git log 有许多选项可以帮助你搜寻你所要找的提交：</p><ul><li>使用选项 <code>-p</code>，用来显示每次提交的内容差异。 </li><li>可以加上 <code>-2</code> 来仅显示最近两次提交。</li><li>使用 <code>--stat</code> 选项查看每次提交的简略的统计信息。</li><li>使用 <code>--pretty</code> 这个选项可以指定使用不同于默认格式的方式展示提交历史。 比如用 <code>--pretty=oneline</code> 将每个提交放在一行显示。另外还有 short，full 和 fuller 可以用</li><li>使用 <code>--pretty=format</code> 来定制要显示的记录格式，具体格式可以参考 Git 帮助文档。</li><li>按照时间作限制的选项 <code>--since</code> 和 <code>--until</code>，比如列出最近两周内的提交记录：<code>$ git log --since=2.weeks</code>；或具体到某一天：<code>git log --since=2008-03-30</code>。</li></ul><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>在任何一个阶段，你都有可能想要撤消某些操作。</p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令尝试重新提交：<br>在上次提交后马上执行了此命令，那么快照会保持不变，而你所修改的只是提交信息。例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;initial commit&apos;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如果你想取消暂存的指定文件，可以使用 <code>git reset HEAD &lt;file&gt;...</code> 来操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">$ git reset HEAD README.md</span><br></pre></td></tr></table></figure><h3 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h3><p>如果你并不想保留对某个文件的修改，可以使用 <code>git checkout -- &lt;file&gt;...</code> 将文件还原成上次提交时的样子。<strong>请注意</strong>，这个命令是非常危险，除非你确实不想修改那个文件，否则不要使用这个命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">$ git checkout -- README.md</span><br></pre></td></tr></table></figure><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。<br>管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。</p><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。<br>如果你已经克隆了自己的仓库，那么至少应该能看到 <code>origin</code> - 这是 Git 给你克隆的仓库服务器的默认名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。如果你的远程仓库不止一个，该命令会将它们全部列出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/Veinin/blog.git (fetch)</span><br><span class="line">origin  https://github.com/Veinin/blog.git (push)</span><br></pre></td></tr></table></figure></p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit</span><br><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure><p>现在你可以在命令行中使用字符串 pb 来代替整个 URL。例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>。</p><h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>从远程仓库中获得数据，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><p>如果你有一个分支设置为跟踪一个远程分支，可以使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。</p><h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push [remote-name] [branch-name]</code>。 当你想要将 master 分支推送到 origin 服务器时，那么运行这个命令就可以将你所做的备份到服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。否则，你的推送就会毫无疑问地被拒绝。</p><h3 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show [remote-name]</code> 命令。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">λ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/chenshuo/muduo.git</span><br><span class="line">  Push  URL: https://github.com/chenshuo/muduo.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    backport   new (next fetch will store in remotes/origin)</span><br><span class="line">    cpp11      new (next fetch will store in remotes/origin)</span><br><span class="line">    cpp17      tracked</span><br><span class="line">    cpp98      tracked</span><br><span class="line">    experiment stale (use &apos;git remote prune&apos; to remove)</span><br><span class="line">    gh-pages   tracked</span><br><span class="line">    mac        tracked</span><br><span class="line">    master     tracked</span><br><span class="line">  Local branch configured for &apos;git pull&apos;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &apos;git push&apos;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure><p>这条命令会列出你执行 <code>git push</code>、<code>git pull</code> 会推送到哪个分支。<br>也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 <code>git pull</code> 时哪些分支会自动合并。</p><h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>如果想要重命名引用的名字可以运行 <code>git remote rename</code> 去修改一个远程仓库的简写名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p>如果因为一些原因想要移除一个远程仓库， 可以使用 <code>git remote rm</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p><h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p>在 Git 中列出已有的标签是非常简单直观的。 只需要输入 <code>git tag</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">λ git tag   </span><br><span class="line">v0.1.0      </span><br><span class="line">v0.1.1      </span><br><span class="line">v0.1.2      </span><br><span class="line">...</span><br><span class="line">v0.9.7      </span><br><span class="line">v0.9.8      </span><br><span class="line">v1.0.0      </span><br><span class="line">v1.0.1      </span><br><span class="line">...</span><br><span class="line">v2.0.0-beta</span><br></pre></td></tr></table></figure><p>你也可以使用特定的模式查找标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">λ git tag -l v1.0.*</span><br><span class="line">v1.0.0</span><br><span class="line">v1.0.0-rc1</span><br><span class="line">v1.0.0-rc2</span><br><span class="line">v1.0.1</span><br><span class="line">v1.0.2</span><br></pre></td></tr></table></figure><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p><h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>附注标签是存储在 Git 数据库中的一个完整对象。其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。通常建议创建附注标签，这样你可以拥有以上所有信息。<br>创建附注标签，只需在在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1.0 -m &quot;new version&quot; </span><br><span class="line">$ git tag</span><br><span class="line">v0.1.0</span><br></pre></td></tr></table></figure><p>使用 <code>git show</code> 命令可以看到标签信息与对应的提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">λ git show v0.1.0</span><br><span class="line">tag v0.1.0</span><br><span class="line">Tagger: veinin &lt;veininguo@gmail.com&gt;</span><br><span class="line">Date:   Fri Mar 30 18:14:44 2018 +0800</span><br><span class="line"></span><br><span class="line">new version</span><br><span class="line"></span><br><span class="line">commit 2f2ff67cb4e8731dad9bb1b8ec4f0963c0368870</span><br><span class="line">Author: Veinin Guo &lt;Veinin@users.noreply.github.com&gt;</span><br><span class="line">Date:   Fri Mar 30 00:46:23 2018 +0800</span><br><span class="line"></span><br><span class="line">    modify the theme</span><br></pre></td></tr></table></figure><h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。 创建轻量标签，不需要使用任何选项，只需要提供标签名字：<br>如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，可以使用轻量标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.0.1</span><br><span class="line">$ git tag</span><br><span class="line">v0.0.1</span><br><span class="line">v0.1.0</span><br></pre></td></tr></table></figure><p>如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.0.1</span><br><span class="line">commit 2f2ff67cb4e8731dad9bb1b8ec4f0963c0368870</span><br><span class="line">Author: Veinin Guo &lt;Veinin@users.noreply.github.com&gt;</span><br><span class="line">Date:   Fri Mar 30 00:46:23 2018 +0800</span><br><span class="line"></span><br><span class="line">    modify the theme</span><br></pre></td></tr></table></figure><h3 id="后期标签"><a href="#后期标签" class="headerlink" title="后期标签"></a>后期标签</h3><p>可以对过去的某个提交记录打标签，当你忘记给某个时间点的提交打标签时，你可以使用提交记录的校验和（或部分）来重新打上标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">2f2ff67cb4e8731dad9bb1b8ec4f0963c0368870 modify the theme</span><br><span class="line">6d434e8c571342290ffa15d8852a9487db63b7e1 modify the theme</span><br><span class="line">633e5f7e0cbf87fba2e922956667c9cb627bd4a0 initialize commit</span><br><span class="line">ba67864882e13b588bb5061f334d8a23b7dc29b3 initialize commit</span><br><span class="line">d5a38f1858b5af96f3338060b8f13071a878b17b first commit</span><br><span class="line"></span><br><span class="line">$ git tag -a v0.0.2 633e5f7 -m &quot;initial version&quot;</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line">v0.0.1</span><br><span class="line">v0.0.2</span><br><span class="line">v0.1.0</span><br></pre></td></tr></table></figure><h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样，你可以运行 <code>git push origin [tagname]</code> 命令推送一个标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v0.1.0</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 166 bytes | 0 bytes/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/Veinin/blog.git</span><br><span class="line"> * [new tag]         v0.1.0 -&gt; v0.1.0</span><br></pre></td></tr></table></figure><p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项，这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">λ git push origin --tags</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 161 bytes | 0 bytes/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/Veinin/blog.git</span><br><span class="line"> * [new tag]         v0.0.1 -&gt; v0.0.1</span><br><span class="line"> * [new tag]         v0.0.2 -&gt; v0.0.2</span><br></pre></td></tr></table></figure><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>在 Git 中你并不能真的检出一个标签，但你可以指定某个新标签来创建新的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b version2 v0.0.2</span><br><span class="line">Switched to a new branch &apos;version2&apos;</span><br></pre></td></tr></table></figure><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>删除一个标签分两种：</p><ul><li>删除本地标签：<code>git tag -d 标签名</code></li><li>删除远程仓库标签：<code>git push origin :ref/tag/标签名</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1.0</span><br><span class="line">Deleted tag &apos;v0.1.0&apos; (was 729a196)</span><br><span class="line"></span><br><span class="line">$ git push origin :refs/tags/v0.0.1</span><br><span class="line">To https://github.com/Veinin/blog.git</span><br><span class="line"> - [deleted]         v0.0.1</span><br></pre></td></tr></table></figure><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>使用别名小技巧可以使你的 Git 体验更简单、容易、熟悉。<br>如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br><span class="line">$ git config --global alias.unstage &apos;reset HEAD --&apos;</span><br><span class="line">$ git config --global alias.last &apos;log -1 HEAD&apos;</span><br></pre></td></tr></table></figure><p>有了这些别名后，当你输入 <code>git co</code> 时，它就对应了 <code>git checkout</code> 命令，所以，如果你把你常用的一些命令设置为别名，那将对你很有帮助。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，你可以完成所有基本的 Git 本地操作：创建或者克隆一个仓库、做更改、暂存并提交这些更改、浏览你的仓库从创建到现在的所有更改的历史。<br>下一步，本书将介绍 Git 的杀手级特性：分支模型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在获得 Git 后你需要学会使用 Git 完成各种&lt;strong&gt;工作中&lt;/strong&gt;将要使用的各种基本命令。&lt;br&gt;例如配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改。&lt;br&gt;更进一步，你应该学会如何配置 Git 来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。&lt;/p&gt;
&lt;h2 id=&quot;获取-Git-仓库&quot;&gt;&lt;a href=&quot;#获取-Git-仓库&quot; class=&quot;headerlink&quot; title=&quot;获取 Git 仓库&quot;&gt;&lt;/a&gt;获取 Git 仓库&lt;/h2&gt;&lt;p&gt;取得 Git 项目仓库有两种方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在现有项目或目录下导入所有文件到 Git 中。&lt;/li&gt;
&lt;li&gt;从一个服务器克隆一个现有的 Git 仓库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;在现有目录中初始化仓库&quot;&gt;&lt;a href=&quot;#在现有目录中初始化仓库&quot; class=&quot;headerlink&quot; title=&quot;在现有目录中初始化仓库&quot;&gt;&lt;/a&gt;在现有目录中初始化仓库&lt;/h3&gt;&lt;p&gt;如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Git" scheme="https://veinin.com/categories/Git/"/>
    
    
      <category term="Git 教程" scheme="https://veinin.com/tags/Git-%E6%95%99%E7%A8%8B/"/>
    
      <category term="Git 安装" scheme="https://veinin.com/tags/Git-%E5%AE%89%E8%A3%85/"/>
    
      <category term="Git 基础" scheme="https://veinin.com/tags/Git-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Git 教程 - 起步</title>
    <link href="https://veinin.com/2018/04/01/git-tutorial-started/"/>
    <id>https://veinin.com/2018/04/01/git-tutorial-started/</id>
    <published>2018-04-01T02:10:00.000Z</published>
    <updated>2018-04-01T03:01:23.352Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 内核开源项目有着为数众广的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</p><ul><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li></ul><p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在你开始使用 Git 前，需要将它安装在你的计算机上。 即便已经安装，最好将它升级到最新的版本。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>使用 yum：<code>sudo yum install git</code><br>使用 apt-get：<code>sudo apt-get install git</code></p><h3 id="Mac-上安装"><a href="#Mac-上安装" class="headerlink" title="Mac 上安装"></a>Mac 上安装</h3><p>可以使用二进制安装程序。 官方维护的 OSX Git 安装程序可以在 Git 官方网站下载，网址为 <a href="http://git-scm.com/download/mac。" target="_blank" rel="noopener">http://git-scm.com/download/mac。</a></p><h3 id="Windows-上安装"><a href="#Windows-上安装" class="headerlink" title="Windows 上安装"></a>Windows 上安装</h3><p>官方版本可以在 Git 官方网站下载。 地址为 <a href="http://git-scm.com/download/win" target="_blank" rel="noopener">http://git-scm.com/download/win</a><br>简单的方法是安装 GitHub for Windows。 地址为 <a href="https://desktop.github.com/" target="_blank" rel="noopener">https://desktop.github.com/</a></p><h2 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h2><p>在开始学习 Git 的时候，请努力分清你对其它版本管理系统的已有认识，如 Subversion 和 Perforce 等；这么做能帮助你使用工具时避免发生混淆。 Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。</p><h3 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h3><p>相比传统的版本管理系统（CVS、Subversion、Perforce、Bazaar 等等），它们将保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。<br>反之，Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个快照流。</p><h3 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h3><p>因为你在本地磁盘上就有项目的完整历史，所以在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。<br>例如：</p><ul><li>你可以不需外连到服务器去获取历史，浏览项目的历史。</li><li>离线或者没有 VPN 时，几乎可以进行任何操作。</li></ul><h3 id="Git-保证完整性"><a href="#Git-保证完整性" class="headerlink" title="Git 保证完整性"></a>Git 保证完整性</h3><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p><h3 id="Git-一般只添加数据"><a href="#Git-一般只添加数据" class="headerlink" title="Git 一般只添加数据"></a>Git 一般只添加数据</h3><p>你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。一旦你提交快照到 Git 中，就难以再丢失数据。</p><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：</p><ul><li>已提交（committed），表示数据已经安全的保存在本地数据库中。</li><li>已修改（modified），表示修改了文件，但还没保存到数据库中。</li><li>已暂存（staged），表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li></ul><p>Git 项目的三个工作区域的概念：</p><ul><li>Git 仓库，是 Git 用来保存项目的元数据和对象数据库的地方。</li><li>工作目录，工作目录是对项目的某个版本独立提取出来的内容。</li><li>暂存区域，是一个文件，保存了下次将提交的文件列表信息。</li></ul><p>工作目录中保存着的特定版本文件，就属于已提交状态。<br>如果作了修改并颐和园已放入暂存区域，就属于已暂存状态。<br>如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。</p><h2 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h2><p>Git 有多种使用方式。 你可以使用原生的命令行模式，也可以使用 GUI 模式。 但只有在命令行模式下你才能执行 Git 的 所有 命令。</p><h3 id="获得帮助"><a href="#获得帮助" class="headerlink" title="获得帮助"></a>获得帮助</h3><p>使用 Git 命令行时有三种方法可以找到 Git 命令的使用手册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure><p>例如，如果想要获得 config 命令的手册，可以: <code>$ git help config</code></p><h3 id="初次运行配置"><a href="#初次运行配置" class="headerlink" title="初次运行配置"></a>初次运行配置</h3><p>初次安装 Git 的系统上，首先需要做几件事来定制你的 Git 环境。 每台计算机上只需要配置一次。</p><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ul><li>/etc/gitconfig 文件，包含系统上每一个用户及他们仓库的通用配置。</li><li>~/.gitconfig 或 ~/.config/git/config 文件，只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。</li><li>当前使用仓库的 Git 目录中的 config 文件（就是 .git/config），针对该仓库的配置。</li></ul><p>每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Veinin Guo&quot;</span><br><span class="line">$ git config --global user.email veininguo@gmail.com</span><br></pre></td></tr></table></figure><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">rebase.autosquash=true</span><br><span class="line">credential.helper=manager</span><br><span class="line">user.name=veinin</span><br><span class="line">user.email=veininguo@gmail.com</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你也可以通过输入 <code>git config &lt;key&gt;</code> 来检查 Git 的某一项配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">veinin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 内核开源项目有着为数众广的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。&lt;/p&gt;
&lt;p&gt;到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;速度&lt;/li&gt;
&lt;li&gt;简单的设计&lt;/li&gt;
&lt;li&gt;对非线性开发模式的强力支持（允许成千上万个并行开发的分支）&lt;/li&gt;
&lt;li&gt;完全分布式&lt;/li&gt;
&lt;li&gt;有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://veinin.com/categories/Git/"/>
    
    
      <category term="Git 教程" scheme="https://veinin.com/tags/Git-%E6%95%99%E7%A8%8B/"/>
    
      <category term="Git 安装" scheme="https://veinin.com/tags/Git-%E5%AE%89%E8%A3%85/"/>
    
      <category term="Git 基础" scheme="https://veinin.com/tags/Git-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记：游戏中属性定义、策划公式处理方案</title>
    <link href="https://veinin.com/2018/03/24/dev-notes-designer-formula-processing-solution-in-game/"/>
    <id>https://veinin.com/2018/03/24/dev-notes-designer-formula-processing-solution-in-game/</id>
    <published>2018-03-24T13:28:00.000Z</published>
    <updated>2018-08-08T15:28:12.197Z</updated>
    
    <content type="html"><![CDATA[<p>在游戏设计中，策划喜欢通过表格来制定自己的数值方案，通常一个游戏制作会有几十上百张不同功能的表格，这些表格通常采用Excel制定。大部分时候，策划更想要的是自己来操作所有数值，而不需要程序为其各种需求去正对性的通过代码来实现。</p><p>这样做有几个好处：</p><ul><li>1.策划可以独立拓展自己的业务，而不依赖于程序。</li><li>2.程序可以更加专心于自己的逻辑功能，而不用去特意维护策划的数值变动需求。</li><li>3.工作内容分离，减少沟通成本，更加提升工作效率，让各部门更加专注于自己所处的领域。</li></ul><p>在游戏日常开发中，有两个典型的应用场景，一个是角色的属性，一个是计算这些属性的公式，最后还需要通过这些属性在战斗中通过公式生成伤害数值。如果涉及复杂的战斗系统，通常一个角色的战斗属性可能会有上百种，而计算这些属性的公式，也可能成百上千。这里就会产生几个问题：属性、公式由程序去定义，还是策划自己去主导？属性、公式通过某种方式定义出来了，程序如何去使用？</p><a id="more"></a><p>最近和策划一起讨论了下，最终给出了解决方案，属性、公式都有策划去配置，但公式需要简化，于是我们先给出了两张表格。</p><h3 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h3><p>一个属性字典，对于程序来说，特别设计属性服务器、客户端传输的过程，我们可以通过一个唯一ID、类型进行，只要客户端、服务器都拥有这么一张属性字典，那么将很容易对属性进行传输：</p><table><thead><tr><th style="text-align:center">属性ID</th><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">初值</th><th style="text-align:center">描述</th><th style="text-align:center">成长公式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">strength</td><td style="text-align:center">int</td><td style="text-align:center">5</td><td style="text-align:center">力量</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">pdCorrect</td><td style="text-align:center">float</td><td style="text-align:center">1.2</td><td style="text-align:center">物理伤害修正系数</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">physicalDamage</td><td style="text-align:center">int</td><td style="text-align:center">20</td><td style="text-align:center">物理基础伤害</td><td style="text-align:center">公式1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">physicalCritical</td><td style="text-align:center">int</td><td style="text-align:center">15</td><td style="text-align:center">物理暴击率</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">physicalCriticalDec</td><td style="text-align:center">int</td><td style="text-align:center">10</td><td style="text-align:center">物理暴击抵抗率</td><td style="text-align:center"></td></tr></tbody></table><h3 id="公式表"><a href="#公式表" class="headerlink" title="公式表"></a>公式表</h3><p>一张公式表，由策划去配置，但程序得把策划的公式翻译成程序能读懂的代码。</p><table><thead><tr><th style="text-align:center">公式ID</th><th style="text-align:center">公式名称</th><th style="text-align:center">公式内容</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">physicalDamage</td><td style="text-align:center">40 <em> (level </em> pdCorrect + 1) * rand(1, 1.5)</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">physicalCriticalRate</td><td style="text-align:center">max(min(a.physicalCritical / 10 - t.physicalCriticalDec), 20), 0)</td></tr></tbody></table><h3 id="函数支持"><a href="#函数支持" class="headerlink" title="函数支持"></a>函数支持</h3><p>另外，对于策划来说，要通过公式来操作属性数据，特别是战斗中产生的伤害数据，就要求我们有一些简单函数支持，比如在Lua中，一些数学公式：<code>math.min</code>、<code>math.ceil</code>、<code>math.random</code> 等等。而对策划来说，大部分其实是不懂编程的，因此我们需要更加简化函数名称的设计。最终，我们得出需要以下函数的支持：</p><ul><li>min(…) ，返回参数中的最小值，如 min(1, 5, 2) ，会得到数值 1</li><li>max(…)，返回参数中的最大值，如 max(4, 10, 3)，会得到数值 10</li><li>rand(m, n)，当不带参数时，返回 [0,1] 区间内的浮点伪随机数，当以两个整数 m 与 n 调用时，返回一个 [m, n] 区间内的一致分布的伪随机数。如 rand(1, 10)，产生1-10区间内的一个随机数。</li><li>ceil(x)，返回不等于 x 的最小整数。如 ceil(1.55)，会得到数值 2</li><li>float(x)，返回不大于 x 的最大整数值，如 flooat(1.55)，会得到数值 1</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>有了上面这些，程序就可以编写工具，把策划配置的公式，导出成程序能够识别的公式函数了，比如：<br>怪物的随等级增长物理伤害公式：40 <em> (等级 </em> 物理伤害修正系数 + 1) * rand(1, 1.5)<br>怪物的物理暴击计算：max(min(怪物暴击率 / 10 - 目标暴击抵抗率 / 10, 25), 0)</p><p>那么其最终需要转换成代码公式函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> formula = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 怪物物理伤害公式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formula.physicalDamage</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">40</span> * (a.level * a.pdCorrect + <span class="number">1</span>) * <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, <span class="number">1.5</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 怪物暴击几率公式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formula.physicalCriticalRate</span><span class="params">(a, t)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">math</span>.<span class="built_in">max</span>(<span class="built_in">math</span>.<span class="built_in">min</span>(a.physicalCritical / <span class="number">10</span> - t.physicalCriticalDec), <span class="number">20</span>), <span class="number">0</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> formulas = &#123;</span><br><span class="line">    [<span class="number">1</span>] = formula.physicalDamage,</span><br><span class="line">    [<span class="number">2</span>] = formula.physicalCriticalRate,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formula.exec</span><span class="params">(id, ...)</span></span></span><br><span class="line">    <span class="keyword">return</span> formula[id](...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> formula</span><br></pre></td></tr></table></figure><p>有了上面的表格，外加生成的公式，我们很容易计算出一个怪物的基础属性或战斗中产生的伤害数值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> formula = <span class="built_in">require</span> <span class="string">"formula"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> monster = &#123;</span><br><span class="line">     level = <span class="number">3</span>,</span><br><span class="line">     strength = <span class="number">5</span>,</span><br><span class="line">     pdCorrect = <span class="number">1.3</span>,</span><br><span class="line">     physicalDamage = <span class="number">15</span>,</span><br><span class="line">     physicalCritical = <span class="number">35</span>,</span><br><span class="line">     physicalCriticalDec = <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> target = &#123;</span><br><span class="line">     level = <span class="number">2</span>,</span><br><span class="line">     strength = <span class="number">5</span>,</span><br><span class="line">     pdCorrect = <span class="number">1.3</span>,</span><br><span class="line">     physicalDamage = <span class="number">20</span>,</span><br><span class="line">     physicalCritical = <span class="number">35</span>,</span><br><span class="line">     physicalCriticalDec = <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 得出怪物物理伤害</span></span><br><span class="line"><span class="keyword">local</span> damage = formula.exec(<span class="number">1</span>, monster)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 得出怪物物理暴击率</span></span><br><span class="line"><span class="keyword">local</span> criticalRate = formula.exec(<span class="number">2</span>, monster, target)</span><br></pre></td></tr></table></figure><p>最终，通过这套方案的实现，程序不用再去代码里维护各种各样的公式，策划也不在需要程序来帮忙维护公式，如果需求变动，只需要更改下表格，然后重新生成一份新公式就行；如果有新属性增加，只需要在表格中创建以个新的属性值，然后不管是角色，还是战斗中都能应用到新增加的变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在游戏设计中，策划喜欢通过表格来制定自己的数值方案，通常一个游戏制作会有几十上百张不同功能的表格，这些表格通常采用Excel制定。大部分时候，策划更想要的是自己来操作所有数值，而不需要程序为其各种需求去正对性的通过代码来实现。&lt;/p&gt;
&lt;p&gt;这样做有几个好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.策划可以独立拓展自己的业务，而不依赖于程序。&lt;/li&gt;
&lt;li&gt;2.程序可以更加专心于自己的逻辑功能，而不用去特意维护策划的数值变动需求。&lt;/li&gt;
&lt;li&gt;3.工作内容分离，减少沟通成本，更加提升工作效率，让各部门更加专注于自己所处的领域。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在游戏日常开发中，有两个典型的应用场景，一个是角色的属性，一个是计算这些属性的公式，最后还需要通过这些属性在战斗中通过公式生成伤害数值。如果涉及复杂的战斗系统，通常一个角色的战斗属性可能会有上百种，而计算这些属性的公式，也可能成百上千。这里就会产生几个问题：属性、公式由程序去定义，还是策划自己去主导？属性、公式通过某种方式定义出来了，程序如何去使用？&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://veinin.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="游戏角色属性设计" scheme="https://veinin.com/tags/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E5%B1%9E%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="游戏策划公式设计" scheme="https://veinin.com/tags/%E6%B8%B8%E6%88%8F%E7%AD%96%E5%88%92%E5%85%AC%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记：MMORPG场景同步AOI解决方案</title>
    <link href="https://veinin.com/2018/03/23/dev-notes-mmorpg-aoi-algorithm/"/>
    <id>https://veinin.com/2018/03/23/dev-notes-mmorpg-aoi-algorithm/</id>
    <published>2018-03-23T11:20:00.000Z</published>
    <updated>2018-08-08T15:29:28.255Z</updated>
    
    <content type="html"><![CDATA[<p>MMO 游戏，需要解决的最重要的问题之一，就是如何把游戏世界中各种状态的改变通知给需要知道这条信息的玩家。<br>为此，需要为每个玩家设定一个AOI（Area Of Interest），当一个对象状态发生改变时，需要将信息广播出去，那些AOI覆盖到这条消息的玩家都会收到这条广播消息。</p><p>AOI 主要作用有两：<br>第一，服务器上的玩家或 NPC 状态发生改变时，将消息广播到附近的玩家。<br>第二，当玩家接近NPC时，进入NPC警戒区域，AOI 模块将消息发送给NPC，NPC再做出相应的AI反应。</p><p>目前游戏中 AOI 实现主要有3种：<br>第一种，最容易也是最笨的一种，玩家定期同步自己状态给服务器，服务器定期比较所有对象间的关系，发现可以触发 AOI 事件就发送消息。写法简单，不容易出错，但如果处理不好，效率往往是最低的。</p><a id="more"></a><h2 id="空间切割网格算法"><a href="#空间切割网格算法" class="headerlink" title="空间切割网格算法"></a>空间切割网格算法</h2><p>把整个场景用等分大的格子划分成一个个小区域，对象进入、退出、移动时都需要更新相应的格子对象列表。这种算法插入、删除对象都非常快，时间复杂度为O（1）。缺点是当对象在格子直接移动时，需要消耗大量计算时间。目前《幻想西游》采用的是这种算法。</p><h3 id="场景划分"><a href="#场景划分" class="headerlink" title="场景划分"></a>场景划分</h3><p>场景大小：200 <em> 200<br>格子大小：50 </em> 50<br>场景中需要划分等分大小的格子数： 200 / 50 <em> 200 </em> 50 = 16 个</p><p>效果如下图所示：</p><p><img src="/images/aoi/01.png" alt="aoi01"></p><h3 id="世界坐标与格子坐标"><a href="#世界坐标与格子坐标" class="headerlink" title="世界坐标与格子坐标"></a>世界坐标与格子坐标</h3><p>每个格子有对于的格子坐标，每个世界坐标可以轻易的转换成格子坐标。<br>世界坐标 (x, y) 转换成格子坐标公式为：(math.floor(x/gridWeidth), math.floor(y/gridHeight))<br>如世界坐标为 (80, 50)，转换后对应格子坐标为 (2, 1)。</p><h3 id="划分九宫格"><a href="#划分九宫格" class="headerlink" title="划分九宫格"></a>划分九宫格</h3><p>每个格子都需要维护该格子内的对象信息，同时也需要维护关心该格子的观察者信息。<br>当对象处于场景某个格子时，该对象会有 9 个自己所关心的格子，对象可以观察并收到自己关心区域的 AOI 事件。<br>当然，对象所处的格子也会被其他格子的对象所关心。也就是说一个格子里面的对象可以作为观察者，观察周围格子内对象；同时也是被观察者，被其他格子内的对象所观察。</p><p><img src="/images/aoi/02.png" alt="aoi02"></p><p>如图所示，当对象所进入格子 (2, 2) 时（红色区域），那么其关心的周围 9 个格子（浅蓝色区域）中任何一个发生 AOI 事件时，它都会收到相应的 AOI 事件消息。</p><h3 id="对象进入场景"><a href="#对象进入场景" class="headerlink" title="对象进入场景"></a>对象进入场景</h3><p>通知对象所处周围9个格子的其他对象 进入 AOI 事件。</p><h3 id="对象离开场景"><a href="#对象离开场景" class="headerlink" title="对象离开场景"></a>对象离开场景</h3><p>与进入相反，通知对象所处九宫格的其他对象 离开 AOI 事件。</p><h3 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h3><p>如果对象格子变更时，如图所示，对象纵向移动由(2, 2) 移动到 (3, 2)，45度角移动由 (2, 2) 移动到 (3, 3）：</p><p><img src="/images/aoi/03.png" alt="aoi03"></p><p>会产生3种格子：</p><ul><li>对象离开视野的格子（灰色格子），通知对象离开 AOI 事件。</li><li>对象进入视野的格子（橙色格子），通知对象进入 AOI 事件。</li><li>取所有需要操作的格子的交集（浅蓝色格子），通知对象移动 AOI 事件。</li></ul><h2 id="十字链表算法"><a href="#十字链表算法" class="headerlink" title="十字链表算法"></a>十字链表算法</h2><p>场景维护着两个双向链表（如果3D空间，则增加第3条），分别对应着 X 轴 和 Y 轴。每个链表对象的坐标按从小到大排列，也就是 X 坐标值越小，排在越前面，Y轴同理。此算法对象短距离移动时，很节省计算量，但涉及长距离移动时，计算量会非常大。</p><h3 id="对象进入场景-1"><a href="#对象进入场景-1" class="headerlink" title="对象进入场景"></a>对象进入场景</h3><p>遍历 X 轴 和 Y 轴两个链表，找出新增对象在两个轴中所处的位置，将新对象加入到指定位置，并根据新对象的通知范围（可动态设定）获得需要通知对象集合，发送 进入 AOI 事件。</p><h3 id="对象离开场景-1"><a href="#对象离开场景-1" class="headerlink" title="对象离开场景"></a>对象离开场景</h3><p>对象进入场景后，在 X 轴 和 Y 轴各保存了两个节点位置，可以通过这个位置，获取指定范围的的对象集合，发送 离开 AOI 事件。</p><h3 id="对象移动-1"><a href="#对象移动-1" class="headerlink" title="对象移动"></a>对象移动</h3><p>与格字算法类似，对象移动后也会会产生3种对象集合：</p><ul><li>更新位置前的集合，通知 离开 AOI 事件。</li><li>更新位置后的集合，通知 进入 AOI 事件。</li><li>取上面两个集合的交集，通知对象 移动 AOI 事件。</li></ul><p>处理上面产生事件顺序与格字算法相同。</p><h2 id="分层-AOI"><a href="#分层-AOI" class="headerlink" title="分层 AOI"></a>分层 AOI</h2><p>有了AOI算法，并不意味着能有满意的效果，假设场景里面放入10000人，那么按分布情况来说，即使有AOI算法，也会很糟糕，你会看到满屏幕的人，密密麻麻，卡的要死。这种情况下，玩家体验会很糟糕，所以可能需要进一步优化。<br>目前市面上见得比较多的解决方案有几种，一种是对单个场景分线，复制多个相同的场景副本，玩家随机进入某个场景的副本，以此来达到分流的目的。<br>另外一种方案，是从梦幻西游手游服务器AOI设计方案中看到的，设计一个分层AOI概念，也就是单个场景创建多个AOI对象。把玩家分通过某个规则，分在不同的层次。当人数增多时，可以动态进行分层，人数少的时候可以把层数合并回来，然后就是让玩家在人少的时候也能看到几个人，人多的时候还是看到几个人。这种优化放过来后，这是同一台服务器，效果大概是这样的，你在同一层里看到的都是你关心的人。这个感受就很好了。</p><p><img src="/images/aoi/04.png" alt="aoi04"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MMO 游戏，需要解决的最重要的问题之一，就是如何把游戏世界中各种状态的改变通知给需要知道这条信息的玩家。&lt;br&gt;为此，需要为每个玩家设定一个AOI（Area Of Interest），当一个对象状态发生改变时，需要将信息广播出去，那些AOI覆盖到这条消息的玩家都会收到这条广播消息。&lt;/p&gt;
&lt;p&gt;AOI 主要作用有两：&lt;br&gt;第一，服务器上的玩家或 NPC 状态发生改变时，将消息广播到附近的玩家。&lt;br&gt;第二，当玩家接近NPC时，进入NPC警戒区域，AOI 模块将消息发送给NPC，NPC再做出相应的AI反应。&lt;/p&gt;
&lt;p&gt;目前游戏中 AOI 实现主要有3种：&lt;br&gt;第一种，最容易也是最笨的一种，玩家定期同步自己状态给服务器，服务器定期比较所有对象间的关系，发现可以触发 AOI 事件就发送消息。写法简单，不容易出错，但如果处理不好，效率往往是最低的。&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://veinin.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MMORPG" scheme="https://veinin.com/tags/MMORPG/"/>
    
      <category term="AOI" scheme="https://veinin.com/tags/AOI/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 字符串</title>
    <link href="https://veinin.com/2018/03/18/python-practice-strings/"/>
    <id>https://veinin.com/2018/03/18/python-practice-strings/</id>
    <published>2018-03-18T08:46:00.000Z</published>
    <updated>2018-03-24T15:00:56.181Z</updated>
    
    <content type="html"><![CDATA[<p>文本是程序需要处理的最常见的数据形式。涉及字符串的操作不仅仅是使用+操作符连接两个字符串，你还可以从字符串中提取部分字符串， 添加或删除空白字符， 将字母转换成小写或大写， 检查字符串的格式是否正确。你甚至可以编写 Python 代码访问剪贴板， 复制或粘贴文本。</p><h2 id="处理字符串"><a href="#处理字符串" class="headerlink" title="处理字符串"></a>处理字符串</h2><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><p>在Python中构建一个字符串相当简单：以单引号开始和结束。<br>如果字符串里面也使用单引号的话，则需要使用双引号开始和结束来表示一个字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"I found hi's very selfish."</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>“转义字符” 让你输入一些字符，它们用其他方式是不可能放在字符串里的。转义字符包含一个倒斜杠（\）， 紧跟着是想要添加到字符串中的字符。<br>常用的转移字符包括:\’(单引号)、 \”(双引号)、 \t(制表符)、 \(倒斜杠)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'I found hi\'s very selfish.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">"I found hi's very selfish."</span></span><br></pre></td></tr></table></figure><h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><p>在字符串开始的引号之前加上 r， 那么它就成为了一个原始字符串。“原始字符串” 会完全忽略所有的转义字符， 打印出字符串中所有的倒斜杠。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">r'That is Carol\'s cat.'</span>)</span><br></pre></td></tr></table></figure><h3 id="用三重引号的多行字符串"><a href="#用三重引号的多行字符串" class="headerlink" title="用三重引号的多行字符串"></a>用三重引号的多行字符串</h3><p>虽然可以用\n转义字符将换行放入一个字符串，但使用多行字符串通常更容易。<br>在 Python 中，多行字符串的起止是 3 个单引号或 3 个双引号。“三重引号” 之间的所有引号、 制表符或换行， 都被认为是字符串的一部分。 Python 的代码块缩进规则不适用于多行字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'''Dear Alice,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Eve's cat has been arrested for catnapping.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Sincerely,</span></span><br><span class="line"><span class="string">Bob'''</span>)</span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>虽然井号字符（#） 表示这一行是注释， 但多行字符串常常用作多行注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""This is a test Python program.</span></span><br><span class="line"><span class="string">Written by Al Sweigart al@inventwithpython.com</span></span><br><span class="line"><span class="string">This program was designed for Python 3, not Python 2.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""This is a multiline comment to help</span></span><br><span class="line"><span class="string">    explain what the spam() function does."""</span></span><br><span class="line">    print(<span class="string">'Hello!'</span>)</span><br></pre></td></tr></table></figure><h3 id="字符串下标和切片"><a href="#字符串下标和切片" class="headerlink" title="字符串下标和切片"></a>字符串下标和切片</h3><p>字符串像列表一样，可以使用下标和切片。<br>字符串切片并不能修改原来的字符串。但可以从一个变量中获取切片，记录在另一个变量中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'Hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[<span class="number">1</span>]</span><br><span class="line"><span class="string">'e'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[<span class="number">-2</span>]</span><br><span class="line"><span class="string">'d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="string">'Hell'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[:<span class="number">5</span>]</span><br><span class="line"><span class="string">'Hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[<span class="number">4</span>:]</span><br><span class="line"><span class="string">'o world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text2 = text[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="string">'Hello'</span></span><br></pre></td></tr></table></figure><h3 id="字符串使用-in-和-not-in-操作符"><a href="#字符串使用-in-和-not-in-操作符" class="headerlink" title="字符串使用 in 和 not in 操作符"></a>字符串使用 in 和 not in 操作符</h3><p>像列表一样， in 和 not in 操作符也可以用于字符串。用 in 或 not in 连接两个字符串得到的表达式， 将求值为布尔值 True 或 False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span> <span class="keyword">in</span> <span class="string">'Veinin Guo'</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'Veinin Guo'</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span> <span class="keyword">in</span> <span class="string">'Veinin Guo'</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h2><p>某些字符串需要转换、分析然后产生新的字符串，字符串内置了一些常用的方法。<br><strong>注意</strong>：Python 中所有字符串操作方法并不会改变字符串本身的属性，而是返回一个操作后的新字符串。</p><h3 id="upper-、-lower-、-isupper-和-islower"><a href="#upper-、-lower-、-isupper-和-islower" class="headerlink" title="upper()、 lower()、 isupper()和 islower()"></a>upper()、 lower()、 isupper()和 islower()</h3><p>upper()和 lower() 方法会返回一个新字符串，所有字母都被相应地转换为大写或小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; text = &apos;Hello World!&apos;</span><br><span class="line">&gt;&gt;&gt; print(text.upper())</span><br><span class="line">HELLO WORLD!</span><br><span class="line">&gt;&gt;&gt; print(text.lower())</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>isupper()和islower()方法用来判断字符串是否至少有要给字母，并且所有字母都是大写或小写，相应地如果成立就会返回布尔值 True，否则返回 False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello world'</span>.isupper()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'HELLO WORLD'</span>.isupper()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello'</span>.islower()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'hello'</span>.islower()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="isX-方法"><a href="#isX-方法" class="headerlink" title="isX 方法"></a>isX 方法</h3><p>为了能判断字符串的特点，提供了一些常用的以 <code>is</code> 开头的方法。</p><ul><li>isalpha() 如果字符串非空，且只包含字母，则返回 True</li><li>isalnum() 如果字符串非空，且只包含字母和数字，则返回 True</li><li>isdecimal() 如果字符串非空，且只包含数字，则返回 True</li><li>isspace() 如果字符串非空，且只包含空格、换行和制表符，则返回 True</li><li>istitle() 如果字符串包含以大写字母开头且后面字母都是小写字母的单词，则返回 True</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc'</span>.isalpha()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc123'</span>.isalpha()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc123'</span>.isalnum()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc123'</span>.isdecimal()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'10088'</span>.isdecimal()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'  '</span>.isspace()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'I Am From China'</span>.istitle()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'I am from China'</span>.istitle()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="startswith-和-endswith"><a href="#startswith-和-endswith" class="headerlink" title="startswith() 和 endswith()"></a>startswith() 和 endswith()</h3><p>startswith() 和 endswith() 用来判断某个字符串以某个字符串开始或结束，成立则返回 True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello World'</span>.startswith(<span class="string">'Hello'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello World'</span>.startswith(<span class="string">'nihao'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello World'</span>.endswith(<span class="string">'World'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="join-和-split"><a href="#join-和-split" class="headerlink" title="join() 和 split()"></a>join() 和 split()</h3><p>join() 方法用来将一个字符串列表中的每个字符串连接成一个新的字符串。<br>而 split() 方法与 join() 方法刚好相反，它会将一个字符串按制定分隔符进行分割，返回一个分割后的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">', '</span>.join([<span class="string">'java'</span>, <span class="string">'python'</span>, <span class="string">'golang'</span>])</span><br><span class="line"><span class="string">'java, python, golang'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'I am from China'</span>.split()</span><br><span class="line">[<span class="string">'I'</span>, <span class="string">'am'</span>, <span class="string">'from'</span>, <span class="string">'China'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABCDEFGEFGEFG'</span>.split(<span class="string">'E'</span>)</span><br><span class="line">[<span class="string">'ABCD'</span>, <span class="string">'FG'</span>, <span class="string">'FG'</span>, <span class="string">'FG'</span>]</span><br></pre></td></tr></table></figure><h3 id="使用-rjust-、-ljust-和-center-方法对齐文本"><a href="#使用-rjust-、-ljust-和-center-方法对齐文本" class="headerlink" title="使用 rjust()、 ljust() 和 center() 方法对齐文本"></a>使用 rjust()、 ljust() 和 center() 方法对齐文本</h3><p>rjust() 和 ljust() 方法使用向左或向右插入空格的方式返回一个字符串的填充版本。而 center() 方法则是让字符串文本居中。<br>上面三个方法都接受两个参数，第一个参数指定填充数量。第二个参数，指定填充的字符，默认是填充空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span>.ljust(<span class="number">20</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="string">'Veinin--------------'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span>.rjust(<span class="number">20</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="string">'--------------Veinin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span>.center(<span class="number">20</span>)</span><br><span class="line"><span class="string">'       Veinin       '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span>.center(<span class="number">20</span>, <span class="string">'#'</span>)</span><br><span class="line"><span class="string">'#######Veinin#######'</span></span><br></pre></td></tr></table></figure><h3 id="使用-strip-、-rstrip-和-lstrip-方法删除空白字符"><a href="#使用-strip-、-rstrip-和-lstrip-方法删除空白字符" class="headerlink" title="使用 strip()、 rstrip() 和 lstrip() 方法删除空白字符"></a>使用 strip()、 rstrip() 和 lstrip() 方法删除空白字符</h3><p>strip()、 rstrip() 和 lstrip() 三个方法分别对一个字符串的两边、右边和左边的空白字符进行删除操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'   Veinin Guo   '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.strip()</span><br><span class="line"><span class="string">'Veinin Guo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.rstrip()</span><br><span class="line"><span class="string">'   Veinin Guo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.lstrip()</span><br><span class="line"><span class="string">'Veinin Guo   '</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本是程序需要处理的最常见的数据形式。涉及字符串的操作不仅仅是使用+操作符连接两个字符串，你还可以从字符串中提取部分字符串， 添加或删除空白字符， 将字母转换成小写或大写， 检查字符串的格式是否正确。你甚至可以编写 Python 代码访问剪贴板， 复制或粘贴文本。&lt;/p&gt;
&lt;h2 id=&quot;处理字符串&quot;&gt;&lt;a href=&quot;#处理字符串&quot; class=&quot;headerlink&quot; title=&quot;处理字符串&quot;&gt;&lt;/a&gt;处理字符串&lt;/h2&gt;&lt;h3 id=&quot;双引号&quot;&gt;&lt;a href=&quot;#双引号&quot; class=&quot;headerlink&quot; title=&quot;双引号&quot;&gt;&lt;/a&gt;双引号&lt;/h3&gt;&lt;p&gt;在Python中构建一个字符串相当简单：以单引号开始和结束。&lt;br&gt;如果字符串里面也使用单引号的话，则需要使用双引号开始和结束来表示一个字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;I found hi&#39;s very selfish.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 字典</title>
    <link href="https://veinin.com/2018/03/18/python-practice-dictionaries/"/>
    <id>https://veinin.com/2018/03/18/python-practice-dictionaries/</id>
    <published>2018-03-18T08:10:00.000Z</published>
    <updated>2018-03-24T14:09:51.148Z</updated>
    
    <content type="html"><![CDATA[<p>字典数据类型提供了一种灵活的访问和组织数据的方式。<br>像列表一样，“字典”是许多值的集合。但不像列表的下标， 字典的索引可以使用许多不同数据类型， 不只是整数。 字典的索引被称为“键”，键及其关联的值称为“键-值”对。<br>字典仍然可以用整数值作为键， 就像列表使用整数值作为下标一样， 但它们不必从 0 开始， 可以是任何数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myCat = &#123;<span class="string">'size'</span>: <span class="string">'fat'</span>, <span class="string">'color'</span>: <span class="string">'gray'</span>, <span class="string">'disposition'</span>: <span class="string">'loud'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myCat[<span class="string">'size'</span>]</span><br><span class="line"><span class="string">'fat'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'My cat has '</span> + myCat[<span class="string">'color'</span>] + <span class="string">' fur.'</span></span><br><span class="line"><span class="string">'My cat has gray fur.'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ticket = &#123;<span class="number">12306</span>: <span class="string">'websites'</span>, <span class="number">123456</span>: <span class="string">'phone number'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ticket[<span class="number">12306</span>]</span><br><span class="line"><span class="string">'websites'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ticket[<span class="number">123456</span>]</span><br><span class="line"><span class="string">'phone number'</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="字典与列表"><a href="#字典与列表" class="headerlink" title="字典与列表"></a>字典与列表</h2><p>确定两个列表是否相同时， 表项的顺序很重要。<br>字典不像列表，字典中的表项是不排序的，键-值对输入的顺序并不重要。<br>因为字典是不排序的， 所以不能像列表那样切片。<br>尽管字典是不排序的，但可以用任意值作为键，这一点让你能够用强大的方式来组织数据。<br>尝试访问字典中不存在的键， 将导致 KeyError 出错信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'cats'</span>, <span class="string">'dogs'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">'dogs'</span>, <span class="string">'cats'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'age'</span>: <span class="number">25</span>, <span class="string">'firstName'</span>: <span class="string">'Veinin'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c == d</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'lastName'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'lastName'</span></span><br></pre></td></tr></table></figure><h2 id="keys-、-values-和-items-方法"><a href="#keys-、-values-和-items-方法" class="headerlink" title="keys()、 values()和 items()方法"></a>keys()、 values()和 items()方法</h2><p>有 3 个字典方法，它们将返回类似列表的值，分别对应于字典的键、值和键-值对：keys()、 values()和 items()。<br>这些方法返回的值不是真正的列表，它们不能被修改，没有append()方法。但这些数据类型（分别是 dict_keys、 dict_values 和 dict_items）可以用于for 循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'lastName'</span>: <span class="string">'Guo'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> person.keys():</span><br><span class="line">        print(k)</span><br><span class="line"></span><br><span class="line">firstName</span><br><span class="line">lastName</span><br><span class="line">age</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> v <span class="keyword">in</span> person.values():</span><br><span class="line">        print(v)</span><br><span class="line"></span><br><span class="line">Veinin</span><br><span class="line">Guo</span><br><span class="line"><span class="number">18</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> person.items():</span><br><span class="line">        print(k, v)</span><br><span class="line"></span><br><span class="line">firstName Veinin</span><br><span class="line">lastName Guo</span><br><span class="line">age <span class="number">18</span></span><br></pre></td></tr></table></figure><h2 id="检查字典中是否存在键或值"><a href="#检查字典中是否存在键或值" class="headerlink" title="检查字典中是否存在键或值"></a>检查字典中是否存在键或值</h2><p>in 和 not in 操作符可以检查值是否存在于列表中。也可以利用这些操作符，检查某个键或值是否存在于字典中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'lastName'</span>: <span class="string">'Guo'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'name'</span> <span class="keyword">in</span> person</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'sex'</span> <span class="keyword">not</span> <span class="keyword">in</span> person</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><p>在访问一个键的值之前，检查该键是否存在于字典中，这很麻烦。好在，字典有一个 get()方法，它有两个参数：要取得其值的键，以及如果该键不存在时，返回的备用值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'lastName'</span>: <span class="string">'Guo'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"I'm "</span> + str(person.get(<span class="string">'age'</span>, <span class="number">0</span>)) + <span class="string">'.'</span></span><br><span class="line"><span class="string">"I'm 18."</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'His height is '</span> + str(person.get(<span class="string">'height'</span>, <span class="number">188</span>)) + <span class="string">'cm.'</span></span><br><span class="line"><span class="string">'His height is 188cm.'</span></span><br></pre></td></tr></table></figure><h2 id="setdefault-方法"><a href="#setdefault-方法" class="headerlink" title="setdefault()方法"></a>setdefault()方法</h2><p>你常常需要为字典中某个键设置一个默认值，当该键没有任何值时使用它。<br>setdefault()方法的第一个参数，是要检查的键。第二个参数，是如果该键不存在时要设置的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'lastName'</span>: <span class="string">'Guo'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person.setdefault(<span class="string">'height'</span>, <span class="number">180</span>)</span><br><span class="line"><span class="number">180</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'His height is '</span> + str(person.get(<span class="string">'height'</span>, <span class="number">188</span>)) + <span class="string">'cm.'</span>)</span><br><span class="line">His height <span class="keyword">is</span> <span class="number">180</span>cm.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字典数据类型提供了一种灵活的访问和组织数据的方式。&lt;br&gt;像列表一样，“字典”是许多值的集合。但不像列表的下标， 字典的索引可以使用许多不同数据类型， 不只是整数。 字典的索引被称为“键”，键及其关联的值称为“键-值”对。&lt;br&gt;字典仍然可以用整数值作为键， 就像列表使用整数值作为下标一样， 但它们不必从 0 开始， 可以是任何数字。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myCat = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;size&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;fat&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;color&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;gray&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;disposition&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;loud&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myCat[&lt;span class=&quot;string&quot;&gt;&#39;size&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;fat&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&#39;My cat has &#39;&lt;/span&gt; + myCat[&lt;span class=&quot;string&quot;&gt;&#39;color&#39;&lt;/span&gt;] + &lt;span class=&quot;string&quot;&gt;&#39; fur.&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;My cat has gray fur.&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ticket = &amp;#123;&lt;span class=&quot;number&quot;&gt;12306&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;websites&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;123456&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;phone number&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ticket[&lt;span class=&quot;number&quot;&gt;12306&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;websites&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ticket[&lt;span class=&quot;number&quot;&gt;123456&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;phone number&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 列表</title>
    <link href="https://veinin.com/2018/03/18/python-practice-list/"/>
    <id>https://veinin.com/2018/03/18/python-practice-list/</id>
    <published>2018-03-18T07:50:00.000Z</published>
    <updated>2018-03-24T14:10:00.527Z</updated>
    
    <content type="html"><![CDATA[<p>列表和元组可以包含多个值，这样编写程序来处理大量数据就变得更容易。而且，由于列表本身又可以包含其他列表，所以可以用它们将数据安排成层次结构。</p><h2 id="列表数据类型"><a href="#列表数据类型" class="headerlink" title="列表数据类型"></a>列表数据类型</h2><p>“列表” 是一个值， 它包含多个字构成的序列。列表用左方括号开始， 右方括号结束，即[]。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="用下标取得列表中的单个值"><a href="#用下标取得列表中的单个值" class="headerlink" title="用下标取得列表中的单个值"></a>用下标取得列表中的单个值</h2><p>列表后面方括号内的整数被称为“下标”。列表中第一个值的下标是 0，第二个值的下标是 1，第三个值的下标是 2，依此类推。<br>如果使用的下标超出了列表中值的个数， Python 将给出 IndexError 出错信息。<br>列表也可以包含其他列表值。这些列表的列表中的值， 可以通过多重下标来访问。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, [<span class="string">'red and blue'</span>, <span class="string">'red and green'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">0</span>]</span><br><span class="line">red</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>]</span><br><span class="line">green</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">2</span>]</span><br><span class="line">blue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>] + colors[<span class="number">2</span>]</span><br><span class="line">greenblue</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pcolors[<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">red <span class="keyword">and</span> green</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">5</span>]</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure></p><h2 id="负数下标"><a href="#负数下标" class="headerlink" title="负数下标"></a>负数下标</h2><p>虽然下标从 0 开始并向上增长，但也可以用负整数作为下标。整数值−1 指的是列表中的最后一个下标， −2 指的是列表中倒数第二个下标，以此类推。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-1</span>]</span><br><span class="line">blue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-3</span>]</span><br><span class="line">red</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-1</span>] + colors[<span class="number">-3</span>]</span><br><span class="line">bluered</span><br></pre></td></tr></table></figure></p><h2 id="用-len-取得列表的长度"><a href="#用-len-取得列表的长度" class="headerlink" title="用 len()取得列表的长度"></a>用 len()取得列表的长度</h2><p>len()函数将返回传递给它的列表中值的个数， 就像它能计算字符串中字符的个数一样。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(colors)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p><h2 id="用下标改变列表中的值"><a href="#用下标改变列表中的值" class="headerlink" title="用下标改变列表中的值"></a>用下标改变列表中的值</h2><p>可以使用列表的下标来改变下标处的值。例如， <code>spam[1] = &#39;aardvark&#39;</code> 意味着“将列表 spam 下标 1 处的值赋值为字符串’aardvark’。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>] = <span class="string">'red and blue'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>]</span><br><span class="line"><span class="string">'red and blue'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-1</span>] = <span class="string">'blue and red'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(colors[<span class="number">-1</span>])</span><br><span class="line">blue <span class="keyword">and</span> red</span><br></pre></td></tr></table></figure></p><h2 id="列表连接和列表复制"><a href="#列表连接和列表复制" class="headerlink" title="列表连接和列表复制"></a>列表连接和列表复制</h2><p>操作符可以连接两个列表， 得到一个新列表， 就像它将两个字符串合并成一个新字符串一样。 *操作符可以用于一个列表和一个整数，实现列表的复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><h2 id="用-del-语句从列表中删除值"><a href="#用-del-语句从列表中删除值" class="headerlink" title="用 del 语句从列表中删除值"></a>用 del 语句从列表中删除值</h2><p>del 语句将删除列表中下标处的值， 表中被删除值后面的所有值， 都将向前移动一个下标。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> colors[<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>, <span class="string">'green'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> colors[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="列表用于循环"><a href="#列表用于循环" class="headerlink" title="列表用于循环"></a>列表用于循环</h2><p>在 for 循环中可以使用 range(len(someList))， 来迭代列表的每一个下标。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(colors)):</span><br><span class="line">        print(<span class="string">'Index : '</span> + str(i) + <span class="string">" in color is: "</span> + colors[i])</span><br><span class="line"></span><br><span class="line">Index : <span class="number">0</span> <span class="keyword">in</span> color <span class="keyword">is</span>: red</span><br><span class="line">Index : <span class="number">1</span> <span class="keyword">in</span> color <span class="keyword">is</span>: green</span><br><span class="line">Index : <span class="number">2</span> <span class="keyword">in</span> color <span class="keyword">is</span>: blue</span><br></pre></td></tr></table></figure></p><h2 id="in-和-not-in-操作符"><a href="#in-和-not-in-操作符" class="headerlink" title="in 和 not in 操作符"></a>in 和 not in 操作符</h2><p>利用 in 和 not in 操作符， 可以确定一个值否在列表中。 像其他操作符一样， in和 not in 用在表达式中， 连接两个值： 一个要在列表中查找的值， 以及待查找的列表。这些表达式将求值为布尔值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'red'</span> <span class="keyword">in</span> colors</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'black'</span> <span class="keyword">not</span> <span class="keyword">in</span> colors</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><h2 id="多重赋值技巧"><a href="#多重赋值技巧" class="headerlink" title="多重赋值技巧"></a>多重赋值技巧</h2><p>多重赋值技巧是一种快捷方式， 让你在一行代码中， 用列表中的值为多个变量赋值。<br>所以不必像这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">red = colors[<span class="number">0</span>]</span><br><span class="line">green = colors[<span class="number">1</span>]</span><br><span class="line">blue = colors[<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p>可有使用如下技巧：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">red, green, blue = colors</span><br></pre></td></tr></table></figure></p><p>最后要注意变量的数目和列表的长度必须严格相等， 否则 Python 将给出 ValueError。</p><h2 id="增强赋值"><a href="#增强赋值" class="headerlink" title="增强赋值"></a>增强赋值</h2><p>针对+、 -、 *、 /和%操作符， 都有增强的赋值操作符。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">a += <span class="number">1</span></span><br><span class="line">a -= <span class="number">2</span></span><br><span class="line">a *= <span class="number">2</span></span><br><span class="line">a /= <span class="number">2</span></span><br><span class="line">a %= <span class="number">5</span></span><br><span class="line"></span><br><span class="line">print(a) <span class="comment"># 9.0</span></span><br></pre></td></tr></table></figure></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法和函数是一回事，只是它是调用在一个值上。方法部分跟在这个值后面，以一个句点分隔。<br>每种数据类型都有它自己的一组方法。例如， 列表数据类型有一些有用的方法，用来查找、 添加、 删除或操作列表中的值。</p><h3 id="用-index-方法在列表中查找值"><a href="#用-index-方法在列表中查找值" class="headerlink" title="用 index()方法在列表中查找值"></a>用 index()方法在列表中查找值</h3><p>列表值有一个 index()方法， 可以传入一个值， 如果该值存在于列表中， 就返回它的下标。如果该值不在列表中， Python 就报 ValueError。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.index(<span class="string">'red'</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.index(<span class="string">'black'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: <span class="string">'black'</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> list</span><br></pre></td></tr></table></figure></p><h3 id="用-append-和-insert-方法在列表中添加值"><a href="#用-append-和-insert-方法在列表中添加值" class="headerlink" title="用 append()和 insert()方法在列表中添加值"></a>用 append()和 insert()方法在列表中添加值</h3><p>使用append()方法调用， 可以将参数添加到列表末尾。<br>insert()方法可以在列表任意下标处插入一个值。 insert()方法的第一个参数是新值的下标， 第二个参数是要插入的新值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.append(<span class="string">'black'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.insert(<span class="number">1</span>, <span class="string">'orange'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>, <span class="string">'orange'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="用-remove-方法从列表中删除值"><a href="#用-remove-方法从列表中删除值" class="headerlink" title="用 remove()方法从列表中删除值"></a>用 remove()方法从列表中删除值</h3><p>给 remove()方法传入一个值，它将从被调用的列表中删除。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'orange'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.remove(<span class="string">'black'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.remove(<span class="string">'orange'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="用-sort-方法将列表中的值排序"><a href="#用-sort-方法将列表中的值排序" class="headerlink" title="用 sort()方法将列表中的值排序"></a>用 sort()方法将列表中的值排序</h3><p>数值的列表或字符串的列表， 能用 sort()方法排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'red'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>也可以指定 reverse 关键字参数为 True， 让 sort()按逆序排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>排序注意事项：</p><ul><li>首先， sort()方法当场对列表排序。不要写出 colors = colors.sort()这样的代码。</li><li>其次， 不能对既有数字又有字符串值的列表排序，因为 Python 不知道如何比较它们。</li><li>第三， sort()方法对字符串排序时， 使用“ASCII 字符顺序”， 而不是实际的字典顺序。这意味着大写字母排在小写字母之前。因此在排序时， 小写的 a 在大写的 Z 之后。</li></ul><h2 id="类似列表的类型：字符串和元组"><a href="#类似列表的类型：字符串和元组" class="headerlink" title="类似列表的类型：字符串和元组"></a>类似列表的类型：字符串和元组</h2><p>列表并不是唯一表示序列值的数据类型。例如， 字符串和列表实际上很相似，只要你认为字符串是单个文本字符的列表。对列表的许多操作， 也可以作用于字符串：按下标取值、 切片、 用于 for 循环、 用于 len()， 以及用于 in 和 not in 操作符。<br>需要注意的是：字符串是“不可变的”， 它不能被更改。尝试对字符串中的一个字符重新赋值， 将导致 TypeError 错误。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'Veinin'</span>                                    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">0</span>]                                        </span><br><span class="line"><span class="string">'V'</span>                                             </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">-1</span>]                                       </span><br><span class="line"><span class="string">'n'</span>                                             </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'in'</span> <span class="keyword">in</span> name                                           </span><br><span class="line"><span class="keyword">True</span>                                         </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'p'</span> <span class="keyword">not</span> <span class="keyword">in</span> name                      </span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">0</span>] = <span class="string">'A'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure></p><p>字符串是“不可变的”， 它不能被更改。<br>“改变” 一个字符串的正确方式， 是使用切片和连接。构造一个“新的” 字符串， 从老的字符串那里复制一些部分。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'Veinin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newName = <span class="string">'Jali'</span> + name[<span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name</span><br><span class="line"><span class="string">'Veinin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newName</span><br><span class="line"><span class="string">'Jaliin'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="元组数据类型"><a href="#元组数据类型" class="headerlink" title="元组数据类型"></a>元组数据类型</h2><p>除了两个方面，“元组” 数据类型几乎与列表数据类型一样。<br>首先， 元组输入时用圆括号()， 而不是用方括号[]。<br>其次，元组像字符串一样， 是不可变的。 元组不能让它们的值被修改、 添加或删除。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = (<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">0</span>]</span><br><span class="line"><span class="string">'red'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-2</span>]</span><br><span class="line"><span class="string">'green'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">(<span class="string">'green'</span>, <span class="string">'blue'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">2</span>] = <span class="string">'black'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure></p><p>如果需要元组值的一个可变版本， 使用函数函数 list() 将元组转换成列表就很方便。 相反也可以使用 tuple() 函数将列表转换成元组。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>对于字符串和整数值赋值操作，将执行拷贝操作，赋值后二者是不同的变量，保存了不同的值。<br>但列表不是这样的。 当你将列表赋给一个变量时，实际上是将列表的“引用”赋给了该变量。引用是一个值，指向某些数据。列表引用是指向一个列表的值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">40</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar = foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="number">0</span>] = <span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo</span><br><span class="line">[<span class="number">120</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar</span><br><span class="line">[<span class="number">120</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="传递引用"><a href="#传递引用" class="headerlink" title="传递引用"></a>传递引用</h2><p>当函数被调用时， 参数的值被复制给变元。对于列表以及字典， 这意味着变元得到的是引用的拷贝。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">something</span><span class="params">(arr)</span>:</span></span><br><span class="line"><span class="meta">... </span>    arr.append(<span class="number">4</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>something(arr)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></p><h2 id="copy-和-deepcopy-函数"><a href="#copy-和-deepcopy-函数" class="headerlink" title="copy()和 deepcopy() 函数"></a>copy()和 deepcopy() 函数</h2><p>在处理列表和字典时，尽管传递引用常常是最方便的方法， 但如果函数修改了传入的列表或字典， 你可能不希望这些变动影响原来的列表或字典。要做到这一点，Python 提供了名为 copy 的模块， 其中包含 copy()和 deepcopy()函数。<br>第一个函数copy.copy()， 可以用来复制列表或字典这样的可变值， 而不只是复制引用。<br>如果要复制的列表中包含了列表， 那就使用 copy.deepcopy()函数来代替。deepcopy()函数将同时复制它们内部的列表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">110</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">120</span></span><br><span class="line">print(a) <span class="comment"># [110, 2, 3, [120, 5, 6]]</span></span><br><span class="line">print(b) <span class="comment"># [1, 2, 3, [120, 5, 6]]</span></span><br><span class="line"></span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line">c[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">print(a) <span class="comment"># [110, 2, 3, [120, 5, 6]]</span></span><br><span class="line">print(c) <span class="comment"># [110, 2, 3, [4, 5, 6]]</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列表和元组可以包含多个值，这样编写程序来处理大量数据就变得更容易。而且，由于列表本身又可以包含其他列表，所以可以用它们将数据安排成层次结构。&lt;/p&gt;
&lt;h2 id=&quot;列表数据类型&quot;&gt;&lt;a href=&quot;#列表数据类型&quot; class=&quot;headerlink&quot; title=&quot;列表数据类型&quot;&gt;&lt;/a&gt;列表数据类型&lt;/h2&gt;&lt;p&gt;“列表” 是一个值， 它包含多个字构成的序列。列表用左方括号开始， 右方括号结束，即[]。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;colors = [&lt;span class=&quot;string&quot;&gt;&#39;red&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;green&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;blue&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 函数</title>
    <link href="https://veinin.com/2018/03/18/python-practice-functions/"/>
    <id>https://veinin.com/2018/03/18/python-practice-functions/</id>
    <published>2018-03-18T07:29:00.000Z</published>
    <updated>2018-03-24T14:09:57.972Z</updated>
    
    <content type="html"><![CDATA[<p>Python 提供了这样一些内建函数，但你也可以编写自己的函数。“函数”就像一个程序内的小程序。</p><h2 id="使用-def-语句定义一个函数"><a href="#使用-def-语句定义一个函数" class="headerlink" title="使用 def 语句定义一个函数"></a>使用 def 语句定义一个函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Veinin'</span>)</span><br><span class="line">    print(<span class="string">'Veinin Guo'</span>)</span><br><span class="line">    print(<span class="string">'Hello trere.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    hello()</span><br><span class="line">    print(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>定义一个函数时可以自己定义接收参数，传入的参数值，放在函数的括号之间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Hello '</span> + name)</span><br><span class="line"></span><br><span class="line">hello(<span class="string">'Veinin'</span>)</span><br><span class="line">hello(<span class="string">'Jalin'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="返回值和-return-语句"><a href="#返回值和-return-语句" class="headerlink" title="返回值和 return 语句"></a>返回值和 return 语句</h2><p>函数调用求值的结果， 称为函数的“返回值”。<br>用 def 语句创建函数时， 可以用 return 语句指定应该返回什么值。 return 语句包含以下部分：</p><ul><li>return 关键字；</li><li>函数应该返回的值或表达式。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAnswer</span><span class="params">(answerNumber)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> answerNumber == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'It is certain'</span></span><br><span class="line">    <span class="keyword">elif</span> answerNumber == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'It is decidedly so'</span></span><br><span class="line">    <span class="keyword">elif</span> answerNumber == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Yes'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'No'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = random.randint(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">fortune = getAnswer(r)</span><br><span class="line">print(fortune)</span><br></pre></td></tr></table></figure></li></ul><h2 id="None-值"><a href="#None-值" class="headerlink" title="None 值"></a>None 值</h2><p>在 Python 中有一个值称为 None，它表示没有值。 None 是 NoneType 数据类型的唯一值。<br>像布尔值 True和 False 一样， None 必须大写首字母 N。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spam = <span class="keyword">None</span></span><br><span class="line">print(<span class="keyword">None</span> == spam)</span><br><span class="line"></span><br><span class="line">spam = <span class="string">'Hello'</span></span><br><span class="line">print(<span class="keyword">None</span> == spam)</span><br></pre></td></tr></table></figure></p><h2 id="关键字参数和-print"><a href="#关键字参数和-print" class="headerlink" title="关键字参数和 print()"></a>关键字参数和 print()</h2><p>print()函数有可选的变元 end 和 sep， 分别指定在参数末尾打印什么，以及在参数之间打印什么来隔开它们。<br>默认情况下，print()函数自动在传入的字符串末尾添加了换行符。<br>可以设置 end 关键字参数，将它变成另一个字符串。例如，如果程序像这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Hello'</span>, end=<span class="string">''</span>)</span><br><span class="line">print(<span class="string">'World'</span>)</span><br></pre></td></tr></table></figure></p><p>print()传入多个字符串值时，该函数就会自动用一个空格分隔它们。可以传入 sep 关键字参数， 替换掉默认的分隔字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'cats'</span>, <span class="string">'dogs'</span>, <span class="string">'mice'</span>)</span><br><span class="line">cats dogs mice</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Red'</span>, <span class="string">'Green'</span>, <span class="string">'Blue'</span>)</span><br><span class="line">Red Green Blue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Red'</span>, <span class="string">'Green'</span>, <span class="string">'Blue'</span>, sep=<span class="string">','</span>)</span><br><span class="line">Red,Green,Blue</span><br></pre></td></tr></table></figure></p><h2 id="局部和全局作用域"><a href="#局部和全局作用域" class="headerlink" title="局部和全局作用域"></a>局部和全局作用域</h2><p>在被调用函数内赋值的变元和变量，处于该函数的“局部作用域”。在所有函数之外赋值的变量，属于“全局作用域”。<br>处于局部作用域的变量，被称为“局部变量”。处于全局作用域的变量，被称为“全局变量”。</p><p>作用域很重要， 理由如下：</p><ul><li><p>全局作用域中的代码不能使用任何局部变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    eggs = <span class="number">31337</span></span><br><span class="line"></span><br><span class="line">spam()</span><br><span class="line">print(eggs) <span class="comment"># NameError: name 'eggs' is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>局部作用域可以访问全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Veinin'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello, '</span> + name)</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure></li><li><p>一个函数的局部作用域中的代码，不能使用其他局部作用域中的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    eggs = <span class="number">99</span></span><br><span class="line">    bacon()</span><br><span class="line">    print(eggs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bacon</span><span class="params">()</span>:</span></span><br><span class="line">    ham = <span class="number">101</span></span><br><span class="line">    print(eggs) <span class="comment"># NameError: name 'eggs' is not defined</span></span><br><span class="line"></span><br><span class="line">spam()</span><br></pre></td></tr></table></figure></li><li><p>如果在不同的作用域中，你可以用相同的名字命名不同的变量。也就是说，可<br>以有一个名为 spam 的局部变量，和一个名为 spam 的全局变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    eggs = <span class="string">'spam local'</span></span><br><span class="line">    print(eggs) <span class="comment"># prints 'spam local'</span></span><br><span class="line"></span><br><span class="line">eggs = <span class="string">'global'</span></span><br><span class="line">spam()</span><br><span class="line">print(eggs) <span class="comment"># prints 'global'</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="global-语句"><a href="#global-语句" class="headerlink" title="global 语句"></a>global 语句</h2><p>如果需要在一个函数内修改全局变量， 就使用 global 语句。它就告诉 Python，在这个函数中， 某个值指的是全局变量， 所以不要用这个名字创建一个局部变量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> eggs</span><br><span class="line">    eggs = <span class="string">'spam'</span></span><br><span class="line"></span><br><span class="line">eggs = <span class="string">'global'</span></span><br><span class="line">spam()</span><br><span class="line">print(eggs)</span><br></pre></td></tr></table></figure></p><p>有 4 条法则， 来区分一个变量是处于局部作用域还是全局作用域：</p><ul><li>1．如果变量在全局作用域中使用（即在所有函数之外），它就总是全局变量。</li><li>2．如果在一个函数中，有针对该变量的 global 语句，它就是全局变量。</li><li>3．否则，如果该变量用于函数中的赋值语句，它就是局部变量。</li><li>4．但是，如果该变量没有用在赋值语句中，它就是全局变量。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> eggs</span><br><span class="line">    eggs = <span class="string">'spam'</span> <span class="comment"># this is the global</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bacon</span><span class="params">()</span>:</span></span><br><span class="line">    eggs = <span class="string">'bacon'</span> <span class="comment"># this is the local</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ham</span><span class="params">()</span>:</span></span><br><span class="line">    print(eggs) <span class="comment"># this is the global</span></span><br><span class="line"></span><br><span class="line">eggs = <span class="number">42</span> <span class="comment"># this is the global</span></span><br><span class="line">spam()</span><br><span class="line">print(eggs)</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在 Python 程序中遇到错误， 或“异常”， 如果不处理，意味着整个程序崩溃。<br>而我们希望程序能检测错误， 处理它们，然后继续运行。</p><p>以下代码，当试图用一个数除以零时，就会发生 <code>ZeroDivisionError: division by zero</code> 错误提示。从而导致后面代码中断运行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">devide</span><span class="params">(divideBy)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span> / divideBy</span><br><span class="line"></span><br><span class="line">print(devide(<span class="number">2</span>))</span><br><span class="line">print(devide(<span class="number">0</span>))</span><br><span class="line">print(devide(<span class="number">22</span>))</span><br></pre></td></tr></table></figure></p><p>我们可以使用 try 和 except 语句来处理错误。那些可能出错的语句被放在 try 子句中。如果错误发生，程序执行就转到接下来的 except 子句开始处。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">devide</span><span class="params">(divideBy)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span> / divideBy</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        print(<span class="string">'Error: Invalid argument.'</span>)</span><br><span class="line"></span><br><span class="line">print(devide(<span class="number">2</span>))</span><br><span class="line">print(devide(<span class="number">0</span>))</span><br><span class="line">print(devide(<span class="number">22</span>))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 提供了这样一些内建函数，但你也可以编写自己的函数。“函数”就像一个程序内的小程序。&lt;/p&gt;
&lt;h2 id=&quot;使用-def-语句定义一个函数&quot;&gt;&lt;a href=&quot;#使用-def-语句定义一个函数&quot; class=&quot;headerlink&quot; title=&quot;使用 def 语句定义一个函数&quot;&gt;&lt;/a&gt;使用 def 语句定义一个函数&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Veinin&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Veinin Guo&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Hello trere.&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hello()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
