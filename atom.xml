<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Veinin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://veinin.com/"/>
  <updated>2018-03-24T13:50:02.180Z</updated>
  <id>https://veinin.com/</id>
  
  <author>
    <name>Veinin Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开发笔记：游戏中属性定义、策划公式处理方案</title>
    <link href="https://veinin.com/2018/03/24/dev-notes-designer-formula-processing-solution-in-game/"/>
    <id>https://veinin.com/2018/03/24/dev-notes-designer-formula-processing-solution-in-game/</id>
    <published>2018-03-24T13:28:00.000Z</published>
    <updated>2018-03-24T13:50:02.180Z</updated>
    
    <content type="html"><![CDATA[<p>在游戏设计中，策划喜欢通过表格来制定自己的数值方案，通常一个游戏制作会有几十上百张不同功能的表格，这些表格通常采用Excel制定。大部分时候，策划更想要的是自己来操作所有数值，而不需要程序为其各种需求去正对性的通过代码来实现。</p><p>这样做有几个好处：</p><ul><li>1.策划可以独立拓展自己的业务，而不依赖于程序。</li><li>2.程序可以更加专心于自己的逻辑功能，而不用去特意维护策划的数值变动需求。</li><li>3.工作内容分离，减少沟通成本，更加提升工作效率，让各部门更加专注于自己所处的领域。</li></ul><p>在游戏日常开发中，有两个典型的应用场景，一个是角色的属性，一个是计算这些属性的公式，最后还需要通过这些属性在战斗中通过公式生成伤害数值。如果涉及复杂的战斗系统，通常一个角色的战斗属性可能会有上百种，而计算这些属性的公式，也可能成百上千。这里就会产生几个问题：属性、公式由程序去定义，还是策划自己去主导？属性、公式通过某种方式定义出来了，程序如何去使用？</p><a id="more"></a><p>最近和策划一起讨论了下，最终给出了解决方案，属性、公式都有策划去配置，但公式需要简化，于是我们先给出了两张表格。</p><h3 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h3><p>一个属性字典，对于程序来说，特别设计属性服务器、客户端传输的过程，我们可以通过一个唯一ID、类型进行，只要客户端、服务器都拥有这么一张属性字典，那么将很容易对属性进行传输：</p><table><thead><tr><th style="text-align:center">属性ID</th><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">初值</th><th style="text-align:center">描述</th><th style="text-align:center">成长公式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">strength</td><td style="text-align:center">int</td><td style="text-align:center">5</td><td style="text-align:center">力量</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">pdCorrect</td><td style="text-align:center">float</td><td style="text-align:center">1.2</td><td style="text-align:center">物理伤害修正系数</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">physicalDamage</td><td style="text-align:center">int</td><td style="text-align:center">20</td><td style="text-align:center">物理基础伤害</td><td style="text-align:center">公式1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">physicalCritical</td><td style="text-align:center">int</td><td style="text-align:center">15</td><td style="text-align:center">物理暴击率</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">physicalCriticalDec</td><td style="text-align:center">int</td><td style="text-align:center">10</td><td style="text-align:center">物理暴击抵抗率</td><td style="text-align:center"></td></tr></tbody></table><h3 id="公式表"><a href="#公式表" class="headerlink" title="公式表"></a>公式表</h3><p>一张公式表，由策划去配置，但程序得把策划的公式翻译成程序能读懂的代码。</p><table><thead><tr><th style="text-align:center">公式ID</th><th style="text-align:center">公式名称</th><th style="text-align:center">公式内容</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">physicalDamage</td><td style="text-align:center">40 <em> (level </em> pdCorrect + 1) * rand(1, 1.5)</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">physicalCriticalRate</td><td style="text-align:center">max(min(a.physicalCritical / 10 - t.physicalCriticalDec), 20), 0)</td></tr></tbody></table><h3 id="函数支持"><a href="#函数支持" class="headerlink" title="函数支持"></a>函数支持</h3><p>另外，对于策划来说，要通过公式来操作属性数据，特别是战斗中产生的伤害数据，就要求我们有一些简单函数支持，比如在Lua中，一些数学公式：<code>math.min</code>、<code>math.ceil</code>、<code>math.random</code> 等等。而对策划来说，大部分其实是不懂编程的，因此我们需要更加简化函数名称的设计。最终，我们得出需要以下函数的支持：</p><ul><li>min(…) ，返回参数中的最小值，如 min(1, 5, 2) ，会得到数值 1</li><li>max(…)，返回参数中的最大值，如 max(4, 10, 3)，会得到数值 10</li><li>rand(m, n)，当不带参数时，返回 [0,1] 区间内的浮点伪随机数，当以两个整数 m 与 n 调用时，返回一个 [m, n] 区间内的一致分布的伪随机数。如 rand(1, 10)，产生1-10区间内的一个随机数。</li><li>ceil(x)，返回不等于 x 的最小整数。如 ceil(1.55)，会得到数值 2</li><li>float(x)，返回不大于 x 的最大整数值，如 flooat(1.55)，会得到数值 1</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>有了上面这些，程序就可以编写工具，把策划配置的公式，导出成程序能够识别的公式函数了，比如：<br>怪物的随等级增长物理伤害公式：40 <em> (等级 </em> 物理伤害修正系数 + 1) * rand(1, 1.5)<br>怪物的物理暴击计算：max(min(怪物暴击率 / 10 - 目标暴击抵抗率 / 10, 25), 0)</p><p>那么其最终需要转换成代码公式函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> formula = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 怪物物理伤害公式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formula.physicalDamage</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">40</span> * (a.level * a.pdCorrect + <span class="number">1</span>) * <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, <span class="number">1.5</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 怪物暴击几率公式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formula.physicalCriticalRate</span><span class="params">(a, t)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">math</span>.<span class="built_in">max</span>(<span class="built_in">math</span>.<span class="built_in">min</span>(a.physicalCritical / <span class="number">10</span> - t.physicalCriticalDec), <span class="number">20</span>), <span class="number">0</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> formulas = &#123;</span><br><span class="line">    [<span class="number">1</span>] = formula.physicalDamage,</span><br><span class="line">    [<span class="number">2</span>] = formula.physicalCriticalRate,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formula.exec</span><span class="params">(id, ...)</span></span></span><br><span class="line">    <span class="keyword">return</span> formula[id](...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> formula</span><br></pre></td></tr></table></figure><p>有了上面的表格，外加生成的公式，我们很容易计算出一个怪物的基础属性或战斗中产生的伤害数值：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> formula = <span class="built_in">require</span> <span class="string">"formula"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> monster = &#123;</span><br><span class="line">     level = <span class="number">3</span>,</span><br><span class="line">     strength = <span class="number">5</span>,</span><br><span class="line">     pdCorrect = <span class="number">1.3</span>,</span><br><span class="line">     physicalDamage = <span class="number">15</span>,</span><br><span class="line">     physicalCritical = <span class="number">35</span>,</span><br><span class="line">     physicalCriticalDec = <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> target = &#123;</span><br><span class="line">     level = <span class="number">2</span>,</span><br><span class="line">     strength = <span class="number">5</span>,</span><br><span class="line">     pdCorrect = <span class="number">1.3</span>,</span><br><span class="line">     physicalDamage = <span class="number">20</span>,</span><br><span class="line">     physicalCritical = <span class="number">35</span>,</span><br><span class="line">     physicalCriticalDec = <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 得出怪物物理伤害</span></span><br><span class="line"><span class="keyword">local</span> damage = formula.exec(<span class="number">1</span>, monster)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 得出怪物物理暴击率</span></span><br><span class="line"><span class="keyword">local</span> criticalRate = formula.exec(<span class="number">2</span>, monster, target)</span><br></pre></td></tr></table></figure></p><p>最终，通过这套方案的实现，程序不用再去代码里维护各种各样的公式，策划也不在需要程序来帮忙维护公式，如果需求变动，只需要更改下表格，然后重新生成一份新公式就行；如果有新属性增加，只需要在表格中创建以个新的属性值，然后不管是角色，还是战斗中都能应用到新增加的变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在游戏设计中，策划喜欢通过表格来制定自己的数值方案，通常一个游戏制作会有几十上百张不同功能的表格，这些表格通常采用Excel制定。大部分时候，策划更想要的是自己来操作所有数值，而不需要程序为其各种需求去正对性的通过代码来实现。&lt;/p&gt;
&lt;p&gt;这样做有几个好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.策划可以独立拓展自己的业务，而不依赖于程序。&lt;/li&gt;
&lt;li&gt;2.程序可以更加专心于自己的逻辑功能，而不用去特意维护策划的数值变动需求。&lt;/li&gt;
&lt;li&gt;3.工作内容分离，减少沟通成本，更加提升工作效率，让各部门更加专注于自己所处的领域。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在游戏日常开发中，有两个典型的应用场景，一个是角色的属性，一个是计算这些属性的公式，最后还需要通过这些属性在战斗中通过公式生成伤害数值。如果涉及复杂的战斗系统，通常一个角色的战斗属性可能会有上百种，而计算这些属性的公式，也可能成百上千。这里就会产生几个问题：属性、公式由程序去定义，还是策划自己去主导？属性、公式通过某种方式定义出来了，程序如何去使用？&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://veinin.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="游戏角色属性设计" scheme="https://veinin.com/tags/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E5%B1%9E%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="游戏策划公式设计" scheme="https://veinin.com/tags/%E6%B8%B8%E6%88%8F%E7%AD%96%E5%88%92%E5%85%AC%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记：MMORPG场景同步AOI解决方案</title>
    <link href="https://veinin.com/2018/03/23/dev-notes-mmorpg-aoi-algorithm/"/>
    <id>https://veinin.com/2018/03/23/dev-notes-mmorpg-aoi-algorithm/</id>
    <published>2018-03-23T11:20:00.000Z</published>
    <updated>2018-03-24T13:33:33.049Z</updated>
    
    <content type="html"><![CDATA[<p>MMO 游戏，需要解决的最重要的问题之一，就是如何把游戏世界中各种状态的改变通知给需要知道这条信息的玩家。<br>为此，需要为每个玩家设定一个AOI（Area Of Interest），当一个对象状态发生改变时，需要将信息广播出去，那些AOI覆盖到这条消息的玩家都会收到这条广播消息。</p><p>AOI 主要作用有两：<br>第一，服务器上的玩家或 NPC 状态发生改变时，将消息广播到附近的玩家。<br>第二，当玩家接近NPC时，进入NPC警戒区域，AOI 模块将消息发送给NPC，NPC再做出相应的AI反应。</p><p>目前游戏中 AOI 实现主要有3种：<br>第一种，最容易也是最笨的一种，玩家定期同步自己状态给服务器，服务器定期比较所有对象间的关系，发现可以触发 AOI 事件就发送消息。写法简单，不容易出错，但如果处理不好，效率往往是最低的。</p><a id="more"></a><h2 id="空间切割网格算法"><a href="#空间切割网格算法" class="headerlink" title="空间切割网格算法"></a>空间切割网格算法</h2><p>把整个场景用等分大的格子划分成一个个小区域，对象进入、退出、移动时都需要更新相应的格子对象列表。这种算法插入、删除对象都非常快，时间复杂度为O（1）。缺点是当对象在格子直接移动时，需要消耗大量计算时间。目前《幻想西游》采用的是这种算法。</p><h3 id="场景划分"><a href="#场景划分" class="headerlink" title="场景划分"></a>场景划分</h3><p>场景大小：200 <em> 200<br>格子大小：50 </em> 50<br>场景中需要划分等分大小的格子数： 200 / 50 <em> 200 </em> 50 = 16 个</p><p>效果如下图所示：<br><img src="/images/2018-03-24/01.png" alt=""></p><h3 id="世界坐标与格子坐标"><a href="#世界坐标与格子坐标" class="headerlink" title="世界坐标与格子坐标"></a>世界坐标与格子坐标</h3><p>每个格子有对于的格子坐标，每个世界坐标可以轻易的转换成格子坐标。<br>世界坐标 (x, y) 转换成格子坐标公式为：(math.floor(x/gridWeidth), math.floor(y/gridHeight))<br>如世界坐标为 (80, 50)，转换后对应格子坐标为 (2, 1)。</p><h3 id="划分九宫格"><a href="#划分九宫格" class="headerlink" title="划分九宫格"></a>划分九宫格</h3><p>每个格子都需要维护该格子内的对象信息，同时也需要维护关心该格子的观察者信息。<br>当对象处于场景某个格子时，该对象会有 9 个自己所关心的格子，对象可以观察并收到自己关心区域的 AOI 事件。<br>当然，对象所处的格子也会被其他格子的对象所关心。也就是说一个格子里面的对象可以作为观察者，观察周围格子内对象；同时也是被观察者，被其他格子内的对象所观察。<br><img src="/images/2018-03-24/02.png" alt=""><br>如图所示，当对象所进入格子 (2, 2) 时（红色区域），那么其关心的周围 9 个格子（浅蓝色区域）中任何一个发生 AOI 事件时，它都会收到相应的 AOI 事件消息。</p><h3 id="对象进入场景"><a href="#对象进入场景" class="headerlink" title="对象进入场景"></a>对象进入场景</h3><p>通知对象所处周围9个格子的其他对象 进入 AOI 事件。</p><h3 id="对象离开场景"><a href="#对象离开场景" class="headerlink" title="对象离开场景"></a>对象离开场景</h3><p>与进入相反，通知对象所处九宫格的其他对象 离开 AOI 事件。</p><h3 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h3><p>如果对象格子变更时，如图所示，对象纵向移动由(2, 2) 移动到 (3, 2)，45度角移动由 (2, 2) 移动到 (3, 3）：<br><img src="/images/2018-03-24/03.png" alt=""><br>会产生3种格子：</p><ul><li>对象离开视野的格子（灰色格子），通知对象离开 AOI 事件。</li><li>对象进入视野的格子（橙色格子），通知对象进入 AOI 事件。</li><li>取所有需要操作的格子的交集（浅蓝色格子），通知对象移动 AOI 事件。</li></ul><h2 id="十字链表算法"><a href="#十字链表算法" class="headerlink" title="十字链表算法"></a>十字链表算法</h2><p>场景维护着两个双向链表（如果3D空间，则增加第3条），分别对应着 X 轴 和 Y 轴。<br>每个链表对象的坐标按从小到大排列，也就是 X 坐标值越小，排在越前面，Y轴同理。<br>此算法对象短距离移动时，很节省计算量，但涉及长距离移动时，计算量会非常大。</p><h3 id="对象进入场景-1"><a href="#对象进入场景-1" class="headerlink" title="对象进入场景"></a>对象进入场景</h3><p>遍历 X 轴 和 Y 轴两个链表，找出新增对象在两个轴中所处的位置，将新对象加入到指定位置，并根据新对象的通知范围（可动态设定）获得需要通知对象集合，发送 进入 AOI 事件。</p><h3 id="对象离开场景-1"><a href="#对象离开场景-1" class="headerlink" title="对象离开场景"></a>对象离开场景</h3><p>对象进入场景后，在 X 轴 和 Y 轴各保存了两个节点位置，可以通过这个位置，获取指定范围的的对象集合，发送 离开 AOI 事件。</p><p>###对象移动<br>与格字算法类似，对象移动后也会会产生3种对象集合：</p><ul><li>更新位置前的集合，通知 离开 AOI 事件。</li><li>更新位置后的集合，通知 进入 AOI 事件。</li><li>取上面两个集合的交集，通知对象 移动 AOI 事件。</li></ul><p>处理上面产生事件顺序与格字算法相同。</p><h2 id="分层-AOI"><a href="#分层-AOI" class="headerlink" title="分层 AOI"></a>分层 AOI</h2><p>有了AOI算法，并不意味着能有满意的效果，假设场景里面放入10000人，那么按分布情况来说，即使有AOI算法，也会很糟糕，你会看到满屏幕的人，密密麻麻，卡的要死。这种情况下，玩家体验会很糟糕，所以可能需要进一步优化。<br>目前市面上见得比较多的解决方案有几种，一种是对单个场景分线，复制多个相同的场景副本，玩家随机进入某个场景的副本，以此来达到分流的目的。<br>另外一种方案，是从梦幻西游手游服务器AOI设计方案中看到的，设计一个分层AOI概念，也就是单个场景创建多个AOI对象。把玩家分通过某个规则，分在不同的层次。当人数增多时，可以动态进行分层，人数少的时候可以把层数合并回来，然后就是让玩家在人少的时候也能看到几个人，人多的时候还是看到几个人。这种优化放过来后，这是同一台服务器，效果大概是这样的，你在同一层里看到的都是你关心的人。这个感受就很好了。<br><img src="/images/2018-03-24/04.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MMO 游戏，需要解决的最重要的问题之一，就是如何把游戏世界中各种状态的改变通知给需要知道这条信息的玩家。&lt;br&gt;为此，需要为每个玩家设定一个AOI（Area Of Interest），当一个对象状态发生改变时，需要将信息广播出去，那些AOI覆盖到这条消息的玩家都会收到这条广播消息。&lt;/p&gt;
&lt;p&gt;AOI 主要作用有两：&lt;br&gt;第一，服务器上的玩家或 NPC 状态发生改变时，将消息广播到附近的玩家。&lt;br&gt;第二，当玩家接近NPC时，进入NPC警戒区域，AOI 模块将消息发送给NPC，NPC再做出相应的AI反应。&lt;/p&gt;
&lt;p&gt;目前游戏中 AOI 实现主要有3种：&lt;br&gt;第一种，最容易也是最笨的一种，玩家定期同步自己状态给服务器，服务器定期比较所有对象间的关系，发现可以触发 AOI 事件就发送消息。写法简单，不容易出错，但如果处理不好，效率往往是最低的。&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://veinin.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MMORPG" scheme="https://veinin.com/tags/MMORPG/"/>
    
      <category term="AOI" scheme="https://veinin.com/tags/AOI/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 字符串</title>
    <link href="https://veinin.com/2018/03/18/python-practice-strings/"/>
    <id>https://veinin.com/2018/03/18/python-practice-strings/</id>
    <published>2018-03-18T08:46:00.000Z</published>
    <updated>2018-03-24T15:00:56.181Z</updated>
    
    <content type="html"><![CDATA[<p>文本是程序需要处理的最常见的数据形式。涉及字符串的操作不仅仅是使用+操作符连接两个字符串，你还可以从字符串中提取部分字符串， 添加或删除空白字符， 将字母转换成小写或大写， 检查字符串的格式是否正确。你甚至可以编写 Python 代码访问剪贴板， 复制或粘贴文本。</p><h2 id="处理字符串"><a href="#处理字符串" class="headerlink" title="处理字符串"></a>处理字符串</h2><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><p>在Python中构建一个字符串相当简单：以单引号开始和结束。<br>如果字符串里面也使用单引号的话，则需要使用双引号开始和结束来表示一个字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"I found hi's very selfish."</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>“转义字符” 让你输入一些字符，它们用其他方式是不可能放在字符串里的。转义字符包含一个倒斜杠（\）， 紧跟着是想要添加到字符串中的字符。<br>常用的转移字符包括:\’(单引号)、 \”(双引号)、 \t(制表符)、 \(倒斜杠)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'I found hi\'s very selfish.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">"I found hi's very selfish."</span></span><br></pre></td></tr></table></figure><h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><p>在字符串开始的引号之前加上 r， 那么它就成为了一个原始字符串。“原始字符串” 会完全忽略所有的转义字符， 打印出字符串中所有的倒斜杠。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">r'That is Carol\'s cat.'</span>)</span><br></pre></td></tr></table></figure><h3 id="用三重引号的多行字符串"><a href="#用三重引号的多行字符串" class="headerlink" title="用三重引号的多行字符串"></a>用三重引号的多行字符串</h3><p>虽然可以用\n转义字符将换行放入一个字符串，但使用多行字符串通常更容易。<br>在 Python 中，多行字符串的起止是 3 个单引号或 3 个双引号。“三重引号” 之间的所有引号、 制表符或换行， 都被认为是字符串的一部分。 Python 的代码块缩进规则不适用于多行字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'''Dear Alice,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Eve's cat has been arrested for catnapping.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Sincerely,</span></span><br><span class="line"><span class="string">Bob'''</span>)</span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>虽然井号字符（#） 表示这一行是注释， 但多行字符串常常用作多行注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""This is a test Python program.</span></span><br><span class="line"><span class="string">Written by Al Sweigart al@inventwithpython.com</span></span><br><span class="line"><span class="string">This program was designed for Python 3, not Python 2.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""This is a multiline comment to help</span></span><br><span class="line"><span class="string">    explain what the spam() function does."""</span></span><br><span class="line">    print(<span class="string">'Hello!'</span>)</span><br></pre></td></tr></table></figure><h3 id="字符串下标和切片"><a href="#字符串下标和切片" class="headerlink" title="字符串下标和切片"></a>字符串下标和切片</h3><p>字符串像列表一样，可以使用下标和切片。<br>字符串切片并不能修改原来的字符串。但可以从一个变量中获取切片，记录在另一个变量中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'Hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[<span class="number">1</span>]</span><br><span class="line"><span class="string">'e'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[<span class="number">-2</span>]</span><br><span class="line"><span class="string">'d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="string">'Hell'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[:<span class="number">5</span>]</span><br><span class="line"><span class="string">'Hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[<span class="number">4</span>:]</span><br><span class="line"><span class="string">'o world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text2 = text[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="string">'Hello'</span></span><br></pre></td></tr></table></figure><h3 id="字符串使用-in-和-not-in-操作符"><a href="#字符串使用-in-和-not-in-操作符" class="headerlink" title="字符串使用 in 和 not in 操作符"></a>字符串使用 in 和 not in 操作符</h3><p>像列表一样， in 和 not in 操作符也可以用于字符串。用 in 或 not in 连接两个字符串得到的表达式， 将求值为布尔值 True 或 False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span> <span class="keyword">in</span> <span class="string">'Veinin Guo'</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'Veinin Guo'</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span> <span class="keyword">in</span> <span class="string">'Veinin Guo'</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h2><p>某些字符串需要转换、分析然后产生新的字符串，字符串内置了一些常用的方法。<br><strong>注意</strong>：Python 中所有字符串操作方法并不会改变字符串本身的属性，而是返回一个操作后的新字符串。</p><h3 id="upper-、-lower-、-isupper-和-islower"><a href="#upper-、-lower-、-isupper-和-islower" class="headerlink" title="upper()、 lower()、 isupper()和 islower()"></a>upper()、 lower()、 isupper()和 islower()</h3><p>upper()和 lower() 方法会返回一个新字符串，所有字母都被相应地转换为大写或小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; text = &apos;Hello World!&apos;</span><br><span class="line">&gt;&gt;&gt; print(text.upper())</span><br><span class="line">HELLO WORLD!</span><br><span class="line">&gt;&gt;&gt; print(text.lower())</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>isupper()和islower()方法用来判断字符串是否至少有要给字母，并且所有字母都是大写或小写，相应地如果成立就会返回布尔值 True，否则返回 False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello world'</span>.isupper()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'HELLO WORLD'</span>.isupper()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello'</span>.islower()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'hello'</span>.islower()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="isX-方法"><a href="#isX-方法" class="headerlink" title="isX 方法"></a>isX 方法</h3><p>为了能判断字符串的特点，提供了一些常用的以 <code>is</code> 开头的方法。</p><ul><li>isalpha() 如果字符串非空，且只包含字母，则返回 True</li><li>isalnum() 如果字符串非空，且只包含字母和数字，则返回 True</li><li>isdecimal() 如果字符串非空，且只包含数字，则返回 True</li><li>isspace() 如果字符串非空，且只包含空格、换行和制表符，则返回 True</li><li>istitle() 如果字符串包含以大写字母开头且后面字母都是小写字母的单词，则返回 True</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc'</span>.isalpha()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc123'</span>.isalpha()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc123'</span>.isalnum()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc123'</span>.isdecimal()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'10088'</span>.isdecimal()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'  '</span>.isspace()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'I Am From China'</span>.istitle()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'I am from China'</span>.istitle()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="startswith-和-endswith"><a href="#startswith-和-endswith" class="headerlink" title="startswith() 和 endswith()"></a>startswith() 和 endswith()</h3><p>startswith() 和 endswith() 用来判断某个字符串以某个字符串开始或结束，成立则返回 True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello World'</span>.startswith(<span class="string">'Hello'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello World'</span>.startswith(<span class="string">'nihao'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello World'</span>.endswith(<span class="string">'World'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="join-和-split"><a href="#join-和-split" class="headerlink" title="join() 和 split()"></a>join() 和 split()</h3><p>join() 方法用来将一个字符串列表中的每个字符串连接成一个新的字符串。<br>而 split() 方法与 join() 方法刚好相反，它会将一个字符串按制定分隔符进行分割，返回一个分割后的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">', '</span>.join([<span class="string">'java'</span>, <span class="string">'python'</span>, <span class="string">'golang'</span>])</span><br><span class="line"><span class="string">'java, python, golang'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'I am from China'</span>.split()</span><br><span class="line">[<span class="string">'I'</span>, <span class="string">'am'</span>, <span class="string">'from'</span>, <span class="string">'China'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABCDEFGEFGEFG'</span>.split(<span class="string">'E'</span>)</span><br><span class="line">[<span class="string">'ABCD'</span>, <span class="string">'FG'</span>, <span class="string">'FG'</span>, <span class="string">'FG'</span>]</span><br></pre></td></tr></table></figure><h3 id="使用-rjust-、-ljust-和-center-方法对齐文本"><a href="#使用-rjust-、-ljust-和-center-方法对齐文本" class="headerlink" title="使用 rjust()、 ljust() 和 center() 方法对齐文本"></a>使用 rjust()、 ljust() 和 center() 方法对齐文本</h3><p>rjust() 和 ljust() 方法使用向左或向右插入空格的方式返回一个字符串的填充版本。而 center() 方法则是让字符串文本居中。<br>上面三个方法都接受两个参数，第一个参数指定填充数量。第二个参数，指定填充的字符，默认是填充空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span>.ljust(<span class="number">20</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="string">'Veinin--------------'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span>.rjust(<span class="number">20</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="string">'--------------Veinin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span>.center(<span class="number">20</span>)</span><br><span class="line"><span class="string">'       Veinin       '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span>.center(<span class="number">20</span>, <span class="string">'#'</span>)</span><br><span class="line"><span class="string">'#######Veinin#######'</span></span><br></pre></td></tr></table></figure><h3 id="使用-strip-、-rstrip-和-lstrip-方法删除空白字符"><a href="#使用-strip-、-rstrip-和-lstrip-方法删除空白字符" class="headerlink" title="使用 strip()、 rstrip() 和 lstrip() 方法删除空白字符"></a>使用 strip()、 rstrip() 和 lstrip() 方法删除空白字符</h3><p>strip()、 rstrip() 和 lstrip() 三个方法分别对一个字符串的两边、右边和左边的空白字符进行删除操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'   Veinin Guo   '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.strip()</span><br><span class="line"><span class="string">'Veinin Guo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.rstrip()</span><br><span class="line"><span class="string">'   Veinin Guo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.lstrip()</span><br><span class="line"><span class="string">'Veinin Guo   '</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本是程序需要处理的最常见的数据形式。涉及字符串的操作不仅仅是使用+操作符连接两个字符串，你还可以从字符串中提取部分字符串， 添加或删除空白字符， 将字母转换成小写或大写， 检查字符串的格式是否正确。你甚至可以编写 Python 代码访问剪贴板， 复制或粘贴文本。&lt;/p&gt;
&lt;h2 id=&quot;处理字符串&quot;&gt;&lt;a href=&quot;#处理字符串&quot; class=&quot;headerlink&quot; title=&quot;处理字符串&quot;&gt;&lt;/a&gt;处理字符串&lt;/h2&gt;&lt;h3 id=&quot;双引号&quot;&gt;&lt;a href=&quot;#双引号&quot; class=&quot;headerlink&quot; title=&quot;双引号&quot;&gt;&lt;/a&gt;双引号&lt;/h3&gt;&lt;p&gt;在Python中构建一个字符串相当简单：以单引号开始和结束。&lt;br&gt;如果字符串里面也使用单引号的话，则需要使用双引号开始和结束来表示一个字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;I found hi&#39;s very selfish.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 字典</title>
    <link href="https://veinin.com/2018/03/18/python-practice-dictionaries/"/>
    <id>https://veinin.com/2018/03/18/python-practice-dictionaries/</id>
    <published>2018-03-18T08:10:00.000Z</published>
    <updated>2018-03-24T14:09:51.148Z</updated>
    
    <content type="html"><![CDATA[<p>字典数据类型提供了一种灵活的访问和组织数据的方式。<br>像列表一样，“字典”是许多值的集合。但不像列表的下标， 字典的索引可以使用许多不同数据类型， 不只是整数。 字典的索引被称为“键”，键及其关联的值称为“键-值”对。<br>字典仍然可以用整数值作为键， 就像列表使用整数值作为下标一样， 但它们不必从 0 开始， 可以是任何数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myCat = &#123;<span class="string">'size'</span>: <span class="string">'fat'</span>, <span class="string">'color'</span>: <span class="string">'gray'</span>, <span class="string">'disposition'</span>: <span class="string">'loud'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myCat[<span class="string">'size'</span>]</span><br><span class="line"><span class="string">'fat'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'My cat has '</span> + myCat[<span class="string">'color'</span>] + <span class="string">' fur.'</span></span><br><span class="line"><span class="string">'My cat has gray fur.'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ticket = &#123;<span class="number">12306</span>: <span class="string">'websites'</span>, <span class="number">123456</span>: <span class="string">'phone number'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ticket[<span class="number">12306</span>]</span><br><span class="line"><span class="string">'websites'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ticket[<span class="number">123456</span>]</span><br><span class="line"><span class="string">'phone number'</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="字典与列表"><a href="#字典与列表" class="headerlink" title="字典与列表"></a>字典与列表</h2><p>确定两个列表是否相同时， 表项的顺序很重要。<br>字典不像列表，字典中的表项是不排序的，键-值对输入的顺序并不重要。<br>因为字典是不排序的， 所以不能像列表那样切片。<br>尽管字典是不排序的，但可以用任意值作为键，这一点让你能够用强大的方式来组织数据。<br>尝试访问字典中不存在的键， 将导致 KeyError 出错信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'cats'</span>, <span class="string">'dogs'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">'dogs'</span>, <span class="string">'cats'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'age'</span>: <span class="number">25</span>, <span class="string">'firstName'</span>: <span class="string">'Veinin'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c == d</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'lastName'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'lastName'</span></span><br></pre></td></tr></table></figure><h2 id="keys-、-values-和-items-方法"><a href="#keys-、-values-和-items-方法" class="headerlink" title="keys()、 values()和 items()方法"></a>keys()、 values()和 items()方法</h2><p>有 3 个字典方法，它们将返回类似列表的值，分别对应于字典的键、值和键-值对：keys()、 values()和 items()。<br>这些方法返回的值不是真正的列表，它们不能被修改，没有append()方法。但这些数据类型（分别是 dict_keys、 dict_values 和 dict_items）可以用于for 循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'lastName'</span>: <span class="string">'Guo'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> person.keys():</span><br><span class="line">        print(k)</span><br><span class="line"></span><br><span class="line">firstName</span><br><span class="line">lastName</span><br><span class="line">age</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> v <span class="keyword">in</span> person.values():</span><br><span class="line">        print(v)</span><br><span class="line"></span><br><span class="line">Veinin</span><br><span class="line">Guo</span><br><span class="line"><span class="number">18</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> person.items():</span><br><span class="line">        print(k, v)</span><br><span class="line"></span><br><span class="line">firstName Veinin</span><br><span class="line">lastName Guo</span><br><span class="line">age <span class="number">18</span></span><br></pre></td></tr></table></figure><h2 id="检查字典中是否存在键或值"><a href="#检查字典中是否存在键或值" class="headerlink" title="检查字典中是否存在键或值"></a>检查字典中是否存在键或值</h2><p>in 和 not in 操作符可以检查值是否存在于列表中。也可以利用这些操作符，检查某个键或值是否存在于字典中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'lastName'</span>: <span class="string">'Guo'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'name'</span> <span class="keyword">in</span> person</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'sex'</span> <span class="keyword">not</span> <span class="keyword">in</span> person</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><p>在访问一个键的值之前，检查该键是否存在于字典中，这很麻烦。好在，字典有一个 get()方法，它有两个参数：要取得其值的键，以及如果该键不存在时，返回的备用值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'lastName'</span>: <span class="string">'Guo'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"I'm "</span> + str(person.get(<span class="string">'age'</span>, <span class="number">0</span>)) + <span class="string">'.'</span></span><br><span class="line"><span class="string">"I'm 18."</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'His height is '</span> + str(person.get(<span class="string">'height'</span>, <span class="number">188</span>)) + <span class="string">'cm.'</span></span><br><span class="line"><span class="string">'His height is 188cm.'</span></span><br></pre></td></tr></table></figure><h2 id="setdefault-方法"><a href="#setdefault-方法" class="headerlink" title="setdefault()方法"></a>setdefault()方法</h2><p>你常常需要为字典中某个键设置一个默认值，当该键没有任何值时使用它。<br>setdefault()方法的第一个参数，是要检查的键。第二个参数，是如果该键不存在时要设置的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'lastName'</span>: <span class="string">'Guo'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person.setdefault(<span class="string">'height'</span>, <span class="number">180</span>)</span><br><span class="line"><span class="number">180</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'His height is '</span> + str(person.get(<span class="string">'height'</span>, <span class="number">188</span>)) + <span class="string">'cm.'</span>)</span><br><span class="line">His height <span class="keyword">is</span> <span class="number">180</span>cm.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字典数据类型提供了一种灵活的访问和组织数据的方式。&lt;br&gt;像列表一样，“字典”是许多值的集合。但不像列表的下标， 字典的索引可以使用许多不同数据类型， 不只是整数。 字典的索引被称为“键”，键及其关联的值称为“键-值”对。&lt;br&gt;字典仍然可以用整数值作为键， 就像列表使用整数值作为下标一样， 但它们不必从 0 开始， 可以是任何数字。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myCat = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;size&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;fat&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;color&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;gray&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;disposition&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;loud&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myCat[&lt;span class=&quot;string&quot;&gt;&#39;size&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;fat&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&#39;My cat has &#39;&lt;/span&gt; + myCat[&lt;span class=&quot;string&quot;&gt;&#39;color&#39;&lt;/span&gt;] + &lt;span class=&quot;string&quot;&gt;&#39; fur.&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;My cat has gray fur.&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ticket = &amp;#123;&lt;span class=&quot;number&quot;&gt;12306&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;websites&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;123456&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;phone number&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ticket[&lt;span class=&quot;number&quot;&gt;12306&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;websites&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ticket[&lt;span class=&quot;number&quot;&gt;123456&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;phone number&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 列表</title>
    <link href="https://veinin.com/2018/03/18/python-practice-list/"/>
    <id>https://veinin.com/2018/03/18/python-practice-list/</id>
    <published>2018-03-18T07:50:00.000Z</published>
    <updated>2018-03-24T14:10:00.527Z</updated>
    
    <content type="html"><![CDATA[<p>列表和元组可以包含多个值，这样编写程序来处理大量数据就变得更容易。而且，由于列表本身又可以包含其他列表，所以可以用它们将数据安排成层次结构。</p><h2 id="列表数据类型"><a href="#列表数据类型" class="headerlink" title="列表数据类型"></a>列表数据类型</h2><p>“列表” 是一个值， 它包含多个字构成的序列。列表用左方括号开始， 右方括号结束，即[]。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="用下标取得列表中的单个值"><a href="#用下标取得列表中的单个值" class="headerlink" title="用下标取得列表中的单个值"></a>用下标取得列表中的单个值</h2><p>列表后面方括号内的整数被称为“下标”。列表中第一个值的下标是 0，第二个值的下标是 1，第三个值的下标是 2，依此类推。<br>如果使用的下标超出了列表中值的个数， Python 将给出 IndexError 出错信息。<br>列表也可以包含其他列表值。这些列表的列表中的值， 可以通过多重下标来访问。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, [<span class="string">'red and blue'</span>, <span class="string">'red and green'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">0</span>]</span><br><span class="line">red</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>]</span><br><span class="line">green</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">2</span>]</span><br><span class="line">blue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>] + colors[<span class="number">2</span>]</span><br><span class="line">greenblue</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pcolors[<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">red <span class="keyword">and</span> green</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">5</span>]</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure></p><h2 id="负数下标"><a href="#负数下标" class="headerlink" title="负数下标"></a>负数下标</h2><p>虽然下标从 0 开始并向上增长，但也可以用负整数作为下标。整数值−1 指的是列表中的最后一个下标， −2 指的是列表中倒数第二个下标，以此类推。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-1</span>]</span><br><span class="line">blue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-3</span>]</span><br><span class="line">red</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-1</span>] + colors[<span class="number">-3</span>]</span><br><span class="line">bluered</span><br></pre></td></tr></table></figure></p><h2 id="用-len-取得列表的长度"><a href="#用-len-取得列表的长度" class="headerlink" title="用 len()取得列表的长度"></a>用 len()取得列表的长度</h2><p>len()函数将返回传递给它的列表中值的个数， 就像它能计算字符串中字符的个数一样。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(colors)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p><h2 id="用下标改变列表中的值"><a href="#用下标改变列表中的值" class="headerlink" title="用下标改变列表中的值"></a>用下标改变列表中的值</h2><p>可以使用列表的下标来改变下标处的值。例如， <code>spam[1] = &#39;aardvark&#39;</code> 意味着“将列表 spam 下标 1 处的值赋值为字符串’aardvark’。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>] = <span class="string">'red and blue'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>]</span><br><span class="line"><span class="string">'red and blue'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-1</span>] = <span class="string">'blue and red'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(colors[<span class="number">-1</span>])</span><br><span class="line">blue <span class="keyword">and</span> red</span><br></pre></td></tr></table></figure></p><h2 id="列表连接和列表复制"><a href="#列表连接和列表复制" class="headerlink" title="列表连接和列表复制"></a>列表连接和列表复制</h2><p>操作符可以连接两个列表， 得到一个新列表， 就像它将两个字符串合并成一个新字符串一样。 *操作符可以用于一个列表和一个整数，实现列表的复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><h2 id="用-del-语句从列表中删除值"><a href="#用-del-语句从列表中删除值" class="headerlink" title="用 del 语句从列表中删除值"></a>用 del 语句从列表中删除值</h2><p>del 语句将删除列表中下标处的值， 表中被删除值后面的所有值， 都将向前移动一个下标。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> colors[<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>, <span class="string">'green'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> colors[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="列表用于循环"><a href="#列表用于循环" class="headerlink" title="列表用于循环"></a>列表用于循环</h2><p>在 for 循环中可以使用 range(len(someList))， 来迭代列表的每一个下标。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(colors)):</span><br><span class="line">        print(<span class="string">'Index : '</span> + str(i) + <span class="string">" in color is: "</span> + colors[i])</span><br><span class="line"></span><br><span class="line">Index : <span class="number">0</span> <span class="keyword">in</span> color <span class="keyword">is</span>: red</span><br><span class="line">Index : <span class="number">1</span> <span class="keyword">in</span> color <span class="keyword">is</span>: green</span><br><span class="line">Index : <span class="number">2</span> <span class="keyword">in</span> color <span class="keyword">is</span>: blue</span><br></pre></td></tr></table></figure></p><h2 id="in-和-not-in-操作符"><a href="#in-和-not-in-操作符" class="headerlink" title="in 和 not in 操作符"></a>in 和 not in 操作符</h2><p>利用 in 和 not in 操作符， 可以确定一个值否在列表中。 像其他操作符一样， in和 not in 用在表达式中， 连接两个值： 一个要在列表中查找的值， 以及待查找的列表。这些表达式将求值为布尔值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'red'</span> <span class="keyword">in</span> colors</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'black'</span> <span class="keyword">not</span> <span class="keyword">in</span> colors</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><h2 id="多重赋值技巧"><a href="#多重赋值技巧" class="headerlink" title="多重赋值技巧"></a>多重赋值技巧</h2><p>多重赋值技巧是一种快捷方式， 让你在一行代码中， 用列表中的值为多个变量赋值。<br>所以不必像这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">red = colors[<span class="number">0</span>]</span><br><span class="line">green = colors[<span class="number">1</span>]</span><br><span class="line">blue = colors[<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p>可有使用如下技巧：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">red, green, blue = colors</span><br></pre></td></tr></table></figure></p><p>最后要注意变量的数目和列表的长度必须严格相等， 否则 Python 将给出 ValueError。</p><h2 id="增强赋值"><a href="#增强赋值" class="headerlink" title="增强赋值"></a>增强赋值</h2><p>针对+、 -、 *、 /和%操作符， 都有增强的赋值操作符。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">a += <span class="number">1</span></span><br><span class="line">a -= <span class="number">2</span></span><br><span class="line">a *= <span class="number">2</span></span><br><span class="line">a /= <span class="number">2</span></span><br><span class="line">a %= <span class="number">5</span></span><br><span class="line"></span><br><span class="line">print(a) <span class="comment"># 9.0</span></span><br></pre></td></tr></table></figure></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法和函数是一回事，只是它是调用在一个值上。方法部分跟在这个值后面，以一个句点分隔。<br>每种数据类型都有它自己的一组方法。例如， 列表数据类型有一些有用的方法，用来查找、 添加、 删除或操作列表中的值。</p><h3 id="用-index-方法在列表中查找值"><a href="#用-index-方法在列表中查找值" class="headerlink" title="用 index()方法在列表中查找值"></a>用 index()方法在列表中查找值</h3><p>列表值有一个 index()方法， 可以传入一个值， 如果该值存在于列表中， 就返回它的下标。如果该值不在列表中， Python 就报 ValueError。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.index(<span class="string">'red'</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.index(<span class="string">'black'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: <span class="string">'black'</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> list</span><br></pre></td></tr></table></figure></p><h3 id="用-append-和-insert-方法在列表中添加值"><a href="#用-append-和-insert-方法在列表中添加值" class="headerlink" title="用 append()和 insert()方法在列表中添加值"></a>用 append()和 insert()方法在列表中添加值</h3><p>使用append()方法调用， 可以将参数添加到列表末尾。<br>insert()方法可以在列表任意下标处插入一个值。 insert()方法的第一个参数是新值的下标， 第二个参数是要插入的新值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.append(<span class="string">'black'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.insert(<span class="number">1</span>, <span class="string">'orange'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>, <span class="string">'orange'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="用-remove-方法从列表中删除值"><a href="#用-remove-方法从列表中删除值" class="headerlink" title="用 remove()方法从列表中删除值"></a>用 remove()方法从列表中删除值</h3><p>给 remove()方法传入一个值，它将从被调用的列表中删除。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'orange'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.remove(<span class="string">'black'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.remove(<span class="string">'orange'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="用-sort-方法将列表中的值排序"><a href="#用-sort-方法将列表中的值排序" class="headerlink" title="用 sort()方法将列表中的值排序"></a>用 sort()方法将列表中的值排序</h3><p>数值的列表或字符串的列表， 能用 sort()方法排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'red'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>也可以指定 reverse 关键字参数为 True， 让 sort()按逆序排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>排序注意事项：</p><ul><li>首先， sort()方法当场对列表排序。不要写出 colors = colors.sort()这样的代码。</li><li>其次， 不能对既有数字又有字符串值的列表排序，因为 Python 不知道如何比较它们。</li><li>第三， sort()方法对字符串排序时， 使用“ASCII 字符顺序”， 而不是实际的字典顺序。这意味着大写字母排在小写字母之前。因此在排序时， 小写的 a 在大写的 Z 之后。</li></ul><h2 id="类似列表的类型：字符串和元组"><a href="#类似列表的类型：字符串和元组" class="headerlink" title="类似列表的类型：字符串和元组"></a>类似列表的类型：字符串和元组</h2><p>列表并不是唯一表示序列值的数据类型。例如， 字符串和列表实际上很相似，只要你认为字符串是单个文本字符的列表。对列表的许多操作， 也可以作用于字符串：按下标取值、 切片、 用于 for 循环、 用于 len()， 以及用于 in 和 not in 操作符。<br>需要注意的是：字符串是“不可变的”， 它不能被更改。尝试对字符串中的一个字符重新赋值， 将导致 TypeError 错误。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'Veinin'</span>                                    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">0</span>]                                        </span><br><span class="line"><span class="string">'V'</span>                                             </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">-1</span>]                                       </span><br><span class="line"><span class="string">'n'</span>                                             </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'in'</span> <span class="keyword">in</span> name                                           </span><br><span class="line"><span class="keyword">True</span>                                         </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'p'</span> <span class="keyword">not</span> <span class="keyword">in</span> name                      </span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">0</span>] = <span class="string">'A'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure></p><p>字符串是“不可变的”， 它不能被更改。<br>“改变” 一个字符串的正确方式， 是使用切片和连接。构造一个“新的” 字符串， 从老的字符串那里复制一些部分。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'Veinin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newName = <span class="string">'Jali'</span> + name[<span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name</span><br><span class="line"><span class="string">'Veinin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newName</span><br><span class="line"><span class="string">'Jaliin'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="元组数据类型"><a href="#元组数据类型" class="headerlink" title="元组数据类型"></a>元组数据类型</h2><p>除了两个方面，“元组” 数据类型几乎与列表数据类型一样。<br>首先， 元组输入时用圆括号()， 而不是用方括号[]。<br>其次，元组像字符串一样， 是不可变的。 元组不能让它们的值被修改、 添加或删除。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = (<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">0</span>]</span><br><span class="line"><span class="string">'red'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-2</span>]</span><br><span class="line"><span class="string">'green'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">(<span class="string">'green'</span>, <span class="string">'blue'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">2</span>] = <span class="string">'black'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure></p><p>如果需要元组值的一个可变版本， 使用函数函数 list() 将元组转换成列表就很方便。 相反也可以使用 tuple() 函数将列表转换成元组。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>对于字符串和整数值赋值操作，将执行拷贝操作，赋值后二者是不同的变量，保存了不同的值。<br>但列表不是这样的。 当你将列表赋给一个变量时，实际上是将列表的“引用”赋给了该变量。引用是一个值，指向某些数据。列表引用是指向一个列表的值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">40</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar = foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="number">0</span>] = <span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo</span><br><span class="line">[<span class="number">120</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar</span><br><span class="line">[<span class="number">120</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="传递引用"><a href="#传递引用" class="headerlink" title="传递引用"></a>传递引用</h2><p>当函数被调用时， 参数的值被复制给变元。对于列表以及字典， 这意味着变元得到的是引用的拷贝。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">something</span><span class="params">(arr)</span>:</span></span><br><span class="line"><span class="meta">... </span>    arr.append(<span class="number">4</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>something(arr)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></p><h2 id="copy-和-deepcopy-函数"><a href="#copy-和-deepcopy-函数" class="headerlink" title="copy()和 deepcopy() 函数"></a>copy()和 deepcopy() 函数</h2><p>在处理列表和字典时，尽管传递引用常常是最方便的方法， 但如果函数修改了传入的列表或字典， 你可能不希望这些变动影响原来的列表或字典。要做到这一点，Python 提供了名为 copy 的模块， 其中包含 copy()和 deepcopy()函数。<br>第一个函数copy.copy()， 可以用来复制列表或字典这样的可变值， 而不只是复制引用。<br>如果要复制的列表中包含了列表， 那就使用 copy.deepcopy()函数来代替。deepcopy()函数将同时复制它们内部的列表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">110</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">120</span></span><br><span class="line">print(a) <span class="comment"># [110, 2, 3, [120, 5, 6]]</span></span><br><span class="line">print(b) <span class="comment"># [1, 2, 3, [120, 5, 6]]</span></span><br><span class="line"></span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line">c[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">print(a) <span class="comment"># [110, 2, 3, [120, 5, 6]]</span></span><br><span class="line">print(c) <span class="comment"># [110, 2, 3, [4, 5, 6]]</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列表和元组可以包含多个值，这样编写程序来处理大量数据就变得更容易。而且，由于列表本身又可以包含其他列表，所以可以用它们将数据安排成层次结构。&lt;/p&gt;
&lt;h2 id=&quot;列表数据类型&quot;&gt;&lt;a href=&quot;#列表数据类型&quot; class=&quot;headerlink&quot; title=&quot;列表数据类型&quot;&gt;&lt;/a&gt;列表数据类型&lt;/h2&gt;&lt;p&gt;“列表” 是一个值， 它包含多个字构成的序列。列表用左方括号开始， 右方括号结束，即[]。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;colors = [&lt;span class=&quot;string&quot;&gt;&#39;red&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;green&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;blue&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 函数</title>
    <link href="https://veinin.com/2018/03/18/python-practice-functions/"/>
    <id>https://veinin.com/2018/03/18/python-practice-functions/</id>
    <published>2018-03-18T07:29:00.000Z</published>
    <updated>2018-03-24T14:09:57.972Z</updated>
    
    <content type="html"><![CDATA[<p>Python 提供了这样一些内建函数，但你也可以编写自己的函数。“函数”就像一个程序内的小程序。</p><h2 id="使用-def-语句定义一个函数"><a href="#使用-def-语句定义一个函数" class="headerlink" title="使用 def 语句定义一个函数"></a>使用 def 语句定义一个函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Veinin'</span>)</span><br><span class="line">    print(<span class="string">'Veinin Guo'</span>)</span><br><span class="line">    print(<span class="string">'Hello trere.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    hello()</span><br><span class="line">    print(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>定义一个函数时可以自己定义接收参数，传入的参数值，放在函数的括号之间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Hello '</span> + name)</span><br><span class="line"></span><br><span class="line">hello(<span class="string">'Veinin'</span>)</span><br><span class="line">hello(<span class="string">'Jalin'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="返回值和-return-语句"><a href="#返回值和-return-语句" class="headerlink" title="返回值和 return 语句"></a>返回值和 return 语句</h2><p>函数调用求值的结果， 称为函数的“返回值”。<br>用 def 语句创建函数时， 可以用 return 语句指定应该返回什么值。 return 语句包含以下部分：</p><ul><li>return 关键字；</li><li>函数应该返回的值或表达式。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAnswer</span><span class="params">(answerNumber)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> answerNumber == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'It is certain'</span></span><br><span class="line">    <span class="keyword">elif</span> answerNumber == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'It is decidedly so'</span></span><br><span class="line">    <span class="keyword">elif</span> answerNumber == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Yes'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'No'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = random.randint(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">fortune = getAnswer(r)</span><br><span class="line">print(fortune)</span><br></pre></td></tr></table></figure></li></ul><h2 id="None-值"><a href="#None-值" class="headerlink" title="None 值"></a>None 值</h2><p>在 Python 中有一个值称为 None，它表示没有值。 None 是 NoneType 数据类型的唯一值。<br>像布尔值 True和 False 一样， None 必须大写首字母 N。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spam = <span class="keyword">None</span></span><br><span class="line">print(<span class="keyword">None</span> == spam)</span><br><span class="line"></span><br><span class="line">spam = <span class="string">'Hello'</span></span><br><span class="line">print(<span class="keyword">None</span> == spam)</span><br></pre></td></tr></table></figure></p><h2 id="关键字参数和-print"><a href="#关键字参数和-print" class="headerlink" title="关键字参数和 print()"></a>关键字参数和 print()</h2><p>print()函数有可选的变元 end 和 sep， 分别指定在参数末尾打印什么，以及在参数之间打印什么来隔开它们。<br>默认情况下，print()函数自动在传入的字符串末尾添加了换行符。<br>可以设置 end 关键字参数，将它变成另一个字符串。例如，如果程序像这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Hello'</span>, end=<span class="string">''</span>)</span><br><span class="line">print(<span class="string">'World'</span>)</span><br></pre></td></tr></table></figure></p><p>print()传入多个字符串值时，该函数就会自动用一个空格分隔它们。可以传入 sep 关键字参数， 替换掉默认的分隔字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'cats'</span>, <span class="string">'dogs'</span>, <span class="string">'mice'</span>)</span><br><span class="line">cats dogs mice</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Red'</span>, <span class="string">'Green'</span>, <span class="string">'Blue'</span>)</span><br><span class="line">Red Green Blue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Red'</span>, <span class="string">'Green'</span>, <span class="string">'Blue'</span>, sep=<span class="string">','</span>)</span><br><span class="line">Red,Green,Blue</span><br></pre></td></tr></table></figure></p><h2 id="局部和全局作用域"><a href="#局部和全局作用域" class="headerlink" title="局部和全局作用域"></a>局部和全局作用域</h2><p>在被调用函数内赋值的变元和变量，处于该函数的“局部作用域”。在所有函数之外赋值的变量，属于“全局作用域”。<br>处于局部作用域的变量，被称为“局部变量”。处于全局作用域的变量，被称为“全局变量”。</p><p>作用域很重要， 理由如下：</p><ul><li><p>全局作用域中的代码不能使用任何局部变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    eggs = <span class="number">31337</span></span><br><span class="line"></span><br><span class="line">spam()</span><br><span class="line">print(eggs) <span class="comment"># NameError: name 'eggs' is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>局部作用域可以访问全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Veinin'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello, '</span> + name)</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure></li><li><p>一个函数的局部作用域中的代码，不能使用其他局部作用域中的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    eggs = <span class="number">99</span></span><br><span class="line">    bacon()</span><br><span class="line">    print(eggs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bacon</span><span class="params">()</span>:</span></span><br><span class="line">    ham = <span class="number">101</span></span><br><span class="line">    print(eggs) <span class="comment"># NameError: name 'eggs' is not defined</span></span><br><span class="line"></span><br><span class="line">spam()</span><br></pre></td></tr></table></figure></li><li><p>如果在不同的作用域中，你可以用相同的名字命名不同的变量。也就是说，可<br>以有一个名为 spam 的局部变量，和一个名为 spam 的全局变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    eggs = <span class="string">'spam local'</span></span><br><span class="line">    print(eggs) <span class="comment"># prints 'spam local'</span></span><br><span class="line"></span><br><span class="line">eggs = <span class="string">'global'</span></span><br><span class="line">spam()</span><br><span class="line">print(eggs) <span class="comment"># prints 'global'</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="global-语句"><a href="#global-语句" class="headerlink" title="global 语句"></a>global 语句</h2><p>如果需要在一个函数内修改全局变量， 就使用 global 语句。它就告诉 Python，在这个函数中， 某个值指的是全局变量， 所以不要用这个名字创建一个局部变量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> eggs</span><br><span class="line">    eggs = <span class="string">'spam'</span></span><br><span class="line"></span><br><span class="line">eggs = <span class="string">'global'</span></span><br><span class="line">spam()</span><br><span class="line">print(eggs)</span><br></pre></td></tr></table></figure></p><p>有 4 条法则， 来区分一个变量是处于局部作用域还是全局作用域：</p><ul><li>1．如果变量在全局作用域中使用（即在所有函数之外），它就总是全局变量。</li><li>2．如果在一个函数中，有针对该变量的 global 语句，它就是全局变量。</li><li>3．否则，如果该变量用于函数中的赋值语句，它就是局部变量。</li><li>4．但是，如果该变量没有用在赋值语句中，它就是全局变量。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> eggs</span><br><span class="line">    eggs = <span class="string">'spam'</span> <span class="comment"># this is the global</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bacon</span><span class="params">()</span>:</span></span><br><span class="line">    eggs = <span class="string">'bacon'</span> <span class="comment"># this is the local</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ham</span><span class="params">()</span>:</span></span><br><span class="line">    print(eggs) <span class="comment"># this is the global</span></span><br><span class="line"></span><br><span class="line">eggs = <span class="number">42</span> <span class="comment"># this is the global</span></span><br><span class="line">spam()</span><br><span class="line">print(eggs)</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在 Python 程序中遇到错误， 或“异常”， 如果不处理，意味着整个程序崩溃。<br>而我们希望程序能检测错误， 处理它们，然后继续运行。</p><p>以下代码，当试图用一个数除以零时，就会发生 <code>ZeroDivisionError: division by zero</code> 错误提示。从而导致后面代码中断运行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">devide</span><span class="params">(divideBy)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span> / divideBy</span><br><span class="line"></span><br><span class="line">print(devide(<span class="number">2</span>))</span><br><span class="line">print(devide(<span class="number">0</span>))</span><br><span class="line">print(devide(<span class="number">22</span>))</span><br></pre></td></tr></table></figure></p><p>我们可以使用 try 和 except 语句来处理错误。那些可能出错的语句被放在 try 子句中。如果错误发生，程序执行就转到接下来的 except 子句开始处。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">devide</span><span class="params">(divideBy)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span> / divideBy</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        print(<span class="string">'Error: Invalid argument.'</span>)</span><br><span class="line"></span><br><span class="line">print(devide(<span class="number">2</span>))</span><br><span class="line">print(devide(<span class="number">0</span>))</span><br><span class="line">print(devide(<span class="number">22</span>))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 提供了这样一些内建函数，但你也可以编写自己的函数。“函数”就像一个程序内的小程序。&lt;/p&gt;
&lt;h2 id=&quot;使用-def-语句定义一个函数&quot;&gt;&lt;a href=&quot;#使用-def-语句定义一个函数&quot; class=&quot;headerlink&quot; title=&quot;使用 def 语句定义一个函数&quot;&gt;&lt;/a&gt;使用 def 语句定义一个函数&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Veinin&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Veinin Guo&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Hello trere.&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hello()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 控制流</title>
    <link href="https://veinin.com/2018/03/18/python-practice-flow-control/"/>
    <id>https://veinin.com/2018/03/18/python-practice-flow-control/</id>
    <published>2018-03-18T07:22:00.000Z</published>
    <updated>2018-03-24T14:09:55.493Z</updated>
    
    <content type="html"><![CDATA[<p>程序就是一系列指令。但编程真正的力量不仅在于运行（或“执行”） 一条接一条的指令， 就像周末的任务清单那样。根据表达式求值的结果，程序可以决定跳过指令， 重复指令， 或从几条指令中选择一条运行。实际上， 你几乎永远不希望程序从第一行代码开始， 简单地执行每行代码， 直到最后一行。“控制流语句” 可以决定在什么条件下执行哪些 Python 语句。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>“布尔” 数据类型只有两种值： True 和 False。 Boolean（布尔） 的首字母大写， 因为这个数据类型是根据数学家 George Boole 命名的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = <span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>true</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;pyshell#2&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">true</span><br><span class="line">NameError: name <span class="string">'true'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> = <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">SyntaxError: assignment to keyword</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h2><p>“比较操作符” 比较两个值，求值为一个布尔值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">42</span> == <span class="number">42</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">42</span> == <span class="number">99</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> != <span class="number">3</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> != <span class="number">2</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><h2 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h2><p>3 个布尔操作符（and、 or 和 not） 用于比较布尔值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">and</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="keyword">False</span> <span class="keyword">or</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">(<span class="number">4</span> &lt; <span class="number">5</span>) <span class="keyword">and</span> (<span class="number">5</span> &lt; <span class="number">6</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><h2 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>if 语句的子句（也就是紧跟 if 语句的语句块），将在语句的条件为 True 时执行。如果条件为 False，子句将跳过。<br>if 语句包含以下部分：</p><ul><li>if 关键字；</li><li>条件（即求值为 True 或 False 的表达式）；</li><li>冒号；</li><li>在下一行开始，缩进的代码块（称为 if 子句）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">'Alice'</span>:</span><br><span class="line">    print(<span class="string">'Hi, Alice.'</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="else-语句"><a href="#else-语句" class="headerlink" title="else 语句"></a>else 语句</h3><p>if 子句后面有时候也可以跟着 else 语句。只有 if 语句的条件为 False 时， else子句才会执行。<br>lse 语句中包<br>含下面部分：</p><ul><li>else 关键字；</li><li>冒号；</li><li>在下一行开始，缩进的代码块（称为 else 子句）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">'Alice'</span>:</span><br><span class="line">    print(<span class="string">'Hi, Alice.'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Hello, stranger.'</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="elif-语句"><a href="#elif-语句" class="headerlink" title="elif 语句"></a>elif 语句</h3><p>有时候可能你希望，“许多” 可能的子句中有一个被执行。 elif 语句是“否则如果”，总是跟在 if 或另一条 elif 语句后面。<br>在代码中， elif 语句<br>总是包含以下部分：</p><ul><li>elif 关键字；</li><li>条件（即求值为 True 或 False 的表达式）；</li><li>冒号；</li><li>在下一行开始，缩进的代码块（称为 elif 子句）。</li></ul><h3 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h3><p>while 语句总是包含下面几<br>部分：</p><ul><li>关键字；</li><li>条件（求值为 True 或 False 的表达式）；</li><li>冒号；</li><li>从新行开始，缩进的代码块（称为 while 子句）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spam = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> spam &lt; <span class="number">5</span>:</span><br><span class="line">    print(<span class="string">'Hello, world.'</span>)</span><br><span class="line">    spam = spam + <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><p>如果执行遇到 break 语句，就会马上退出 while 循环子句。在代码中， break 语句仅包含 break 关键字。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(<span class="string">'Please type your name.'</span>)</span><br><span class="line">    name = input()</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">'Veinin'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(<span class="string">'Thank you!'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h3><p>像 break 语句一样， continue 语句用于循环内部。如果程序执行遇到 continue语句，就会马上跳回到循环开始处，重新对循环条件求值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(<span class="string">'Who are your?'</span>)</span><br><span class="line">    name = input()</span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">'Veinin'</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(<span class="string">'Hello, Veinin. What is the password?'</span>)</span><br><span class="line">    password = input()</span><br><span class="line">    <span class="keyword">if</span> password == <span class="string">'123'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(<span class="string">'Access granted.'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="for-循环和-range-函数"><a href="#for-循环和-range-函数" class="headerlink" title="for 循环和 range()函数"></a>for 循环和 range()函数</h3><p>通过 for 循环语句和 range()函数来实现一个代码块执行固定次数。<br>for 语句看起来像 for i in range(5):这样， 总是包含以下部分：</p><ul><li>for 关键字；</li><li>一个变量名；</li><li>in 关键字；</li><li>调用 range()方法，最多传入 3 个参数；</li><li>冒号；</li><li>从下一行开始，缩退的代码块（称为 for 子句）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'My name is'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    print(<span class="string">'Jimmy Five Time ('</span> + str(i) + <span class="string">')'</span>)</span><br><span class="line">    </span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    total = total + num</span><br><span class="line">print(total)</span><br></pre></td></tr></table></figure></li></ul><h3 id="range-的开始、-停止和步长参数"><a href="#range-的开始、-停止和步长参数" class="headerlink" title="range()的开始、 停止和步长参数"></a>range()的开始、 停止和步长参数</h3><p>下列代码 <code>range</code> 函数中，第一个参数是 for 循环变量开始的值， 第二个参数是上限， 但不包含它， 也就是循环停止的数字。第三个参数是“步长”。 步长是每次迭代后循环变量增加的值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><p>Python 程序可以调用一组基本的函数， 这称为“内建函数”， 包括你见到过的print()、 input()和 len()函数。 Python 也包括一组模块，称为“标准库”。每个模块都是一个 Python 程序， 包含一组相关的函数， 可以嵌入你的程序之中。例如， math模块有数学运算相关的函数， random 模块有随机数相关的函数， 等等。<br>在代码中，</p><p>import 语句包含以下部分：</p><ul><li>import 关键字；</li><li>模块的名称；</li><li>可选的更多模块名称，之间用逗号隔开。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    print(random.randint(<span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用逗号分隔符来导入多个模块"><a href="#使用逗号分隔符来导入多个模块" class="headerlink" title="使用逗号分隔符来导入多个模块"></a>使用逗号分隔符来导入多个模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random, sys, os, math</span><br></pre></td></tr></table></figure><h4 id="from-import-语句"><a href="#from-import-语句" class="headerlink" title="from import 语句"></a>from import 语句</h4><p>import 语句的另一种形式包括 from 关键字，之后是模块名称， import 关键字和<br>一个星号， 例如 <code>from random import *</code> 。<br>使用这种形式的 import 语句，调用 random模块中的函数时不需要 random.前缀。<br>但是， 使用完整的名称会让代码更可读， 所以最好是使用普通形式的 import 语句。</p><h3 id="用-sys-exit-提前结束程序"><a href="#用-sys-exit-提前结束程序" class="headerlink" title="用 sys.exit()提前结束程序"></a>用 sys.exit()提前结束程序</h3><p>通过调用 sys.exit()函数， 可以让程序终止或退出。因为这个函数在 sys 模块中，所以必须先导入 sys， 才能使用它。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(<span class="string">'Type exit to exit.'</span>)</span><br><span class="line">    response = input()</span><br><span class="line">    <span class="keyword">if</span> response == <span class="string">'exit'</span>:</span><br><span class="line">        sys.exit()</span><br><span class="line">    print(<span class="string">'You typed '</span> + response + <span class="string">'.'</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序就是一系列指令。但编程真正的力量不仅在于运行（或“执行”） 一条接一条的指令， 就像周末的任务清单那样。根据表达式求值的结果，程序可以决定跳过指令， 重复指令， 或从几条指令中选择一条运行。实际上， 你几乎永远不希望程序从第一行代码开始， 简单地执行每行代码， 直到最后一行。“控制流语句” 可以决定在什么条件下执行哪些 Python 语句。&lt;/p&gt;
&lt;h2 id=&quot;布尔值&quot;&gt;&lt;a href=&quot;#布尔值&quot; class=&quot;headerlink&quot; title=&quot;布尔值&quot;&gt;&lt;/a&gt;布尔值&lt;/h2&gt;&lt;p&gt;“布尔” 数据类型只有两种值： True 和 False。 Boolean（布尔） 的首字母大写， 因为这个数据类型是根据数学家 George Boole 命名的。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;spam = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;spam&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Traceback (most recent call last):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;File &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;pyshell#2&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NameError: name &lt;span class=&quot;string&quot;&gt;&#39;true&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; defined&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SyntaxError: assignment to keyword&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>《小狗钱钱》读书笔记</title>
    <link href="https://veinin.com/2018/03/04/reading-notes-money-oder-das/"/>
    <id>https://veinin.com/2018/03/04/reading-notes-money-oder-das/</id>
    <published>2018-03-04T12:12:00.000Z</published>
    <updated>2018-03-04T12:21:15.600Z</updated>
    
    <content type="html"><![CDATA[<p>《小狗钱钱》讲述的是一个童话故事，一个普通小女孩吉娅发现一只受伤的拉布拉多犬，并把它带回了家，取名叫钱钱。可是，有谁会想到，这只普通的四脚动物却是一个真正的理财天才呢？吉娅和小狗成为了朋友，通过小狗钱钱的指导，最后吉娅成功实现了自己的梦想，它彻底改变了吉娅一家人的财富命运。<br>这是一本老少皆宜的理财入门书籍。作者是被誉为欧洲首席金钱教练博多·舍费尔。这本书会教你如何从小学会支配金钱，而不是受金钱的支配；如何像富人那样思考，正确地认识和使用金钱；如何进行理财投资，找到积累资产的方法，早日实现财务自由！</p><a id="more"></a><h2 id="梳理理财目标"><a href="#梳理理财目标" class="headerlink" title="梳理理财目标"></a>梳理理财目标</h2><p>中国的智者老子说过：“天下难事，必作于易；天下大事，必作于细”。你自己必须真的有“想要变得富有”这个愿望，所以你必须找到10个“想要变得富有”的梦想。然后找出3项你觉得最重要的梦想出来，并作为目标，<br>然后拿一本相册作为你的梦想相册。收集一些与自己的愿望有关的照片，把它们贴在相册里。我们要通过图片来思考。<br>最后为自己的每一个梦想各准备一个储蓄罐，比如银行卡子账户。一旦储蓄罐准备好，你就应当把省下的每一分钱放进去。</p><h2 id="撰写成功日记"><a href="#撰写成功日记" class="headerlink" title="撰写成功日记"></a>撰写成功日记</h2><p>你是否能挣到钱，最关键的并不是你有没有好点子，也不是你有多聪明，而是你的自信程度。你的自信程度决定了你是否相信自己的能力，是否相信你自己。假如你根本不相信你能做到的话，那么你就根本不会动手去做，而假如你不开始去做，那么你就什么也得不到。<br>自信是很容易梳理的，你只需要准备一个本子，给它取名叫‘成功日记’，然后每天都把当天所有做成功的事情记录进去。每次都写至少5条你的个人成果，任何小事都可以。</p><h2 id="坚持你的梦想"><a href="#坚持你的梦想" class="headerlink" title="坚持你的梦想"></a>坚持你的梦想</h2><p>不论在什么情况下，每天都坚持自己所做所想。不间断地设想我的未来。<br>当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。</p><h2 id="快速摆脱负债"><a href="#快速摆脱负债" class="headerlink" title="快速摆脱负债"></a>快速摆脱负债</h2><p>毁掉所有的信用卡。<br>在许可范围内按最低的分期付款数目标准支付。应当尽可能少地偿还贷款。分期付款额越高，每个月剩下的生活费就越少。许多人和银行约定的分期付款数额刚好在他们承受能力的上限，因此他们手里的钱一直很紧张。<br>将扣除生活费后剩下的钱的一半存起来，剩下的一半用于支付消费贷款。最好根本不申请消费贷款。<br>债务人都应该在自己的钱包里贴一张纸条，上面写着“这真的有必要吗”。这样的话，当他站在收银台前的时候，就会想到不应该花太多的钱。</p><h2 id="合理分配你挣到的钱"><a href="#合理分配你挣到的钱" class="headerlink" title="合理分配你挣到的钱"></a>合理分配你挣到的钱</h2><p>如果你想变得富有，你同时还要存钱，这笔钱是你绝不会再花的，只用利息进行消费，让你能依靠本金来生活。<br>拥有一只自己的“鹅”。鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。把50％的收入变的“鹅”，用来让鹅长大；40％放入梦想储蓄罐，用来帮助实现自己的目标；剩下的10％用来零花。</p><h2 id="进行明确的投资"><a href="#进行明确的投资" class="headerlink" title="进行明确的投资"></a>进行明确的投资</h2><p>应该把钱投资在安全的地方。<br>我的钱应该下很多“金蛋”。<br>我们要足够了解你的投资对象，投资应该简单明了，而且易于操作。<br>用72除以通货膨胀率，得出的数字就是你的钱在多少年后只值现在的一半。聪明的商人可不会让自己的钱只躺在银行里睡大觉，这样做根本没有什么利息。即使有，通货膨胀也会完全吞掉你的利息。<br>用72除以年收益率的百分比，得出的数字就是这笔钱翻一番的年数。如果你们投资的收益率是15％，差不多5年以后，钱就会翻一倍。</p><h2 id="如何挑选基金"><a href="#如何挑选基金" class="headerlink" title="如何挑选基金"></a>如何挑选基金</h2><p>基金应该至少有10年历史。假如它在这么长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。<br>应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。<br>对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。</p><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ul><li><p>不是试试看，而是去切实行动！如果你只是抱着试试看的心态，那么你只会以失败告终，你会一事无成。“尝试”纯粹是一种借口，你还没有做，就已经给自己想好了退路。不能试验，你只有两个选择——做或者不做。</p></li><li><p>学习就是认识新观念和新想法的过程。假如人们始终以同一种思维方式来考虑问题的话，那么始终只会得到同样的结果。因为我对你讲述的许多内容是你以前从未接触过的，所以我建议你，在你还没有做之前，不要轻易下结论。没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。</p></li><li><p>必须学会量入为出，否则有了更多的钱只会给他们带来更大的麻烦，因为支出往往会和收入一同增长，除非我们学会合理分配我们的财产。</p></li><li><p>要想过更幸福、更满意的生活，人就得改变自身。这和钱无关，金钱本身既不会使人幸福，也不会带来不幸。金钱是中性的，既不好，也不坏。只有当钱属于某一个人的时候，它才会对这个人产生好的影响或者坏的影响。钱可以被用于好的用途，也可以被用于坏的用途。一个幸福的人有了钱会更幸福；而一个悲观忧虑的人，钱越多，烦恼就越多。”</p></li><li><p>没有人能强迫你做你不愿意做的事情。只有你自己才能强迫自己去做。</p></li><li><p>最珍贵的礼物是我们自己争取来的。克服了丢面子的恐惧，世界就会向你敞开大门！</p></li><li><p>成功会使人骄傲。如果你骄傲自大，你就会停止学习。不学习，人就不会再进步。</p></li><li><p>对股票，每个人都知道一点点，可是很少有人清楚它到底是什么东西。</p></li><li><p>金融家有时候还真是一群奇怪的人。也许当他们随意地说出一串除了他们自己谁也听不懂的名词时，他们会觉得自己比较重要。但遗憾的是，许多人因此感到自己不懂投资。不懂的东西，人们是不相信的。而其实这些东西就是这么简单。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《小狗钱钱》讲述的是一个童话故事，一个普通小女孩吉娅发现一只受伤的拉布拉多犬，并把它带回了家，取名叫钱钱。可是，有谁会想到，这只普通的四脚动物却是一个真正的理财天才呢？吉娅和小狗成为了朋友，通过小狗钱钱的指导，最后吉娅成功实现了自己的梦想，它彻底改变了吉娅一家人的财富命运。&lt;br&gt;这是一本老少皆宜的理财入门书籍。作者是被誉为欧洲首席金钱教练博多·舍费尔。这本书会教你如何从小学会支配金钱，而不是受金钱的支配；如何像富人那样思考，正确地认识和使用金钱；如何进行理财投资，找到积累资产的方法，早日实现财务自由！&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="投资" scheme="https://veinin.com/tags/%E6%8A%95%E8%B5%84/"/>
    
      <category term="理财" scheme="https://veinin.com/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>《富爸爸，穷爸爸》读书笔记</title>
    <link href="https://veinin.com/2018/02/25/reading-notes-rich-dad-poor-dad/"/>
    <id>https://veinin.com/2018/02/25/reading-notes-rich-dad-poor-dad/</id>
    <published>2018-02-25T14:42:00.000Z</published>
    <updated>2018-03-04T12:13:53.003Z</updated>
    
    <content type="html"><![CDATA[<p>我们从小就听父母说，好好读书，好好上课，毕业了找一份好的工作。那好好上学真的可以找到好的工作吗？找到好的工作肯定会变富有吗？我想这些问题的答案都是否定的，谁能够一直坐在教室里听着那些枯燥乏味的教学内容，那些内容让我们只会运用于考试中，在生活中往往被我们给忽略了。我们如何才能让我们的生活不在为了金钱而忙碌，我们为什么不能让金钱为我们而工作呢！</p><p>因此，要学会管理风险，要学会投资，不要让我们的生活只留下房贷、车贷。不要生活在一种虚假的忙碌中，那样的生活没有意义，只会让我们在往后的生活中教育自己的后代：好好上学，好好读书，找个好工作。这样的生活在当今社会已经不实用了，没有谁会认为只有读书才有出路。</p><p>《富爸爸，穷爸爸》是一个真实的故事，作者罗伯特·清崎从人的个体出发分析富人之所以成为富人，穷人之所以成为穷人的自身因素，提出了一个全新的“财商”的概念。并向传统的学校教育提出挑战。</p><a id="more"></a><p>清崎有两个爸爸，其中一个有博士学位的是他的亲生爸爸，也是本书中的穷爸爸；另外一个初中都没有读完是他好友的爸爸，即本书中的富爸爸。两位爸爸都有非常高的收入，但是穷爸爸却常常为钱而烦恼，而富爸爸最后成为了夏威夷最富有的人。 富爸爸过世后给家里留下了很多的财产，而穷爸爸则为家人留下了很多没有还清的债务。之所以会出现这样的情况，是因为穷爸爸缺乏基本的财务知识。</p><p>而关于财务教育最大的问题是学校没有教过这门学科，所以我们对于财务的教育都来自家庭，而问题就在于除非你的父母是属于收入很高的1%的那一部分人，不然我们普通的家庭并不知道如何教自己的孩子财务方面的知识。而且他们也不会阅读像《富爸爸穷爸爸》这类的书籍。如果我们没有出身在那1%的家庭，那么我们可以向清崎来学习，学习“富爸爸”的观念，即不要做金钱的奴隶，要让金钱为我们工作。</p><h2 id="第一课：富人不为钱工作"><a href="#第一课：富人不为钱工作" class="headerlink" title="第一课：富人不为钱工作"></a>第一课：富人不为钱工作</h2><p>穷人和中产阶级为钱而工作。<br>起床，上班，付账，再起床，再上班，再付账……<br>他们的生活从此被这两种感觉所控制：恐惧和贪婪。给他们更多的钱，他们就会以更高的开支重复这种循环。这就是所谓的的‘老鼠赛跑’。<br>人们自身的恐惧和无知使他们困在陷阱里，正是出于恐惧的心理，人们才想找一份安稳的工作。这些恐惧有：害怕付不起账单，害怕被解雇，害怕没有足够的钱，害怕重新开始。为了寻求保障，他们会学习某种专业，或是做生意，拼命为钱而工作。大多数人成了钱的奴隶，然后就把怒气发泄在他们老板身上。<br>他们不明白自己为什么老缺钱，于是以为多挣点钱就能解决问题，但几乎没有人意识到缺乏财商教育才是问题的关键。</p><h2 id="第二课：为什么要教授财务知识"><a href="#第二课：为什么要教授财务知识" class="headerlink" title="第二课：为什么要教授财务知识"></a>第二课：为什么要教授财务知识</h2><p>一个受过高等教育且事业有成的人，同时也可能是财务上的文盲。这种人往往太过努力地工作，因为他们只知道努力工作，却不知道如何让钱为他们工作。<br>如果人们认为钱能解决一切问题，恐怕他们的日子就不会太好过。只有知识才能解决问题并创造财富，那些不是靠财务知识挣来的钱也不会长久。<br>你必须明白资产和负债的区别，并且购买资产。如果你想致富，这一点你必须知道。富人获得资产，而穷人和中产阶级获得负债，只不过他们以为那些负债就是资产。<br>资产是能把钱放进你口袋里的东西。<br>负债是把钱从你口袋里取走的东西。<br>富人：增加收入，减少支出和负债，买入更多资产。<br>穷人：增加收入，增加支出和负债。<br>中产阶级：购买自以为是资产的负债。</p><h2 id="第三课：关注自己的事业"><a href="#第三课：关注自己的事业" class="headerlink" title="第三课：关注自己的事业"></a>第三课：关注自己的事业</h2><p>职业不等于你的事业。大多数人工作其实是为其他人，而非他们自己。首先他们要为公司的老板工作，其次是通过纳税为政府工作，最后是为向他们提供住房按揭贷款的银行工作。多关注自己的事业。存在财务问题的人经常耗费一生为别人工作，其中许多人在他们不能工作时就变得一无所有。<br>富人与穷人一个重要的区别就是：富人最后才买奢侈品，而穷人和中产阶级会先买下诸如大房子、珠宝、皮衣、宝石、游艇等奢侈品，因为他们想让自己看上去很富有。他们看上去的确很富有，但实际上他们已深陷贷款的陷阱之中。那些能给子孙留下遗产的人和那些能长期富有的人，就是先构筑资产项，然后才用资产所产生的收入购买奢侈品的，而穷人和中产阶级则用他们的血汗钱和本应该留给子孙的遗产来购买奢侈品。</p><p>真正的资产可以分为以下几类：</p><ul><li>1．不需我到场就可以正常运作的业务。我拥有它们，但由别人经营和管理。如果我必须在那儿工作，那它就不是我的事业而是我的职业了；</li><li>2．股票；</li><li>3．债券；</li><li>4．共同基金；</li><li>5．能够产生收入的房地产；</li><li>6．票据（借据）；</li><li>7．版税，如音乐、手稿、专利；</li><li>8．其他任何有价值、可产生收入或有增值潜力并且有很好销路的东西。</li></ul><h2 id="第四课：税收的历史和公司的力量"><a href="#第四课：税收的历史和公司的力量" class="headerlink" title="第四课：税收的历史和公司的力量"></a>第四课：税收的历史和公司的力量</h2><p>公司的避税优势：</p><ul><li>1.公司的某些收入可以用于税前收入支出</li><li>2.企业所得税率低于个人所得税率</li></ul><p>知识就是力量，而且钱越多，就越需要知识管理它，使它继续增加。没有这种知识，世界就会牵着你走。</p><p>财商是由4个方面的专门知识构成的：</p><ul><li>第一是会计，也就是我说的财务知识。</li><li>第二是投资，我把它称为钱生钱的科学。投资涉及策略和方案，这要右脑来做，是属于创造的部分。</li><li>第三是了解市场，它是供给与需求的科学。这要求了解受感情驱动的市场的“技术面”。</li><li>第四是法律。利用一个具有会计、投资和市场运营的企业会使你的财富实现爆炸性地增长。了解减税优惠政策和公司法的人会比雇员和小业主更快致富。<br>拥有公司的富人：挣钱、支出、缴税<br>为公司工作的人：挣钱、缴税、支出</li></ul><h2 id="第五课：富人的投资"><a href="#第五课：富人的投资" class="headerlink" title="第五课：富人的投资"></a>第五课：富人的投资</h2><p>我们都拥有巨大的潜能，然而，我们都拥有或多或少的自我怀疑的心理。过分的害怕和自我怀疑是毁掉我们才能的最大因素。成为财务上的天才既需要专业知识，又需要足够的勇气。<br>投资者分为两类：<br>第一类也是最普遍的一类，即进行一揽子投资的人。他们联系一家从事经营个人投资业务的中介机构，例如房地产公司、股票经纪人或财务规划师等，然后买下某些产品。这些产品可能是共同基金、房地产投资信托、股票或债券等。</p><p>第二类是自己创造投资机会的投资者。这种投资者通常会自行组织一项交易，好比一个人买来电脑零部件，然后自己组装，这有点像量身定做。<br>这类投资者，除了提高财商的4项基本技能，还必须具备3种主要技能，</p><ul><li>1．如何寻找其他人都忽视的机会。</li><li>2．如何增加资金。</li><li>3．怎样把精明的人组织起来。聪明的人往往会雇用比自己更聪明的人或与他们一起工作。当你需要建议的时候，你一定要确定你选择的是明智的顾问。</li></ul><h2 id="第六课：学会不为钱工作"><a href="#第六课：学会不为钱工作" class="headerlink" title="第六课：学会不为钱工作"></a>第六课：学会不为钱工作</h2><p>大部分人需要学习和掌握不止一项技能，只有这样他们的收入才能获得显著增长。财商是会计、投资、市场和法律等各方面知识和能力的综合。将上述4种技能结合起来，以钱生钱就会容易得多。当涉及钱的时候，只有一项技能的人不得不努力工作。<br>找一份稳定的工作。大部分人是为短期的工资和福利工作的，但从长期来看这种做法常常是具有灾难性的。<br>劝告年轻人在找工作时要看能从中学到什么，而不是只看能挣多少钱。在选择某种职业或陷入“老鼠赛跑”的陷阱之前，要仔细看看脚下的路，弄清楚自己到底想获得什么技能。<br>是建议他们要有长远的眼光。我承认为了金钱和生活安稳而工作是很重要，但我仍主张要再找一份工作，以便从中学到另一种技能。<br>我受过良好教育的爸爸工作越努力，就越具有竞争力，但同时他也更深地陷入专业特长的陷阱之中。虽然他的工资增长了，可他的选择机会却少了。直到失去了在政府中的工作，他才发现自己在职业选择上是多么被动。这就好比职业运动员因为突然受伤或是年龄太大而无法继续参加比赛一样，他们会失去曾经拥有的高收入工作，而有限的技能又使他们无法另辟蹊径。我想，</p><h2 id="克服困难"><a href="#克服困难" class="headerlink" title="克服困难"></a>克服困难</h2><p>掌握财务知识的人有时候还是不能积累丰厚的资产项，其主要原因有5个：</p><ul><li>1．恐惧心理。</li><li>2．愤世嫉俗。</li><li>3．懒惰。</li><li>4．不良习惯。</li><li>5．自负。</li></ul><h2 id="开始行动"><a href="#开始行动" class="headerlink" title="开始行动"></a>开始行动</h2><ul><li>1．我需要一个超现实的理由——精神的力量。</li><li>2．每天作出自己的选择——选择的力量。从理财的角度来说，我们每挣到一美元，就得到了一次选择自己是成为富人、穷人还是中产阶级的机会。我们花钱的习惯反映了我们是什么样的人，穷人之所以贫穷是因为他们有着不良的消费习惯。</li><li>3．慎重地选择朋友——关系的力量。首先，我不会把理财状况作为挑选朋友的标准。</li><li>4．掌握一种模式，然后再学习一种新的模式——快速学习的力量。面包师要按照一定的配方做面包，即使配方只是记在脑子里。挣钱也是一样的道理，这也是金钱有时被称做“面包圈”的原因。</li><li>5．首先支付自己——自律的力量。如果你控制不了自己，就别想着致富。<br>不要背上数额过大的债务包袱。要保持低支出。首先增加自己的资产，然后，再用资产项产生的现金流来买大房子或好车子。陷在“老鼠赛跑”中不是明智的选择。<br>当你资金短缺时，让压力去发挥作用，而不要动用你的储蓄或资本。利用这种压力来激发你的理财天赋，想出新办法挣到更多的钱，然后再支付账单。这样做，不但能让你赚到钱，还能提高你的财商。</li><li>6．给你的经纪人以优厚的报酬——好建议的力量。</li><li>7．做一个“印第安给予者”——无私的力量。</li><li>8．用资产来购买奢侈品——专注的力量。</li><li>9．对英雄的崇拜——神话的力量。</li><li>10．先予后取——给予的力量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们从小就听父母说，好好读书，好好上课，毕业了找一份好的工作。那好好上学真的可以找到好的工作吗？找到好的工作肯定会变富有吗？我想这些问题的答案都是否定的，谁能够一直坐在教室里听着那些枯燥乏味的教学内容，那些内容让我们只会运用于考试中，在生活中往往被我们给忽略了。我们如何才能让我们的生活不在为了金钱而忙碌，我们为什么不能让金钱为我们而工作呢！&lt;/p&gt;
&lt;p&gt;因此，要学会管理风险，要学会投资，不要让我们的生活只留下房贷、车贷。不要生活在一种虚假的忙碌中，那样的生活没有意义，只会让我们在往后的生活中教育自己的后代：好好上学，好好读书，找个好工作。这样的生活在当今社会已经不实用了，没有谁会认为只有读书才有出路。&lt;/p&gt;
&lt;p&gt;《富爸爸，穷爸爸》是一个真实的故事，作者罗伯特·清崎从人的个体出发分析富人之所以成为富人，穷人之所以成为穷人的自身因素，提出了一个全新的“财商”的概念。并向传统的学校教育提出挑战。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="理财" scheme="https://veinin.com/tags/%E7%90%86%E8%B4%A2/"/>
    
      <category term="富爸爸" scheme="https://veinin.com/tags/%E5%AF%8C%E7%88%B8%E7%88%B8/"/>
    
      <category term="穷爸爸" scheme="https://veinin.com/tags/%E7%A9%B7%E7%88%B8%E7%88%B8/"/>
    
  </entry>
  
  <entry>
    <title>《人类简史》读书笔记</title>
    <link href="https://veinin.com/2017/12/31/reading-notes-a-brief-history-of-humankind/"/>
    <id>https://veinin.com/2017/12/31/reading-notes-a-brief-history-of-humankind/</id>
    <published>2017-12-31T11:59:10.000Z</published>
    <updated>2017-12-31T03:03:03.098Z</updated>
    
    <content type="html"><![CDATA[<p>十万年前，地球上至少有六种不同的人。但今日，世界舞台为什么只剩下了我们自己？从只能啃食虎狼吃剩的残骨的猿人，到跃居食物链顶端的智人，从雪维洞穴壁上的原始人手印，到阿姆斯壮踩上月球的脚印，从认知革命、农业革命，到科学革命、生物科技革命，我们如何登上世界舞台成为万物之灵的？</p><p>这是以色列历史学家尤瓦尔·赫拉利成名作，这本书以不到500页的篇幅，从10万年前一直讲到了21世纪，为我们理清人类的发展脉络提供了一个充满哲思的全局视角。</p><a id="more"></a><p>在历史的路上，有三大重要革命：<br>大约7万年前，“认知革命”（CognitiveRevolution）让历史正式启动。<br>大约12000年前，“农业革命”（AgriculturalRevolution）让历史加速发展。<br>而到了大约不过是500年前，“科学革命”（ScientificRevolution）可以说是让历史画下句点而另创新局。<br>这本书的内容，讲述的就是这三大革命如何改变了人类和其他生物。</p><h2 id="认知革命"><a href="#认知革命" class="headerlink" title="认知革命"></a>认知革命</h2><p>人类是怎么从一种平凡无奇的动物走到食物链顶端的，认知革命带给了我们答案。</p><p>大约在240万年前的东非最早的人类开始演化，祖先是一种更早的猿属“Australopithecus”（南方古猿）。<br>大约200万年前，这些远古人类有一部分离开了家园而踏上旅程，足迹遍及北非、欧洲和亚洲的广大地带。北欧的森林白雪皑皑，印度尼西亚的热带丛林湿气蒸腾，想活命显然需要不同的特征，因此人类也开始朝着不同方向进化。于是人类发展出几个不同的物种，除了“智人”以外，还有比如在欧洲和西亚的“尼安德特人”，住在在东方亚洲的“直立人”等等。</p><p>如果不出意外，可能在今天我们可以看到多个不同的人种，多种人种共存其实会是常态。但是，意外出现了，大约7万年前，智人从东非扩张到阿拉伯半岛，并且很快席卷整个欧亚大陆，由于不同的人种之间的水火不容，互有反感，于是发生种族灭杀，当地的原生人种很快就会灭绝。大约3万年前尼安德特人退出了世界舞台，而到了12000年前，像小矮人般的人类也从弗洛里斯岛上永远消失，这种残酷的种族屠杀一直持续到了大约1万年前，终于，地球上的人种只剩下了智人一种。</p><p>因为智人迁移到其他地区，而造成其他人类物种的灭绝。那么为什么是智人，而不是其他人种呢？那是因为在大约7万年前，智人仿佛脱胎换骨，某次偶然的基因突变，改变了智人的大脑内部连接方式，让他们以前所未有的方式来思考，用完全新式的语言来沟通。他们的认知能力（学习、记忆、沟通）得到了革命性的发展，这时的智人已经和你我同样聪明、有创意、反应灵敏，他们产生了新的思维和沟通方式，这也是所谓的认知革命。</p><p>认知革命给智人带来了新的语言，这种新语言带来了最独特的功能–“讨论虚构的事物”。智人的语言并不是世界上的第一种语言。因为许多动物（包括所有的猿类和猴类）都会使用有声语言。例如，青猴（greenmonkey）就有各种不同的喊叫方式，传达不同的信息。不论是人类还是许多动物，都能大喊：“小心！有狮子！”。但在认知革命之后，智人就能够说出：“狮子是我们部落的守护神”。智人能够谈论并不真正存在的事物，相信一些不太可能的事情。于是传说、神话、神以及宗教也应运而生。</p><p>“虚构”这件事的重点不只在于让人类能够拥有想象，更重要的是可以“一起”想象，编织出种种共同的虚构故事，不管是《圣经》的《创世记》、澳大利亚原住民的“梦世记”（Dreamtime），甚至连现代所谓的国家其实也是种想象。这样的虚构故事赋予智人前所未有的能力，让我们得以集结大批人力、灵活合作。虽然一群蚂蚁和蜜蜂也会合作，但方式死板，而且其实只限近亲。至于狼或黑猩猩的合作方式，虽然已经比蚂蚁灵活许多，但仍然只能和少数其他十分熟悉的个体合作。智人的合作则是不仅灵活，而且能和无数陌生人合作。正因如此，才会是智人统治世界，蚂蚁只能吃我们的剩饭，而黑猩猩则被关在动物园和实验室里。</p><p>于人类共同的想象之外，这个宇宙中根本没有神、没有国家、没有钱、没有人权、没有法律，也没有正义。通过虚构的故事，就算是大批互不相识的人，只要同样相信相信某个故事，就能共同合作。无论是现代国家、中世纪的教堂、古老的城市，或者古老的部落，任何大规模人类合作的根基，都在于某种只存在于集体想象中的虚构故事。而这也使智人最后打破了团体的人数限制，<br>创造出了有数万居民的城市、有上亿人口的帝国，这也是智人成功的关键。</p><h2 id="农业革命"><a href="#农业革命" class="headerlink" title="农业革命"></a>农业革命</h2><p>人类曾有长达250万年的时间靠采集及狩猎维生，并不会特别干预动植物的生长情形。直立人、匠人或是尼安德特人都会采集野无花果、猎捕野绵羊，但不会去管究竟无花果树该长在哪，羊该在哪片草地吃草，又或是哪只公羊该跟母羊交配。</p><p>这一切在大约1万年前全然改观，人类开始投入几乎全部的心力，操纵着几种动植物的生命。从日升到日落，人类忙着播种、浇水、除草、牧羊，一心以为这样就能得到更多的水果、谷物和肉类。这是一场关于人类生活方式的革命：农业革命。</p><p>农业革命让人类的食物总量增加，但量的增加并不代表吃得更好、过得更悠闲，反而只是造成人口爆炸，而且产生一群养尊处优、娇生惯养的精英分子。普遍来说，农民的工作要比采集者更辛苦，而且到头来的饮食还要更糟。农业革命可说是史上最大的一桩骗局。</p><p>正是这些征收来的多余食粮，养活了政治、战争、艺术和哲学，建起了宫殿、堡垒、纪念碑和庙宇。在现代晚期之前，总人口有九成以上都是农民，日出而作、胼手胝足。他们生产出来的多余食粮养活了一小撮的精英分子：国王、官员、战士、牧师、艺术家和思想家，但历史写的几乎全是这些人的故事。于是，历史只告诉了我们极少数的人在做些什么，而其他绝大多数人的生活就是不停挑水耕田。</p><p>农业革命后几千年的历史，可以总结为一个问题：如果人类的基因里并没有大规模合作的生物本能，所有的合作网络究竟如何维系？简单的讲法，是人类创造出了由想象建构的秩序、发明了文字，以这两者补足我们基因中的不足。但对许多人来说，这些合作网络究竟是好是坏实在难说。网络背后那些想象的秩序既不中立也不公平，总把人分成一些其实并不存在的分类，并且排出上下等级。上等人享有各种权力和特权，而下等人有的只有歧视和压迫。</p><h2 id="人类统一融合"><a href="#人类统一融合" class="headerlink" title="人类统一融合"></a>人类统一融合</h2><p>农业革命之后，人类社会规模变得更大、更复杂，而维系社会秩序的虚构故事也更为细致完整。人类几乎从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照着这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化”。</p><p>每种文化都自成一格、和谐共存，而且都有独特的不变本质。每一群人都会有自己的世界观，和社会、法律及政治系统，而且各自运作顺畅，就像是行星绕着太阳一样。</p><p>从实际观点看，全球融合最关键的阶段就是过去这几个世纪。各大帝国成长，全球贸易强化，亚洲、非洲、美洲和大洋洲的人类形成紧密连接，于是印度菜里出现了墨西哥的辣椒，阿根廷的草原上漫步着来自西班牙的牛。</p><p>在过去的3000年间，人类有越来越多雄心勃勃的计划，想要实现这种世界一家的概念。他们发明货币、建筑帝国和传播宗教。</p><p>商业、帝国和全球性的宗教，最后终于将几乎每个智人都纳入了我们今天的全球世界。这个扩张和统一的过程并不是完全直线发展、一帆风顺。但纵观大局，可以看到从许多小文化到少数大文化再到最后的全球单一文化，应该是人类历史无法避免的结果。</p><h2 id="科学革命"><a href="#科学革命" class="headerlink" title="科学革命"></a>科学革命</h2><p>历史就这样从一个岔路走到下一个岔路，选择走某条道路而非另一条的原因总是神秘而不得而知。大约在公元1500年，历史做出了最重大的选择，改变的不只是人类的命运，而是地球上所有生命的命运。我们将它称为“科学革命”。</p><p>将人类带到阿拉莫戈多、带上月球的这段历史进程，称为“科学革命”。在这场革命中，人类因为将资源投入科学研究，取得了巨大的新力量。之所以说这是一场革命，是因为一直到大约公元1500年前，全球人类还不相信自己能在医疗、军事和经济方面再有什么突破。政府和富有的赞助者虽然也会将资金投入教育和作为奖学金，但一般来说只是为了维持现有能力，而不是取得新的能力。典型的前现代统治者会赞助牧师、哲学家和诗人，目的是请他们让他的统治合法化，并且维护社会秩序，而不是要他们发明新的药物、武器，或是刺激经济成长。</p><p>但在过去的500年中，人类越来越相信可以靠着投资科学研究提升人类的能力。而且这不只是盲目的信仰，而是经过了反复的证明。随着证据越来越多，手中握有资源的富人和政府也就越来越愿意投入科学。如果没有这些投资，人类永远不可能在月球上漫步，不可能操纵微生物，更不可能分裂原子。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>历史有太多的可能性，而许多的可能性最后都未成真。我们不难想象，历史其实很有可能就这样一代又一代地过去，而从未发生科学革命，就算没有基督教，没有古罗马帝国，没有金币，历史还是会继续发展下去。</p><p>在7万年前，智人还不过是一种微不足道的动物，在非洲的角落自顾自地生活。但就在接下来的几千年间，智人就成了整个地球的主人、生态系统的梦魇。时至今日，智人似乎只要再跨一步就能进入神的境界，不仅有望获得永恒的青春，更拥有创造和毁灭一切的神力。</p><p>但遗憾的是，智人在地球上的所作所为，实在没有太多令人自豪。虽然我们主宰了环境、增加了粮食产量、盖起城市、建立帝国，还创造了无远弗届的贸易网络，但全球的痛苦减少了吗？一次又一次，虽然整体人类的能力大幅提升，但却不一定能改善个别人类的福祉，而且常常还让其他动物深受其害。</p><p>拥有神的能力，但是不负责任、贪得无厌，而且连想要什么都不知道。天下危险，恐怕莫此为甚。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;十万年前，地球上至少有六种不同的人。但今日，世界舞台为什么只剩下了我们自己？从只能啃食虎狼吃剩的残骨的猿人，到跃居食物链顶端的智人，从雪维洞穴壁上的原始人手印，到阿姆斯壮踩上月球的脚印，从认知革命、农业革命，到科学革命、生物科技革命，我们如何登上世界舞台成为万物之灵的？&lt;/p&gt;
&lt;p&gt;这是以色列历史学家尤瓦尔·赫拉利成名作，这本书以不到500页的篇幅，从10万年前一直讲到了21世纪，为我们理清人类的发展脉络提供了一个充满哲思的全局视角。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="人类简史" scheme="https://veinin.com/tags/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"/>
    
      <category term="历史" scheme="https://veinin.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="人类学" scheme="https://veinin.com/tags/%E4%BA%BA%E7%B1%BB%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《拖延心理学》读书笔记</title>
    <link href="https://veinin.com/2017/12/02/reading-notes-procrastination/"/>
    <id>https://veinin.com/2017/12/02/reading-notes-procrastination/</id>
    <published>2017-12-02T08:15:00.000Z</published>
    <updated>2017-12-02T08:22:19.080Z</updated>
    
    <content type="html"><![CDATA[<p>拖延从根本上来说并不是一个时间管理方面或懒惰的问题，也不是一个道德问题，而是一个复杂的心理问题。根本而言，拖延的问题是一个人跟自身如何相处的问题，它反映的是一个人在自尊上的问题。</p><p>本书的第一部分中，我们对产生拖延的形形色色的根源进行了追溯，告诉我们为何会拖延。<br>在第二部分中，给出了一些帮助你采取行动的建议，教导我们如何去应对拖延症。我们的目标并不是消除拖延。很多时候对一些事情弃之不理反而对你最为有利；相反，这本书希望能够让你更加接受自己，由你自己来掌握取舍和得失。</p><a id="more"></a><h2 id="我们为何拖延"><a href="#我们为何拖延" class="headerlink" title="我们为何拖延"></a>我们为何拖延</h2><p>表面上看来，拖延症是因为懒，或者是对时间管理能力不足而造成的。而本书告诉了我们一个真正的原因，拖延症的成因主要是源于内心的恐惧。</p><p>由于家庭、性格、以及自己的各种经历，会导致人们产生各种各样的恐惧。很多拖延者并不能识别所有这些活跃于表面现象之下的情绪波动，因为他们利用拖延来逃避不舒服的感受。为了对付这些恐惧，我们产生了一种防卫机制来对抗恐惧，而拖延就是用来避免恐惧的。这样的反应模式一次次循环，让我们一次次的陷入了“拖延怪圈”中。</p><p>对于“拖延怪圈”，每个人都有自己不同的体验。你或许在几个星期、几个月，甚至几年时间内都挣扎在这个怪圈当中，或者，你也可能从头到尾只需要几个小时就经历了一个怪圈。</p><ol><li>“这次我想早点开始。”</li><li>“我得马上开始。”</li><li>“我不开始又怎么样呢？”<ul><li>a.“我应该早点开始。”</li><li>b.“我可以做任何事，除了这件……”</li><li>c.“我无法享受任何事情。”</li><li>d.“我希望没人发现。”</li></ul></li><li>“还有时间。”</li><li>“我这个人有毛病。”</li><li>最后的抉择：做还是不做。<ul><li>道路之一：不做</li><li>a.“我无法忍受了！”</li><li>b.“何必庸人自扰呢？”</li><li>道路之二：背水一战</li><li>a.“我不能再坐等了。”</li><li>b.“事情还没有这么糟，为什么当初我不早一点开始做呢？”</li><li>c.“把它做完就行了！”</li></ul></li><li>“我永远不会再拖延！”</li></ol><p>人们之所以产生拖延的不良习性，是因为他们害怕。他们害怕如果他们行动了，他们的行为会让他们陷入麻烦。他们担心如果展示了自己真实的一面，会有危险的结果等着他们。在所有无序和拖拉的背后，他们其实在害怕他们不被接受，以至于他们不仅躲开这个世界，甚至还躲开他们自己。虽然要忍受自责、自轻和对自己的反感是相当痛苦的，但是比起去看清真实的自我所带来的脆弱和无地自容，这样的感受或许更能够被承受得起，拖延是保护他们的盾牌。</p><h2 id="如何改变拖延"><a href="#如何改变拖延" class="headerlink" title="如何改变拖延"></a>如何改变拖延</h2><p>做出改变和学会一种新的行为模式是一个渐进的过程，这是一个可以预知的改变顺序，称为为“改变的阶段”。</p><ul><li>第一阶段，“前关注”，没有准备做出改变，甚至都没有想过要做改变。</li><li>第二阶段，“关注”，通过阅读这本书，你知道了拖延是因为恐惧，你开始思考是否准备采取行动。</li><li>第三阶段，“准备”，做了一点尝试，虽然没有完全投入其中。“好吧，我终于要开始锻炼身体了”。</li><li>第四阶段，“行动”，“我今天去健身房，感觉还不错”。</li></ul><p>当你迟迟不肯记账的时候，你可能是不想面对花费过大而收入过少的事实。<br>当你一直不回短信的时候，你可能在恐惧跟陌生人打交道。<br>当你迟迟不想写论文的时候，你可能是担心论文会占用所有的娱乐时间。</p><p>无论你的任何拖延是出于什么奇奇怪怪的原因，我们都应该坦然接受。慢慢来，不管你多么渴望改善自己，也不管你怎样努力，你不可能在第二天，或者下个星期，或者下个月，就一下子停止拖延了。</p><p>当我们再一次面对一件难事，大脑依然会收到恐惧信号，焦虑会立刻袭来，此时请提醒自己，不要重蹈覆辙，而是要改变心态，跳出拖延。</p><p>当你知道自己花钱太多，收入太少时，你可以提醒你自己，年轻人收入低，没关系，能进步就好。<br>当你害怕和陌生人打交道是，你可以告诉自己，很多人都在做这样的事情。</p><p>观察你内心的抵抗情绪，虽然你在处理拖延问题上开始有所进步，但是你可能还是会因为自己努力不够、进步不大或者没有完成自己设定的所有目标而对自己感到失望或者生气。或者，你也可能会觉得我们对你要求太多了。不管抵抗情绪采取什么样的形式表现出来，它会让你停留在原地停滞不前。</p><p>通过树立新的行为模式和思维方法，我们就可以舒缓恐惧所带来的焦虑和压力，而不是靠拖延来逃避恐惧。</p><p>除此之外，涉及一些具体的改变拖延方法方面，书中还给出了很多实用性的建议，比如：</p><ul><li>明确自己的目标与可行性的计划，启动一周试验。</li><li>学会更好的判断时间，提升你定是能力的技巧，让自己的时间观念通常跟“钟表时间”同步。</li><li>学会接受有益于你的人和事，学会结局那些没有意义的追求。</li><li>通过运动来启动你的状态，从拖延的麻痹状态中解救出来。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本书指出了人们之所以拖延的很多原因，认为拖延是心理问题。就像书中说的那样，光是认清楚拖延的根源还是不够的，你还必须做一些事情以防止拖延来主导你的生活，采用一些书中的建议，并行动起来。最后去尝试一种新的行为模式，感受自己的拖延，如实的去接受它，不再躲避，打破自己的拖延循环。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《拖延心理学》，<a href="https://book.douban.com/subject/4180711/" target="_blank" rel="noopener">豆瓣读书</a></li><li>速读《拖延心理学》，<a href="https://www.bilibili.com/video/av14625804/" target="_blank" rel="noopener">bilibili</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拖延从根本上来说并不是一个时间管理方面或懒惰的问题，也不是一个道德问题，而是一个复杂的心理问题。根本而言，拖延的问题是一个人跟自身如何相处的问题，它反映的是一个人在自尊上的问题。&lt;/p&gt;
&lt;p&gt;本书的第一部分中，我们对产生拖延的形形色色的根源进行了追溯，告诉我们为何会拖延。&lt;br&gt;在第二部分中，给出了一些帮助你采取行动的建议，教导我们如何去应对拖延症。我们的目标并不是消除拖延。很多时候对一些事情弃之不理反而对你最为有利；相反，这本书希望能够让你更加接受自己，由你自己来掌握取舍和得失。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="拖延症" scheme="https://veinin.com/tags/%E6%8B%96%E5%BB%B6%E7%97%87/"/>
    
      <category term="心理学" scheme="https://veinin.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《Linux 命令行与shell脚本编程大全》读书笔记（命令行部分）</title>
    <link href="https://veinin.com/2017/11/24/reading-notes-linux-command-lime/"/>
    <id>https://veinin.com/2017/11/24/reading-notes-linux-command-lime/</id>
    <published>2017-11-24T15:30:00.000Z</published>
    <updated>2017-11-26T15:36:17.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Linux"><a href="#什么是-Linux" class="headerlink" title="什么是 Linux"></a>什么是 Linux</h2><p>Linux可划分为以下四部分：</p><h3 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h3><ul><li>系统内存管理</li><li>软件程序管理</li><li>硬件设备管理</li><li>文件系统管理</li></ul><h3 id="GNU工具"><a href="#GNU工具" class="headerlink" title="GNU工具"></a>GNU工具</h3><p>GNU组织（GNU是GNU’s Not Unix的缩写），模仿Unix操作系统开发一系列标准的计算机系统工具，但没有可以运行它们的内核系统。</p><a id="more"></a><ul><li><p><strong>核心GNU工具</strong><br>该项目移植了很多常见的Unix系统命令行工具。供Linux系统使用的这组核心工具被称为coreutils（coreutilities）软件包。由三部分构成：用以处理文件的工具、用以操作文本的工具、用以管理进程的工具</p></li><li><p><strong>shell</strong><br>GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。 shell的核心是命令行提示符。命令行提示符是shell负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中执行。所有Linux发行版默认的shell都是bash shell。</p></li></ul><h3 id="图形化桌面环境"><a href="#图形化桌面环境" class="headerlink" title="图形化桌面环境"></a>图形化桌面环境</h3><ul><li>X Window系统</li><li>KDE桌面（K Desktop Environment， K桌面环境）</li><li>GNOME桌面（the GNU Network Object Model Environment， GNU网络对象模型环境）</li><li>Unity桌面……</li></ul><h3 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h3><h2 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a>Linux 发行版</h2><p>不同的Linux发行版通常归类为3种：</p><h3 id="完整的核心Linux发行版"><a href="#完整的核心Linux发行版" class="headerlink" title="完整的核心Linux发行版"></a>完整的核心Linux发行版</h3><p>核心Linux发行版含有内核、一个或多个图形化桌面环境以及预编译好的几乎所有能见到的Linux应用。它提供了一站式的完整Linux安装。</p><h3 id="特定用途的发行版"><a href="#特定用途的发行版" class="headerlink" title="特定用途的发行版"></a>特定用途的发行版</h3><p>它们通常基于某个主流发行版，但仅包含主流发行版中一小部分用于某种特定用途的应用程序。如许多特定用途的Linux发行版都是基于Debian Linux，但仅打包了完整Debian系统中的一小部分。</p><h3 id="LiveCD测试发行版"><a href="#LiveCD测试发行版" class="headerlink" title="LiveCD测试发行版"></a>LiveCD测试发行版</h3><p>它无需安装就可以看到Linux系统是什么样的。多数现代PC都能从CD启动，而不是必须从标准硬盘启动。基于这点，一些Linux发行版创建了含有Linux样本系统（称为Linux LiveCD）的可引导CD。</p><h2 id="bash-手册"><a href="#bash-手册" class="headerlink" title="bash 手册"></a>bash 手册</h2><p>man命令用来访问存储在Linux系统上的手册页面。在想要查找的工具的名称前面输入man命令，就可以找到那个工具相应的手册条目。<br>手册每个内容区域都分配了一个数字，从1开始，一直到9：<br>1：可执行程序或shell命令<br>2：系统调用<br>3：库调用<br>4：特殊文件<br>5：文件格式与约定<br>6：游戏<br>7：概览、约定及杂项<br>8：超级用户和系统管理员命令<br>9：内核例程</p><h2 id="过滤输出列表"><a href="#过滤输出列表" class="headerlink" title="过滤输出列表"></a>过滤输出列表</h2><p>ls命令能够识别标准通配符，并在过滤器中用它们进行模式匹配：</p><ul><li>问号（?）代表一个字符；</li><li>星号（*）代表零个或多个字符。</li><li><p>在特定位置上可能出现的两种字符，a或i:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l my_scr[ai]pt</span><br></pre></td></tr></table></figure></li><li><p>指定字符范围，例如字母范围[a – i]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l f[a-i]ll</span><br></pre></td></tr></table></figure></li><li><p>使用感叹号（!）将不需要的内容排除在外:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l f[!a]ll</span><br></pre></td></tr></table></figure></li></ul><h2 id="管理文件目录"><a href="#管理文件目录" class="headerlink" title="管理文件目录"></a>管理文件目录</h2><h3 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h3><ul><li>创建文件：touch</li><li>复制文件：cp</li><li>重命名文件：mv</li><li>删除文件：rm</li><li>链接文件：ln<br>在系统上维护同一文件的两份或多份副本，除了保存多份单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法。这种虚拟的副本就称为链接。</li></ul><h3 id="文件链接"><a href="#文件链接" class="headerlink" title="文件链接"></a>文件链接</h3><p>在Linux中有两种不同类型的文件链接：</p><h4 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h4><p>符号链接就是一个实实在在的文件，它指向存放在虚拟目录结构中某个地方的另一个文件。这两个通过符号链接在一起的文件，彼此的内容并不相同。<br>使用ln命令以及-s选项来创建符号链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s data_file sl_data_file</span><br></pre></td></tr></table></figure></p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件。引用硬链接文件等同于引用了源文件。<br>使用ln命令时不再需要加入额外的参数创建硬链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln code_file hl_code_file</span><br></pre></td></tr></table></figure></p><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><ul><li>显示文本文件中所有数据；cat</li><li>显示文本文件的内容，但会在显示每页数据之后停下来：more</li><li>more命令的升级版：less</li><li>显示文件最后几行的内容：tail</li><li>显示文件开头那些行的内容：head</li></ul><h3 id="处理目录"><a href="#处理目录" class="headerlink" title="处理目录"></a>处理目录</h3><ul><li>创建目录：mkdir New_Dir</li><li>创建多个目录和子目录，需要加入-p参数：mkdir -p New_Dir/Sub_Dir/Under_Dir</li><li>删除目录，只删除空目录：rmdir New_Dir</li><li>删除目录及其所有内容：rm -rf Small_Dir</li><li>查看文件类型：file my_file</li></ul><h2 id="处理数据文件"><a href="#处理数据文件" class="headerlink" title="处理数据文件"></a>处理数据文件</h2><h3 id="排序、搜索"><a href="#排序、搜索" class="headerlink" title="排序、搜索"></a>排序、搜索</h3><ul><li>排序数据：sort [options] [file]</li><li>搜索数据：grep [options] pattern [file]</li></ul><h3 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h3><p>Linux上的文件压缩工具：</p><ul><li>bzip2，采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码，文件扩展名：.bz2        </li><li>compress，最初的Unix文件压缩工具，已经快没人用了，文件扩展名：.Z  </li><li>gzip，GNU压缩工具，用Lempel-Ziv编码，文件扩展名：.gz </li><li>zip，Windows上PKZIP工具的Unix实现，文件扩展名：.zip</li></ul><p>gzip 软件包是GNU项目的产物，意在编写一个能够替代原先Unix中compress工具的免费版本。这个软件包含有下面的工具：</p><ul><li>gzip：用来压缩文件。</li><li>gzcat：用来查看压缩过的文本文件的内容。</li><li>gunzip：用来解压文件。</li></ul><h3 id="归档数据"><a href="#归档数据" class="headerlink" title="归档数据"></a>归档数据</h3><p>虽然zip命令能够很好地将数据压缩和归档进单个文件，但它不是Unix和Linux中的标准归档工具。目前，Unix和Linux上最广泛使用的归档工具是tar命令。</p><p>tar命令的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar function [options] object1 object2 ...</span><br></pre></td></tr></table></figure></p><p>function参数定义了tar命令应该做什么：</p><ul><li>-A –concatenate 将一个已有tar归档文件追加到另一个已有tar归档文件</li><li>-c –create 创建一个新的tar归档文件</li><li>-d –diff 检查归档文件和文件系统的不同之处</li><li>–delete 从已有tar归档文件中删除</li><li>-r –append 追加文件到已有tar归档文件末尾</li><li>-t –list 列出已有tar归档文件的内容</li><li>-u –update 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中</li><li>-x –extract 从已有tar归档文件中提取文件</li></ul><p>每个功能可用选项来针对tar归档文件定义一个特定行为：</p><ul><li>-C dir 切换到指定目录</li><li>-f file 输出结果到文件或设备file</li><li>-j 将输出重定向给bzip2命令来压缩内容</li><li>-p 保留所有文件权限</li><li>-v 在处理文件时显示文件</li><li>-z 将输出重定向给gzip命令来压缩内容</li></ul><p>列出归档内容：tar -tf test.tar<br>提取归档内容：tar -xvf test.tar<br>创建归档文件：tar -cvf test.tar test/ test2</p><h2 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h2><h3 id="探查进程"><a href="#探查进程" class="headerlink" title="探查进程"></a>探查进程</h3><p>当程序运行在系统上时，我们称之为进程（process）。想监测这些进程，需要熟悉ps命令的用法。<br>使用ps命令的关键不在于记住所有可用的参数，而在于记住最有用的那些参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 Aug21 ?        00:07:16 /usr/lib/systemd/systemd --system --deserialize 26</span><br><span class="line">root         2     0  0 Aug21 ?        00:00:04 [kthreadd]</span><br><span class="line">root         3     2  0 Aug21 ?        00:00:28 [ksoftirqd/0]</span><br><span class="line">root         7     2  0 Aug21 ?        00:00:00 [migration/0]</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li>-e参数指定显示所有运行在系统上的进程；</li><li>-f参数则扩展了输出，这些扩展的列包含了有用的信息。</li><li>-l参数，它会产生一个长格式输出。</li></ul><p>这些扩展的列包含了有用的信息：</p><ul><li>UID：启动这些进程的用户。</li><li>PID：进程的进程ID。</li><li>PPID：父进程的进程号（如果该进程是由另一个进程启动的）。</li><li>C：进程生命周期中的CPU利用率。</li><li>STIME：进程启动时的系统时间。</li><li>TTY：进程启动时的终端设备。</li><li>TIME：运行进程需要的累计CPU时间。</li><li>CMD：启动的程序名称。</li></ul><h3 id="实时监测进程"><a href="#实时监测进程" class="headerlink" title="实时监测进程"></a>实时监测进程</h3><p>想观察那些频繁换进换出的内存的进程趋势，top命令刚好适用这种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">top - 15:54:00 up 95 days, 10:46,  1 user,  load average: 0.14, 0.07, 0.06</span><br><span class="line">Tasks: 176 total,   1 running, 175 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :   602816 total,    65452 free,   248696 used,   288668 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   177264 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">  170 root      20   0       0      0      0 S  0.3  0.0  20:03.70 xfsaild/sda1</span><br><span class="line">14270 root      20   0  828800  24620   2880 S  0.3  4.1  19:15.48 dockerd</span><br><span class="line">16454 systemd+  20   0  888224  33020      0 S  0.3  5.5   7:18.88 mysqld</span><br><span class="line">31990 veining+  20   0  155620   2216   1500 R  0.3  0.4   0:00.04 top</span><br><span class="line">    1 root      20   0  193496   4944   2392 S  0.0  0.8   7:25.59 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S  0.0  0.0   0:04.07 kthreadd</span><br></pre></td></tr></table></figure><p>输出的第一部分显示的是系统的概况：</p><ul><li>第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载。</li><li>第二行显示了进程概要信息——top命令的输出中将进程叫作任务（task）：有多少进程处在运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）。</li><li>第三行显示了CPU的概要信息。 top根据进程的属主（用户还是系统）和进程的状态（运行、<br>空闲还是等待）将CPU利用率分成几类输出。</li><li>最后两行说明了系统内存的状态。第一行说的是系统的物理内存：总共有多少内存，当前用了多少，还有多少空闲。<br>后一行说的是同样的信息，不过是针对系统交换空间（如果分配了的话）的状态而言的。</li></ul><p>最后一部分显示了当前运行中的进程的详细列表，有些列跟ps命令的输出类似：</p><ul><li>PID：进程的ID。</li><li>USER：进程属主的名字。</li><li>PR：进程的优先级。</li><li>NI：进程的谦让度值。</li><li>VIRT：进程占用的虚拟内存总量。</li><li>RES：进程占用的物理内存总量。</li><li>SHR：进程和其他进程共享的内存总量。</li><li>S：进程的状态（D代表可中断的休眠状态， R代表在运行状态， S代表休眠状态， T代表跟踪状态或停止状态， Z代表僵化状态）。</li><li>%CPU：进程使用的CPU时间比例。</li><li>%MEM：进程使用的内存占可用内存的比例。</li><li>TIME+：自进程启动到目前为止的CPU时间总量。</li><li>COMMAND：进程所对应的命令行名称，也就是启动的程序名。</li></ul><h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><p>在Linux中，进程之间通过信号来通信。进程的信号就是预定义好的一个消息，进程能识别它并决定忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。</p><p>在Linux上有两个命令可以向运行中的进程发出进程信号。</p><ol><li>kill命令：kill 3940<br>kill命令可通过进程ID（PID）给进程发信号。默认情况下，kill命令会向命令行中列出的全部PID发送一个TERM信号。遗憾的是，你只能用进程的PID而不能用命令名，所以kill命令有时并不好用。</li><li>killall命令：killall http*<br>killall命令非常强大，它支持通过进程名而不是PID来结束进程。 killall命令也支持通配符，这在系统因负载过大而变得很慢时很有用。</li></ol><h2 id="管理磁盘"><a href="#管理磁盘" class="headerlink" title="管理磁盘"></a>管理磁盘</h2><p>Linux文件系统将所有的磁盘都并入一个虚拟目录下。在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作称为挂载（mounting）。如果用的Linux发行版不支持自动挂载和卸载可移动存储媒体，就必须手动完成。</p><h3 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a>mount命令</h3><p>Linux上用来挂载媒体的命令叫作mount。默认情况下， mount命令会输出当前系统上挂载的设备列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mount</span><br><span class="line">sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)</span><br><span class="line">proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=294632k,nr_inodes=73658,mode=755)</span><br><span class="line">securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)</span><br></pre></td></tr></table></figure></p><p>mount命令提供如下四部分信息：</p><ul><li>媒体的设备文件名</li><li>媒体挂载到虚拟目录的挂载点</li><li>文件系统类型</li><li>已挂载媒体的访问状态</li></ul><p>手动挂载媒体设备的基本命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t type device directory</span><br></pre></td></tr></table></figure></p><h3 id="umount命令"><a href="#umount命令" class="headerlink" title="umount命令"></a>umount命令</h3><p>从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。umount命令的格式非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [directory | device ]</span><br></pre></td></tr></table></figure></p><h3 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h3><p>有时你需要知道在某个设备上还有多少磁盘空间。df命令可以让你很方便地查看所有已挂载磁盘的使用情况<br>常用参数是-h，它会把输出中的磁盘空间按照用户易读的形式显示，通常用M来替代兆字节，用G替代吉字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ df</span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda1       10474496 8675760   1798736  83% /</span><br><span class="line">devtmpfs          294632       0    294632   0% /dev</span><br><span class="line">tmpfs             301408       0    301408   0% /dev/shm</span><br></pre></td></tr></table></figure></p><p>df命令会显示每个有数据的已挂载文件系统。命令输出如下：</p><ul><li>设备的设备文件位置；</li><li>能容纳多少个1024字节大小的块；</li><li>已用了多少个1024字节大小的块；</li><li>还有多少个1024字节大小的块可用；</li><li>已用空间所占的比例；</li><li>设备挂载到了哪个挂载点上。</li></ul><h3 id="du-命令"><a href="#du-命令" class="headerlink" title="du 命令"></a>du 命令</h3><p>du命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这一方法可用来快速判断系统上某个目录下是不是有超大文件。</p><p>能让du命令用起来更方便的几个命令行参数：</p><ul><li>-c：显示所有已列出文件总的大小。</li><li>-h：按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节。</li><li>-s：显示每个输出参数的总计。</li></ul><h2 id="理解Shell"><a href="#理解Shell" class="headerlink" title="理解Shell"></a>理解Shell</h2><h3 id="shell-的类型"><a href="#shell-的类型" class="headerlink" title="shell 的类型"></a>shell 的类型</h3><p>系统启动什么样的shell程序取决于你个人的用户ID配置，在/etc/passwd文件中。<br>默认的交互shell会在用户登录某个虚拟控制台终端或在GUI中运行终端仿真器时启动。不过还有另外一个默认shell是/bin/sh，它作为默认的系统shell，用于那些需要在启动时使用的系统shell脚本。</p><h3 id="shell-的父子关系"><a href="#shell-的父子关系" class="headerlink" title="shell 的父子关系"></a>shell 的父子关系</h3><p>用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell，是一个父shell。<br>在CLI提示符后输入/bin/bash命令或其他等效的bash命令时， 会创建一个新的shell程序。这个shell程序被称为子shell（child shell） 。</p><p>bash shell程序可使用命令行参数修改shell启动方式：</p><ul><li>-c string 从string中读取命令并进行处理</li><li>-i 启动一个能够接收用户输入的交互shell</li><li>-l 以登录shell的形式启动</li><li>-r 启动一个受限shell，用户会被限制在默认目录中</li><li><p>-s 从标准输入中读取命令</p></li><li><p>依次运行的一系列命令。这可以通过命令列表来实现，只需要在命令之间加入分号（;）即可：pwd ; ls ; cd /etc ; pwd ;</p></li><li>要想将命令置入后台模式，可以在命令末尾加上字符&amp;：sleep 3000&amp;</li><li>协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。使用coproc命令进行协程处理：coproc sleep 10</li></ul><h3 id="理解-shell-的内建命令"><a href="#理解-shell-的内建命令" class="headerlink" title="理解 shell 的内建命令"></a>理解 shell 的内建命令</h3><h4 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h4><p>外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、 /usr/bin、 /sbin或/usr/sbin中。<br>ps就是一个外部命令。你可以使用which和type命令找到它。<br>当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。外部命令ps很方便显示出它的父进程以及自己所对应的衍生子进程。</p><h4 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h4><p>内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。cd和exit命令都内建于bash shell。可以利用type命令来了解某个命令是否是内建的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ type ps</span><br><span class="line">ps is hashed (/usr/bin/ps)</span><br><span class="line">$</span><br><span class="line">$ type -a echo</span><br><span class="line">echo is a shell builtin</span><br><span class="line">echo is /bin/echo</span><br></pre></td></tr></table></figure></p><ul><li>查看最近用过的命令列表：history</li><li>为常用的命令（及其参数）创建另一个名称：alias</li><li>要查看当前可用的别名，使用alias命令以及选项-p：alias -p</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>Linux环境变量能帮你提升Linux shell体验。很多程序和脚本都通过环境变量来获取系统信息、存储临时数据和配置信息。在Linux系统上有很多地方可以设置环境变量，了解去哪里设置相应的环境变量很重要。<br>在涉及环境变量名时，如果要用到变量，使用$；如果要操作变量，不使用$。</p><p>在bash shell中，环境变量分为两类：</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的<br>shell可见。这让全局环境变量对那些所创建的子shell需要获取父shell信息的程序来说非常有用。<br>要查看全局变量，可以使用 <code>env</code> 或 <code>printenv</code> 命令。</p><p>要显示个别环境变量的值，可以使用 <code>printenv</code> 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ printenv HOME</span><br><span class="line">/home/veininguo</span><br></pre></td></tr></table></figure></p><p>也可以使用 <code>echo</code> 显示变量的值。在变量前面加上一个美元符（$）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $HOME</span><br><span class="line">/home/veininguo</span><br></pre></td></tr></table></figure></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部环境变量只能在定义它们的进程中可见。<br>在Linux系统并没有一个只显示局部环境变量的命令。 set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。</p><h3 id="设置用户定义变量"><a href="#设置用户定义变量" class="headerlink" title="设置用户定义变量"></a>设置用户定义变量</h3><p>可以在bash shell中直接设置自己的变量。</p><h4 id="设置局部用户定义变量"><a href="#设置局部用户定义变量" class="headerlink" title="设置局部用户定义变量"></a>设置局部用户定义变量</h4><p>创建在shell进程内可见的局部变量，但在子shell中无法使用用户定义变量。可以通过等号给环境变量赋值，值可以是数值或字符串。<br>所有的环境变量名均使用大写字母，如果是你自己创建的局部变量或是shell脚本，请使用小写字母。<br>变量名、等号和值之间没有空格，这一点非常重要。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable=&quot;Veinin Guo&quot;</span><br><span class="line">$ echo $my_variable</span><br><span class="line">Veinin Guo</span><br></pre></td></tr></table></figure></p><h4 id="设置全局环境变量"><a href="#设置全局环境变量" class="headerlink" title="设置全局环境变量"></a>设置全局环境变量</h4><p>在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。<br>创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。通过export命令来完成，变量名前面不需要加$。<br>子shell无法使用export命令改变父shell中全局环境变量的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable=&quot;I am Global now&quot;</span><br><span class="line">$ export my_variable</span><br><span class="line">$</span><br><span class="line">$ echo $my_variable</span><br><span class="line">I am Global now</span><br><span class="line">$</span><br><span class="line">$ bash</span><br><span class="line">$ echo $my_variable</span><br><span class="line">I am Global now</span><br><span class="line">$</span><br><span class="line">$ exit</span><br><span class="line">exit</span><br><span class="line">$ echo $my_variable</span><br><span class="line">I am Global now</span><br></pre></td></tr></table></figure></p><h4 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h4><p>可以用 <code>unset</code> 命令完成这个操作。在命令中引用环境变量时不要使用$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo $my_variable</span><br><span class="line">I am Global now</span><br><span class="line">$ unset my_variable</span><br><span class="line">$ echo $my_variable</span><br></pre></td></tr></table></figure></p><h3 id="设置-PATH-环境变量"><a href="#设置-PATH-环境变量" class="headerlink" title="设置 PATH 环境变量"></a>设置 PATH 环境变量</h3><p>在 shell 命令行界面中输入一个外部命令时， shell 必须搜索系统来找到对应的程序。PATH 环境变量定义了用于进行命令和程序查找的目录。PATH中的目录使用冒号分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/veininguo/.local/bin:/home/veininguo/bin</span><br></pre></td></tr></table></figure><p>把新的搜索目录添加到现有的PATH环境变量中，无需从头定义。PATH中各个目录之间是用冒号分隔的。你只需引用原来的PATH值，然后再给这个字符串添加新目录就行了。也将单点符也加入PATH环境变量，单点符代表当前目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/veininguo/.local/bin:/home/veininguo/bin</span><br><span class="line">$</span><br><span class="line">$ PATH=$PATH:/usr/games:/usr/local/games</span><br><span class="line">$</span><br><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/veininguo/.local/bin:/home/veininguo/bin:/usr/games:/usr/local/games</span><br><span class="line">$</span><br><span class="line">$ PATH=$PATH:.</span><br></pre></td></tr></table></figure><h3 id="定位系统环境变量"><a href="#定位系统环境变量" class="headerlink" title="定位系统环境变量"></a>定位系统环境变量</h3><p>在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作启动文件或环境文件。<br>在大多数发行版中，存储个人用户永久性bash shell变量的地方是$HOME/.bashrc文件。 </p><p>启动bash shell有3种方式：</p><ul><li>登录时作为默认登录shell，登录shell会从5个不同的启动文件里读取命令：</li></ul><ol><li>/etc/profile，是bash shell默认的的主启动文件。只要你登录了Linux系统， bash就会执行/etc/profile启动文件中的命令。</li><li>$HOME目录下的启动文件，剩下的启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环<br>境变量。大多数Linux发行版只用这四个启动文件中的一到两个：<br>$HOME/.bash_profile<br>$HOME/.bashrc<br>$HOME/.bash_login<br>$HOME/.profile</li></ol><ul><li><p>作为非登录shell的交互式shell<br>如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入bash时启动），那么你启动的shell叫作交互式shell。<br>交互式shell启动时，只会检查用户HOME目录中的.bashrc文件。</p></li><li><p>作为运行脚本的非交互shell<br>系统执行shell脚本时用的就是这种shell。不同的地方在于它没有命令行提示符。<br>但是当你在系统上运行脚本时，也许希望能够运行一些特定启动的命令，为了处理这种情况， bash shell提供了BASH_ENV环境变量。</p></li></ul><h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><p>要给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mytest=(one two three four five)</span><br></pre></td></tr></table></figure></p><p>引用一个单独的数组元素，就必须用代表它在数组中位置的数值索引值。索引值要用方括号括起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;mytest[2]&#125;</span><br><span class="line">three</span><br></pre></td></tr></table></figure></p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>缺乏安全性的系统不是完整的系统。系统中必须有一套能够保护文件免遭非授权用户浏览或修改的机制。 Linux沿用了Unix文件权限的办法，即允许用户和组根据每个文件和目录的安全性设置来访问文件。</p><h3 id="Linux-的安全性"><a href="#Linux-的安全性" class="headerlink" title="Linux 的安全性"></a>Linux 的安全性</h3><p>Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。用户对系统中各种对象的访问权限取决于他们登录系统时用的账户。用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是登录名。</p><h4 id="etc-passwd-文件"><a href="#etc-passwd-文件" class="headerlink" title="/etc/passwd 文件"></a>/etc/passwd 文件</h4><p>这个文件将用户的登录名匹配到对应的UID值，它包含了一些与用户有关的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">...</span><br><span class="line">veininguo:x:1000:1001::/home/veininguo:/bin/bash</span><br><span class="line">dockerroot:x:996:993:Docker User:/var/lib/docker:/sbin/nologin</span><br></pre></td></tr></table></figure><p>/etc/passwd文件的字段包含了如下信息：</p><ul><li>登录用户名</li><li>用户密码</li><li>用户账户的UID（数字形式）</li><li>用户账户的组ID（GID）（数字形式）</li><li>用户账户的文本描述（称为备注字段）</li><li>用户HOME目录的位置</li><li>用户的默认shell</li></ul><h4 id="etc-shadow-文件"><a href="#etc-shadow-文件" class="headerlink" title="/etc/shadow 文件"></a>/etc/shadow 文件</h4><p>/etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow文件，这让它比起/etc/passwd安全许多。<br>etc/shadow文件为系统上的每个用户账户都保存了一条记录。记录就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">veininguo:*:17399:0:99999:7:::</span><br></pre></td></tr></table></figure></p><p>每条记录中都有9个字段：</p><ul><li>与/etc/passwd文件中的登录名字段对应的登录名</li><li>加密后的密码</li><li>自上次修改密码后过去的天数密码（自1970年1月1日开始计算）</li><li>多少天后才能更改密码</li><li>多少天后必须更改密码</li><li>密码过期前提前多少天提醒用户更改密码</li><li>密码过期后多少天禁用用户账户</li><li>用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）</li><li>预留字段给将来使用</li></ul><h4 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h4><p>用来向Linux系统添加新用户的主要工具是useradd。系统默认值被设置在/etc/default/useradd文件中。</p><p>在创建新用户时，如果你不在命令行中指定具体的值， useradd命令就会使用-D选项所显示的那些默认值。这个例子列出的默认值如下：</p><ul><li>新用户会被添加到GID为100的公共组；</li><li>新用户的HOME目录将会位于/home/loginname；</li><li>新用户账户密码在过期后不会被禁用；</li><li>新用户账户未被设置过期日期；</li><li>新用户账户将bash shell作为默认shell；</li><li>系统会将/etc/skel目录下的内容复制到用户的HOME目录下；</li><li>系统为该用户账户在mail目录下创建一个用于接收邮件的文件。</li></ul><p>默认情况下，useradd命令不会创建HOME目录，但是-m命令行选项会使其创建HOME目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -m test</span><br><span class="line">$ sudo ls -al /home/test/</span><br><span class="line">total 12</span><br><span class="line">drwx------. 2 test test  62 Nov 26 13:18 .</span><br><span class="line">drwxr-xr-x. 4 root root  35 Nov 26 13:18 ..</span><br><span class="line">-rw-r--r--. 1 test test  18 Sep  6 16:25 .bash_logout</span><br><span class="line">-rw-r--r--. 1 test test 193 Sep  6 16:25 .bash_profile</span><br><span class="line">-rw-r--r--. 1 test test 231 Sep  6 16:25 .bashrc</span><br></pre></td></tr></table></figure><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>userdel可以从系统中删除用户， 加上-r参数， userdel会删除用户的HOME目录以及邮件目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$sudo userdel -r test</span><br><span class="line">$</span><br><span class="line">$ sudo ls -al /home/test/</span><br><span class="line">ls: cannot access /home/test/: No such file or directory</span><br></pre></td></tr></table></figure><h4 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h4><p>Linux提供了一些不同的工具来修改已有用户账户的信息：</p><ol><li><p>usermod，修改用户账户的字段，还可以指定主要组以及附加组的所属关系。常用参数如下：<br>-c修改备注字段。<br>-e修改过期日期。<br>-g修改默认的登录组。<br>-l修改用户账户的登录名。<br>-L锁定账户，使用户无法登录。<br>-p修改账户的密码。<br>-U解除锁定，使用户能够登录。</p></li><li><p>passwd和chpasswd<br>改变用户密码的一个简便方法就是用passwd命令。<br>如果需要为系统中的大量用户修改密码， chpasswd命令可以事半功倍。 </p></li><li><p>chsh、 chfn和chage<br>chsh、 chfn和chage工具专门用来修改特定的账户信息。<br>chsh命令用来快速修改默认的用户登录shell。<br>chfn命令提供了在/etc/passwd文件的备注字段中存储信息的标准方法。<br>chage命令用来帮助管理用户账户的有效期。</p></li></ol><h3 id="Linux-组"><a href="#Linux-组" class="headerlink" title="Linux 组"></a>Linux 组</h3><p>组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。<br>每个组都有唯一的GID——跟UID类似，在系统上这是个唯一的数值。</p><h4 id="etc-group-文件"><a href="#etc-group-文件" class="headerlink" title="/etc/group 文件"></a>/etc/group 文件</h4><p>/etc/group文件包含系统上用到的每个组的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/group</span><br><span class="line">root:x:0:</span><br><span class="line">bin:x:1:</span><br><span class="line">daemon:x:2:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>/etc/group文件有4个字段：</p><ul><li>组名</li><li>组密码</li><li>ID</li><li>属于该组的用户列表</li></ul><h4 id="创建新组"><a href="#创建新组" class="headerlink" title="创建新组"></a>创建新组</h4><p>groupadd命令可在系统上创建新组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd shared</span><br><span class="line">$ tail /etc/group</span><br><span class="line">docker:x:992:</span><br><span class="line">shared:x:1002:</span><br></pre></td></tr></table></figure></p><p>usermod命令将用户被分配到该组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -G shared test</span><br><span class="line">$</span><br><span class="line">$ tail /etc/group</span><br><span class="line">shared:x:1002:test</span><br><span class="line">test:x:1003:</span><br></pre></td></tr></table></figure></p><h4 id="修改组"><a href="#修改组" class="headerlink" title="修改组"></a>修改组</h4><p>groupmod命令可以修改已有组的GID（加-g选项）或组名（加-n选项）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupmod -n sharering shared</span><br><span class="line">$ tail /etc/group</span><br><span class="line">google-sudoers:x:1000:veininguo</span><br><span class="line">test:x:1003:</span><br><span class="line">sharering:x:1002:test</span><br></pre></td></tr></table></figure></p><h3 id="文件权限-1"><a href="#文件权限-1" class="headerlink" title="文件权限"></a>文件权限</h3><h4 id="文件权限符"><a href="#文件权限符" class="headerlink" title="文件权限符"></a>文件权限符</h4><p>ls命令可以用来查看Linux系统上的文件、目录和设备的权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">total 1693436</span><br><span class="line">drwxrwxr-x. 2 veininguo veininguo         6 Nov 21 16:08 data_file</span><br></pre></td></tr></table></figure></p><p>输出结果的第一个字段就是描述文件和目录权限的编码。<br>第一个字符代表了对象的类型：</p><ul><li>-代表文件</li><li>d代表目录</li><li>l代表链接</li><li>c代表字符型设备</li><li>b代表块设备</li><li>n代表网络设备</li></ul><p>之后有3组三字符的编码。每一组定义了3种访问权限：</p><ul><li>r代表对象是可读的</li><li>w代表对象是可写的</li><li>x代表对象是可执行的</li></ul><p>若没有某种权限，在该权限位会出现单破折线。这3组权限分别对应对象的3个安全级别：</p><ul><li>对象的属主</li><li>对象的属组</li><li>系统其他用户</li></ul><h4 id="改变权限"><a href="#改变权限" class="headerlink" title="改变权限"></a>改变权限</h4><p>chmod命令用来改变文件和目录的安全性设置：<code>chmod options mode file</code></p><p>chmod命令采用了另一种方法。下面是在符号模式下指定权限的格式：<code>[ugoa…][[+-=][rwxXstugo…]</code><br>第一组字符定义了权限作用的对象：</p><ul><li>u代表用户</li><li>g代表组</li><li>o代表其他</li><li>a代表上述所有</li></ul><p>现有权限基础上增加权限（+），还是在现有权限基础上移除权限（-），或是将权限设置成后面的值（=）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ chmod o+r newfile</span><br><span class="line">$ ls -lF newfile</span><br><span class="line">-rwxrw-r-- 1 rich rich 0 Sep 20 19:16 newfile</span><br><span class="line">$</span><br><span class="line">$ chmod u-x newfile</span><br><span class="line">$ ls -lF newfile</span><br><span class="line">-rw-rw-r-- 1 rich rich 0 Sep 20 19:16 newfile</span><br></pre></td></tr></table></figure></p><h4 id="改变所属关系"><a href="#改变所属关系" class="headerlink" title="改变所属关系"></a>改变所属关系</h4><p>chown命令用来改变文件的属主。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ chown dan newfile</span><br><span class="line">$ ls -l newfile</span><br><span class="line">-rw-rw-r-- 1 dan rich 0 Sep 20 19:16 newfile</span><br><span class="line">$</span><br><span class="line">$ chown dan.shared newfile</span><br><span class="line">$ ls -l newfile</span><br><span class="line">-rw-rw-r-- 1 dan shared 0 Sep 20 19:16 newfile</span><br></pre></td></tr></table></figure></p><p>chgrp命令可以更改文件或目录的默认属组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chgrp shared newfile</span><br><span class="line">$ ls -l newfile</span><br><span class="line">-rw-rw-r-- 1 rich shared 0 Sep 20 19:16 newfile</span><br></pre></td></tr></table></figure></p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>使用Linux系统时，需要作出的决策之一就是为存储设备选用什么文件系统。大多数Linux发行版在安装时会非常贴心地提供默认的文件系统，了解一下可用的选择有时也会有所帮助。</p><h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><ol><li>ext文件系统，最早的文件系统，叫作扩展文件系统 （extended filesystem，简记为ext）。</li><li>ext2文件系统，ext文件系统有不少限制，比如文件大小不得超过2 GB。ext文件系统就升级到了第二代扩展文件系统，叫作ext2。</li></ol><h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p>日志文件系统为Linux系统增加了一层安全性。它不再使用之前先将数据直接写入存储设备再更新索引节点表的做法，而是先将文件的更改写入到临时文件（称作日志， journal）中。在数据成功写到存储设备和索引节点表之后，再删除对应的日志条目。</p><ol><li>ext3文件系统，它采用和ext2文件系统相同的索引节点表结构，但给每个存储设备增加了一个日志文件，以将准备写入存储设备的数据先记入日志。</li><li>ext4文件系统，扩展ext3文件系统功能的结果是ext4文件系统。</li><li>Reiser文件系统。</li><li>JFS文件系统，最老的日志文件系统之一， 是IBM在1990年为其Unix衍生版AIX开发的。</li><li>XFS文件系统，美国硅图公司（SGI）最初在1994年为其商业化的IRIX Unix系统开发的。</li></ol><h3 id="写时复制文件系统"><a href="#写时复制文件系统" class="headerlink" title="写时复制文件系统"></a>写时复制文件系统</h3><p>写时复制（copy-on-write， COW）的技术。COW利用快照兼顾了安全性和性能。如果要修改数据，会使用克隆或可写快照。修改过的数据<br>并不会直接覆盖当前数据，而是被放入文件系统中的另一个位置上。即便是数据修改已经完成，之前的旧数据也不会被重写。</p><ol><li>ZFS文件系统，没有使用GPL许可。OpenZFS项目有可能改变这种局面。</li><li>Btrf文件系统，被称为B树文件系统。它是由Oracle公司于2007年开始研发的。 </li></ol><h3 id="操作文件系统"><a href="#操作文件系统" class="headerlink" title="操作文件系统"></a>操作文件系统</h3><p>创建分区：fdisk工具用来帮助管理安装在系统上的任何存储设备上的分区。<br>创建文件系统：每个文件系统命令都有很多命令行选项，允许你定制如何在分区上创建文件系统。</p><h3 id="逻辑卷管理"><a href="#逻辑卷管理" class="headerlink" title="逻辑卷管理"></a>逻辑卷管理</h3><p>如果硬盘上没有地方了，你就必须弄一个更大的硬盘，然后手动将已有的文件系统移动到新的硬盘上。Linux逻辑卷管理器（logical volume manager， LVM）软件包可以用来做动态地添加存储空间。</p><h2 id="安装软件程序"><a href="#安装软件程序" class="headerlink" title="安装软件程序"></a>安装软件程序</h2><p>Linux开发人员通过把软件打包成更易于安装的预编译包，在Linux上能见到的各种包管理系统（package management system， PMS），以及用来进行软件安装、管理和删除的命令行工具。</p><h3 id="基于-Debian-的系统"><a href="#基于-Debian-的系统" class="headerlink" title="基于 Debian 的系统"></a>基于 Debian 的系统</h3><p>dpkg命令是基于Debian系PMS工具的核心。包含在这个PMS中的其他工具有：</p><ul><li>apt-get</li><li>apt-cache</li><li>aptitude</li></ul><h3 id="基于-Red-Hat-的系统"><a href="#基于-Red-Hat-的系统" class="headerlink" title="基于 Red Hat 的系统"></a>基于 Red Hat 的系统</h3><p>和基于Debian的发行版类似，基于Red Hat的系统也有几种不同的可用前端工具。常见的有以下3种。</p><ul><li>yum：在Red Hat和Fedora中使用。</li><li>urpm：在Mandriva中使用。</li><li>zypper：在openSUSE中使用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Linux&quot;&gt;&lt;a href=&quot;#什么是-Linux&quot; class=&quot;headerlink&quot; title=&quot;什么是 Linux&quot;&gt;&lt;/a&gt;什么是 Linux&lt;/h2&gt;&lt;p&gt;Linux可划分为以下四部分：&lt;/p&gt;
&lt;h3 id=&quot;Linux内核&quot;&gt;&lt;a href=&quot;#Linux内核&quot; class=&quot;headerlink&quot; title=&quot;Linux内核&quot;&gt;&lt;/a&gt;Linux内核&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;系统内存管理&lt;/li&gt;
&lt;li&gt;软件程序管理&lt;/li&gt;
&lt;li&gt;硬件设备管理&lt;/li&gt;
&lt;li&gt;文件系统管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;GNU工具&quot;&gt;&lt;a href=&quot;#GNU工具&quot; class=&quot;headerlink&quot; title=&quot;GNU工具&quot;&gt;&lt;/a&gt;GNU工具&lt;/h3&gt;&lt;p&gt;GNU组织（GNU是GNU’s Not Unix的缩写），模仿Unix操作系统开发一系列标准的计算机系统工具，但没有可以运行它们的内核系统。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://veinin.com/tags/Linux/"/>
    
      <category term="Linux 命令行" scheme="https://veinin.com/tags/Linux-%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>《单核工作法》读书笔记</title>
    <link href="https://veinin.com/2017/11/12/reading-notes-monotasking/"/>
    <id>https://veinin.com/2017/11/12/reading-notes-monotasking/</id>
    <published>2017-11-12T15:30:00.000Z</published>
    <updated>2018-03-30T14:59:23.142Z</updated>
    
    <content type="html"><![CDATA[<p>《单核工作法图解》是Staffan先生多年自我管理实践与咨询经验的结晶，阅读这本书让人收获颇多。该书轻松易读，引用了大量<br>前沿研究，也提出了一系列可实践的方法。</p><p>自我管理方法不是科学，是技术。脑科学的研究日新月异，但多数人不会去阅读科研文献，就需要有人把这些新发现翻译成可操<br>作的技术，才能运用到生活中，所以自我管理方法也在随着科学的发展而不停前进。</p><p>正确的方法是一个方面，另一个重要的方面是，你能不能把正确的方法转化为持续的行动，并且养成长久的习惯。讲方法的<br>书其实用不着贪多求全，关键是看你能不能用起来。</p><a id="more"></a><p>怎样的方法是真正可以帮助我们的方法？两点心得与你分享：<br>一、它应是一套有逻辑的系统方法，而不光是鸡汤；<br>二、这套方法应当易于使用。</p><h2 id="果壳中的单核工作法"><a href="#果壳中的单核工作法" class="headerlink" title="果壳中的单核工作法"></a>果壳中的单核工作法</h2><h3 id="什么是单核工作法？"><a href="#什么是单核工作法？" class="headerlink" title="什么是单核工作法？"></a>什么是单核工作法？</h3><p><strong>快捷清单</strong> 是单核工作法的核心。它最多存放5项当前最重要的任务。如果还要添加更多的任务，就必须删掉原有任务。</p><p><strong>单核时段</strong> 只用于专心处理快捷清单上的一项任务。以全景闹钟作为单核时段的结束。</p><p><strong>全景闹钟</strong> 应该设置在分针的下一个竖直位置，例如9:00、9:30、10:00，但距离现在不少于25分钟。在闹钟响铃时，<br>把注意力从单核时段切换到全景时段。</p><p><strong>全景时段</strong> 期间查看所有的待办任务，并且思考“拉金问题”（Lakein’squestion）：此时此刻，我的时间最好用来做什么？</p><p><strong>颠倒优先级</strong> 是指把紧急任务排到重要任务之前，应该避免。完成最重要的任务，我们的长期目标才能实现。</p><h3 id="单核工作法的五大原理"><a href="#单核工作法的五大原理" class="headerlink" title="单核工作法的五大原理"></a>单核工作法的五大原理</h3><ul><li>原理1：已经开始的任务会无条件地占据我们每天的所思所想，直到被完成或删除。</li><li>原理2：多任务切换不仅会拖慢速度，而且注定会耗尽大脑能量。</li><li>原理3：我们应该负起区分优先级的责任，选出现在头号重要的事来做。因为会不断有各种事情出现在我们脑海中，值得做的事数不清。</li><li>原理4：经常休息、好好睡觉、锻炼身体、吃得健康——我们必须在这些事情上进行投资，才能在日常工作中稳步前进。</li><li>原理5：我们的方法必须适应环境；要根据自己最新的个人经验，一点一点调整。没有放之四海皆准的方法。</li></ul><h3 id="颠倒优先级"><a href="#颠倒优先级" class="headerlink" title="颠倒优先级"></a>颠倒优先级</h3><p>“我把问题分成两类：重要的和紧急的。紧急的问题不重要，重要的问题从来不紧急。”<br>把紧急任务放在重要任务之前做，就是颠倒优先级。<br>要事第一。你花在紧急事情上的时间越多，紧急工作就会堆积得越高。那些本来重要但不紧急的任务也会变成紧急任务。</p><h3 id="“我没时间”是谎言"><a href="#“我没时间”是谎言" class="headerlink" title="“我没时间”是谎言"></a>“我没时间”是谎言</h3><p>我们每天都有新的24小时，说“不”的原因并非缺少时间，真实原因是：我们给其他任务排了更高的优先级。因此，别再说“我没时间”了。<br>制定你的优先级顺序，就是要选择把时间用在哪里。一旦定下来就别不好意思。保持透明度，允许其他人直面和质疑你的优先级排序，他们也会尊重和接受你的“不”。千万别说“我没时间”了。</p><h3 id="全景闹钟"><a href="#全景闹钟" class="headerlink" title="全景闹钟"></a>全景闹钟</h3><p>使用计时器。使用单核工作法时，为了在全景模式和单核模式中切换，我们要在单核时段开始之前设置定时响铃的全景闹钟。闹钟响铃提醒我们重新评估优先级。</p><p><img src="/images/monotasking_01.png" alt=""></p><h2 id="削减待办任务"><a href="#削减待办任务" class="headerlink" title="削减待办任务"></a>削减待办任务</h2><p><strong>本周目的</strong> 把你的专注点放在“为什么”上。在这一周，你最想取得什么进展、得到什么收获、产出什么成果？把首要目的写入一张索引卡片，贴在工作间隔板上。每当迷茫的时候，本周目的可以提醒你。</p><p><strong>快捷清单</strong> 包含当前最重要的5项任务。每天早晨把它们写在一张纸上。如果还要添加更多的任务，必须去掉原有的——要么完成一项、要么直接删掉一项。</p><p><strong>集草器清单</strong> 收集一些未排序的任务和想法，都是你没有拒绝、但也不会马上做的事情。集草器清单则完全没有限制，也不排列优先级。你可以时不时添加内容进去。有什么点子就集中放在这里，免得一转身忘了。表格中的每项任务应该包括“目标、利益关系人、进入清单的日期”这三项属性。</p><p><strong>除草</strong> 是删掉集草器清单里的内容，每个星期都要做。除草是一项必要工作，以便保持清单可读、及时、可靠。你随时都可以根据需要在集草器清单里增加内容，但应该每周做一次批量清理。</p><p><img src="/images/monotasking_02.png" alt=""></p><h2 id="现在专注一件事"><a href="#现在专注一件事" class="headerlink" title="现在专注一件事"></a>现在专注一件事</h2><p><strong>多任务的误区</strong> 误导雇主们到处寻找三头六臂的人才，看谁有同时玩转很多事的本领。我们自以为能多线程处理任务，其实只是在多个任务间切换。任务切换会给手头的工作带来更多错误，拖慢速度。</p><p><strong>单核与全景</strong> 两种时段帮你建立节奏感。单核工作意味着聚焦放大一项且仅此一项任务；全景总览意味着放眼全局，选择当前最重要的一件事。我们要在这两种模式间互相切换。</p><p><strong>戒绝通知</strong> 的方法要求在单核工作期间关掉你能听到和看到的通知提醒。看一眼电子邮件之后要重新达到之前的工作状态，所花费的时间超过一分钟。自动推送的通知消息会引发服务生效应的负面作用，妨碍我们对有价值任务的专注。</p><p><strong>志愿者小时</strong> 是应对中断的一个实用策略。如果同事在上午找你讨论问题，可以引导他的需求，安排一次下午的会议。这样你就有继续工作的余地，也能为同事的问题提前做准备。</p><p><strong>时间压力</strong> 是自己给自己的。别人可能会说他的事情比较急，但时间压力是我们的内部事务。使用单核工作法，不用担心自己没有尽力，因为我们已将重要的任务排在紧急的任务之前。</p><p><img src="/images/monotasking_03.png" alt=""></p><h2 id="永不拖延"><a href="#永不拖延" class="headerlink" title="永不拖延"></a>永不拖延</h2><p><strong>时间不一致</strong> 是指人们在评估自己未来的忙碌程度时，会认为近期超忙，远期不那么忙。这是人类思维的误区。跳出误区的方法是，现在就做最重要的事，对紧急程度不作考虑。</p><p><strong>可支配时间</strong> 的浪费意味着，你本来有一段受保护的时间来处理最重要的任务，但却花在了其他事情上。我们必须确保足够珍视可支配时间的价值。浪费掉的时间不会再回来。</p><p><strong>服务生效应</strong> 让我们知道，未完成的任务更容易被记住。正确利用这个效应有助于停止拖延；错误使用则会让拖延更严重。可以动用潜意识思维来促使我们完成最重要的任务，而不是其他任务。</p><p><strong>自动坚持任务</strong> 是服务生效应的延伸。人类有一种强烈的意愿，想要完成被中断的任务。在下午下班前开始一项任务，这会鼓励你自己明天早晨回来继续做这件事。</p><p><strong>内在动力</strong> 比奖励和惩罚的影响更大。自主是为自己的选择负起责任。专精是一种不断渴求进步的心态。目的可以激发你成为比自己更伟大事物的一部分。</p><p><img src="/images/monotasking_04.png" alt=""></p><h2 id="循序渐进"><a href="#循序渐进" class="headerlink" title="循序渐进"></a>循序渐进</h2><p><strong>任务分解</strong> 可能是战胜拖延最有效的方式。开始做一项小任务，要比开始做一项大任务更容易。但要把大任务的整体目的牢记在心，而且不要提前把所有子任务规划得太详细。</p><p><strong>拉金问题</strong> ：“此时此刻我的时间最好用来做什么？”这是我们必须经常问自己的问题。要让工作取得成效，就必须经常检查成果并调整规划。</p><p><strong>时间盒子</strong> 是要先确定：什么时候开始，什么时候结束，专注在什么任务上。这与工作成果的多少好坏无关，纯粹与注意力有关。当然，良好的专注度会带来更高的产出。</p><p><strong>幼鸟先飞</strong> 让我们把想法尽早分享给别人，从而获得反馈。这些反馈有助于确定下一步行动的最佳方向：看，这些是已经实现的，接下来怎么做最好？</p><p><strong>虚假紧急</strong> 是一个坑人的骗局，让你把力气花在一些次要的任务上。它让你进入来者不拒的响应状态。但是用客观标准衡量，这些任务其实不重要，反而耽误事。它们让你忙来忙去，阻碍了真正的工作。</p><p><img src="/images/monotasking_05.png" alt=""></p><h2 id="简化协作"><a href="#简化协作" class="headerlink" title="简化协作"></a>简化协作</h2><p><strong>富足心态</strong> 是把你的时间、知识和人脉分享给同事。这不仅仅是助人为乐，他们也会回过头来分享给你。[1]对自己面前的选项有一个全面认识可以帮你打开局面，得到双赢的解决方案。</p><p><strong>相处的责任</strong> 我们都应该承担起来。要明白，职场中的每个人都是和你我一样的独立个体。通过认识到他们的强项和弱项所在，我们可以更好地在协作中获益。</p><p><strong>高效会议</strong> 要求你不仅仅是例行公事地逢会必到。这场会议有没有限定一项会议目的？你的贡献是否无关紧要？你自己组织会议时也要注意，如果没有清晰地描述出唯一的会议目的，就不要发出邀请。</p><p><strong>议会场合</strong> 着眼于未来、以更有创造性的方式来讨论事情。永远不要为过去的事件责怪任何人，不要为核心价值观争论不休。想想从这里出发该如何往前走，是一种更有建设性的思路。</p><p><strong>透明度</strong> 要求我们做到言出必践。如果这样还是落入了认知失调的陷阱，就必须后退一步，以开放的心态环顾四周，找出一条让各方共赢的新路径。</p><p><img src="/images/monotasking_06.png" alt=""></p><h2 id="给创意充电"><a href="#给创意充电" class="headerlink" title="给创意充电"></a>给创意充电</h2><p><strong>经常休息</strong> 不仅可以让大脑歇口气，还能够激活潜意识思维的创造力。当你休息回来时，经常会有很棒的新想法。</p><p><strong>充氧的大脑</strong> 是我们散步或运动时得到的效果。研究发现，成人如果每周进行150分钟的身体锻炼，就更不容易在白天昏昏欲睡，也更不容易出现注意力涣散的情况。</p><p><strong>健康饮食</strong> 会影响到我们思维、创意和正确记忆的能力。那些快速释放葡萄糖的食物会让我们的能量忽高忽低。水果、蔬菜、全麦食品和适量摄入的蛋白质能产生更稳定的输出，给大脑持续提供能量。</p><p><strong>充足睡眠</strong> 的原则已经被证实可以提高生产力、减少犯错。睡眠不足还意味着失去了快速眼动睡眠时间，导致难以完成记忆编码，无法对新记忆进行删除和整理。</p><p><strong>思考的时候拿支铅笔</strong> 能够补充我们极度有限的工作记忆。大脑的结构天生不适合同时思考两件事情，而写下来的笔记更有利于前瞻记忆对问题进行处理。</p><p><strong>思维导图</strong> 对长期记忆很有帮助。一项研究还显示它能提高批判性思维能力。我们的大脑喜欢在概念之间建立连接，可惜顺序结构的笔记和线性思维方式都做不到这一点。</p><p><img src="/images/monotasking_07.png" alt=""></p><p>本文大部分内容摘自：《单核工作法》，<a href="https://book.douban.com/subject/27177909/" target="_blank" rel="noopener">豆瓣读书</a>、<a href="http://www.ituring.com.cn/book/1925" target="_blank" rel="noopener">图灵社区</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《单核工作法图解》是Staffan先生多年自我管理实践与咨询经验的结晶，阅读这本书让人收获颇多。该书轻松易读，引用了大量&lt;br&gt;前沿研究，也提出了一系列可实践的方法。&lt;/p&gt;
&lt;p&gt;自我管理方法不是科学，是技术。脑科学的研究日新月异，但多数人不会去阅读科研文献，就需要有人把这些新发现翻译成可操&lt;br&gt;作的技术，才能运用到生活中，所以自我管理方法也在随着科学的发展而不停前进。&lt;/p&gt;
&lt;p&gt;正确的方法是一个方面，另一个重要的方面是，你能不能把正确的方法转化为持续的行动，并且养成长久的习惯。讲方法的&lt;br&gt;书其实用不着贪多求全，关键是看你能不能用起来。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时间管理" scheme="https://veinin.com/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
      <category term="单核工作法" scheme="https://veinin.com/tags/%E5%8D%95%E6%A0%B8%E5%B7%A5%E4%BD%9C%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Centos 从官方 Yum Repositories 安装 MySQL</title>
    <link href="https://veinin.com/2017/11/08/centos-install-mysql/"/>
    <id>https://veinin.com/2017/11/08/centos-install-mysql/</id>
    <published>2017-11-08T13:55:49.000Z</published>
    <updated>2017-11-08T14:12:47.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>2013年10月，MySQL开发团队正式启动了对 Yum 版本库的支持。这意味着您现在可以确保您拥有从源代码直接安装的最新版本的 MySQL！<br>本文将在全新的CentOS 6中安装 MySQL 5.7。5.7是当前默认最新版本，当然你也可以选择直接安装其他版本，可参考本文关于 <a href="http://localhost:8080/2017/11/08/centos-install-mysql/#选择指定版本安装" target="_blank" rel="noopener">选择指定版本安装</a>章节。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Yum 版本库文件需要从 MYSQL 开发者网站下载，安装完成后，使用 <code>yum update</code> 来确保你运行的是最新的MySQL版本，包括其安全更新，Yum 会帮你解决任何依赖关系，这使你安装过程变成很简单。</p><p>刚开始，你需要访问 <a href="https://dev.mysql.com/downloads/repo/" target="_blank" rel="noopener">MySQL Repositories</a> ，选择 <a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">MySQL Yum Repository</a>，根据你 CentOS 的版本，选择相应的下载链接，然后点击 Download。<br><img src="/images/02_centos_install_mysql_download.jpg" alt=""></p><p>右键 “No thanks, just start my download.” ， 点击 “复制链接地址”。<br><img src="/images/03_centos_install_mysql_link.jpg" alt=""></p><p>登录到您的服务器，根据复制的连接地址然后下载此文件。以下只是一个示例网址 - 你可能需要检查这个地址是否正确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el6-11.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>从本地文件中安装下载好的 rpm 文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum localinstall mysql57-community-release-el6-11.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>您现在已经在服务器上从官方存储库安装了，但尚未安装任何软件。存储库包括MySQL服务器，MySQL Workbench管理工具和ODBC驱动程序。让我们安装MySQL服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mysql-community-server</span><br></pre></td></tr></table></figure></p><p>启动 MySQL 服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysqld start</span><br></pre></td></tr></table></figure></p><p>配置MySQL在重新启动时自动启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chkconfig mysqld on</span><br><span class="line">chkconfig --list mysqld</span><br></pre></td></tr></table></figure></p><p>到此，你的MySQL服务已经安装完成。</p><hr><h2 id="重置-Root-密码"><a href="#重置-Root-密码" class="headerlink" title="重置 Root 密码"></a>重置 Root 密码</h2><p>如果你安装的是 MySQL 5.7 版本，root 密码会自动生成，并在启动日志 /var/log/mysqld.log 里面输出。</p><p>获取初始密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;password&quot; /var/log/mysqld.log</span><br><span class="line">2017-11-08T05:09:31.492454Z 1 [Note] A temporary password is generated for root@localhost: 1!Ta0EEis-yR</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">登录 root 账号，如果默认密码为空，请去除 -p 参数：</span><br><span class="line">mysql -uroot -p &apos;1!Ta0EEis-yR&apos;</span><br></pre></td></tr></table></figure><p>用你的新密码替换字符串 “ your_new_password “，如果你的版本是 5.6 或之前版本，请使用一下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.user SET Password=PASSWORD(&apos;your_new_password&apos;) WHERE User=&apos;root&apos;;</span><br><span class="line">flush privileges;</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p><p>如果你的版本是 5.7 版本，请使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER USER() IDENTIFIED BY &apos; your_new_password &apos;;</span><br></pre></td></tr></table></figure></p><p>如果提示：ERROR 1819 (HY000): Your password does not satisfy the current policy requirements，那是因为默认开启了简单密码检查政策，你可以通过以下命令关闭其功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password_policy=0;</span><br></pre></td></tr></table></figure></p><hr><h2 id="选择指定版本安装"><a href="#选择指定版本安装" class="headerlink" title="选择指定版本安装"></a>选择指定版本安装</h2><p>使用 MySQL Yum 存储库时，默认情况下选择最新的 GA 版本（当前为 MySQL 5.7）进行安装。</p><p>在 MySQL Yum 存储库中，MySQL社区服务器的不同版本托管在不同的子库中。最新的 GA 系列（目前是 MySQL 5.7）的子库是默认启用的，所有其他系列的子库（例如MySQL 5.6版本）默认是禁用的。可以使用以下命令查看 MySQL Yum 存储库中的所有子存储库，并查看其中哪些被启用或禁用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist all | grep mysql</span><br></pre></td></tr></table></figure></p><p>如果要安装最新的版本，不需要配置。如果要选择特定版本，请在运行安装命令之前，禁用最新 GA 版本的子库，并启用特定版本的子库。如果你的平台支持 yum-config-manager，你可以通过以下这些命令来实现，这些命令将禁用 5.7 版本的 subrepository，并启用5.6 版本的 subrepository：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --disable mysql57-community</span><br><span class="line">sudo yum-config-manager --enable mysql56-community</span><br></pre></td></tr></table></figure></p><p>除了使用 yum-config-manager 命令之外，还可以通过手动编辑 /etc/yum.repos.d/mysql-community.repo 文件来选择发行版，项目是一个典型的文件系列子库的条目信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysql57-community]</span><br><span class="line">name=MySQL 5.7 Community Server</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure></p><p>找到要配置的子库的条目，然后编辑该 enabled 选项。指定 enabled=0 禁用子库，或 enabled=1 启用子库。例如，要安装MySQL 5.6，请确保您拥有 enabled=0 MySQL 5.7版本的上述子目录条目，并且具有 enabled=1 MySQL 5.6版本的条目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Enable to use MySQL 5.6</span><br><span class="line">[mysql56-community]</span><br><span class="line">name=MySQL 5.6 Community Server</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-5.6-community/el/6/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure></p><p>最后再运行安装命令（mysql-community-server），那么你安装到的是你想要的指定版本的 MySQL。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;2013年10月，MySQL开发团队正式启动了对 Yum 版本库的支持。这意味着您现在可以确保您拥有从源代码直接安装的最新版本的 MySQL！&lt;br&gt;本文将在全新的CentOS 6中安装 MySQL 5.7。5.7是当前默认最新版本，当然你也可以选择直接安装其他版本，可参考本文关于 &lt;a href=&quot;http://localhost:8080/2017/11/08/centos-install-mysql/#选择指定版本安装&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;选择指定版本安装&lt;/a&gt;章节。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CentOS" scheme="https://veinin.com/tags/CentOS/"/>
    
      <category term="MySQL" scheme="https://veinin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Lua 表序列化与反序列化</title>
    <link href="https://veinin.com/2017/11/01/lua-serialize-table/"/>
    <id>https://veinin.com/2017/11/01/lua-serialize-table/</id>
    <published>2017-11-01T14:11:17.000Z</published>
    <updated>2017-11-01T14:49:03.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天看了下同事写的关于 Lua 序列化的代码，觉得代码存在几个问题，其主要欠缺以下几点：</p><h3 id="1-支持循环引用的-table，反序列后，能正确恢复循环引用状态，如："><a href="#1-支持循环引用的-table，反序列后，能正确恢复循环引用状态，如：" class="headerlink" title="1.支持循环引用的 table，反序列后，能正确恢复循环引用状态，如："></a>1.支持循环引用的 table，反序列后，能正确恢复循环引用状态，如：</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a.b = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, a&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="2-字符串内支持内嵌双引号、支持转义字，如一下字符串："><a href="#2-字符串内支持内嵌双引号、支持转义字，如一下字符串：" class="headerlink" title="2.字符串内支持内嵌双引号、支持转义字，如一下字符串："></a>2.字符串内支持内嵌双引号、支持转义字，如一下字符串：</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> s = <span class="string">"ss\"aa\"bb\ncc"</span></span><br></pre></td></tr></table></figure><p>序列化后我希望是这样子：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'ss"aa"bb\ncc'</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="3-Table-数组部分序列化后隐藏每个值得索引值，如："><a href="#3-Table-数组部分序列化后隐藏每个值得索引值，如：" class="headerlink" title="3.Table 数组部分序列化后隐藏每个值得索引值，如："></a>3.Table 数组部分序列化后隐藏每个值得索引值，如：</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure><p>如果保留数组的索引值，会是这样子：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;[<span class="number">1</span>]=<span class="number">4</span>,[<span class="number">2</span>]=<span class="number">7</span>,[<span class="number">3</span>]=<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure></p><p>为了更加节省空间，我希望的是这样子：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>对于以上几点要求，Google 搜了下，并没有找到满足上面需求的合适版本，于是在前人的基础上做了一些改进。<br>实现部分，序列化函数函数为 table.tostring。反序列化函数相对来说比较简单，可以直接通过函数loadstring进行加载，下面实现为函数 table.loadstring</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table.tostring</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">local</span> mark   = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> assign = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(tbl, parent)</span></span></span><br><span class="line">mark[tbl] = parent</span><br><span class="line"><span class="keyword">local</span> tmp = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(tbl) <span class="keyword">do</span></span><br><span class="line"><span class="keyword">local</span> typek = <span class="built_in">type</span>(k)</span><br><span class="line"><span class="keyword">local</span> typev = <span class="built_in">type</span>(v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = typek == <span class="string">"number"</span> <span class="keyword">and</span> <span class="string">"["</span> .. k ..<span class="string">"]"</span> <span class="keyword">or</span> k</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> typev == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> dotkey = parent .. (typek == <span class="string">"number"</span> <span class="keyword">and</span> key <span class="keyword">or</span> <span class="string">"."</span> .. key)</span><br><span class="line"><span class="keyword">if</span> mark[v] <span class="keyword">then</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(assign, dotkey .. <span class="string">"="</span> .. mark[v])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> typek == <span class="string">"number"</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tmp, serialize(v,dotkey))</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tmp, key .. <span class="string">"="</span> .. serialize(v, dotkey))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> typev == <span class="string">"string"</span> <span class="keyword">then</span></span><br><span class="line">v = <span class="built_in">string</span>.<span class="built_in">gsub</span>(v, <span class="string">"\n"</span>, <span class="string">"\\n"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">match</span>( <span class="built_in">string</span>.<span class="built_in">gsub</span>(v,<span class="string">"[^'\"]"</span>,<span class="string">""</span>), <span class="string">'^"+$'</span> ) <span class="keyword">then</span></span><br><span class="line">v = <span class="string">"'"</span> .. v .. <span class="string">"'"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">v = <span class="string">'"'</span> .. v .. <span class="string">'"'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">v = <span class="built_in">tostring</span>(v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> typek == <span class="string">"number"</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tmp, v)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tmp, key .. <span class="string">"="</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"&#123;"</span> .. <span class="built_in">table</span>.<span class="built_in">concat</span>(tmp, <span class="string">","</span>) .. <span class="string">"&#125;"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> serialize(t, <span class="string">"ret"</span>) .. <span class="built_in">table</span>.<span class="built_in">concat</span>(assign,<span class="string">" "</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table.loadstring</span><span class="params">(str)</span></span></span><br><span class="line"><span class="keyword">local</span> chunk = loadstring(<span class="string">"do local ret = "</span> .. str .. <span class="string">" return ret end"</span>)</span><br><span class="line"><span class="keyword">if</span> chunk <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> chunk()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>测试代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;a = <span class="number">1</span>, b = <span class="number">2</span>&#125;</span><br><span class="line">t.rt = &#123;c = <span class="number">3</span>, d = <span class="number">4</span>, t&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> s = <span class="built_in">table</span>.<span class="built_in">tostring</span>(t)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">-- 输出 &#123;b=2,a=1,rt=&#123;c=3,d=4&#125;&#125;ret.rt[1]=ret</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tl = <span class="built_in">table</span>.loadstring(s)</span><br><span class="line"><span class="built_in">assert</span>(tl.a == t.a)</span><br><span class="line"></span><br><span class="line"><span class="comment">----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t = &#123;[<span class="string">'foo'</span>]=<span class="string">'bar'</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="string">"ss\"aa\"bb\ncc"</span>, <span class="string">"hello"</span>, &#123;<span class="string">'a'</span>,<span class="string">'b'</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> s = <span class="built_in">table</span>.<span class="built_in">tostring</span>(t)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">-- 输出 &#123;11,22,33,'ss"aa"bb\ncc',"hello",&#123;"a","b"&#125;,foo="bar"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tl = <span class="built_in">table</span>.loadstring(s)</span><br><span class="line"><span class="built_in">assert</span>(tl.foo == t.foo)</span><br><span class="line"><span class="built_in">assert</span>(tl[<span class="number">4</span>] == <span class="string">'ss"aa"bb\ncc'</span>)</span><br></pre></td></tr></table></figure></p><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.codingnow.com/cloud/LuaSerializeTable" target="_blank" rel="noopener">云风的个人空间</a></li><li><a href="http://lua-users.org/wiki/TableUtils" target="_blank" rel="noopener">lua-users wiki</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天看了下同事写的关于 Lua 序列化的代码，觉得代码存在几个问题，其主要欠缺以下几点：&lt;/p&gt;
&lt;h3 id=&quot;1-支持循环引用的-table，反序列后，能正确恢复循环引用状态，如：&quot;&gt;&lt;a href=&quot;#1-支持循环引用的-table，反序列后，能正确恢复循环引用状态，如：&quot; class=&quot;headerlink&quot; title=&quot;1.支持循环引用的 table，反序列后，能正确恢复循环引用状态，如：&quot;&gt;&lt;/a&gt;1.支持循环引用的 table，反序列后，能正确恢复循环引用状态，如：&lt;/h3&gt;&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt; a = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.b = &amp;#123;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, a&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Lua" scheme="https://veinin.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="https://veinin.com/tags/Lua/"/>
    
      <category term="Lua Serialize Table" scheme="https://veinin.com/tags/Lua-Serialize-Table/"/>
    
  </entry>
  
  <entry>
    <title>《番茄工作法图解》读书笔记</title>
    <link href="https://veinin.com/2017/09/24/pomodoro-technique/"/>
    <id>https://veinin.com/2017/09/24/pomodoro-technique/</id>
    <published>2017-09-24T14:06:59.000Z</published>
    <updated>2017-12-04T16:00:40.860Z</updated>
    
    <content type="html"><![CDATA[<p>这本书以我采用番茄工作法的切身经历，向你传授这一工作法的实施全过程，你能看到它如何提高了我的工作效率。另外书中还加入了一些有关人脑思维的研究成果，用以揭示番茄工作法的原理；还包括采用该工作法的若干影响；以及如何根据需要，对该工作法进行调节和扩充。</p><p>番茄工作法能帮你与时间化敌为友，不会再因为还有一小时、一天、一周、一个月的时限而充满焦虑，你要做的就是定好25分钟番茄钟，然后全然专注于手头的任务。如果番茄钟响铃，25分钟结束，而任务还没完成，这并不代表失败。相反，这铃声在为你已连续地工作了一整段时间而喝彩。</p><a id="more"></a><p>什么是番茄工作法？简单说，就是列出你当天要做的事，设置25分钟闹钟，然后从第一件事开始。此外还要有每日回顾、做每日承诺、控制中断、预估要花的工夫等。这本书中我会以自己为例，向你展示如何使用番茄工作法，包括如何记录活动，以及如何挑出最重要的任务。</p><p>在番茄工作法中，1个番茄钟等于25分钟的努力。这是一个不可分割的抽象单位，是一段“一视同仁”的时间。你的基本承诺是，花上25分钟，尽可能地努力做好。在这段时间内，关键不在于当前活动是否能在当前番茄钟内完成，关键是在这一刻你尽了全力。</p><h2 id="番茄工作者的一天中的5个阶段"><a href="#番茄工作者的一天中的5个阶段" class="headerlink" title="番茄工作者的一天中的5个阶段"></a>番茄工作者的一天中的5个阶段</h2><ul><li><strong>计划</strong>：在一天的开始，从积压的工作（称为“活动清单”）中提取最重要的活动，填写到“今日待办”表格中。这就是你当天的自我承诺。</li><li><strong>跟踪</strong>：确定当天活动后，扭启25分钟的番茄钟，从当天活动的第一项开始进行。在每个25分钟的时间段（称为一个番茄钟）内，你要收集一些过程指标，比如计算遇到的中断次数。</li><li><strong>记录</strong>：在一天结束时，将当天收集的数据归档，写入“记录”表格。如果你跟踪了中断次数，就把中断次数写下来。</li><li><strong>处理</strong>：从所记录的原始数据中提取有用信息。例如，可以计算在每个25分钟的时间段，平均遇到几次中断。</li><li><strong>可视化</strong>：最终你要将信息以某种方式组织起来，从中找出改进流程的思路。如果你想获得最适合现实情况的工作习惯，在自我调整过程中，基本上每天都要做这样的回顾。</li></ul><h2 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h2><ul><li><strong>番茄钟一枚</strong></li><li><strong>铅笔一支</strong>（最好带橡皮）</li><li><strong>纸质表格三张</strong>（白纸即可，横格纸更好）　<ul><li>“今日待办”表格，列出打算在今天进行的活动。每天早上这张表要换新的。</li><li>“活动清单”表格，列出最近要进行的活动，随想随填，不用排序。同一张“活动清单”表格可以用很多天，增加新的活动，划掉已完成的。</li><li>记录表格，记录所采样的流程指标，以便对流程进行改进。同一张“记录”表格可以用很多天，以便比较每天的跟踪记录。</li></ul></li></ul><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p>将要完成的活动全部填入“活动清单”表格，每天早晨，从其中选出数项要在今天进行的活动，抄入“今日待办”表格。</p><p>开始工作</p><ul><li>在“今日待办”中选择一项最重要的活动</li><li>启动番茄钟，时间设定为25分钟</li><li>开始工作，直到番茄钟响铃•在“今日待办”表格该活动右侧标一个×</li><li>休息片刻（3～5分钟）</li><li>开始下一个番茄钟，继续工作，直到完成这项活动，在“今日待办”表格上划掉它</li><li>每四个番茄钟后，多休息一会儿（15～30分钟）</li></ul><h2 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h2><p>你将学习如何以合理、有效的方式处理番茄钟时间内的中断和干扰。</p><p>番茄钟期间的中断有以下两种形式</p><h3 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h3><p>具体地说，是直觉向心智发出信号，告诉自己去做当前专注活动以外的事情。<br>要对付内部中断，最佳策略是可视化、接受，然后纳入计划或删除。</p><h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><p>有人找你询问或请你帮忙，并且等你答复。接下来我们看，对于这两类中断，番茄工作法都有相应的处理策略。<br>外部中断具有互动性。有人正在等你答复。他们试图阻止你画×，而你需要一个策略来减少中断。所以必须“扭转”番茄钟和中断之间的依赖关系。<br>如电子邮件和电话很容易，你可以将其关闭。发电子邮件的人不会期待在25分钟内就收到回信。<br>假如有人找你面谈，在不影响结果的前提下，可以请求对方尽量推迟。对于你的同事来说，你今天答复还是周五答复，结果可能是一样的。在对方接受的范围内，建议他尽量往后安排。用稍后的番茄钟重新计划中断事件，而不要在当时直接处理，这样做好处多多。</p><h3 id="处理外部中断的策略"><a href="#处理外部中断的策略" class="headerlink" title="处理外部中断的策略"></a>处理外部中断的策略</h3><ul><li><strong>告知</strong>：“我手头有事，正忙。”</li><li><strong>协商</strong>：“周五再帮你做，行吗？”</li><li><strong>计划</strong>：写下活动名称，稍后为它计划未来的番茄钟。</li><li><strong>答复</strong>：按照承诺回电或答复，不然的话，下次别人就没法信任你了。</li></ul><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>番茄钟具有原子性。不可分割。它是这套流程方法中最小的货币单位。如果任务被放下了，无论是暂时的还是长期的，当前番茄钟都必须作废。它就不能算数了，也不应该画×。你得扭启一个新的25分钟番茄钟代替它。如果需要，可以先休息一下再开始。</p><h2 id="预估任务"><a href="#预估任务" class="headerlink" title="预估任务"></a>预估任务</h2><p>预估和测量在番茄工作法中必不可少。如果没有它们，每天要做计划是很困难的。番茄工作法要求花时间做回顾，这样才能不断改进，继往开来。设法将你“认为自己能做的”与“实际做到的”相对应。跟踪和记录是番茄工作法中的测量方法。<br>你无法预言会出现什么新情况、新问题。但可以通过训练和监控，积累做预估的经验和技巧。</p><p>计算预估的“货币”单位是番茄钟。因为番茄钟的原子性，不能使用小数，如1/2或2.2个番茄钟是不行的。</p><p>假如一项活动预估超过7个番茄钟，说明它太复杂了。需要拆分这项活动。拆开的每项小活动在“活动清单”表格中单独占一行，各自有预估值。活动越大，预估越不准。</p><p>如果一项活动预估不够1个番茄钟，则可以在它旁边标个0。并不是说它要花0个番茄钟来完成，只是表示时间花费小于1个番茄钟。这样的活动在“活动清单”表格中仍然各自占一行。</p><p>本来预估这项活动需要若干个番茄钟，但这些番茄钟用完了，这时要做二次预估。猜测要完成这项活动还需要多少个番茄钟。如果二次预估也不合要求，你可以做三次预估，也是最终预估。</p><p>如果三次预估的数目还不够完成活动，那真是有点失败了。你得分析一下，为什么一次又一次反复地低估这件事？也许应当将活动拆开，降低复杂度。按照常理，活动越复杂，预估越不准。</p><h2 id="应变"><a href="#应变" class="headerlink" title="应变"></a>应变</h2><p>番茄工作法是守则。它提供简单而具体的最佳实践，容易上手。这可能意味着它不适合所有的人或环境。但番茄工作法也内置了应变能力。</p><p>当你了解应用番茄工作法的常规方法之后，可能会有调整它的想法。很好。这就是收集跟踪数据、做每日回顾的目的。但是，请尝试坚持使用常规方法，至少两周内不要做任何改动。你需要亲身经历，以便确切知道哪里适合你、哪里不适合。</p><p>刚开始学习使用番茄工作法，简单朴实就是最好的。一段时间后，你可以根据个人情况进行一些优化。比如说，我在一天里要花大量时间来写电子邮件。为了避免每次收到新邮件都会中断我手头的活动，我可以每天分配两个番茄钟，也就是50分钟来写回信。</p><p>番茄工作法的默认时间表中，每隔三个短休息就要有一个长休息，但不是强制性的，而要根据你的角色和工作内容而定，包括工作场所和个人状态。</p><h2 id="番茄工作法流程示意图"><a href="#番茄工作法流程示意图" class="headerlink" title="番茄工作法流程示意图"></a>番茄工作法流程示意图</h2><p><img src="/images/01_pomodoro-technique_Illustrated.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《番茄工作法图解》，<a href="https://book.douban.com/subject/5916234/" target="_blank" rel="noopener">豆瓣读书</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书以我采用番茄工作法的切身经历，向你传授这一工作法的实施全过程，你能看到它如何提高了我的工作效率。另外书中还加入了一些有关人脑思维的研究成果，用以揭示番茄工作法的原理；还包括采用该工作法的若干影响；以及如何根据需要，对该工作法进行调节和扩充。&lt;/p&gt;
&lt;p&gt;番茄工作法能帮你与时间化敌为友，不会再因为还有一小时、一天、一周、一个月的时限而充满焦虑，你要做的就是定好25分钟番茄钟，然后全然专注于手头的任务。如果番茄钟响铃，25分钟结束，而任务还没完成，这并不代表失败。相反，这铃声在为你已连续地工作了一整段时间而喝彩。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时间管理" scheme="https://veinin.com/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
      <category term="番茄工作法" scheme="https://veinin.com/tags/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>《大教堂与集市》读书笔记</title>
    <link href="https://veinin.com/2017/09/11/reading-notes-the-cathedral-the-bazaar/"/>
    <id>https://veinin.com/2017/09/11/reading-notes-the-cathedral-the-bazaar/</id>
    <published>2017-09-11T12:57:54.000Z</published>
    <updated>2017-11-24T16:38:12.197Z</updated>
    
    <content type="html"><![CDATA[<p>这是一本关于黑客行为与文化的书籍。本书并没有给出基础理论上的创新，只是描述了这样的事实：开源软件系统性地利用开放式开发和分布式同行评审（peerreview），不仅降低了成本，还提高了软件质量。</p><p>作者EricS.Raymond作为黑客文化的第一理论家，他通过观察和参与，对黑客这个群体的习俗、信念及关系有着深入而广泛的研究。他极力为“黑客”（hacker）一词正名，强调“黑客”并不是媒体报道中的计算机违法分子，而是那种着迷于计算机技术并通过编程提供极具价值软件的人。</p><p>黑客（hacker）一词，原指喜欢通过智力和创造性方法挑战难题的人，尤指那些热衷于计算机技术的编程高手。由于媒体报道中出现的黑客事件往往和计算机犯罪相连，导致人们常常误认为黑客是利用网络入侵他人系统的破坏者。事实上，这些破坏者应该被称为cracker，即“骇客”。</p><a id="more"></a><p>Eric在本书中向大家展示了两种最为经典且截然不同的模式：大教堂模式 和 集市模式。传统大型软件公司的开发模式就像是艰难而缓慢的大教堂建造工程，它有着严密的管理和封闭的集中式结构，但在创新上、生产力上和Bug控制上却落后于集市模式。集市模式是一种并行的、对等的扁平化开发结构，其参与者大多来自于互联网上的志愿者，结构松散，来去自由，就像是一个乱糟糟的集市，但就是这样的组织形式，却取得了像Linux这样令人惊叹的成功。</p><p>我们可以看到，互联网和移动智能终端已经日益影响着每个人的日常生活，而你每天访问的互联网网站，绝大部分基于开源的操作系统、Web服务器和数据库，你所使用的智能手机多采用 Andriod 或 iOS 系统，Andriod 源于 Linux，iOS 源于开源的 Darwin（Darwin 则基于开源的 Mach 和 FreeBSD 开发），可以说，只要你上网或使用智能手机，你就在不知不觉中使用了开源软件。开源对软件业和互联网带来了巨大影响，并正在和将会对人们的工作和生活产生更显著的影响，正如Eric在前言中所说的，对于任何一个对计算机有所依赖的人，对于任何一个要在未来工作和生活的人，了解一些开源文化，都是很有意义的。</p><h2 id="黑客圈简史"><a href="#黑客圈简史" class="headerlink" title="黑客圈简史"></a>黑客圈简史</h2><h3 id="真程序员（Real-Programmer）"><a href="#真程序员（Real-Programmer）" class="headerlink" title="真程序员（Real Programmer）"></a>真程序员（Real Programmer）</h3><p>通常具备工程学和物理学背景，并常常是业余无线电爱好者。使用机器语言、汇编语言、FORTRAN或者其他一些已经被人们遗忘了的古老的编程语言。</p><h3 id="早期的黑客"><a href="#早期的黑客" class="headerlink" title="早期的黑客"></a>早期的黑客</h3><p>20世纪60年代到70年代期间，第一个横贯美国大陆的高速计算机网络开始出现，使得位于各地的研究者能够以前所未有的速度和灵活性交换信息，这些电子高速公路把散落全美各地的黑客聚集到一起，构成了产生黑客文化的关键力量。</p><h3 id="Unix的兴起"><a href="#Unix的兴起" class="headerlink" title="Unix的兴起"></a>Unix的兴起</h3><p>最开始的操作系统都是用汇编语言精心编写的，目的是充分利用机器的效能。但因为机器的更新换代，用户往往要为那些新机器重新编写软件，也就造成了每次都去做类似发明轮子和钻木取火的事。<br>黑客Ken Thompson，参与了分时操作系统Multics的开发工作，因为其显示出庞大而又无用之物的迹象后，贝尔实验室从这个项目中退出了。<br>出于对Multics的执念，KenThompson开始尝试将Multics的一些理念和自己的一些想法融合起来，准备开发一种新的系统：Unix。<br>与此此时，黑客Dennis Ritchie为还处于雏形阶段的UNIX发明了一种新的语言：C语言。因其设计为好用、限制少和灵活方便的语言，很快在贝尔实验室流行了起来。<br>Thompson和Ritchie是最早意识到当时硬件和编译技术都已经好到能让整个操作系统用C语言编写的那批人之一。于是，Unix和C组合在了一起，并很快因其可移植性、极为广泛的计算作业，很快被数以千计的黑客们接受。</p><h3 id="远古时代的终结"><a href="#远古时代的终结" class="headerlink" title="远古时代的终结"></a>远古时代的终结</h3><p>一群没有组织的微机爱好者决心让普通大众都享受到计算机的威力。<br>很多实验室随着人工智能的首次商业化尝试而四分五裂，受一些新成立公司的高薪职位吸引，实验室里室里最优秀的人才正纷纷出走。<br>RichardM.Stallman（人们更熟悉他的名字缩写RMS，这也是他常用的登录名）离开实验室，创建了自由软件基金会（Free Software Foundation），献身于生产高质量的自由软件。并在1982年用C语言重新构建了整个Unix的克隆，并免费发布，这就是后来广为人知的GNU（Gnu’sNotUNIX，这是一种递归式的缩写）操作系统，GNU迅速成为黑客活动的焦点。</p><h3 id="“专有UNIX”时代"><a href="#“专有UNIX”时代" class="headerlink" title="“专有UNIX”时代"></a>“专有UNIX”时代</h3><p>黑客圈形成了两大阵营，一边是围绕Internet和Usenet而形成的相对有凝聚力的“网络部落”（他们中绝大多数使用运行着UNIX的小型机或工作站级别的机器），一边则是没有网络的分散在各个角落的微机爱好者。<br>这一阶段，一些严重的计算机破坏（cracking）事件开始被主流媒体报道，记者们误用黑客（hacker）一词来形容那些破坏者，这种不幸的误用一直延续至今。<br>随着20世纪90年代的到来，已经有十多年发展的工作站技术，受到了明显的威胁，基于Intel386系列芯片的廉价且高性能的个人计算机出现了，历史上第一次，黑客个人有能力购买一台家用机器，而UNIX则有能力提供运行于其上的整个开发环境，并能连上互联网。<br>但是，动辄数千美元的商业UNIX仍然太贵了，价格也没怎么降下来，人们清楚地看到，十多年来对专有UNIX的商业化努力显然已经失败了。</p><h3 id="早起的自由UNIX"><a href="#早起的自由UNIX" class="headerlink" title="早起的自由UNIX"></a>早起的自由UNIX</h3><p>如果软件复杂到操作系统这样的程度，就必须要有一个精心协作的团队，团队要比较小，而且紧密互动，不管是以前还是现在，这都是很典型的开发模式。<br>FSF一直未能完成的HURD使得Helsinki大学一名叫Linus Torvalds的学生有了施展才能的空间，1991年，他开始为386机器开发自由UNIX内核，使用的正是FSF提供的软件套件。Linus很快获得了成功并吸引了互联网上的黑客们，他们帮助Linus一同开发Linux：一个全功能的UNIX，源代码完全免费，而且可以再发布。</p><h3 id="Web大爆发"><a href="#Web大爆发" class="headerlink" title="Web大爆发"></a>Web大爆发</h3><p>公众发现了互联网。20世纪90年代早期，普通大众一个月花不了多少美元就可以连上互联网，WWW发明以来，互联网本来就很快的增长速度更是加速到了不可思议的地步。<br>1994年，若干种不同版本的自由UNIX（Linux和386BSD的后裔）成为黑客活动的主要焦点。Linux开始被商业公司刻录在CD-ROM上发布，并且非常畅销。<br>互联网成为主流后，黑客文化开始受到尊敬，并有了一定政治影响力。</p><h2 id="大教堂与集市"><a href="#大教堂与集市" class="headerlink" title="大教堂与集市"></a>大教堂与集市</h2><p>两种完全不同的开发模式：绝大多数商业公司所采用的“大教堂”模式和 Linux 世界采用的“集市”模式。</p><h3 id="大教堂模式和集市模式最关键的区别"><a href="#大教堂模式和集市模式最关键的区别" class="headerlink" title="大教堂模式和集市模式最关键的区别"></a>大教堂模式和集市模式最关键的区别</h3><p>在大教堂建筑者看来，bug是棘手的、难以发现的、隐藏在深处的，要经过几个人数月的全心投入和仔细检查，才能有点信心说已经剔除了所有错误。而发布间隔越长，倘若等待已久的发布版本并不完美，人们的失望就越发不可避免。<br>对集市模式而言则完全不同，在上千名合作开发者热切钻研每个新发布版本的情况下，你可以假定bug是浅显易找的，或者至少可以很快变得浅显易找。所以你会频繁发布以获取更多的修正，其副作用是良性的：即便发布中有些小问题，你也不会损失太多。</p><h3 id="开发者和测试者对程序有着不匹配的思维模式"><a href="#开发者和测试者对程序有着不匹配的思维模式" class="headerlink" title="开发者和测试者对程序有着不匹配的思维模式"></a>开发者和测试者对程序有着不匹配的思维模式</h3><p>测试者是从外往内看，程序员是从内往外看。对于不开放源码的软件开发，开发者与测试者往往局限于自己的角色，各说各话，都对对方倍感沮丧。开源开发打破了这种困境，由于大家都有真实的源码，开发者和测试者很容易发展出一个共享的表达模式并进行有效的交流。</p><h3 id="集市模式的成功"><a href="#集市模式的成功" class="headerlink" title="集市模式的成功"></a>集市模式的成功</h3><p>LinusTorvalds的开发风格是：早发布、常发布、委托所有能委托的事、开放到几乎是混乱的程度，这些都令人感到惊讶不已。<br>在Linux社区里，没有建筑大教堂那样的安静和虔诚，倒更像是一个乱糟糟的大集市，充满了各种不同的计划和方法。而既稳定又一致的一个操作系统就这么诞生了。</p><p>1.好的软件作品，往往源自于开发者的个人需要。<br>2.优秀的程序员知道写什么，卓越的程序员知道改写（和重用）什么。<br>以LinusTorvalds为例，他并没有尝试从零开始写Linux，而是以重用Minix（一个用于PC机的迷你型UNIX类操作系统）的代码和理念作为开始，虽然Linux中所有Minix代码最终都被移除或重写，但它在Linux成长初期确实起到了类似脚手架的作用。<br>3.在你第一次把问题解决的时候，你往往并不了解这个问题，第二次你才可能知道怎么把事情做好。所以，如果你想做对事情，至少要再做一次。<br>4.如果你有正确的态度，有趣的事情自然会找到你。<br>5.当你对一个程序不再感兴趣时，你最后的责任就是把它交给一个可以胜任的接棒者。<br>6.把你的用户当成开发合作者对待，如果想让代码质量快速提升并有效排错，这是最省心的途径。<br>7.早发布，常发布，倾听用户的反馈。<br>8.如果有足够多的beta测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。或者说得更通俗一些：“只要眼睛多，bug容易捉。”<br>9.聪明的数据结构配上愚笨的代码，远比反过来要好得多。<br>10.如果你把beta测试者当做最珍贵的资源对待，他们就会成为你最珍贵的资源。<br>11.仅次于拥有好主意的是，识别来自用户的好主意，有时后者会更好。<br>12.通常，那些最有突破性和最有创新力的解决方案来自于你认识到你对问题的基本观念是错的。<br>13.“设计上的完美不是没有东西可以再加，而是没有东西可以再减。”<br>14.任何工具都应具备预期内的功能，但一个伟大的工具能给你带来预期外的功能。<br>15.写网关类软件时，尽可能不要干扰数据流，而且绝不要扔掉信息，除非接收方强迫你这么做。<br>16.当你的语言还远不是图灵完备（Turing-complete）的时候，语法糖[4]会让你受益良多。<br>17.系统的安全性只取决于它所拥有的秘密。谨防虚假的秘密。<br>18.想要解决一个有趣的问题，先去找一个让你感兴趣的问题。在某些工作场所，开发人员不将代码看作是自己的“领土”，而是鼓励别人发现其中的bug和潜在改进点，这些场所中软件改善速度之快，与别处相比是不可同日而语的。<br>19.如果开发协调者有一个至少像Internet这样好的沟通媒介，并且知道如何不靠强制来领导，那么多人合作必然强于单兵作战。</p><h3 id="集市模式的必要条件"><a href="#集市模式的必要条件" class="headerlink" title="集市模式的必要条件"></a>集市模式的必要条件</h3><p>不可能从零开始实施集市模式。<br>需要拿出一个像样的承诺。程序此时并不需要特别好，它可以简陋、有错、不完整，文档可以少得可怜。但它至少要做到：(a)能运行，(b)让潜在的合作开发者相信，这个软件在可预见的未来，能演变成一个非常棒的东西。<br>项目领导人必须要有高度的设计直觉和聪明才智。<br>一定水准的设计和编码能力。<br>集市项目的协调人或领导人必须要有很好的人际交往和沟通能力。</p><p>开源项目如果失败了，根本不会是因为机器、网络或办公场地，它们死掉的唯一原因就是开发者们不再感兴趣了。<br>开源成功的一个最重要成果，就是告诉我们，“玩”是创造性活动中最具经济效能的工作模式。</p><h2 id="开垦心智层"><a href="#开垦心智层" class="headerlink" title="开垦心智层"></a>开垦心智层</h2><p>所谓黑客，是一个通过贡献礼物表现出他（或她）既拥有技术能力又懂得声誉竞争如何运转的人。对是否为黑客的判断是一种感知和认同，只能由那在文化中已经做得很好的人给出。</p><h3 id="黑客意识形态的多样性"><a href="#黑客意识形态的多样性" class="headerlink" title="黑客意识形态的多样性"></a>黑客意识形态的多样性</h3><p>差异可以体现在热忱度上：开源仅仅是一个便利的手段（好工具、有趣的玩具、有意思的游戏），还是说其本身就是目的？<br>差异还体现在敌对性上：反对商业软件，以及反对那些试图支配商业软件市场的公司。</p><p>文化中的禁忌：</p><ul><li>分化一个项目会遇到强大的社会压力，只有在极为必要的情况下才使用，而且要重新命名和做出大量的公开解释。</li><li>在没有项目主持人认可的情况下发布更新是令人不悦的，除非是特殊情况（如本质上不重要的移植bug修复）。</li><li>在项目历史、致谢表或维护列表中移除某个人的名字是绝对不可以的，除非当事人明确表示同意。</li></ul><h3 id="所有权和开放源码"><a href="#所有权和开放源码" class="headerlink" title="所有权和开放源码"></a>所有权和开放源码</h3><p>一个软件项目的“所有者”就是在社区中众所周知的对软件版本改动有唯一发布权的那个人。</p><p>通常有三种方式获得开源项目的所有权：</p><ul><li>第一种也是最显然的，就是去创建这个项目，当这个项目在开始时就只有一个维护者而且这个维护者仍然起作用的时候，所有权问题是连提都不该提的。</li><li>第二种方式是获取前任对所有权的移交（有点像“接力棒传递”）。这在社区中很容易理解，当项目“所有者”不愿意或者不能在开发和维护中投入必要的时间时，他（她）有义务将项目移交给一个有能力的继任者。</li><li>第三种方式是一个项目需要维护但项目所有者已经消失或失去兴趣了。如果你想维护该项目，你的责任是努力找到这个“所有者”，如果找不到，你可以在相关场所（比如Usenet上专注于该应用领域的新闻组）声明该项目似乎是一个“孤儿”，而你想为之负责。</li></ul><h3 id="声誉的多面性"><a href="#声誉的多面性" class="headerlink" title="声誉的多面性"></a>声誉的多面性</h3><p>追求同侪中声誉（声望）的意义何在？</p><ul><li>首先，也是最明显的一点，在同侪中拥有好名声是一种最基本的激励，出于前面提到的进化上的原因，我们都渴望体验它。<br>（一些人试着将这种对声誉的内驱力做各种升华，使其看起来和同侪没有那么明显的关联性，</li><li>第二，声誉是很好的吸引他人注意和合作的途径（在纯礼物经济中，这是唯一的途径）。如果一个人慷慨、智慧、公平交易、有领导能力，或者有其他优秀品质，就更容易让人相信和他合作能获得好处。</li><li>第三，如果你所处的礼物经济和交换经济或命令体系互相关联交织，你的名声就可能传播到后两种环境中，使你在那里获得更高的地位。</li></ul><h3 id="冲突的起因"><a href="#冲突的起因" class="headerlink" title="冲突的起因"></a>冲突的起因</h3><p>把开源软件中的冲突辨识为以下主要四类：</p><ul><li>谁来做有约束力的决定？</li><li>谁该得到荣誉或责备，因为什么？</li><li>如何防范劳动成果被复制？如何防范流氓版本使bug跟踪变得更复杂？·从技术上讲，什么是正确的事？</li><li>从技术上讲，什么是正确的事情？</li></ul><p>任何一种项目冲突解决理论，必须要解决三个问题：</p><ul><li>谁来负责做设计决策？</li><li>如何决定哪个贡献者应该被授予荣誉，如何授予？</li><li>如何保持项目团队和产品不被分裂为多个分支？</li></ul><p>本书这几篇文章仅仅是个开端而非定论，开源软件还有太多的问题没有解决。开源现象引发了其他创造性工作领域以及知识产权相关的许多问题，但未能真正给出较好的答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一本关于黑客行为与文化的书籍。本书并没有给出基础理论上的创新，只是描述了这样的事实：开源软件系统性地利用开放式开发和分布式同行评审（peerreview），不仅降低了成本，还提高了软件质量。&lt;/p&gt;
&lt;p&gt;作者EricS.Raymond作为黑客文化的第一理论家，他通过观察和参与，对黑客这个群体的习俗、信念及关系有着深入而广泛的研究。他极力为“黑客”（hacker）一词正名，强调“黑客”并不是媒体报道中的计算机违法分子，而是那种着迷于计算机技术并通过编程提供极具价值软件的人。&lt;/p&gt;
&lt;p&gt;黑客（hacker）一词，原指喜欢通过智力和创造性方法挑战难题的人，尤指那些热衷于计算机技术的编程高手。由于媒体报道中出现的黑客事件往往和计算机犯罪相连，导致人们常常误认为黑客是利用网络入侵他人系统的破坏者。事实上，这些破坏者应该被称为cracker，即“骇客”。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="开源" scheme="https://veinin.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>《时间管理》读书笔记</title>
    <link href="https://veinin.com/2017/09/02/reading-notes-time-management/"/>
    <id>https://veinin.com/2017/09/02/reading-notes-time-management/</id>
    <published>2017-09-02T07:39:00.000Z</published>
    <updated>2017-09-02T08:30:36.891Z</updated>
    
    <content type="html"><![CDATA[<p>市面上很多关于时间管理的书籍和文字，但几乎很多著作都大同小异，在读这类书籍或文章时大部分反而是在浪费时间。<br>事实上，有关时间管理的原则，你需要知道的大约只有50条，一旦你了解了这些原则，你就了解了关于这一主题你所需要了解的一切。<br>所有50条原则，都囊括在了这本书上，而你只需要向这本书投资1小时的时间，就能带来不错的回报。</p><a id="more"></a><h2 id="作者关于时间管理的十个重要观点"><a href="#作者关于时间管理的十个重要观点" class="headerlink" title="作者关于时间管理的十个重要观点"></a>作者关于时间管理的十个重要观点</h2><h3 id="1-自我意识是先决条件"><a href="#1-自我意识是先决条件" class="headerlink" title="1.自我意识是先决条件"></a>1.自我意识是先决条件</h3><p>意识到自己对时间的感觉，可以使你更加了解自己。<br>如果你不了解你是如何花费时间的，你便没有能力有效地管理你的时间。自己欺骗自己毫无意义。<br>我们对时间的感觉取决于我们做什么，当我们上网、看视频节目时，我们对时间失去了控制住。时间飞逝而过。<br>然而如果我们到家的时候，因为饥饿难耐，随意将什么东西扔进微波炉加热，而那五分钟的等待仿佛无穷无尽。<br>记时间日志会使你对自己不断贬值的资产–生命时光–保持敏感。</p><p>每个人每周有168个小时，或者每个月大约有720小时的时间。每个小时都很重要，你应该认真回顾你目前是如何利用你的时间的。</p><p>比如我一周168小时是这样度过的：<br>睡觉 - 56小时<br>吃饭 - 3.5小时<br>学习、阅读 - 7小时<br>上网、看视频、玩游戏 - 45小时<br>打电话、发短信 - 5小时<br>运动 - 7小时<br>工作时间 - 37.5小时<br>其他杂物 - 17小时<br>总计 - 168小时</p><p>总结过后，你会发现，天哪，我居然用接近30% 时间用来上网、看视频、玩游戏！！！<br>如果能在这方面做出一些优化，多利用一些时间去做更多其他更有意义的事情，那将会更好。</p><h3 id="2-设定目标，提供线路图"><a href="#2-设定目标，提供线路图" class="headerlink" title="2.设定目标，提供线路图"></a>2.设定目标，提供线路图</h3><p>只有当你确定了努力的方向和目标时，你才能决定一个如何安排你的时间。<br>目标设定决定了你6个月、一年或者5年后，你想要在哪里，想要做什么。<br>一旦你确定了目标，就需要采取步骤，对时间做出承诺。</p><p>比如，我需要在一年内实现看完100本书的目标。<br>这个目标应具备了四个最重要的标准：具体、有时间范围、很现实、对于目标制定者来说，它很重要。<br>如果说看完一本书平均要花 3.5小时，那么看完100本就需要350小时，也就是每周需要7小时来阅读才能保证完成，而这就是你设定的一个目标。</p><h3 id="3-选择是艰难的"><a href="#3-选择是艰难的" class="headerlink" title="3.选择是艰难的"></a>3.选择是艰难的</h3><p>时间管理最终就是关于如何做出选择的。<br>梦想的实现绝非轻而易举，有了目标后，你就必须做出选择。<br>彻底的反省，你到底想要得过且过，做你现在马上想做的事情，还是为了未来着想，做哪些能让你今后过上自己想要的生活的事情呢？<br>生活是不公平的，不是说你努力奋斗就一定能得到想要的东西。但你可以通过正确的选择，保持一种成功的姿态，获得更大的机会，去实现想要达成的目标。时间管理的选择也是如此，只有你自己能够做出选择，没人代替你。</p><h3 id="4-创造时间"><a href="#4-创造时间" class="headerlink" title="4.创造时间"></a>4.创造时间</h3><p>匹配时间和精力<br>有效地时间管理不仅仅是寻找一天中额外时间，还要将你的有效时间和你的有效精力匹配起来。尝试在感觉最清醒的啥时候去从事最艰巨的任务。</p><p>空闲时间<br>利用你一天中的空隙时间来减少不必要的浪费，在你慢条斯理、无所事事的时，尝试做一些更加有意义的事情。<br>比如利用你排队打饭来进行快速阅读、记单词啥的。</p><h3 id="5-不要拖延"><a href="#5-不要拖延" class="headerlink" title="5.不要拖延"></a>5.不要拖延</h3><p>时间管理的大敌之一，梦想的杀手。很多人都有良好的愿望，他们“总有一天”要去做什么。但“总有一天”从未变成“今天”。<br>拖延源自一种非常强大的物理法则—-惯性。物体，包括人，倾向于呆在原地不动。为了实现向前移动，则需要推动自己。</p><p>战胜拖延策略：</p><ul><li>在口袋里放一张纸片或索引卡，用粗体字写上你要达成的目标。</li><li>将大项目分解成易管理的小块。</li><li>教会自己的头脑（意识）识别懒惰或拖延最初的蛛丝马迹。</li><li>坚持通过某种方式做好笔记。</li></ul><p>那些培养强大精神力量的人更有可能：</p><ul><li>按时间表、计划行事</li><li>做出正确的选择</li><li>保持良好的注意力</li><li>战胜拖延</li></ul><h3 id="6-杂乱不堪是大敌"><a href="#6-杂乱不堪是大敌" class="headerlink" title="6.杂乱不堪是大敌"></a>6.杂乱不堪是大敌</h3><p>杂乱会引起情绪紧张，导致无所作为，降低效率。<br>如果你能够清理你的工作区域、你的生活，你将显著增加你的工作成效。</p><h3 id="7-计划和准备是值得花精力去做的"><a href="#7-计划和准备是值得花精力去做的" class="headerlink" title="7.计划和准备是值得花精力去做的"></a>7.计划和准备是值得花精力去做的</h3><p>提前决定某一给定的时期内，你要做的具体事情是什么。<br>很多人都不喜欢做计划。我们生活中这样一个充满行动的社会，以至于我们每日总是忙忙碌碌，很少有时间停下来思考我们正在做什么，以及我们为何而做。<br>做好计划意味着：每一个小时的计划抵得上五小时的执行。</p><p>每天花10分钟来规划你这一天该如何度过，通过思考来提高实现你想达到之事的几率。比如为制定这些问题：</p><ul><li>要完成哪些工作？</li><li>有多少时间可以用来完成这些工作？</li><li>需要完成的工作之间存在逻辑顺序吗？</li></ul><h3 id="8-制定任务清单，确定优先次序"><a href="#8-制定任务清单，确定优先次序" class="headerlink" title="8.制定任务清单，确定优先次序"></a>8.制定任务清单，确定优先次序</h3><p>现你所有计划和准备的实物是任务清单。<br>通过任务清单体确认你所要做的事情是什么，以及你将如何和合适去做每一件事。</p><p>制作任务清单理由:</p><ul><li>便于组织你的时间，为你的每一天创建一个时间框架。</li><li>减轻你的压力。</li><li>让你去考虑该如何使用你的时间以及为何这样使用。</li><li>制作任务清单的过程就像在写一部微型小书，主题就是你自己，而且你永远不知道，在制作任务清单的执行过程中，会迸发出什么样的想法和观点。</li></ul><p>任务清单四个象限：</p><ul><li>重要而紧急</li><li>重要但不紧急</li><li>紧急但不重要</li><li>既不紧急也不重要<br>可以按照 1 -&gt; 3 -&gt; 2 -&gt; 4顺序完成不同象限工作。</li></ul><h3 id="9-专心致志是问题的关键所在"><a href="#9-专心致志是问题的关键所在" class="headerlink" title="9.专心致志是问题的关键所在"></a>9.专心致志是问题的关键所在</h3><h4 id="二八定律"><a href="#二八定律" class="headerlink" title="二八定律"></a>二八定律</h4><p>你的80%的成就来自于你20%的行为。如销售人员80%的收入往往来自于他们20%的客户。投资者知道，80%的收益来自于他们20%的投资。<br>如果你正从一个或两个活动（“20%”）中获得大部分成果（“80%”），那么这一两个活动就是你应该集中精力去做的。<br>把大部分精力都投入到那些真正能够给你带来“最大收益”的项目上去。</p><h4 id="集中精力"><a href="#集中精力" class="headerlink" title="集中精力"></a>集中精力</h4><p>分心和干扰是专注的大敌。<br>学会如何集中精力，即通过训练在同一时间将你的思维专注于某一件事情上，来强化你的思想力量。<br>当你试图同时做不止一件事情时，你便削弱了你正在做的每一件事情的有效性。那些一心二用，并认为每一件事他们都做的好的人，不过是在自欺欺人而已。</p><p>减少分心，排除干扰。</p><h5 id="对于分心的因素："><a href="#对于分心的因素：" class="headerlink" title="对于分心的因素："></a>对于分心的因素：</h5><ul><li>远离互联网。</li><li>关掉手机。</li><li>关掉所有电子邮件提示。</li><li>拔掉电视机插头。</li><li>将一切电子产品（如视频游戏）移出工作区域。</li></ul><h5 id="对于干扰因素："><a href="#对于干扰因素：" class="headerlink" title="对于干扰因素："></a>对于干扰因素：</h5><ul><li>如有可能，把工作时房门关上。</li><li>如果不可能，而且周围有其他人，那么你便：<br>A) 戴上一顶棒球帽，将帽舌下拉，表现出不友善的样子。<br>B) 避免同经过的人进行目光接触。<br>C) 戴耳机（即使什么都不播放）<br>D) 把一盒面巾纸放旁边，把其中几张弄的皱巴巴的放在一旁，表明你感冒了。</li></ul><h3 id="10-选择对你来说行之有效的时间管理技巧"><a href="#10-选择对你来说行之有效的时间管理技巧" class="headerlink" title="10.选择对你来说行之有效的时间管理技巧"></a>10.选择对你来说行之有效的时间管理技巧</h3><p>上面一些时间管理技巧，有一些可能让你感到有意义，有些则不然。<br>你可以对不同的方法进行试验和尝试。关键是努力把你每小时使用的尽可能合理有效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;市面上很多关于时间管理的书籍和文字，但几乎很多著作都大同小异，在读这类书籍或文章时大部分反而是在浪费时间。&lt;br&gt;事实上，有关时间管理的原则，你需要知道的大约只有50条，一旦你了解了这些原则，你就了解了关于这一主题你所需要了解的一切。&lt;br&gt;所有50条原则，都囊括在了这本书上，而你只需要向这本书投资1小时的时间，就能带来不错的回报。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时间管理" scheme="https://veinin.com/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>《如何阅读一本书》读书笔记</title>
    <link href="https://veinin.com/2017/08/26/how-to-read-a-book/"/>
    <id>https://veinin.com/2017/08/26/how-to-read-a-book/</id>
    <published>2017-08-25T16:09:37.000Z</published>
    <updated>2018-03-05T15:17:36.746Z</updated>
    
    <content type="html"><![CDATA[<p>这是一本为阅读的人，或是想要成为阅读的人而写的工具书。尤其是想要阅读书的人。说得更具体点，这本书是为那些想把读书的主要目的当作是增进理解能力的人而写。<br>这本说针对的不是虚构的作品，如小书、戏、史诗剧，而是一些的论说性的书籍，如社会、人文、工具书的这类，而后者是大部分人的兴趣所在。<br>阅读的目标是为获得资讯而读，以及为求得理解而读。如果你想读一本有助于增进理解力的好书，那这本书可以帮忙，这本书的主题就是阅读好书的艺术。</p><a id="more"></a><h2 id="阅读的分类"><a href="#阅读的分类" class="headerlink" title="阅读的分类"></a>阅读的分类</h2><p><strong>第一种阅读</strong>，也就如我们平时看报纸、看电视新闻、刷微信公众号，甚至看电影等等。这种是阅读只是为了获得咨询，此时你的阅读技巧、理解能力完全能与作者相当，这种读物只能增加你的资讯，并不能提升你的理解能力。这在这本书的作者眼里，这种阅读其实不算真正的阅读。</p><p><strong>第二种阅读</strong>，主动的阅读，其实就是一个人面对他本身并不理解的东西，书本的内容超出了你的理解。既然我们想提升自己，获得更深层次的理解，就必须向比你更厉害的人学习。而面对这种阅读，是没有任何外力可以帮助你的，你就是要读这本书，你什么都没有，只凭内心的力量，玩味着眼前的字句，慢慢提升自己，从只有模糊的概念到更清楚地理解为止。这样的一种提升，是在阅读时的一种脑力活动，也就更高的阅读技巧。这种阅读就是让一本书向你既有的理解力做挑战。只有这种方式是真正的阅读。</p><h2 id="阅读的层次"><a href="#阅读的层次" class="headerlink" title="阅读的层次"></a>阅读的层次</h2><p>作者把阅读分为四种层次，阅读的层次是渐进的，更高的层次包含了较低层次的特性。</p><h3 id="基础阅读"><a href="#基础阅读" class="headerlink" title="基础阅读"></a>基础阅读</h3><p>第一层阅读，只要熟练了这个层次的阅读，也就摆脱了文盲的状态。在熟练这个层次的过程中，一个人可以学习到阅读的基本艺术，接受基础的训练，获得初步的阅读技巧。<br>这个阶段是一个学习如何阅读的阶段，对我们来说，如果已经完成九年义务教育，应该都能完成这一层次的阅读，也就是说能结合语境理解字面上的意思。</p><p>在儿童具备纯熟的阅读能力之前，至少需要四个截然不同的阶段。<br>第一个阶段，阅读准备阶段，相当于学前将于的或幼稚园的学习经验。<br>第二个阶段，认字，相当于一年级学生典型的学习经验。<br>第三个阶段，字汇的增长及对课文的运用，有能力阅读一些交通标志，或图片说明，填写政府有关的简单表格等等 。<br>第四个阶段，这个阶段，学生要从小学到初中毕业。有一定的读写能力，几乎可以阅读所有读物，但还不够老练。</p><h3 id="检视阅读（略读）"><a href="#检视阅读（略读）" class="headerlink" title="检视阅读（略读）"></a>检视阅读（略读）</h3><p>特点在于强调时间。在这个层次，必须在规定的时间完成一项阅读。譬如用十五分钟读完一本书，或是同样的时间念完两倍数量的书。<br>与基础阅读相比，检视阅读才算进入了阅读的层次，这是一种让你在有限的时间内尽量抓住一本书的重点的阅读方法。而这一层次，恰恰是很多人所没有掌握的。<br>进行检视阅读的情况大概有两种，一种是让你想在有限的时间当中，对一本书有个基础的了解，然后再决定你是否继续精读下去。而另外一种是，有很多书其实并不适合花大量精力在上面，也就不适合精读，通常面对这类书籍的时候，检视阅读往往是了解一本书的最好方式。</p><p>检视阅读分两种： </p><ul><li><p><strong>第一，有系统化的略读和粗读</strong><br>略读和粗读可以让我们发现这本书值不值得多花时间去仔细阅读，并且，略读也能告诉你许多这本书有关的事。略读的习惯有关用不着花太多时间，下面是一些建议：<br>（1）先看书名页，然后如果有序就先看序。要很快的看过去，特别注意副标题，或其他相关说明或宗旨，或是作者写作本书的特殊角度。<br>（2）研究目录页，对这本书的基本架构做概括性的理解。这就像出发旅行前，先看下地图一样。<br>（3）如果书中附有索引，也要检阅一下，大多数论说类的书籍都有有索引。这样能款苏评估这本书涵盖了那些议题的范围。<br>（4）如果输有包着书衣，不妨读一下出版者的介绍，这应该有作者对本书的主旨描述，这可以让你快速判断这本书是否有可取的内容，而不是根本没任何重要的东西。<br>（5）从本书的目录概的初步印象中，挑几个看起来跟主题息息相关的篇章来看。特别是看看这些篇章的开头或结尾的摘要说明。<br>（6）最后一步，把书打开，东翻翻西翻翻，念个一两段，有时候连续读几页，但不要太多。，就用这样的方法把全书翻过一遍，随时寻找主要论点的讯号，留意主题的基本脉动。<br>通过以上几个步骤，你可以在不到一小时的时间里，对这本书已经了解了很多。尤其，你应该了解这本书是否包含想继续挖掘下去的内容，是否值得你继续投下时间与注意？你应该比以前更清楚这本书该归类为哪一个种类，以便将来有需要时好作参考。</p></li><li><p><strong>第二，粗浅的阅读</strong><br>每个人都有这样的经验：对一本难书包着高度的期望，结果却只是在徒劳无益的挣扎而已。最后得出一个结论：一开始读这本书就是个错误。但这只是对阅读一本难书的期望过高而已。<br>头一次面对一本难读的书的时候，从头到尾先读一遍，碰到不懂的地方不要停下来查询或思索。<br>只注意你能理解的部分，不要为一些设法立即了解的东西而停顿。略过不懂的部分，集中精力去了解你看得懂的部分。<br>从头到尾了解一遍之后，就算只有50%或更少，都能帮助你后来重读第一次略过的部分，增进理解。就算不重读，这本难度很高的书你也理解了一半，比什么都不了解来的更好些。</p></li></ul><p>-</p><h3 id="分析阅读（精读）"><a href="#分析阅读（精读）" class="headerlink" title="分析阅读（精读）"></a>分析阅读（精读）</h3><p>这个层次更复杂，更系统化。如果你的目标只是获得资讯或消遣，就没有必要用到分析阅读。<br>如果说检视阅读是在有限的时间内，最好也最完整的阅读，那么分析阅读就是在无限的时间里，最好也最完整的阅读。<br>在这个层次，我们需要在略读的基础上，更加主动的去提出问题，并且用自己的语言尝试解释这本书的内容。也就是在精读的时候，我怎么样用自己的话把这一段、这一章、甚至整本书的内容说出来。<br>分析阅读的规则是一个理想化的阅读。没有多少人用过这样的方法来阅读一本书。而使用过这些方法的人，可能也没办法用这些规则来阅读许多本书。无论如何，这些规则只是衡量阅读层次的理想标准。如果你是个好读者，也就能达到你应该达到的阅读层次。<br>一个读得很广泛，却读不精的人，与其值得赞美，不如值得同情。就像霍布斯所说：“如果我像一般人一样读那么多书，我就跟他们一样愚蠢了。”<br>当然，许多书都值得精读。但有更多的书只要浏览一下就行了。要成为一个好读者，就要懂得依照一本书的特质，运用不同的阅读技巧来阅读。</p><p>分析阅读分为三个阶段：</p><p><strong>第一个阶段（找出一本书在谈些什么规则）</strong></p><ul><li><p>规则一，依照书本的种类与主题作分类。<br>你一定要知道自己在读的是哪一类书，而且要越早知道越好。最好早在你开始阅读之前就先知道。<br>主要分类法，一种是虚构的小说类，另一种是传达知识，说明性的论说类。<br>论说性作品又区分为理论性和实用性作品。 </p></li><li><p>规则二，用最简短的句子说出整本书在谈些什么。<br>如对亚当斯密的《国富论》，可以缩减为一下篇幅：<br>本书在探讨国家财富的资源。任何一个以劳力为主的经济体制，都要考虑到薪资的给付，资本利润的回收，积欠地主的租金等关系，这些就是物品价格的基本因素。本书探讨到如何更多元化的有效运用资本，并从金钱的起源与使用，谈到积累资本及使用资本。本书接着经验不同的国家在不同状况下的富裕发展，比较了不同财经系统，讨论了自由贸易的好处。</p></li><li><p>规则三，按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。<br>这个规则是可以有一套运用的公式的，比如大纲排列如下：<br>（1）作者将全书分为五个部分，第一部分谈的是什么，第二部分谈的是什么，第三部分谈的是别的事，第四部分则是另外的观点，第五部分优势另一些事。<br>（2）第一个主要部分又分为三个段落，第一段落为X，第二段了为Y，第三段了为Z。<br>（3）在第一部分的第一个阶段，这种有四个重点，第一个重点是A，第二个重点是B，第三个重点是C，第四个重点是D等等。</p></li><li><p>规则四，找出作者在问的问题，或作者想要解决的问题。<br>可以列出简短的公式：<br>某件事存在吗？是什么样的事？发生的原因是什么？或是在什么样的情况下存在？或为什么会有这件事的存在？这件事的目的是什么？造成的影响是什么？特性及特征是什么？与其他类似事件，或不相同事件的关联是什么？这件事是如何进行的？以上这些都是理论性的问题。有哪些结果可以选择？应该采取什么样的手段才能获得某种结果？要达到某个目的，应该采取哪些行动？以什么顺序？在这些条件下，什么事是对的，或怎样才会更好，而不是更糟？在什么样的条件下，这样做会比那样做好一些？以上这些都是实用的问题。</p></li></ul><p><strong>第二个阶段（找出一本书到底在说什么的规则）</strong></p><ul><li>规则五，诠释作者使用的关键字，与作者达成共识。这个规则共分两个部分，第一个部分是找出重要单字，那些举足轻重的单字。第二部分是确认这些单字在使用时的最精确的意义。</li><li>规则六，从最重要的句子中抓出作者的重要主旨。</li><li>规则七，找出作者的论述，重新架构这些论述的前因后果，以明白作者的主张。如果可以，找出书中说明重要论述的段落。但是，如果这个论述并没有这样表达出来，你就要去架构出来。你要从这一段或那一段中挑选句子出来，然后整理出前后顺序的主旨，以及其组成的论述。<br>规则八，确定作者已经解决了哪些问题，还有哪些是未解决的。在未解决的问题中，确定哪些是作者认为自己无法解决的问题。</li></ul><p><strong>第三阶段（公正的评断一本书）</strong></p><ul><li>A.智慧礼节的一般规则</li><li>规则九，在你说出“我同意”，“我不同意”，或“我暂缓评论”之前，你一定要能肯定地说：“我了解了。”除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。</li><li>规则十，不要争强好胜，非辩到底不可。当你不同意作者的观点时，要理性地表达自己的意见，不要无理地辩驳或争论。如果你知道或怀疑自己是错的，就没有必要去赢得那场争辩。</li><li><p>规则十一，尊重知识与个人观点的不同，在作任何评断之前，都要找出理论基础。</p></li><li><p>B.批评观点的特别标准</p></li><li>规则十二，证明作者的知识不足（uninformed），缺少某些与他想要解决的问题相关的知识。</li><li>规则十三，证明作者的知识有错误（misinformed），理念不正确。</li><li>规则十四，证明作者不合逻辑，推论无法令人信服。</li><li>规则十五，证明作者的分析不完整，并没有解决他一开始提出来的所有问题，或是他并没有尽可能善用他手边的资料，或是他并没有看出其间的含意与纵横交错的关系，或是他没法让自己的想法与众不同。</li></ul><h3 id="主题阅读"><a href="#主题阅读" class="headerlink" title="主题阅读"></a>主题阅读</h3><p>也是最高层次的阅读。这是最复杂、最系统化的阅读。虽然它要求非常多，也不被人熟知，但却是所有阅读活动中最有收获、最能获益良多的阅读方式。<br>这个阅读层次已经不仅仅局限于一本书了，而是针对一个主题问题，找出与主题相关的书籍以及这些书籍当中与主题相关的章节，针对这些进行检视阅读或分析阅读。在主题阅读中，你关心的主题才是你的重点，而不是你阅读的书。在这个阶段，检视阅读已经是读者在阅读时主要的工具或手段了。</p><p>在主题阅读中有两个阶段。<br><strong>准备阶段，另一个是主题阅读本身</strong>。</p><ul><li><p>第一阶段，观察研究范围：主题阅读的准备阶段<br>（1）针对你要研究的主题，设计一份试验性的书目。你可以参考图书馆目录、专家的建议与书中的书目索引。<br>（2）浏览这份书目上所有的书，整体进行检视阅读一遍，确定哪些与你的主题相关，并就你的主题建立起清楚的概念。</p></li><li><p>第二阶段主题阅读：阅读所有第一阶段收集到的书籍<br>（1）浏览所有在第一阶段被认定与你主题相关的书，找出最相关的章节。<br>（2）根据主题创造出一套中立的词汇，带引作者与你达成共识——无论作者是否实际用到这些词汇，所有的作者，或至少绝大部分的作者都可以用这套词汇来诠释。<br>（3）建立一个中立的主旨，列出一连串的问题——无论作者是否明白谈过这些问题，所有的作者，或者至少大多数的作者都要能解读为针对这些问题提供了他们的回答。<br>（4）界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。你要记住，各个作者之间或之中，不见得一定存在着某个议题。有时候，你需要针对一些不是作者主要关心范围的事情，把他的观点解读，才能建构出这种议题。<br>（5）分析这些讨论。这得把问题和议题按顺序排列，以求突显主题。比较有共通性的议题，要放在比较没有共通性的议题之前。各个议题之间的关系也要清楚地界定出来。注意：理想上，要一直保持对话式的疏离与客观。要做到这一点，每当你要解读某个作家对一个议题的观点时，必须从他自己的文章中引一段话来并列。</p></li></ul><p>最后，虽然这本说提到的这些阅读方法对于论说性书籍普遍比较适用，但并说是说这些方法适合所有人，只有真是你觉得最适合你自己的读书方法才是好方法。如果你已经有了自己觉得比较合适的阅读方法，其实没必要去强求，用自己的方法就好。</p><h3 id="本文大部分内容摘自："><a href="#本文大部分内容摘自：" class="headerlink" title="本文大部分内容摘自："></a>本文大部分内容摘自：</h3><ul><li>《如何阅读一本书》，<a href="https://book.douban.com/subject/1013208/" target="_blank" rel="noopener">豆瓣读书</a></li><li>【Simple Read】如何阅读一本书？，<a href="https://www.bilibili.com/video/av10624397/" target="_blank" rel="noopener">bilibili</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一本为阅读的人，或是想要成为阅读的人而写的工具书。尤其是想要阅读书的人。说得更具体点，这本书是为那些想把读书的主要目的当作是增进理解能力的人而写。&lt;br&gt;这本说针对的不是虚构的作品，如小书、戏、史诗剧，而是一些的论说性的书籍，如社会、人文、工具书的这类，而后者是大部分人的兴趣所在。&lt;br&gt;阅读的目标是为获得资讯而读，以及为求得理解而读。如果你想读一本有助于增进理解力的好书，那这本书可以帮忙，这本书的主题就是阅读好书的艺术。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书" scheme="https://veinin.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="如何阅读一本书" scheme="https://veinin.com/tags/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Lua C API简介(中篇)</title>
    <link href="https://veinin.com/2017/08/06/lua-c-aip-02/"/>
    <id>https://veinin.com/2017/08/06/lua-c-aip-02/</id>
    <published>2017-08-06T14:15:58.000Z</published>
    <updated>2017-11-24T16:37:33.514Z</updated>
    
    <content type="html"><![CDATA[<p>在运行C程序时，可以调用Lua脚本。C程序可以向Lua传入参数，然后通过Lua返回结果。<br>使用C API调用Lua函数方法很简单，我们最开始先将要调用的函数入栈，然后依次将要传入的参数入栈，调用pcall函数。最后，再从栈中获取函数返回的值。</p><a id="more"></a><h2 id="调用Lua简单脚本"><a href="#调用Lua简单脚本" class="headerlink" title="调用Lua简单脚本"></a>调用Lua简单脚本</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- helloscript.lua</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">"This is comming from lua\n"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helloscript.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lua.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lauxlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lualib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lua_State *L = luaL_newstate();</span><br><span class="line">luaL_openlibs(L);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(luaL_loadfile(L, <span class="string">"call_lua.lua"</span>))</span><br><span class="line">error(L, <span class="string">"luaL_loadfile failed.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"In C, calling Lua\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">error(L, <span class="string">"lua_pcall() failed."</span>, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Back in C again\n"</span>);</span><br><span class="line"></span><br><span class="line">lua_close(L);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">va_list argp;</span><br><span class="line">va_start(argp, fmt);</span><br><span class="line"><span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, argp);</span><br><span class="line">va_end(argp);</span><br><span class="line">lua_close(L);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关函数解析"><a href="#相关函数解析" class="headerlink" title="相关函数解析"></a>相关函数解析</h3><p><code>luaL_loadfile(L, &quot;script.lua&quot;);</code><br><code>lua_loadfile</code> 等价于 <code>luaL_loadfilex</code>，加载为 Lua 代码块。此函数的返回值和 <code>lua_load</code> 相同，不过它还可能产生一个叫做 <code>LUA_ERRFILE</code> 的出错码。这种错误发生于无法打开或读入文件时，或是文件的模式错误。和 <code>lua_load</code> 一样，这个函数仅加载代码块不运行。</p><p><code>lua_pcall(L, number_of_args, number_of_returns, errfunc_idx);</code><br>调用Lua函数，第二个参数位传入参数数量; 第三个参数为调用函数返回值数量; <code>errfunc_idx</code> 是0，则返回在栈顶的错误消息就和原始错误消息完全一致，否则，<code>msgh</code> 就被当成是错误处理函数在栈上的索引位置。</p><h3 id="编译、运行-系统：OSX-Lua版本-5-3-0-："><a href="#编译、运行-系统：OSX-Lua版本-5-3-0-：" class="headerlink" title="编译、运行(系统：OSX Lua版本:5.3.0)："></a>编译、运行(系统：OSX Lua版本:5.3.0)：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cc -o helloscript helloscript.c -I /usr/<span class="built_in">local</span>/include/ -L /usr/<span class="built_in">local</span>/lib/ -llua</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./helloscript</span></span><br><span class="line">In C, calling Lua</span><br><span class="line">This is comming from lua</span><br><span class="line">Back in C again</span><br></pre></td></tr></table></figure><h2 id="调用Lua函数，传值并返回"><a href="#调用Lua函数，传值并返回" class="headerlink" title="调用Lua函数，传值并返回"></a>调用Lua函数，传值并返回</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- call_lua_func.lua </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">"This is comming from lua.sayHello.\n"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a, b)</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"This is comming from lua.add. arg.a ="</span>, a, <span class="string">" arg.b ="</span>, b)</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 04_call_lua_func.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lua.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lauxlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lualib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lua_State *L = luaL_newstate();</span><br><span class="line">luaL_openlibs(L);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(luaL_loadfile(L, <span class="string">"call_lua_func.lua"</span>))</span><br><span class="line">error(L, <span class="string">"luaL_loadfile failed.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">error(L, <span class="string">"lua_pcall failed.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"In C, calling Lua-&gt;sayHello()\n"</span>);</span><br><span class="line"></span><br><span class="line">lua_getglobal(L, <span class="string">"sayHello"</span>);<span class="comment">//Tell it to run test2.lua -&gt; sayHello()</span></span><br><span class="line"><span class="keyword">if</span>(lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">error(L, <span class="string">"lua_pcall failed.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Back in C again\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nIn C, calling Lua-&gt;add()\n"</span>);</span><br><span class="line"></span><br><span class="line">lua_getglobal(L, <span class="string">"add"</span>);<span class="comment">//Tell it to run test2.lua -&gt; add()</span></span><br><span class="line">lua_pushnumber(L, <span class="number">1</span>);</span><br><span class="line">lua_pushnumber(L, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span>(lua_pcall(L, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">error(L, <span class="string">"lua_pcall failed.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Back in C again\n"</span>);</span><br><span class="line"><span class="keyword">int</span> returnNum = lua_tonumber(L, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Returned number : %d\n"</span>, returnNum);</span><br><span class="line"></span><br><span class="line">lua_close(L);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">va_list argp;</span><br><span class="line">va_start(argp, fmt);</span><br><span class="line"><span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, argp);</span><br><span class="line">va_end(argp);</span><br><span class="line">lua_close(L);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关函数解析-1"><a href="#相关函数解析-1" class="headerlink" title="相关函数解析"></a>相关函数解析</h3><p>在 Lua 脚本中， <code>sayHello</code> 函数只做输出操作，而 <code>add</code> 函数则需要传入两值，并进行加法操作并返回结果。</p><p>从 C 层在调用 Lua 脚本层时，首先要把被调用的函数压入栈中，可以通过 <code>lua_getglobal</code> 函数把调用函数入栈。</p><p>把需要传递给被调用函数的参数用 <code>lua_push*</code> 函数按正序压栈。</p><p>最后调用一下 <code>lua_call</code>，把要传入的参数个数及返回值个数一起传进去。  </p><p>当函数调用完毕后，所有的参数以及函数本身都会出栈。紧接着函数的所有返回值这时则被压栈。Lua 会保证返回值都放入栈空间中。函数返回值将按正序压栈（第一个返回值首先压栈），因此在调用结束后，最后一个返回值将被放在栈顶。</p><h3 id="编译、运行"><a href="#编译、运行" class="headerlink" title="编译、运行"></a>编译、运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cc -o callluafunc callluafunc.c -I /usr/<span class="built_in">local</span>/include/ -L /usr/<span class="built_in">local</span>/lib -llua</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./callluafunc</span></span><br><span class="line">In C, calling Lua-&gt;sayHello()</span><br><span class="line"></span><br><span class="line">This is comming from lua.sayHello.</span><br><span class="line"></span><br><span class="line">Back in C again</span><br><span class="line"></span><br><span class="line">In C, calling Lua-&gt;add()</span><br><span class="line"></span><br><span class="line">This is comming from lua.add. arg.a = 1.0 arg.b = 5.0</span><br><span class="line"></span><br><span class="line">Back in C again</span><br><span class="line"></span><br><span class="line">Returned number : 6</span><br></pre></td></tr></table></figure><h2 id="表传递"><a href="#表传递" class="headerlink" title="表传递"></a>表传递</h2><p>在对Lua函数调用值传递时经常涉及到表的传递。通过下面代码我们来讨论它是如何执行的。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- call_lua_table.lua</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 该函数接受一个 table，并且将新建一个 talbe，将穿入的 table 键值都插入新建 table 中，并记录数据长度，最后返回新建立的 table。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tablehandler</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">local</span> returnedt = &#123;numfields = <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">returnedt.numfields = returnedt.numfields + <span class="number">1</span></span><br><span class="line">returnedt[<span class="built_in">tostring</span>(i)] = <span class="built_in">tostring</span>(v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">"this is comming from table handler. table num fields : "</span>, returnedt.numfields, <span class="string">"\n"</span>)</span><br><span class="line"><span class="keyword">return</span> returnedt</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 05_call_lua_table.c </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lua.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lauxlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lualib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lua_State *L = luaL_newstate();</span><br><span class="line">luaL_openlibs(L);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(luaL_loadfile(L, <span class="string">"call_lua_table.lua"</span>))</span><br><span class="line">error(L, <span class="string">"luaL_loadfile failed.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">error(L, <span class="string">"lua_pcall failed"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"In C,  calling Lua-&gt;tablehandler()\n"</span>);</span><br><span class="line">lua_getglobal(L, <span class="string">"tablehandler"</span>);</span><br><span class="line">lua_newtable(L);<span class="comment">//新建一个table入栈</span></span><br><span class="line">lua_pushliteral(L, <span class="string">"firstname"</span>);<span class="comment">//键为"firstname"入栈，此时table位置-2</span></span><br><span class="line">lua_pushliteral(L, <span class="string">"Veinin"</span>);<span class="comment">//值为"Veinin"入栈，次数table位置-3</span></span><br><span class="line">lua_settable(L, <span class="number">-3</span>);<span class="comment">//把key和value放入表中，操作完成后键和值都会被弹出栈</span></span><br><span class="line"></span><br><span class="line">lua_pushliteral(L, <span class="string">"lastname"</span>);</span><br><span class="line">lua_pushliteral(L, <span class="string">"Guo"</span>);</span><br><span class="line">lua_settable(L, <span class="number">-3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(lua_pcall(L, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>))<span class="comment">//执行调用函数</span></span><br><span class="line">error(L, <span class="string">"lua_pcall failed"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"============ Back in C again, Iterating thru returned table ============\n"</span>);</span><br><span class="line"></span><br><span class="line">lua_pushnil(L);<span class="comment">//第一个键，</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *k, *v;</span><br><span class="line"><span class="keyword">while</span>(lua_next(L, <span class="number">-2</span>)) &#123;<span class="comment">//table现在在-2位置，lua_next得到一个键-值对，分别入栈</span></span><br><span class="line">v = lua_tostring(L, <span class="number">-1</span>);</span><br><span class="line">k = lua_tostring(L, <span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">lua_pop(L, <span class="number">1</span>);<span class="comment">//’值’出栈，‘键’不出栈，保留做下一次迭代</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s = %s\n"</span>, k, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lua_close(L);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">va_list argp;</span><br><span class="line">va_start(argp, fmt);</span><br><span class="line"><span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, argp);</span><br><span class="line">va_end(argp);</span><br><span class="line">lua_close(L);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关函数解析-2"><a href="#相关函数解析-2" class="headerlink" title="相关函数解析"></a>相关函数解析</h3><p>对于 C 层代码，我们可以通过 <code>lua_newtable</code> 函数创建一张空表，并将其压栈，该函数它等价于 <code>lua_createtable(L, 0, 0)</code>。<br>然后通过 <code>lua_pushliteral</code> 把键和值分别压入栈中，并通过 <code>lua_settable</code> 把 <code>key</code> 和 <code>value</code> 放入 table 中，做一个等价于 <code>t[k] = v</code> 的操作，在操作完成后，这个函数会将键和值都弹出栈。</p><p>在被调用函数 <code>tablehandler</code> 返回后，此时，栈中存在的只是函数的返回值，而它目前是一张 table，对于迭代输出 table 中的值，上面给出了一种典型的遍历方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lua_next</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><p><code>lua_next</code> 可以从栈顶弹出一个键，然后把索引指定的表中的一个键值对压栈（弹出的键之后的 “下一” 对），在这一步开始之前我们需要调用 <code>lua_pushnil(L)</code> 设置第一个键为缺省值，然后再调用 <code>lua_next</code> 。<br>通常，我们会在下一个迭代到来之前，把‘值’出栈，但会保留‘键’做下一次迭代操作。</p><h3 id="编译、运行-1"><a href="#编译、运行-1" class="headerlink" title="编译、运行"></a>编译、运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cc -o 05_call_lua_table 05_call_lua_table.c -I /usr/<span class="built_in">local</span>/include/ -L /usr/<span class="built_in">local</span>/lib/ -llua</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./05_call_lua_table</span></span><br><span class="line">In C,  calling Lua-&gt;tablehandler()</span><br><span class="line"></span><br><span class="line">this is comming from table handler. table num fields : 3</span><br><span class="line"></span><br><span class="line">============ Back in C again, Iterating thru returned table ============</span><br><span class="line">lastname = Guo</span><br><span class="line"></span><br><span class="line">firstname = Veinin</span><br><span class="line"></span><br><span class="line">numfields = 3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在运行C程序时，可以调用Lua脚本。C程序可以向Lua传入参数，然后通过Lua返回结果。&lt;br&gt;使用C API调用Lua函数方法很简单，我们最开始先将要调用的函数入栈，然后依次将要传入的参数入栈，调用pcall函数。最后，再从栈中获取函数返回的值。&lt;/p&gt;
    
    </summary>
    
      <category term="Lua" scheme="https://veinin.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="https://veinin.com/tags/Lua/"/>
    
      <category term="Lua C API" scheme="https://veinin.com/tags/Lua-C-API/"/>
    
  </entry>
  
</feed>
