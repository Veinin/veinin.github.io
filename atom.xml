<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Veinin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://veinin.com/"/>
  <updated>2019-03-20T13:51:56.171Z</updated>
  <id>https://veinin.com/</id>
  
  <author>
    <name>Veinin Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快节奏多人游戏（4）：延迟补偿</title>
    <link href="https://veinin.com/2019/03/14/fast-paced-multiplayer-04/"/>
    <id>https://veinin.com/2019/03/14/fast-paced-multiplayer-04/</id>
    <published>2019-03-14T14:25:00.000Z</published>
    <updated>2019-03-20T13:51:56.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>前面 3 篇文章阐述了游戏客户端-服务器的架构，我们总结如下：</p><ul><li>服务器从所有客户端获取带有时间戳的输入</li><li>服务器处理输入后更新游戏世界状态</li><li>服务器将游戏世界的快照发送给所有客户端</li><li>客户端发送输入并在本地模拟其效果</li><li>客户端获得游戏世界更新，同步预测状态和权威状态，并插入其他实体已知的过去状态。</li></ul><p>从玩家的角度来看，这里有两个重要的结论：</p><ul><li>玩家可以看到现在的自己</li><li>玩家可以看到其他实体的过去</li></ul><p>这种情况通常表现会不错，但对于时间和空间都非常敏感的事件来说这就会产生问题，例如：爆头射击敌人。</p><a id="more"></a><h2 id="延迟补偿"><a href="#延迟补偿" class="headerlink" title="延迟补偿"></a>延迟补偿</h2><p>当你用你的狙击步枪完美的瞄准了敌人头部，并扣动了扳机，这将是你不能错过的时刻。</p><p>但是你并没有打到。</p><p>为什么会这样呢？</p><p>在之前的客户端-服务器架构解释中，这是因为你射击敌人的头部是在 100 毫秒之前的位置，而不是你射击时的实际位置。</p><p>在某种程度上，它就像在光速的宇宙中游玩，你瞄准了敌人过去的位置，但是当你扣动扳机时他已经消失了。</p><p>幸运的是，有一个相对简单的解决方案，大多数时候这对大多数玩家来说是都是会有一个不错的体验（下面内容讨论了一个例外）。</p><p>以下是它的工作原理：</p><ul><li>当你准备瞄准射击时，客户端会将此事件发送给服务器，服务器会提供完整信息：瞄准射击的确切时间戳以及武器的确切目标。</li><li>至关重要的一步，由于服务器获得带有时间戳的所有输入，因此它可以在过去的任何时刻以可信任的方式重构游戏世界。特别是它可以在任何时间点完全按照任何客户的样子重构游戏世界。</li><li>这意味着服务器可以在你瞄准射击的瞬间确切地知道武器瞄准的内容。虽然对客户端来说敌人头部是的过去位置，但服务器是知道敌人头部在你现在的瞄准位置。</li><li>服务器在射击的时间点处理镜头，并更新客户端。</li></ul><p>现在每个人都很开心！</p><p>服务器很高兴，因为他是服务器，他总是很开心。</p><p>你也很高兴，因为你瞄准了敌人的头部，进行射击，并得到一个爆头奖励！</p><p>敌人可能是唯一一个不完全开心的人。如果他在被击中时站着不动，这是他的错，对吧？如果他在动……哇，你是一个非常棒的狙击手。</p><p>但是，如果他处于空位，背后是一堵墙，然后在他认为自己安全的情况下，在几分之一秒后被枪杀了怎么办？</p><p>嗯，这可能发生。这是你做出的权衡。因为你过去向他射击，他在掩护后的几毫秒可能仍会被射杀。</p><p>这有点不公平，但对于每个参与者来说，这是最合适的解决方案。错过了一次不容错过的射击会更糟糕！</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这是我对于快节奏多人游戏的最后一篇文章。很显然很多事情很难做到正确，但是对于正在发生的事情有明确的概念性理解，这并不是很困难。</p><p>虽然这些文章的读者都是游戏开发者，但它也发现了另一群对这个感兴趣的读者：游戏玩家！从游戏玩家的角度来看，理解为什么有些事情以这种方式发生也是非常有趣的。</p><h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><p>尽管这些技术看起来很聪明，但我不能说对它们有任何功劳，这些文章只是我从其他渠道学到的一些概念所整理成的简单易懂的指南，其中包括文章、源代码以及一些实验。</p><p>关于这个主题相关的文章你可以参考：<a href="http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/" target="_blank" rel="noopener">What Every Programmer Needs To Know About Game Networking</a> 与 <a href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization" target="_blank" rel="noopener">Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization</a></p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/03/02/fast-paced-multiplayer-01/">快节奏多人游戏（1）：客户端与服务器架构</a></li><li><a href="/2019/03/06/fast-paced-multiplayer-02/">快节奏多人游戏（2）：客户端预测与服务器协调</a></li><li><a href="/2019/03/10/fast-paced-multiplayer-03/">快节奏多人游戏（3）：实体插值</a></li><li><a href="/2019/03/14/fast-paced-multiplayer-04/">快节奏多人游戏（4）：延迟补偿</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/lag-compensation.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;前面 3 篇文章阐述了游戏客户端-服务器的架构，我们总结如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器从所有客户端获取带有时间戳的输入&lt;/li&gt;
&lt;li&gt;服务器处理输入后更新游戏世界状态&lt;/li&gt;
&lt;li&gt;服务器将游戏世界的快照发送给所有客户端&lt;/li&gt;
&lt;li&gt;客户端发送输入并在本地模拟其效果&lt;/li&gt;
&lt;li&gt;客户端获得游戏世界更新，同步预测状态和权威状态，并插入其他实体已知的过去状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从玩家的角度来看，这里有两个重要的结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;玩家可以看到现在的自己&lt;/li&gt;
&lt;li&gt;玩家可以看到其他实体的过去&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种情况通常表现会不错，但对于时间和空间都非常敏感的事件来说这就会产生问题，例如：爆头射击敌人。&lt;/p&gt;
    
    </summary>
    
      <category term="多人游戏" scheme="https://veinin.com/categories/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="多人游戏" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
      <category term="多人游戏网络同步" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>快节奏多人游戏（3）：实体插值</title>
    <link href="https://veinin.com/2019/03/10/fast-paced-multiplayer-03/"/>
    <id>https://veinin.com/2019/03/10/fast-paced-multiplayer-03/</id>
    <published>2019-03-10T12:05:00.000Z</published>
    <updated>2019-03-20T13:50:04.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本系列的第一篇文章中，我们介绍了权威服务器的概念及其防止客户欺骗的用处。然而，天真地使用这种技术可能会导致关于可玩性和响应性的潜在问题。在第二篇文章中，我们提出了客户端预测作为克服这些限制的方法。</p><p>这两篇文章的最终结果传递的一组概念与技术是允许玩家通过互联网连接到权威的服务器，并在传输延迟的情况下，让玩家以一种完全像玩单机游戏的感觉方式控制游戏中的角色。</p><p>在本文中，我们将对连接到同一服务器的其他玩家进行探索。</p><a id="more"></a><h2 id="服务器时间步长"><a href="#服务器时间步长" class="headerlink" title="服务器时间步长"></a>服务器时间步长</h2><p>在上一篇文章中，我们描述服务器的行为非常简单：它读取客户的输入，更新游戏状态，并发送结果给客户端。但当多个客户端连接时，服务器的主循环将会有所不同。</p><p>在多个客户端同时连接同一个服务器的情况下，多个客户端可能同时发送输入信息，并且速度将非常快（玩家可以快速的发送诸如按箭头按键、移动鼠标或者点击屏幕的输入操作）。服务器接受每个客户端的输入操作然后马上广播更新后的游戏世界状态将是非常消耗CPU和网络带宽的。</p><p>一个更好的方式是对接受的每个客户端输入进行排队，而不需要接受一个就马上进行处理。相反，游戏世界以一个较低的频率周期性的更新。例如每秒更新 10 次，每次更新之间产生的延迟（这种情况下为 100 毫秒），我们称之为步长。在每次更新循环的迭代中，所有未处理的客户都输入指令都将应用到游戏世界中去（处理这些指令的时间增量可能比时间步长更小一些），并将新状态广播给客户端。</p><p>总之，服务器游戏世界里面的更新步长速率是根据客户端的输入而独立存在的，并且是可以被预测的。</p><h2 id="处理低频率更新"><a href="#处理低频率更新" class="headerlink" title="处理低频率更新"></a>处理低频率更新</h2><p>从客户的角度来看，上面提到的方案可以很容易的进程预测，客户都的预测工作因为与延迟无关，因此在相对不频繁的状态更新的中也是可以进行预测的。但是，由于客户端的低频率广播（继续使用100毫秒的示例），客户端得到的关于其他实体可能在游戏中移动的信息是非常少的。</p><p>在下面的第一个实现中，我们将在接受到服务器的状态更新后再更新角色的位置信息，但这回导致角色的运动非常不稳定，你可能看到的是每 100 毫秒玩家就瞬移一次，而不是很平滑的移动到目的地。</p><p><img src="/images/fpm/fpm3-01.png" alt="fpm"></p><p>根据你正在开发的游戏类型中，有很多方法可以解决这个问题。一般来说，你的游戏实体越可预测，那么就越容易做到正确。</p><h2 id="航位（Dead-reckoning）推算"><a href="#航位（Dead-reckoning）推算" class="headerlink" title="航位（Dead reckoning）推算"></a>航位（Dead reckoning）推算</h2><p>假设你正在制作一款赛车游戏，一辆正在快速行驶的汽车是非常容易预测的。例如，如果它以每秒100米的运行速度，一秒钟后它距离开始的地点大约是100米。</p><p>为什么只能是概略的计算呢？因为一秒钟内，汽车可能会加速或者减速，抑或是转向左侧或右侧一点，这里的关键字是“一点”。不管玩家实际在做什么，汽车的可操作性使得其在高速运行时的任何一个时间点的位置高度依赖于其之前的位置、速度和方向<br>。换句话说，赛车是不可能立即就旋转 180 度的。</p><p>这种情况下，我们应该如何在每 100 毫秒的步长情况下发送服务器的更新呢？客户端每收到一次其他车辆的速度和方向后，在接下来的 100 毫秒它将无法再接收到任何新的信息，但客户端却依旧需要显示车辆正在运行。最简单的解决方案是假设汽车的方向和加速度都会在 100 毫秒内保持不变，我们可以使用这个参数在本地运行汽车的物理模拟。然后，100 毫秒后，当服务器的更新到达时，再将汽车的位置进行校正。</p><p>在很多变动的因素下，这些校正的参数可能会很大，当然也可能相对较小。如果玩家确实把汽车保持在直线上并且不改变汽车的速度，那么预测的位置将和校正位置完全相同。另外，如果玩家遭受到了撞击，那么预测的位置可能会有非常大的错误。</p><p>需要注意的是航行位置推算可以应用于低速的情况，例如战舰。事实上，“航位推算”一词来源于海上航行。</p><h2 id="实体插值"><a href="#实体插值" class="headerlink" title="实体插值"></a>实体插值</h2><p>在某些情况下，根本无法运用航位推算，特别是在玩家的方向和速度可以可以立刻改变的情况下。例如，在 3D 射击游戏中，玩家通常会以非常高的速度进行跑动、停止和转向操作，这使得航位推算根本无法应用，因为根据玩家之前的位置和速度的数据根本无法预测接下来会发生什么。</p><p>当服务器发送权威数据时，你不能只更新玩家的位置，这样你只会让玩家每 100 毫秒只更新一次位置，这会让游戏无法继续玩下去。</p><p>你需要解决的是在你拥有的每 100 毫秒的权威位置数据里面，如何和向玩家展示中间发生了什么事情。解决这个问题的关键是展示其他玩家相对当前玩家来说的过去时间。</p><p>假设你在 t = 1000 时收到位置数据，并且你已经在 t = 900 时也收到了数据，因此你现在知道玩家在 t = 900 和 t = 1000 时的位置数据。你可以在 t = 1000 和 t = 1100 显示其他玩家从 t = 900 到 t = 1000 所做的事情。在“延迟”显示100毫秒的情况下，通过这种方式，你始终会显示用户的实际移动数据。</p><p><img src="/images/fpm/fpm3-02.png" alt="fpm"></p><p>用于从 t = 900 到 t = 1000 进行插值的位置数据取决于游戏。通常插值效果以及不错了，如果觉得还不够好，你可以让服务器在每次更新时发送更详细的移动数据。例如，玩家紧随一系列的直线段，或每隔 10 ms 采样一次的位置，这样的插值看起来会更好（在你发送一些增量的小规模移动数据时，你可以针对此特殊情况对线路上的数据格式进行大量优化，因此你不太需要为此发送10倍数量级的数据）。</p><p>请注意，使用这种技术，每个玩家看到游戏世界的渲染都会略有不同，因为每个玩家虽能看到现在的自己，但看到的其他实体却是过去的行为。然而，即使对于快节奏的游戏，看到具有 100 毫秒延迟的其他实体通常也是显而易见的。</p><p>这里有一些例外，当你需要很多空间和时间精度时，例如当玩家向其他玩家射击时，由于看的是过去的其他玩家，你的目标是延迟 100 毫秒的，也就是说，你的射击的是 100 毫秒前目标！我们将在下一篇文章中讨论这个问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在具有权威服务器的客户端-服务器环境中，因为不太频繁的更新与网络延迟，你仍然必须给予每个玩家显示连续性和平稳移动的假象。在本系列文章的第2部分中，我们探索了一种使用客户端预测和服务器协调来实时显示用户控制的玩家的移动方法，这可确保用户输入会立即对本地玩家产生影响，消除因为延迟而导致游戏无法继续下去的影响。</p><p>但是，游戏中的其他实体仍然是个问题。在本文中，我们探讨了两种处理它们的方法。</p><p>第一种方法，航位推算，适用于实体的位置可以从先前的实体数据（例如位置，速度和加速度）进行预估的游戏。当不满足这些条件时，此方法将不可行。</p><p>第二个方法，实体插值，当你根本无法预测实体未来的位置时，且它仅能使用服务器提供的真实实体数据时，你可以显示其他实体时在时间上稍微做一些延迟让步。实际效果是用户能看到玩家自己在当前的实际数据，但其他实体看到的却是过去。这通常会带来难以置信的无缝体验。</p><p>但是，如果不做其他事情，当需要高分辨率和时间精度时，例如对一个移动的目标进行瞄准射击，上面的做法将不可用：当客户端2渲染客户端1的位置与服务器端客户端1的位置不匹配时，这会让爆头射击变得不可用。由于没有了爆头射击功能，游戏也会变得不完整，我们将在下一篇文章中处理这个问题。</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/03/02/fast-paced-multiplayer-01/">快节奏多人游戏（1）：客户端与服务器架构</a></li><li><a href="/2019/03/06/fast-paced-multiplayer-02/">快节奏多人游戏（2）：客户端预测与服务器协调</a></li><li><a href="/2019/03/10/fast-paced-multiplayer-03/">快节奏多人游戏（3）：实体插值</a></li><li><a href="/2019/03/14/fast-paced-multiplayer-04/">快节奏多人游戏（4）：延迟补偿</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/entity-interpolation.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在本系列的第一篇文章中，我们介绍了权威服务器的概念及其防止客户欺骗的用处。然而，天真地使用这种技术可能会导致关于可玩性和响应性的潜在问题。在第二篇文章中，我们提出了客户端预测作为克服这些限制的方法。&lt;/p&gt;
&lt;p&gt;这两篇文章的最终结果传递的一组概念与技术是允许玩家通过互联网连接到权威的服务器，并在传输延迟的情况下，让玩家以一种完全像玩单机游戏的感觉方式控制游戏中的角色。&lt;/p&gt;
&lt;p&gt;在本文中，我们将对连接到同一服务器的其他玩家进行探索。&lt;/p&gt;
    
    </summary>
    
      <category term="多人游戏" scheme="https://veinin.com/categories/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="多人游戏" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
      <category term="多人游戏网络同步" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>快节奏多人游戏（2）：客户端预测与服务器协调</title>
    <link href="https://veinin.com/2019/03/06/fast-paced-multiplayer-02/"/>
    <id>https://veinin.com/2019/03/06/fast-paced-multiplayer-02/</id>
    <published>2019-03-06T14:10:00.000Z</published>
    <updated>2019-03-20T13:49:39.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本系列文章的第一篇文章中，我们探讨了一个客户端-服务器模型，它具有一个权威的服务器和愚蠢的客户端，客户端只是输入发送指令到服务器，然后服务器发送更新后的游戏状态给客户端进行展示。</p><p>该方案的简单实现会导致客户端输入指令和屏幕上的更新之间产生延迟。例如一个玩家按下了右键，角色开始移动前需要等待半秒钟，这是因为客户端的输入必须首先发送给服务器，服务器必须处理输入并计算出最新的游戏状态，并且把更新后的游戏状态再次发送给客户端。</p><p><img src="/images/fpm/fpm2-01.png" alt="fpm"></p><p>在因特网这类网络环境中，这里的延迟可能只是十分之几秒，游戏可能感觉最多时没有反应，或者最坏的情况下，游戏会无法继续玩下去。在本文中，我们将找到最小化延迟甚至消除该问题的方法。</p><a id="more"></a><h2 id="客户端预测"><a href="#客户端预测" class="headerlink" title="客户端预测"></a>客户端预测</h2><p>即使有一些作弊的玩家，大多数的时候服务器都可以处理有效的请求（来自非作弊客户端和欺骗那些在特定时间没有欺骗的客户）。这意味着收到的大部分输入都是有效的，并会按预期更新游戏状态。也就是说，如果你的角色位于坐标（10, 10）并按下右箭头键，它将结束于坐标（11,10）。</p><p>我们可以利用这个优势，如果游戏世界足够确定（即给定游戏状态和一组输入，结果是完全可预测的）。</p><p>假设我们有一个 100 毫秒的延迟，并且从一个方格移动到下一个方格的角色动画也需要 100 毫秒，使用上文提到的简单实现，这个操作加上延迟则需要花费 200 毫秒：</p><p><img src="/images/fpm/fpm2-02.png" alt="fpm"></p><p>由于世界是确定性的，我们可以先假设我们发送到服务器的输入将成功执行。在此假设下，客户端可以在处理输入后预测游戏世界的状态，并且大多数情况下这将是正确的。</p><p>我们可以发送输入并开始渲染输入的结果，就像它们已经成功一样，而不是发送输入并等待新游戏状态开始呈现它。通常情况下，我们等待服务器发送的“真实”游戏状态将匹配本地计算的状态：</p><p><img src="/images/fpm/fpm2-03.png" alt="fpm"></p><p>现在玩家的动作和屏幕上的结果之间绝对没有延迟，而服务器仍然具有权威性（如果被黑客攻击的客户端会发送无效输入，它可以在屏幕上呈现任何想要的内容，但它不会影响服务器状态）。</p><h2 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h2><p>在上面的例子中，我仔细选择了的延迟数字能游戏一切正常。但是，请考虑稍微修改的情况：假设我们对服务器有 250 毫秒的延迟，从正方形移动到下一个需要 100 毫秒。我们可以说玩家连续按下了右键2次，并试图向右移动2个方格。</p><p>使用上面的客户端预测技术，这将会发生以下事情：</p><p><img src="/images/fpm/fpm2-04.png" alt="fpm"></p><p>当新的游戏状态到来时，我们在 t = 250 毫秒遇到一个有趣的问题。客户端此时预测的状态是 x = 12，但服务器说新的游戏状态是 x = 11。由于服务器是权威的，因此客户端必须将角色移回 x = 11。但是，一个新的服务器状态会在 t = 350 到达，表示 x = 12，所以玩家角色将再次跳转到当前正确的游戏状态。</p><p>从玩家的角度来看，他按了两次右箭头键，角色向右移动了两个方格，在那里站了 50 毫秒，向左跳了一个方格，在那里站了 100 毫秒，又向右跳了一个方格。你可以想象，这种游戏体验是不可接受的。</p><h2 id="服务器对账"><a href="#服务器对账" class="headerlink" title="服务器对账"></a>服务器对账</h2><p>解决这个问题的关键是要意识到客户端在当前时间看到游戏世界，但由于滞后，它从服务器获得的更新实际上是过去的游戏状态。当服务器发送更新的游戏状态时，它还没有处理客户端发送的所有命令。</p><p>但是，要解决这个问题并不是非常困难。首先，客户端为每个请求添加序列号，在我们的例子中，第一次按键是请求 #1，第二次按键是请求 #2。然后，当服务器回复时，它包括它处理的最后一个输入的序列号：</p><p><img src="/images/fpm/fpm2-05.png" alt="fpm"></p><p>现在，在 t = 250 时，服务器会说 “基于我看到你的请求 #1，你的位置是 x = 11”。因为服务器是权威的，所以它将字符位置设置为 x = 11。现在让我们假设客户端保留了它发送给服务器的请求的副本。基于新的游戏状态，它知道服务器已经处理了请求 #1，因此它可以丢弃该副本。但它也知道服务器仍然必须发回处理请求 #2 的结果。因此，再次应用客户端预测，客户端可以基于服务器发送的最后权威状态以及服务器尚未处理的输入来计算游戏的“当前”游戏状态。</p><p>因此，在 t = 250 时，客户端收到了 “x = 11，最后处理的请求 = #1” 的消息。客户端会将其发送输入的 #1 副本丢弃掉，但它仍然保留了 #2 的副本，因为该副本尚未得到服务器的确认。它使用服务器发送的内容更新游戏内部状态：x = 11。此时应用服务器仍未看到的所有输入，在这种情况下，输入 #2 的结果是开始向右移动，最终结果是 x = 12，这将是正确的。</p><p>继续上面的例子，在 t = 350 时刻，一个新的游戏状态从服务器到达，这次它说 “x = 12，最后处理的请求 = #2”。此时，客户端丢弃所有到 #2 的输入，并更新状态 x = 12。你可以看到，这里没有处理任何重复的输入，处理结束后，结果也是正确的。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>上面讨论了一个简单的玩家移动的例子，但同样的原则可以应用于几乎所有的其他事物上面。例如，在回合制战斗中，当前玩家攻击另外一个角色，您可以显示攻击血液特效和表示扣血的数字，但没有在服务器返回角色的真正血量之前，你不应该直接更新角色真实的血量情况。</p><p>由于游戏状态的复杂性，并不是很容易把状态逆转回来。你可能希望避免直接预测角色的死亡状态，直到服务器告诉你角色死亡后才真正执行死亡逻辑，虽然有时候角色的血量在客户的游戏状态已经降为 0 以下了（如果另外一个角色在受到致命打击之前使用了急救箱，而此时服务器还没告诉你）。</p><p>这给我们带来了一个有趣的观点，即使游戏世界是完全确定并且没有任何作弊的客户端，客户端预测的状态和服务器发送的状态仍然可能在协调后不匹配。如上所诉，本文的描述不太可能使用在单个玩家身上，但当多个玩家连接到一个服务器上时这些问题很容易就遇到。我们将在下一篇文章继续讲解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用权威的服务器时，你需要等待服务器实际处理的输入时提供一些模拟响应的假象，因此，客户端需要模拟输入的结果，当服务器实际的状态到达时，预测的客户端将从更新的状态中以及客户端发送的输入指令重新计算。</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/03/02/fast-paced-multiplayer-01/">快节奏多人游戏（1）：客户端与服务器架构</a></li><li><a href="/2019/03/06/fast-paced-multiplayer-02/">快节奏多人游戏（2）：客户端预测与服务器协调</a></li><li><a href="/2019/03/10/fast-paced-multiplayer-03/">快节奏多人游戏（3）：实体插值</a></li><li><a href="/2019/03/14/fast-paced-multiplayer-04/">快节奏多人游戏（4）：延迟补偿</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在本系列文章的第一篇文章中，我们探讨了一个客户端-服务器模型，它具有一个权威的服务器和愚蠢的客户端，客户端只是输入发送指令到服务器，然后服务器发送更新后的游戏状态给客户端进行展示。&lt;/p&gt;
&lt;p&gt;该方案的简单实现会导致客户端输入指令和屏幕上的更新之间产生延迟。例如一个玩家按下了右键，角色开始移动前需要等待半秒钟，这是因为客户端的输入必须首先发送给服务器，服务器必须处理输入并计算出最新的游戏状态，并且把更新后的游戏状态再次发送给客户端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fpm/fpm2-01.png&quot; alt=&quot;fpm&quot;&gt;&lt;/p&gt;
&lt;p&gt;在因特网这类网络环境中，这里的延迟可能只是十分之几秒，游戏可能感觉最多时没有反应，或者最坏的情况下，游戏会无法继续玩下去。在本文中，我们将找到最小化延迟甚至消除该问题的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="多人游戏" scheme="https://veinin.com/categories/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="多人游戏" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
      <category term="多人游戏网络同步" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>快节奏多人游戏（1）：客户端与服务器架构</title>
    <link href="https://veinin.com/2019/03/02/fast-paced-multiplayer-01/"/>
    <id>https://veinin.com/2019/03/02/fast-paced-multiplayer-01/</id>
    <published>2019-03-02T13:13:37.000Z</published>
    <updated>2019-03-20T13:49:28.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是探索使快节奏多人游戏成为可能的技术和算法的系列文章中的第一篇。下面只是一个介绍性的入门讨论，如果你已经熟悉多人游戏设计背后的理念，你可以跳到下一篇文章。</p><p>开发任何类型的游戏本身都是具有非常大的挑战性的。然而，多人游戏却增加了很多需要我们处理的新问题。有趣的是，其核心问题却是人性和物理！</p><h2 id="作弊问题"><a href="#作弊问题" class="headerlink" title="作弊问题"></a>作弊问题</h2><p>多人游戏的一切都始于作弊。</p><p>作为一个游戏开发者，你通常并不关心一个玩家是否在一个买断制的单机游戏中作弊，你也不用关心他的行为是否会影响其他玩家。作弊的玩家可能无法完全按照你的计划去体验游戏，但是由于他们购买了游戏，所以他们有权以任何他们喜欢的方式玩游戏。</p><p>而多人游戏与单机游戏则恰恰相反。在任何有竞争性的游戏当中，玩家作弊的目的可能只是为了让自己更好，但往往这种作弊行为同时也会让其他玩家对游戏的体验变得更糟。作为开发人员，你必须避免这种情况的发生，因为只要有一个作弊玩家的存在往往会导致更多的其他玩家离去，最后你的游戏也会变得没有任何人玩。</p><p>有许许多多的防止游戏中作弊的方法，但其中最重要的一个（可能也是唯一有意义的一个）却很简单：不要相信玩家，总是假设最坏的情况–玩家会试图作弊。</p><a id="more"></a><h2 id="权威的服务器和愚蠢的客户端"><a href="#权威的服务器和愚蠢的客户端" class="headerlink" title="权威的服务器和愚蠢的客户端"></a>权威的服务器和愚蠢的客户端</h2><p>这里有一个看似很简单的解决方案：你可以让游戏中的所有内容都发生在你控制的中央服务器中，并使客户端成为游戏的特权观众。换句话说，你的游戏客户端将输入（按键、指令）发送到服务器，而服务器运行着游戏，并处理玩家的输入，把运行的结果发送回客户端。我们叫这种服务器为“权威性服务器”，因为服务器有权触发游戏时间中发生的任何事情。</p><p>当然，你的服务器可能会被某个漏洞利用，但这超出了本系列文章的范围。但是，使用权威的服务器可以防止各种各样的黑客攻击。例如，如果你不信任游戏中客户端的玩家HP的数值状态，当被客户端被黑客攻击并修改其本地的HP数值时，告诉服务器它的HP数值增加了10000%，但服务器其实是知道玩家血量只有1%，当受到其玩家攻击时，服务器就会判断其死亡，无论黑客对客户端做了任何修改都是徒劳无功的。</p><p>另外一个简单的例子中，对于玩家在游戏时间上的坐标位置。如果你让客户端告知服务器其所处的位置，那么如果受到黑客攻击，玩家上一秒在位置 (10, 10)，一秒钟后可能就变成 (20, 10) 坐标的情况，玩家可能会很轻易就穿越一堵墙，或者跑的比其他玩家更快。相反，在一个权威的服务器中，如果让服务器知道玩家所处的位置，客户端告诉服务器“我想向右移动一个方格”，服务器用 (11, 10) 更新玩家位置的变化，并回复客户端“你现在的位置在 (11, 10)”。</p><p><img src="/images/fpm/fpm1-01.png" alt="fpm"></p><p>总之，游戏状态仅由服务器来管理。客户端将操作发送给服务器。服务器定时更新游戏状态，然后将新游戏状态发送回客户端，客户端只是在屏幕上呈现更新后的状态。</p><h2 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h2><p>愚蠢的客户端方案在慢节奏的回合制游戏中会工作的很正常，例如战略游戏和扑克牌。它也适用于局域网，在所有实际应用中，通信都是即时的。但是，用游戏运用于互联网进行快节奏的游戏时，这一切都会被打破。</p><p>我们来谈谈网络中物理相关的知识。假设你在旧金山，连接到纽约的服务器，那是大约 4000 公里，没有什么东西能比光传输的更快，甚至互联网上的传输的字节（在较低级别是光脉冲，电缆中的电子或电磁波），光大约以 300000 km/s 的速度行进，因此传输 4000 公里大约需要 13 毫秒。</p><p>这可能听起来非常快，但它实际上是一个非常乐观的数据，它假设数据是以直线路径的光速传播的，但实际上很少有这种情况。在现实生活中，数据经历了路由器的一系列跳转，其中大多数都不是在光速中进行的，每个路由器自身也会引入一些延迟，因为数据包往往需要拷贝、校验以及重新路由等操作。</p><p>为了论证，我们假设从客户端到服务器的数据传输需要50毫秒，这可能是最佳的情况。但是如果你在纽约连接到东京的服务器会发生了什么呢？如果由于某种原因出现网络拥塞怎么办？延迟可能会是100毫秒、200毫秒，甚至高达500毫秒。</p><p>回到我们上一个例子，你的客户端向服务器发送了一个输入：我按下了右箭头，服务器在50毫秒后获得它，假设服务器处理请求并立即发回更新的状态。您的客户端在50毫秒后获得最新的游戏状态：你现在处于位置 (1, 0)。从你的角度来看，在你按下右箭头的 1/10 秒内没有发生任何事情，然后你的角色终于向右移动了一个方格，你的输入与输出的结果的显示延迟看起来并不多，但它们是显而易见的。当然，如果你的延迟在半秒以上，你的游戏甚至会因为出现卡顿而无法继续进行下去。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>联网的多人游戏非常有趣，但它也引入了一系列全新的挑战。权威的服务器架构非常擅长阻止大多数的作弊，但其实现可能会使游戏中的操作产生延迟，并使玩家感到反应迟钝。</p><p>在下面的文章中，我们将探讨如何构建一个权威服务器的系统，同时最大限度的减少玩家所经历的操作延迟，使其几乎与本地单人游戏无任何区别。</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/03/02/fast-paced-multiplayer-01/">快节奏多人游戏（1）：客户端与服务器架构</a></li><li><a href="/2019/03/06/fast-paced-multiplayer-02/">快节奏多人游戏（2）：客户端预测与服务器协调</a></li><li><a href="/2019/03/10/fast-paced-multiplayer-03/">快节奏多人游戏（3）：实体插值</a></li><li><a href="/2019/03/14/fast-paced-multiplayer-04/">快节奏多人游戏（4）：延迟补偿</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/client-server-game-architecture.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;这是探索使快节奏多人游戏成为可能的技术和算法的系列文章中的第一篇。下面只是一个介绍性的入门讨论，如果你已经熟悉多人游戏设计背后的理念，你可以跳到下一篇文章。&lt;/p&gt;
&lt;p&gt;开发任何类型的游戏本身都是具有非常大的挑战性的。然而，多人游戏却增加了很多需要我们处理的新问题。有趣的是，其核心问题却是人性和物理！&lt;/p&gt;
&lt;h2 id=&quot;作弊问题&quot;&gt;&lt;a href=&quot;#作弊问题&quot; class=&quot;headerlink&quot; title=&quot;作弊问题&quot;&gt;&lt;/a&gt;作弊问题&lt;/h2&gt;&lt;p&gt;多人游戏的一切都始于作弊。&lt;/p&gt;
&lt;p&gt;作为一个游戏开发者，你通常并不关心一个玩家是否在一个买断制的单机游戏中作弊，你也不用关心他的行为是否会影响其他玩家。作弊的玩家可能无法完全按照你的计划去体验游戏，但是由于他们购买了游戏，所以他们有权以任何他们喜欢的方式玩游戏。&lt;/p&gt;
&lt;p&gt;而多人游戏与单机游戏则恰恰相反。在任何有竞争性的游戏当中，玩家作弊的目的可能只是为了让自己更好，但往往这种作弊行为同时也会让其他玩家对游戏的体验变得更糟。作为开发人员，你必须避免这种情况的发生，因为只要有一个作弊玩家的存在往往会导致更多的其他玩家离去，最后你的游戏也会变得没有任何人玩。&lt;/p&gt;
&lt;p&gt;有许许多多的防止游戏中作弊的方法，但其中最重要的一个（可能也是唯一有意义的一个）却很简单：不要相信玩家，总是假设最坏的情况–玩家会试图作弊。&lt;/p&gt;
    
    </summary>
    
      <category term="多人游戏" scheme="https://veinin.com/categories/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="多人游戏" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
      <category term="多人游戏网络同步" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>寻路算法揭秘（4）：实用 A* 算法</title>
    <link href="https://veinin.com/2019/02/28/pathfinding-demystified-04/"/>
    <id>https://veinin.com/2019/02/28/pathfinding-demystified-04/</id>
    <published>2019-02-28T14:13:45.000Z</published>
    <updated>2019-03-25T16:00:50.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本系列的前三篇文章从寻路算法的基础知识开始，最后非常清晰明了地阐述了A *算法。这在理论上是很好的，但对于理解如何在实践中应用它却是一个不同的主题。</p><p>例如，如果你的世界不是网格怎么办？</p><p>如果你的角色不能瞬间旋转90度怎么办？</p><p>如果你的世界是无限的，你又该如何建立一个图表？</p><p>如果您不关心路径上的长度，但是您依赖太阳光并且需要尽可能地在阳光下呢？</p><p>如何找到两个目标节点中任何一个的最短路径？</p><a id="more"></a><h2 id="成本（Cost）函数"><a href="#成本（Cost）函数" class="headerlink" title="成本（Cost）函数"></a>成本（Cost）函数</h2><p>在最初的示例中，我们搜索了从开始节点到目标节点之间的最短路径。然而，我们没有将路径长度存储在一个变量 <code>length</code> 中，而是将其命名为 <code>cost</code>，为什么呢？</p><p>A* 搜索不仅仅能搜索到最短路径，还可以搜索到你定义的“最好”的路径，这对我们的目标是有好处的。当我们想要最短路径时，代价时路径的长度；但当我们想要最小化，比如说，燃料消耗，那就得把它当作消耗成本（cost）；如果你想最大化“阳光下的时间”，那么成本就是没有阳光的时间。诸如此类…</p><p>这通常意味着图中的每一条边都与一个特定的成本相关。在最初的例子中，因为我们在计算路径上的步长，路径的成本是隐式的，假设它总是为 1，但是你可以根据你想要的最小化的任何值来调整每条边的成本。</p><h2 id="目标（Goal）函数"><a href="#目标（Goal）函数" class="headerlink" title="目标（Goal）函数"></a>目标（Goal）函数</h2><p>假设你是一辆汽车，需要去加油站。任何加油站都可以。您想要到最短的路径的最近加油站。</p><p>一种天真的方法是依次计算到每个加油站的最短路径，然后选择最短的路径。这会奏效，但这会非常浪费。</p><p>你可以做的是用过一个方法来替换单一的目标节点（goal_node），这个方法根据给定的节点来判断是否是目标节点。这样你可以同时寻找多个目标，你还可以调整启发式算法，以返回所有可能目标的最小估计成本。</p><p>根据你的具体情况，你可能无法准确到达目标，或者这样做成本很高（如果你在一张巨大的地图中传送一个角色，你会在一哪怕一英寸的差距吗？），因此，方法 <code>is_goal_node</code> 可以在“足够接近”时返回 <code>true</code>。</p><h2 id="不需要很明确"><a href="#不需要很明确" class="headerlink" title="不需要很明确"></a>不需要很明确</h2><p>将世界表示为离散的网格对于许多游戏来说可能不够好。例如，考虑第一人称射击游戏或赛车游戏，世界是离散的，你不能用网格来表示它。</p><p>但这还有一个更大的难题，如果世界是无限大的呢？在这种情况下，即使你可以把它表示成为一个网格，你也不能建立与网格相对应的图形，因为它是一个无限大的图像。</p><p>然而，希望并没有丧失。我们确实需要一个图表来运行图形搜索算法，但是没人说图表必须是明确的。</p><p>如果仔细查看算法，你会注意到我们对图表整体没有做任何事情。相反，我们通过正在考虑的节点中获取可以到达的节点，正如 A* 算法演示中看到的，图中的一些节点根本没有被探索过。</p><p>那么，如果我们只是在搜索时才去构建图形该怎么办？</p><p>我们将起始节点设置为当前角色的位置。无论何时调用方法 <code>get_adjacent_nodes</code>，它都可以找出角色从给定节点移动的可能方向，并在运行中创建相邻节点。</p><h2 id="超越三重维度"><a href="#超越三重维度" class="headerlink" title="超越三重维度"></a>超越三重维度</h2><p>即使您的世界是 2D 网格，也需要考虑其他因素。例如，如果你的角色不能瞬间转90度或180度，这种情况该怎么办？</p><p>每个搜索节点所代表的状态步兵局限于某个位置，相反，它可以包括一组任意复杂的值。例如，如果旋转90度从一个方块走到另外一个方块所需的时间相同，那么角色的状态可以是： [坐标(position), 航向(heading)]。现在，每个节点不仅仅表示角色的位置，还表示角色的航向，图的每一条新边（隐式或显示）反应了这一点。</p><p>回到最初的 5x5 的网格，现在搜索的起始坐标可能是 [A, East]，相邻节点现在则是 [B, East] 和 [A, South]。如果你想到达 F 节点，首先你需要先修正你的航向，所以路径将是 [A, East] -&gt; [A, South] -&gt; [F, South]。</p><p>而第一人称射击游戏呢？你至少需要四个维度：[X, Y, Z, 航向]，设置可能是：[X, Y, Z, 航向, 血量, 弹药]。</p><p>请注意，状态越复杂，启发式函数也就会越复杂。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这几篇文章的目的是一劳永逸的消除 A* 算法是一种神秘的，难以理解的感觉。相反，我已经证明了它没有什么神秘之处。事实上，它可以用一种非常直接的方式从0开始推导出来。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>阿米特·帕特尔（Amit Patel）有一篇非常好的关于 <a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html" target="_blank" rel="noopener">A* 算法介绍</a>，当然他的其他主题文章也是非常棒的。</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/02/18/pathfinding-demystified-01/">寻路算法揭秘（1）：通用搜索</a></li><li><a href="/2019/02/20/pathfinding-demystified-02/">寻路算法揭秘（2）：搜索策略</a></li><li><a href="/2019/02/23/pathfinding-demystified-03/">寻路算法揭秘（2）：A* 解密</a></li><li><a href="/2019/02/28/pathfinding-demystified-04/">寻路算法揭秘（3）：实用 A* 算法</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/generic-search.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;本系列的前三篇文章从寻路算法的基础知识开始，最后非常清晰明了地阐述了A *算法。这在理论上是很好的，但对于理解如何在实践中应用它却是一个不同的主题。&lt;/p&gt;
&lt;p&gt;例如，如果你的世界不是网格怎么办？&lt;/p&gt;
&lt;p&gt;如果你的角色不能瞬间旋转90度怎么办？&lt;/p&gt;
&lt;p&gt;如果你的世界是无限的，你又该如何建立一个图表？&lt;/p&gt;
&lt;p&gt;如果您不关心路径上的长度，但是您依赖太阳光并且需要尽可能地在阳光下呢？&lt;/p&gt;
&lt;p&gt;如何找到两个目标节点中任何一个的最短路径？&lt;/p&gt;
    
    </summary>
    
      <category term="寻路算法" scheme="https://veinin.com/categories/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="寻路算法" scheme="https://veinin.com/tags/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*" scheme="https://veinin.com/tags/A/"/>
    
  </entry>
  
  <entry>
    <title>寻路算法揭秘（3）：A* 解密</title>
    <link href="https://veinin.com/2019/02/23/pathfinding-demystified-03/"/>
    <id>https://veinin.com/2019/02/23/pathfinding-demystified-03/</id>
    <published>2019-02-23T12:21:00.000Z</published>
    <updated>2019-03-25T16:00:36.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本系列文章中的第一篇介绍了通用的寻路算法，每种不同类型的寻路算法背后都是它的一个微小变化。</p><p>第二篇文章揭示了不同搜索算法背后的秘密：这一切都要归结于 <code>choose_node</code> 函数。它还提供了一个相当简单的 <code>choose_node</code> 函数来生成一个称为<strong>统一搜索成本</strong>的算法。</p><p>这个算法非常好：它将找到从开始节点到目标节点的最短路径。然而，它也有一点点浪费：它会前往人们可以很容易察觉到的错误路径节点，这往往会让目标偏移，我们能避免这种情况的发生吗？</p><h2 id="魔术算法"><a href="#魔术算法" class="headerlink" title="魔术算法"></a>魔术算法</h2><p>想象一下，我们在一台特殊的计算机上运行搜索算法，它拥有一个可以变魔术的芯片。有了这个很棒的芯片，我们就能用一种非常简单的方式来表达 <code>choose_node</code> 函数，它保证产生最短的路径，不会浪费时间去探索那些不会通向目标地方的道路:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function choose_node (reachable):</span><br><span class="line">    return magic(reachable, &quot;最短路径的下一个节点是什么&quot;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>虽然这很诱人，但是神奇的芯片仍然需要一些更低级别的代码，下面是一个类似的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function choose_node (reachable):</span><br><span class="line">    min_cost = infinity</span><br><span class="line">    best_node = None</span><br><span class="line"></span><br><span class="line">    for node in reachable:</span><br><span class="line">        cost_start_to_node = node.cost</span><br><span class="line">        cost_node_to_goal = magic(node, &quot;shortest path to the goal&quot;)</span><br><span class="line">        total_cost = cost_start_to_node + cost_node_to_goal</span><br><span class="line"></span><br><span class="line">        if min_cost &gt; total_cost:</span><br><span class="line">            min_cost = total_cost</span><br><span class="line">            best_node = node</span><br><span class="line"></span><br><span class="line">    return best_node</span><br></pre></td></tr></table></figure><p>这是选择下一个节点的好方式：我们选择从开始节点到目标节点的最短路径，而这正是我们想要的。</p><p>我们还最大幅度的减少了魔法的使用：我们确切的知道从起始节点到目标节点（即node.cost）所需成本，并且我们只是使用魔法来预测从当前节点前往目标节点的成本。</p><h2 id="不神奇但是非常棒的-A-算法"><a href="#不神奇但是非常棒的-A-算法" class="headerlink" title="不神奇但是非常棒的 A* 算法"></a>不神奇但是非常棒的 A* 算法</h2><p>不幸的是，魔术芯片很新，但我们希望其支持传统的硬件。上面大多数代码都没问题，除了这一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 抛出麻瓜处理器异常</span><br><span class="line">cost_node_to_goal = magic(node, &quot;shortest path to the goal&quot;)</span><br></pre></td></tr></table></figure><p>所以，我们并不能用魔法来知道我们尚未探索的道路的成本。很好，那让我们来猜猜看，我们很乐观，所以我们假设当前节点到目标节点之间没有任何东西，我们可以直接走：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cost_node_to_goal = distance(node, goal_node)</span><br></pre></td></tr></table></figure><p>注意，最短路径和最小距离是不同的：最小距离假定了当前节点和目标节点之间绝对没有障碍物。</p><p>这个假设当然非常简单。在我们基于网格的示例种，它是两个节点之间的曼哈顿距离，而所谓“曼哈顿距离”是指两点在在东西方向上的距离加上南北方向上的距离，即：abs(Ax - Bx) + abs(Ay - By)。如果你可以移动到对角线，则它的距离会是：sqrt( (Ax - Bx)^2 + (Ay - By)^2)。诸如此类，但最重要的是永远不要高估道路的成本。</p><p>所以，下面是一个没有魔法的 <code>choose_node</code> 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function choose_node (reachable):</span><br><span class="line">    min_cost = infinity</span><br><span class="line">    best_node = None</span><br><span class="line"></span><br><span class="line">    for node in reachable:</span><br><span class="line">        cost_start_to_node = node.cost</span><br><span class="line">        cost_node_to_goal = estimate_distance(node, goal_node)</span><br><span class="line">        total_cost = cost_start_to_node + cost_node_to_goal</span><br><span class="line"></span><br><span class="line">        if min_cost &gt; total_cost:</span><br><span class="line">            min_cost = total_cost</span><br><span class="line">            best_node = node</span><br><span class="line"></span><br><span class="line">    return best_node</span><br></pre></td></tr></table></figure><p>预估从节点到目标节点的距离的函数成为<strong>启发式算法</strong>，观众朋友们，我们称这种算法叫做 _A*_。</p><h2 id="在线演示"><a href="#在线演示" class="headerlink" title="在线演示"></a>在线演示</h2><p>当你从意识到神秘的 _A*_ 算法实际上那么简单的震惊中恢复过来时，这里有一个你可以试玩的演示。与前面的示例不同，你会注意到整个搜索在错误的方向上浪费的时间非常少。</p><script src="http://www.gabrielgambetta.com/js/path_helpers.js"></script><table><tr><td><canvas width="401" height="401" id="demo"></canvas></td><td><p id="reachable" style="color:green; font-family:courier;">reachable = []</p><p id="explored" style="color:red; font-family:courier;">explored = []</p><p id="path" style="font-family:courier;"></p><p><input type="button" value="Restart" onclick="stopRunSearch(); search.reset();"> <input type="button" value="Step" onclick="stopRunSearch(); search.step();"> <input type="button" value="Run" onclick="runSearch();"></p></td></tr></table><script>// Choose the node with the lowest path cost.Search.prototype.chooseNode = function() {    // return this.reachable[Math.floor(Math.random() * this.reachable.length)];    var min_cost = Infinity;    var best_node = undefined;    for (var i in this.reachable) {        var node = this.reachable[i];        // Compute Manhattan distance to goal.        var idx = getNodeIndex(node, this.graph.nodes);        var nr = Math.floor(idx / this.graph.cols);        var nc = idx % this.graph.cols;         idx = getNodeIndex(this.goal_node, this.graph.nodes);        var gr = Math.floor(idx / this.graph.cols);        var gc = idx % this.graph.cols;         var node_to_goal_distance_estimate = Math.abs(nr - gr) + Math.abs(nc - gc);        var total_cost = node.cost + node_to_goal_distance_estimate;        if (total_cost < min_cost) {            min_cost = total_cost;            best_node = node;        }    }    return best_node;}Search.prototype.addAdjacent = function(node, adjacent) {    if (findNode(adjacent, this.explored)) {        return;    }    if (!findNode(adjacent, this.reachable)) {        this.reachable.push(adjacent);    }    if (adjacent.cost > node.cost + 1) {        adjacent.cost = node.cost + 1;        adjacent.previous = node;    }}// Build the grid used in the example.// "*" represent a blocked square, " " an open one.var graph = new Graph(["          ",                       "          ",                       "          ",                       "          ",                       "          ",                       "          ",                       "        * ",                       "       ** ",                       "      **  ",                       "          "]);var stepDelay = 100;var search = new Search(graph, "BN", "CK");search.reset();render(search);</script><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们最终得到了 _A*_ 算法，它只不过是第一篇文章中描述的通用搜索算法，在第二篇文章的描述中加入了一些改进，使用 <code>choose_node</code> 函数选择我们预估的节点将使我们更加接近目标，仅此而已。</p><p>参照上面的结论，我们给出了主要方法的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function find_path(start_node, goal_node):</span><br><span class="line">    reachable = [start_node]</span><br><span class="line">    explored = []</span><br><span class="line"></span><br><span class="line">    while reachable is not empty:</span><br><span class="line">        # 选择一个我们知道如何到达的节点</span><br><span class="line">        node = choose_node(reachable)</span><br><span class="line"></span><br><span class="line">        # 如果我们刚好到达了目标节点，则构建并返回路径。</span><br><span class="line">        if node == goal_node:</span><br><span class="line">            return build_path(goal_node)</span><br><span class="line"></span><br><span class="line">        # 记录已经处理的节点，防止重复处理</span><br><span class="line">        reachable.remove(node)</span><br><span class="line">        explored.add(node)</span><br><span class="line"></span><br><span class="line">        # 我们能从这个节点得到我们以前没有探索过的新节点</span><br><span class="line">        new_reachable = get_adjacent_node(node) - explored</span><br><span class="line">        for adjacent in new_reachable:</span><br><span class="line">            # 是不是第一次抵达这个节点</span><br><span class="line">            if adjacent not in reachable:</span><br><span class="line">                reachable.add(adjacent)</span><br><span class="line"></span><br><span class="line">            # 如果这是一个新路径，或者比现有的路径更短，则保留它</span><br><span class="line">            if node.cost + 1 &lt; adjacent.cost:</span><br><span class="line">                adjacent.previous = node</span><br><span class="line">                adjacent.cost = node.cost + 1</span><br><span class="line"></span><br><span class="line">    # 如果我们到达了这里，则路径没有找到</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure><p><code>build_path</code> 方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function build_path(to_node):</span><br><span class="line">    path = []</span><br><span class="line">    while to_node != None:</span><br><span class="line">        path.add(to_node)</span><br><span class="line">        to_node = to_node.previous</span><br><span class="line">    return path</span><br></pre></td></tr></table></figure><p>使用 A* 算法实现的 <code>choose_node</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function choose_node(reachable):</span><br><span class="line">    min_cost = infinity</span><br><span class="line">    best_node = None</span><br><span class="line"></span><br><span class="line">    for node in reachable:</span><br><span class="line">        cost_start_to_node = node.cost</span><br><span class="line">        cost_node_to_goal = estimate_distance(node, goal_node)</span><br><span class="line">        total_cost = cost_start_to_node + cost_node_to_goal</span><br><span class="line"></span><br><span class="line">        if min_cost &gt; total_cost:</span><br><span class="line">            min_cost = total_cost</span><br><span class="line">            best_node = node</span><br><span class="line"></span><br><span class="line">    return best_node</span><br></pre></td></tr></table></figure><p>经此而已。</p><p>那么为什么本系列文章还有第四部分？</p><p>现在你已经了解了 _A*_ 算法的工作原理，我想探索一些令人难以置信的应用程序，而不仅仅是在一个正方形的网格中搜索路径。</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/02/18/pathfinding-demystified-01/">寻路算法揭秘（1）：通用搜索</a></li><li><a href="/2019/02/20/pathfinding-demystified-02/">寻路算法揭秘（2）：搜索策略</a></li><li><a href="/2019/02/23/pathfinding-demystified-03/">寻路算法揭秘（2）：A* 解密</a></li><li><a href="/2019/02/28/pathfinding-demystified-04/">寻路算法揭秘（3）：实用 A* 算法</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/generic-search.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;本系列文章中的第一篇介绍了通用的寻路算法，每种不同类型的寻路算法背后都是它的一个微小变化。&lt;/p&gt;
&lt;p&gt;第二篇文章揭示了不同搜索算法背后的秘密：这一切都要归结于 &lt;code&gt;choose_node&lt;/code&gt; 函数。它还提供了一个相当简单的 &lt;code&gt;choose_node&lt;/code&gt; 函数来生成一个称为&lt;strong&gt;统一搜索成本&lt;/strong&gt;的算法。&lt;/p&gt;
&lt;p&gt;这个算法非常好：它将找到从开始节点到目标节点的最短路径。然而，它也有一点点浪费：它会前往人们可以很容易察觉到的错误路径节点，这往往会让目标偏移，我们能避免这种情况的发生吗？&lt;/p&gt;
&lt;h2 id=&quot;魔术算法&quot;&gt;&lt;a href=&quot;#魔术算法&quot; class=&quot;headerlink&quot; title=&quot;魔术算法&quot;&gt;&lt;/a&gt;魔术算法&lt;/h2&gt;&lt;p&gt;想象一下，我们在一台特殊的计算机上运行搜索算法，它拥有一个可以变魔术的芯片。有了这个很棒的芯片，我们就能用一种非常简单的方式来表达 &lt;code&gt;choose_node&lt;/code&gt; 函数，它保证产生最短的路径，不会浪费时间去探索那些不会通向目标地方的道路:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function choose_node (reachable):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return magic(reachable, &amp;quot;最短路径的下一个节点是什么&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="寻路算法" scheme="https://veinin.com/categories/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="寻路算法" scheme="https://veinin.com/tags/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*" scheme="https://veinin.com/tags/A/"/>
    
  </entry>
  
  <entry>
    <title>寻路算法揭秘（2）：搜索策略</title>
    <link href="https://veinin.com/2019/02/20/pathfinding-demystified-02/"/>
    <id>https://veinin.com/2019/02/20/pathfinding-demystified-02/</id>
    <published>2019-02-20T10:20:00.000Z</published>
    <updated>2019-03-25T15:57:58.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本系列第一篇文章介绍了通用寻路算法。如果你没有完全理解它，请返回并重新阅读，因为其对你了解后面的内容至关重要，一旦你掌握了它，A* 算法将是世界上最自然的事情。</p><h2 id="秘制酱汁"><a href="#秘制酱汁" class="headerlink" title="秘制酱汁"></a>秘制酱汁</h2><p>我在上一章结尾处留下了两个悬而未决的问题：如果每一种寻路算法都使用相同的代码，是什么让 A<em> 的行为看起来像 A</em> 呢？而为什么上一章的演示实例会找出不同的路径呢？</p><p>这两个问题的答案是非常相关联的。尽管算法定义得很好，但有一个方面我故意含糊不清，事实证明，它是解释搜索算法行为的关键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node = choose_node(reachable)</span><br></pre></td></tr></table></figure><p>那些看起来很无辜的线使得每个搜索算法都与众不同。<code>choose_node</code> 所作的选择会让世界看起来不同。</p><p>那么为什么上一章的演示实例会找出不同的路径呢？答案是因为 <code>choose_node</code> 方法随机选择了一个节点。</p><a id="more"></a><h2 id="长度很重要"><a href="#长度很重要" class="headerlink" title="长度很重要"></a>长度很重要</h2><p>在深入研究 <code>choose_node</code> 函数的不同行为之前，根据前面的解释，我们需要对算法中存在的一点疏忽进行修正。</p><p>每当我们考虑与当前节点的相邻节点是，我们忽略了那些我们已经知道如何到达的节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if adjacent not in reachable:</span><br><span class="line">    adjacent.previous = node  # 记住我们是如何抵达这个节点的</span><br><span class="line">    reachable.add(adjacent)</span><br></pre></td></tr></table></figure><p>这里犯了一个错误：如果我们刚好发现一个更好的到达此节点的方式呢？在这种情况下，我们应该应该调整这个节点的前驱节点来使到达此节点的路径更短。</p><p>为此，我们需要知道从起始节点到任何可达的节点之间的路径长度，我们称这种长度为 <code>cost</code>。现在让我们假设从一个节点移动到一个相邻节点的固定花费（cost）为 1。</p><p>在开始搜索之前，我们先设置每个节点的 <code>cost</code> 为值 <code>infinity</code>，这使得任何路径都比这个值要短。我们还需要设置到达 <code>start_node</code> 节点的 <code>cost</code> 为 0。</p><p>所以现在代码看起来是这样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if adjacent not in reachable:</span><br><span class="line">    reachable.add(adjacent)</span><br><span class="line"></span><br><span class="line"># 如果这是一条新路径，或者比现有的路径更断，则保留它。</span><br><span class="line">if node.cost + 1 &lt; adjacent.cost:</span><br><span class="line">    adjacent.previous = node</span><br><span class="line">    adjacent.cost = node.cost + 1</span><br></pre></td></tr></table></figure><h2 id="统一的搜索成本"><a href="#统一的搜索成本" class="headerlink" title="统一的搜索成本"></a>统一的搜索成本</h2><p>现在让我们关注 <code>choose_node</code>(选择节点) 方法。如果我们想要得到尽可能短的路径，随机选择一个节点显然不是一个很好的主意。</p><p>一个更好的方法是选择从开始节点可以到达最短路径的节点。这通常会选择较短的路径，而不是较长的路径。当然，这并不意味着不考虑较长的路径，而是优先考虑较短的路径。因为一旦找到有效路径，算法就会停止，这应该就是我们的较短路径。</p><p>这里是一种可能的 <code>choose_node</code> 函数实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function choose_node (reachable):</span><br><span class="line">    best_node = None</span><br><span class="line"></span><br><span class="line">    for node in reachable:</span><br><span class="line">        if beat_node == None or best_node &gt; node.cost:</span><br><span class="line">            best_node = node</span><br><span class="line"></span><br><span class="line">    return best_node</span><br></pre></td></tr></table></figure><p>直观的说，该算法的搜索从开始节点“径向”展开，直到抵达结束节点。下面是这种搜索行为的Demo演示:</p><script src="http://www.gabrielgambetta.com/js/path_helpers.js"></script><table><tr><td><canvas width="401" height="401" id="demo"></canvas></td><td><p id="reachable" style="color:green; font-family:courier;">reachable = []</p><p id="explored" style="color:red; font-family:courier;">explored = []</p><p id="path" style="font-family:courier;"></p><p><input type="button" value="Restart" onclick="stopRunSearch(); search.reset();"> <input type="button" value="Step" onclick="stopRunSearch(); search.step();"> <input type="button" value="Run" onclick="runSearch();"></p></td></tr></table><script>// Choose the node with the lowest path cost.Search.prototype.chooseNode = function() {    // return this.reachable[Math.floor(Math.random() * this.reachable.length)];    var min_cost = Infinity;    var best_node = undefined;    for (var i in this.reachable) {        var node = this.reachable[i];        if (node.cost < min_cost) {            min_cost = node.cost;            best_node = node;        }    }    return best_node;}Search.prototype.addAdjacent = function(node, adjacent) {    if (findNode(adjacent, this.explored)) {        return;    }    if (!findNode(adjacent, this.reachable)) {        this.reachable.push(adjacent);    }    if (adjacent.cost > node.cost + 1) {        adjacent.cost = node.cost + 1;        adjacent.previous = node;    }}// Build the grid used in the example.// "*" represent a blocked square, " " an open one.var graph = new Graph(["          ",                       "          ",                       "          ",                       "          ",                       "          ",                       "          ",                       "        * ",                       "       ** ",                       "      **  ",                       "          "]);var stepDelay = 100;var search = new Search(graph, "BN", "CK");search.reset();render(search);</script><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在选择下一个要考虑的节点方式上做一个非常简单的改变，就可以得到一个非常好的搜索算法：找到从开始节点到目标节点的最短路径。</p><p>在某种程度上，这仍然是个愚蠢的做法。算法会一直漫无目的的寻找，直到它偶然发现了目标节点。在上面的例子中，当我们在朝着 A 节点方向搜索时却距离目标节点越来越远，这有什么意义呢？</p><p>我们能让 <code>choose_node</code> 方法更加智能吗？即使事先不知道正确的方向，也能让它朝着目标不断迈进。</p><p>事实证明我们是可以做到的，在下一篇文章中，我们最终会得到更加完善的 <code>choose_node</code> 方法，它会使常规的寻路算法变成 A*。</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/02/18/pathfinding-demystified-01/">寻路算法揭秘（1）：通用搜索</a></li><li><a href="/2019/02/20/pathfinding-demystified-02/">寻路算法揭秘（2）：搜索策略</a></li><li><a href="/2019/02/23/pathfinding-demystified-03/">寻路算法揭秘（2）：A* 解密</a></li><li><a href="/2019/02/28/pathfinding-demystified-04/">寻路算法揭秘（3）：实用 A* 算法</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/generic-search.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;本系列第一篇文章介绍了通用寻路算法。如果你没有完全理解它，请返回并重新阅读，因为其对你了解后面的内容至关重要，一旦你掌握了它，A* 算法将是世界上最自然的事情。&lt;/p&gt;
&lt;h2 id=&quot;秘制酱汁&quot;&gt;&lt;a href=&quot;#秘制酱汁&quot; class=&quot;headerlink&quot; title=&quot;秘制酱汁&quot;&gt;&lt;/a&gt;秘制酱汁&lt;/h2&gt;&lt;p&gt;我在上一章结尾处留下了两个悬而未决的问题：如果每一种寻路算法都使用相同的代码，是什么让 A&lt;em&gt; 的行为看起来像 A&lt;/em&gt; 呢？而为什么上一章的演示实例会找出不同的路径呢？&lt;/p&gt;
&lt;p&gt;这两个问题的答案是非常相关联的。尽管算法定义得很好，但有一个方面我故意含糊不清，事实证明，它是解释搜索算法行为的关键：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;node = choose_node(reachable)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那些看起来很无辜的线使得每个搜索算法都与众不同。&lt;code&gt;choose_node&lt;/code&gt; 所作的选择会让世界看起来不同。&lt;/p&gt;
&lt;p&gt;那么为什么上一章的演示实例会找出不同的路径呢？答案是因为 &lt;code&gt;choose_node&lt;/code&gt; 方法随机选择了一个节点。&lt;/p&gt;
    
    </summary>
    
      <category term="寻路算法" scheme="https://veinin.com/categories/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="寻路算法" scheme="https://veinin.com/tags/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*" scheme="https://veinin.com/tags/A/"/>
    
  </entry>
  
  <entry>
    <title>寻路算法揭秘（1）：通用搜索</title>
    <link href="https://veinin.com/2019/02/18/pathfinding-demystified-01/"/>
    <id>https://veinin.com/2019/02/18/pathfinding-demystified-01/</id>
    <published>2019-02-18T13:13:37.000Z</published>
    <updated>2019-03-25T15:55:36.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>寻路算法通常是游戏开发者一个比较困惑的主题。特别是 A* 算法常常令人费解，人们普遍会认为这是一种神秘的魔法。</p><p>本系列文章的目的是以一种非常清晰易懂的方式解释常规的寻路与 A* 算法，你不必误解这是一个非常困难的话题，如果解释的当，这将是非常简单明了的问题。</p><p>请注意，我们的重点将放在游戏领域的寻路，与学术化的方法不同，我们将跳过诸如深度优先（Depth-First）或广度优先（Breadth-First）搜索算法的介绍，并尽快进从0到1的介绍 A* 算法。</p><p>第一篇文章将要解释寻路的基本概念，一旦你掌握了这些基本概念，你会发现 A* 算法非常简单。</p><h2 id="简单的第一步"><a href="#简单的第一步" class="headerlink" title="简单的第一步"></a>简单的第一步</h2><p>虽然你能够将这些概念任意复杂的 3D 环境中去，但首先我们将从一个非常简单的设置开始：一个 5x5 的方格。为了方便起见，我们用大写字母标记了每一个方块。</p><p><img src="/images/pathfinding/path1-01.png" alt="pd"></p><a id="more"></a><p>我们要做的第一件事就是通过图形来表示环境。我不会详细介绍图表的内容，直观地说，它是由箭头连接的一组气泡。我们把气泡称为“节点”，箭头称为“边缘”。</p><p>每个节点代表一个角色可以的一种“状态”。在这种情况下，角色的状态就是它的位置，所以我们要为每个方块的网格创建一个节点：</p><p><img src="/images/pathfinding/path1-02.png" alt="pd"></p><p>现在让我们添加边缘，它代表了你可以从其他的给定状态“达到”哪些状态。在下面的例子中，除了被阻挡的方格外，你可以从任何方格走到其相邻的方格：</p><p><img src="/images/pathfinding/path1-03.png" alt="pd"></p><p>如果你你能从 A 节点到达 B 节点，我们可以说 B 是 A 的邻边。</p><p>注意，边缘是有方向的，我们需要一个从 A 到 B 的边，也需要一个从 B 到 A 的边。这看起来可能有点多余，但当你考虑复杂的“状态”时，就不会是这样了。例如，你可以从屋顶掉落到地面，但你不能从地面再跳到屋顶；你可以从“活着”变成“死亡”，但反过来则不行。</p><h2 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h2><p>当我们向从 A 节点到 T 节点时，在第一步中我们可以从两个方向进行选择：走到 B 节点或走到 F 节点。</p><p>假设我们先走到 B 节点，现在你又有了两个选择：回到 A 节点或去到 C 节点。我们记得我们已经去过了 A 节点，这是一个我们已经考虑过的选择，所以没必要再选择一次（否则我们可能整天都在走 A -&gt; B -&gt; A -&gt; B…），所以下一步我们将去到 C 节点。</p><p>现在我们到达了 C 节点，但是我们发现我们已经无路可走了，而再回到 B 节点是没有任何意义的。所以我们到了一个死胡同，当我们在 A 节点选择 B 节点时就不是一个好主意，也许我们应该尝试下 F 节点。</p><p>我们继续不断的重复这个过程，直到我们发现了 T 节点。我们只是通过回溯我们的步骤，重新构建了路径。当我们在 T 节点时，我们怎么来到这里的？那么终点的路径是 O -&gt; T 吗？那我们怎么走到 O 节点？</p><p>请记住，我们实际上根本没有移动，所有的这些都只是一次思考练习。我们仍然站在 A 节点，在我们弄清楚整个路径之前，我们根本不会移动。当我们说“移动到B节点”，我们实际上是在说“想象我们到达了B节点”。</p><h2 id="通用算法"><a href="#通用算法" class="headerlink" title="通用算法"></a>通用算法</h2><p><strong>本章节是本系列文章最重要的部分</strong>。这是你为了寻路必须理解的部分，其他（包括A*）只是一些细节而已。一旦你了解了这一部分你将得到启蒙。</p><p>这一章节当然也很简单。</p><p>让我们将上面的例子形式化成一些伪代码。</p><p>我们需要追踪我们知道的从起点可以到达的节点。开始时，我们只有一个起始节点，但是我们可以对网格进行“探索”，并搞清楚如何到达其他节点。我们把这个列表叫做 <code>reachable</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reachable = [start_node]</span><br></pre></td></tr></table></figure><p>另外，我们需要追踪我们已经到达过的节点，因为我们不想再次前往，我们把这部分节点列表叫做 <code>explored</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explored = []</span><br></pre></td></tr></table></figure><p>这里我们来到了<strong>算法的核心部分</strong>：在搜索的每一个步骤时，我们先选择一个我们已知可达但尚未探索过的节点，然后在此节点检索我们可以到达的新节点。一旦发现我们可以到达目标节点，我们就完成了！否则，继续寻找。</p><p>这听起来好像很简单？是的，但这还不是全部，让我们一步步的用伪代码写出来。</p><p>我们一直寻找，直到我们到达目标节点（在这种情况下，我们已经找到了从开始节点到目标节点的路径），或者直到没有其他节点可以继续探索（在这种情况下，没有从开始节点到达目标节点的路径）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while reachable is not empty:</span><br></pre></td></tr></table></figure><p>我们选择一个我们已知的但没有探索过的节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node = choose_node(reachable)</span><br></pre></td></tr></table></figure><p>如果我们已经直到如何到达目标节点，我们就完成了！然后只需要建立一条路径，根据当前节点的前驱(previous )节点回到开始节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if node == goal_node:</span><br><span class="line">    path = []</span><br><span class="line">    while node != None:</span><br><span class="line">        path.add(node)</span><br><span class="line">        node = node.previous</span><br><span class="line"></span><br><span class="line">    return path</span><br></pre></td></tr></table></figure><p>我们多次的去往同一个节点是没有意义的，所以我们需要追踪那些已经去过的节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reachable.remove(node)</span><br><span class="line">explored.add(node)</span><br></pre></td></tr></table></figure><p>我们可以算出从当前节点可以到达的新节点。我们继续从当前节点的相邻节点开始，并删除我们已经探索过的节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_reachable = get_adjacent_nodes(node) - explored</span><br></pre></td></tr></table></figure><p>然后取出可探索的每一个新节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for adjacent in new_reachable:</span><br></pre></td></tr></table></figure><p>如果我们已经探索过此节点，则忽略它。否则，把此节点加入到已经探索过的节点列表中，记录我们已经探索过它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if adjacent not in reachable:</span><br><span class="line">    adjacent.previous = node  # Remember how we got there.</span><br><span class="line">    reachable.add(adjacent)</span><br></pre></td></tr></table></figure><p>找到目标节点是退出循环的一种方式。另外一种则是当可探索(reachable)的节点为空时：如果我们已经没有可检查的节点，并且没有任何一个节点是我们的目标节点，这意味着没有从开始节点到达目标节点的路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return None</span><br></pre></td></tr></table></figure><p>然后…也就这样了。这已经是一个完整的流程了，我们把上面的代码提取到一个单独的方法中去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function find_path (start_node, end_node):</span><br><span class="line">    reachable = [start_node]</span><br><span class="line">    explored = []</span><br><span class="line"></span><br><span class="line">    while reachable is not empty:</span><br><span class="line">        # Choose some node we know how to reach.</span><br><span class="line">        node = choose_node(reachable)</span><br><span class="line"></span><br><span class="line">        # If we just got to the goal node, build and return the path.</span><br><span class="line">        if node == goal_node:</span><br><span class="line">            return build_path(goal_node)</span><br><span class="line"></span><br><span class="line">        # Don&apos;t repeat ourselves.</span><br><span class="line">        reachable.remove(node)</span><br><span class="line">        explored.add(node)</span><br><span class="line"></span><br><span class="line">        # Where can we get from here?</span><br><span class="line">        new_reachable = get_adjacent_nodes(node) - explored</span><br><span class="line">        for adjacent in new_reachable:</span><br><span class="line">            if adjacent not in reachable</span><br><span class="line">                adjacent.previous = node  # Remember how we got there.</span><br><span class="line">                reachable.add(adjacent)</span><br><span class="line"></span><br><span class="line">    # If we get here, no path was found :(</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure><p>下面这个函数通过前驱节点构建返回起始节点的路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function build_path (to_node):</span><br><span class="line">    path = []</span><br><span class="line">    while to_node != None:</span><br><span class="line">        path.add(to_node)</span><br><span class="line">        to_node = to_node.previous</span><br><span class="line">    return path</span><br></pre></td></tr></table></figure><p>就这样，这是每一个寻路算法的伪代码，包括 A*。</p><h2 id="在线演示"><a href="#在线演示" class="headerlink" title="在线演示"></a>在线演示</h2><p>下面是一个在线演示和上面算法的实现示例。<code>choose_node</code> 只是一个随机选择的节点。你可以一步步的运行它，并查看 <code>可达(reachable)</code> 和 <code>已探索(explored)</code> 节点的变化情况，以及 <code>前驱(previous)</code> 节点的连接情况。</p><script src="http://www.gabrielgambetta.com/js/path_helpers.js"></script><table><tr><td width="201" height="201"><canvas width="201" height="201" id="demo"></canvas></td><td><p id="reachable" style="color:green; font-family:courier;">reachable = []</p><p id="explored" style="color:red; font-family:courier;">explored = []</p><p id="path" style="font-family:courier;"></p><p><input type="button" value="Restart" onclick="stopRunSearch(); search.reset();"> &lt;input type=”button” value=”Step”onclick=”stopRunSearch(); search.step();”&gt; <input type="button" value="Run" onclick="runSearch();"></p></td></tr></table><script>// Choose a random node from the reachable list.Search.prototype.chooseNode = function() {    return this.reachable[Math.floor(Math.random() * this.reachable.length)];}Search.prototype.addAdjacent = function(node, adjacent) {    if (findNode(adjacent, this.explored) || findNode(adjacent, this.reachable)) {        return;    }    adjacent.previous = node;    this.reachable.push(adjacent);}// Build the grid used in the example.// "*" represent a blocked square, " " an open one.var graph = new Graph(["   * ",                       " *** ",                       "     ",                       "* ** ",                       "*    "]);var stepDelay = 200;var search = new Search(graph, "A", "T");search.reset();render(search);</script><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述算法是每一种寻路算法的通用算法。</p><p>那么，你知道是什么使得每一种寻路算法彼此都不相同吗？为什么 <code>A*</code> 叫做 <code>A*</code>。</p><p>这里有个小提示：如果你多次运行上面的演示搜索，你会发现算法每次找到的路径并不一定总是相同。它找到了一些其他路径，但其并不是最短路径，为什么？</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/02/18/pathfinding-demystified-01/">寻路算法揭秘（1）：通用搜索</a></li><li><a href="/2019/02/20/pathfinding-demystified-02/">寻路算法揭秘（2）：搜索策略</a></li><li><a href="/2019/02/23/pathfinding-demystified-03/">寻路算法揭秘（2）：A* 解密</a></li><li><a href="/2019/02/28/pathfinding-demystified-04/">寻路算法揭秘（3）：实用 A* 算法</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/generic-search.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;寻路算法通常是游戏开发者一个比较困惑的主题。特别是 A* 算法常常令人费解，人们普遍会认为这是一种神秘的魔法。&lt;/p&gt;
&lt;p&gt;本系列文章的目的是以一种非常清晰易懂的方式解释常规的寻路与 A* 算法，你不必误解这是一个非常困难的话题，如果解释的当，这将是非常简单明了的问题。&lt;/p&gt;
&lt;p&gt;请注意，我们的重点将放在游戏领域的寻路，与学术化的方法不同，我们将跳过诸如深度优先（Depth-First）或广度优先（Breadth-First）搜索算法的介绍，并尽快进从0到1的介绍 A* 算法。&lt;/p&gt;
&lt;p&gt;第一篇文章将要解释寻路的基本概念，一旦你掌握了这些基本概念，你会发现 A* 算法非常简单。&lt;/p&gt;
&lt;h2 id=&quot;简单的第一步&quot;&gt;&lt;a href=&quot;#简单的第一步&quot; class=&quot;headerlink&quot; title=&quot;简单的第一步&quot;&gt;&lt;/a&gt;简单的第一步&lt;/h2&gt;&lt;p&gt;虽然你能够将这些概念任意复杂的 3D 环境中去，但首先我们将从一个非常简单的设置开始：一个 5x5 的方格。为了方便起见，我们用大写字母标记了每一个方块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pathfinding/path1-01.png&quot; alt=&quot;pd&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="寻路算法" scheme="https://veinin.com/categories/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="寻路算法" scheme="https://veinin.com/tags/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*" scheme="https://veinin.com/tags/A/"/>
    
  </entry>
  
  <entry>
    <title>Lua入门教程：协程</title>
    <link href="https://veinin.com/2019/01/03/programming_in_lua_15/"/>
    <id>https://veinin.com/2019/01/03/programming_in_lua_15/</id>
    <published>2019-01-03T15:10:10.000Z</published>
    <updated>2019-03-25T16:17:59.396Z</updated>
    
    <content type="html"><![CDATA[<p>从多线程的角度来看，协程（coroutine）与线程（thread）类似：协程时一系列的可执行语句，拥有自己的栈、局部变量和指令指针，同时协程又与其他协程共享全局变量和其他几乎一切资源。</p><p>协程与线程的主要区别在于，一个多线程程序可以并行运行多个线程，而协程则需要彼此协作运行，即在任意时刻只能有一个协程运行，且只有当正在运行的协程要求挂起时其执行才会暂停。</p><h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h2><p>与协程相关的函数都放在表 coroutine 中。没个新建立的协程都拥有一个完整的生命周期，其包含四种状态：挂起（suspended）、运行（running）、正常（normal）和死亡（dead)。</p><h3 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h3><p>coroutine.create(f)，创建一个以执行代码的函数 f（协程体）的新协程，并返回以类型 <code>thread</code> 为标志的新协程。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">co = coroutine.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">"hello"</span>) <span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(co)) <span class="comment">--&gt; thread</span></span><br></pre></td></tr></table></figure><p>当协程被创建时，默认处于<strong>挂起状态</strong>，即协程不会在被创建时自动运行，我们可以通过 <code>coroutine.status</code> 来检查协程的状态：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(coroutine.<span class="built_in">status</span>(co)) <span class="comment">--&gt; suspended</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="运行协程"><a href="#运行协程" class="headerlink" title="运行协程"></a>运行协程</h3><p>要想启动或再启动一个协程，我们可以使用函数 <code>coroutine.resume</code> 来执行，并将去状态改为运行：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coroutine.<span class="built_in">resume</span>(co) <span class="comment">--&gt; hello</span></span><br></pre></td></tr></table></figure><p>上面的协程创建后运行的函数会输出 <code>hello</code> 然后该协程就终止了，最后协程执行完成后会变为<strong>死亡状态</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(coroutine.<span class="built_in">status</span>(co)) <span class="comment">--&gt; dead</span></span><br></pre></td></tr></table></figure><h3 id="挂起协程"><a href="#挂起协程" class="headerlink" title="挂起协程"></a>挂起协程</h3><p>协程的强大之处在于函数 <code>coroutine.yield</code>，该函数可以让一个运行中的协程挂起自己，然后在后续执行中恢复运行：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co = coroutine.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"co"</span>, i)</span><br><span class="line">        coroutine.<span class="built_in">yield</span>()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>上面协程运行着一个循环，在循环中打印输出一个数字后遇到 <code>yield</code> 进入挂起状态：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coroutine.<span class="built_in">resume</span>(co) <span class="comment">--&gt; co 1</span></span><br></pre></td></tr></table></figure><p>此时我们可以查看协程状态，会发现协程处于挂起状态：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(coroutine.<span class="built_in">status</span>(co)) <span class="comment">--&gt; suspended</span></span><br></pre></td></tr></table></figure><p>我们可以继续运行，直到上面 for 循环执行结束：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coroutine.<span class="built_in">resume</span>(co) <span class="comment">--&gt; co 2</span></span><br><span class="line">coroutine.<span class="built_in">resume</span>(co) <span class="comment">--&gt; co 3</span></span><br><span class="line">    ...</span><br><span class="line">coroutine.<span class="built_in">resume</span>(co) <span class="comment">--&gt; co 10</span></span><br><span class="line">coroutine.<span class="built_in">resume</span>(co) <span class="comment">--&gt; 不输出任何数据</span></span><br></pre></td></tr></table></figure><p>当最后一次调用 resume 时，协程体执行完毕并返回，不会输出任何数据，如果我们试图再次唤醒它，函数 resume 会返回 false 已经一条错误信息：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(coroutine.<span class="built_in">resume</span>(co)) <span class="comment">--&gt; false  cannot resume dead coroutine</span></span><br></pre></td></tr></table></figure><p>请注意，resume 函数运行在保护模式中，如果协程出错，Lua 不会显示错误信息，而是将错误信息返回给 resume 函数。</p><p>当协程 A 唤醒协程 B 时，协程 A 不是挂起状态（因为不能唤醒协程A），而不是运行状态（因为正在运行协程B），此时的状态称之为<strong>正常状态</strong>。</p><h3 id="交换数据"><a href="#交换数据" class="headerlink" title="交换数据"></a>交换数据</h3><p>协程中一个非常有用的机制是通过一对 <code>resume-yield</code> 来交换数据。第一个 <code>resume</code> 函数会把所有的额外参数传递给协程的主函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">co = coroutine.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(a, b, c)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"co"</span>, a, b, c)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">coroutine.<span class="built_in">resume</span>(co, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">--&gt; co 1 2 3</span></span><br></pre></td></tr></table></figure><p>函数 <code>resume</code> 第一个返回值为 <code>true</code> 时表示没有错误，之后的返回值对应函数 <code>yield</code> 的参数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">co = coroutine.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span></span><br><span class="line">        coroutine.<span class="built_in">yield</span>(a + b, a - b)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(coroutine.<span class="built_in">resume</span>(co, <span class="number">10</span>, <span class="number">20</span>)) <span class="comment">--&gt; true  30  -10</span></span><br></pre></td></tr></table></figure><p>函数 <code>yield</code> 返回值则会对应 <code>resume</code> 的参数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">co = coroutine.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(x)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"co1"</span>, x)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"co2"</span>, coroutine.<span class="built_in">yield</span>())</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">coroutine.<span class="built_in">resume</span>(co, <span class="string">"hi"</span>) <span class="comment">--&gt; co1    hi</span></span><br><span class="line">coroutine.<span class="built_in">resume</span>(co, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">--&gt; co2    4    5</span></span><br></pre></td></tr></table></figure><p>当协程运行结束后，主函数所返回的值将变成对应函数 <code>resume</code> 的返回值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">co = coroutine.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(coroutine.<span class="built_in">resume</span>(co)) <span class="comment">--&gt; true    1    2</span></span><br></pre></td></tr></table></figure><h2 id="使用协程解决生产者于消费者问题"><a href="#使用协程解决生产者于消费者问题" class="headerlink" title="使用协程解决生产者于消费者问题"></a>使用协程解决生产者于消费者问题</h2><p>生产者-消费者设计两个函数，一个函数不断的生成值，而另外一个函数则不断的消费这些值，我们可以看以下代码实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> x = <span class="built_in">io</span>.<span class="built_in">read</span>() <span class="comment">-- 生产新值</span></span><br><span class="line">        send(x)             <span class="comment">-- 发送给消费者</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(x)</span></span></span><br><span class="line">    coroutine.<span class="built_in">yield</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consume</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> x = receive() <span class="comment">-- 接受来自生产者的值</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(x, <span class="string">"\n"</span>)   <span class="comment">-- 消费</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">status</span>, value = coroutine.<span class="built_in">resume</span>(producer)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">producer = coroutine.<span class="built_in">create</span>(producer) <span class="comment">-- 生成者在协程里面运行</span></span><br><span class="line">consume() <span class="comment">-- 通过消费者启动</span></span><br></pre></td></tr></table></figure><p>上面这种设计中，程序通过消费者启动。当消费者需要新值时就唤醒生成者，生成者向消费者返回新值后挂起，知道消费者再次将其唤醒。因此这种设计称之为消费者驱动式设计。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从多线程的角度来看，协程（coroutine）与线程（thread）类似：协程时一系列的可执行语句，拥有自己的栈、局部变量和指令指针，同时协程又与其他协程共享全局变量和其他几乎一切资源。&lt;/p&gt;
&lt;p&gt;协程与线程的主要区别在于，一个多线程程序可以并行运行多个线程，而协程则需要彼此协作运行，即在任意时刻只能有一个协程运行，且只有当正在运行的协程要求挂起时其执行才会暂停。&lt;/p&gt;
&lt;h2 id=&quot;协程基础&quot;&gt;&lt;a href=&quot;#协程基础&quot; class=&quot;headerlink&quot; title=&quot;协程基础&quot;&gt;&lt;/a&gt;协程基础&lt;/h2&gt;&lt;p&gt;与协程相关的函数都放在表 coroutine 中。没个新建立的协程都拥有一个完整的生命周期，其包含四种状态：挂起（suspended）、运行（running）、正常（normal）和死亡（dead)。&lt;/p&gt;
&lt;h3 id=&quot;创建协程&quot;&gt;&lt;a href=&quot;#创建协程&quot; class=&quot;headerlink&quot; title=&quot;创建协程&quot;&gt;&lt;/a&gt;创建协程&lt;/h3&gt;&lt;p&gt;coroutine.create(f)，创建一个以执行代码的函数 f（协程体）的新协程，并返回以类型 &lt;code&gt;thread&lt;/code&gt; 为标志的新协程。&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;co = coroutine.&lt;span class=&quot;built_in&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;(co)) &lt;span class=&quot;comment&quot;&gt;--&amp;gt; thread&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当协程被创建时，默认处于&lt;strong&gt;挂起状态&lt;/strong&gt;，即协程不会在被创建时自动运行，我们可以通过 &lt;code&gt;coroutine.status&lt;/code&gt; 来检查协程的状态：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(coroutine.&lt;span class=&quot;built_in&quot;&gt;status&lt;/span&gt;(co)) &lt;span class=&quot;comment&quot;&gt;--&amp;gt; suspended&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Lua入门教程" scheme="https://veinin.com/categories/Lua%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Lua编程" scheme="https://veinin.com/tags/Lua%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Lua 5.3" scheme="https://veinin.com/tags/Lua-5-3/"/>
    
      <category term="Lua协程" scheme="https://veinin.com/tags/Lua%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Lua入门教程：垃圾回收</title>
    <link href="https://veinin.com/2018/12/25/programming_in_lua_14/"/>
    <id>https://veinin.com/2018/12/25/programming_in_lua_14/</id>
    <published>2018-12-25T15:10:10.000Z</published>
    <updated>2019-03-25T16:18:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>Lua 使用的是自动内存管理，所以我们不需要自己手动取删除创建后的对象，Lua 通过垃圾回收（garbage collection）的方式自动删除成为来及的对象，从而将程序员从内存管理的负担中解放出来。</p><p>虽然在理想的环境中，垃圾回收对我们来说是不可见的，但其却不是万能的，比如某些关键的性能点，我们可能需要停止垃圾回收，或者让它只在特定的时间点运行，这就需要额外的垃圾回收方式来辅助。</p><p>Lua 采用了弱引用表（weak table)、析构器（finalizer）和函数 collectgarbage 的机制来作为辅助垃圾回收。</p><h2 id="弱引用表"><a href="#弱引用表" class="headerlink" title="弱引用表"></a>弱引用表</h2><p>所谓弱引用（weak reference）是一种不在垃圾回收考虑范围内的对象引用。弱引用表允许收集 Lua 中还可以被程序访问的对象，它告知 Lua 语言一个引用不应该阻止对一个对象的回收机制。</p><p>一个典型的内存泄漏的场景是如果我们在数组中存储一些活跃的对象，我们只需要把对象插入到数组中去即可，一旦对象成为了数组中一部分，在数组销毁之前，该对象是永远无法回收的，虽然数组中的对象可能没有任何其他地方引用它，但其仍然被数组引用，除非我们告诉 Lua 数组中的引用不应该阻止此对象的回收。</p><p>表由键和值组成，键和值都是强引用，垃圾回收默认不会回收一个可访问的作为表中键和值的对象。而在一个弱引用表中，键和值都可以是弱引用，一旦某个键或值被回收，那么其对应的整个键值对也会被回收。</p><p>一个表是否为弱引用表由其元表中的 <code>__mode</code> 字段决定，其值应该是个字符串：</p><ul><li>当字符串是 “k” 时，这个表的键是弱引用。</li><li>当字符串是 “v” 时，这个表的值时弱引用。</li><li>当字符串是 “kv” 时，表中的键和值都是弱引用。</li></ul><a id="more"></a><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t, &#123;<span class="built_in">__mode</span> = <span class="string">"k"</span>&#125;)</span><br><span class="line"></span><br><span class="line">k = &#123;&#125;</span><br><span class="line">t[k] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">k = &#123;&#125; <span class="comment">-- 上一个 k 对象引用被清除</span></span><br><span class="line">t[k] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">collectgarbage</span>() <span class="comment">-- 强制垃圾回收</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span> <span class="built_in">print</span>(v) <span class="keyword">end</span>  <span class="comment">--&gt; 2</span></span><br></pre></td></tr></table></figure><p>上面例子中，第二个 <code>k = {}</code> 覆盖了指向了第一个键的索引，调用 <code>collectgarbage</code> 强制垃圾回收器进行一次完整的垃圾回收，由于第一个键没有了其他引用，所以 Lua 会回收该键对象，并从表中删除对应的元素。</p><p>最后，请注意，只有对象可以从弱表中移除，而像数字和布尔这样的“值”是不可回收的。</p><h2 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h2><p>析构器（Finalizer）是一个与对象关联的函数，当该对象即将被会收时该函数会被调用。Lua语言通过元方法 <code>__gc</code> 实现析构器：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;x = <span class="string">"hello"</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(o, &#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o.x) <span class="keyword">end</span>&#125;)</span><br><span class="line">o = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>() <span class="comment">--&gt; hi</span></span><br></pre></td></tr></table></figure><p>上例中，对象 o 创建了一个带有 <code>__gc</code> 元方法的元表，然后清理对象 o 的引用，调用 <code>collectgarbage</code> 函数强制执行一次完整的垃圾回收，对象 o 被回收时，会调用表的析构器，也就是元方法 <code>__gc</code>。</p><h3 id="逆序调用"><a href="#逆序调用" class="headerlink" title="逆序调用"></a>逆序调用</h3><p>当垃圾回收期在同一个周期析构多个对象时，它会按照对象被标记为需要析构处理的顺序逆序调用这些对象的析构器：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mt = &#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o.x) <span class="keyword">end</span>&#125;</span><br><span class="line"></span><br><span class="line">obj = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">    obj = <span class="built_in">setmetatable</span>(&#123;x = i&#125;, mt)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">obj = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">collectgarbage</span>()</span><br><span class="line">    <span class="comment">--&gt; 3</span></span><br><span class="line">    <span class="comment">--&gt; 2</span></span><br><span class="line">    <span class="comment">--&gt; 1</span></span><br></pre></td></tr></table></figure><p>上面代码，创建了三个对象，分别设置了析构器，运行垃圾回收后，可以看到第一个被析构的对象是最后被标记的对象。</p><h3 id="复苏"><a href="#复苏" class="headerlink" title="复苏"></a>复苏</h3><p>当一个析构器被调用时，它的参数是正在被析构的对象。因此，这个对象会至少在析构期间重新变成活跃状态，我们称之为<strong>临时复苏</strong>。而在析构期间，我们无法阻止该对象被存储在某个全局变量中，使得该对象在析构器返回后任然可访问，我们称之为<strong>永久复苏</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x = <span class="string">"hello"</span>&#125;</span><br><span class="line">b = &#123;f = a&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(b, &#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o.f.x) <span class="keyword">end</span>&#125;)</span><br><span class="line">a, b = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()</span><br></pre></td></tr></table></figure><p>上面代码中，对象 b 的析构会访问 a，所以在 a 在 b 析构前都不能被回收，Lua 会在运行析构器之前同时复苏 b 和 a。</p><p>需要注意的是，Lua 会在两个阶段回收具有析构器的对象：</p><ul><li>第一个阶段为发现不可达的带有析构器的对象，并调用析构器开始执行，执行完成后标记为已被析构</li><li>第二个阶段的垃圾回收又发现该对象不可达时，它就会将该对象删除。</li></ul><p>因此，如果我们想保证我们程序所有垃圾都能真正被释放，那么我们必须调用两次 <code>collectgarbage</code> 函数。</p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>垃圾回收（Garbage Collector, GC）算法的原理大体可以概括为：遍历系统中的所有对象，看哪些对象没有被引用，没有引用关系的就认为是可以回收的对象，对其进行删除。</p><p>对于如何找出没有“引用” 的对象有以下几种主流算法：</p><ul><li><strong>引用计数 GC 算法</strong>，当对象被引用时，该对象引用计数加一，反之则减一。当引用计数为 0 时则认为该对象没有被引用，可以被回收删除。该算法有点是只需要对引用计数，不需要对每个对象进行扫描遍历，但有个先天的不足就是很难处理循环引用的问题。</li><li><strong>标记清楚 GC 算法</strong>，每次做GC扫描时，首先扫描并且标记所有对象，被扫描过并且被标记的对象认为时可达的，不能被回收；而没有被标记的对象认为是可回收的。</li></ul><h3 id="双色标记-清除算法"><a href="#双色标记-清除算法" class="headerlink" title="双色标记-清除算法"></a>双色标记-清除算法</h3><p>Lua 5.0 使用的 GC 算法是<strong>双色标记-清除</strong>（Tow-Color Mark and Sweep）算法，其算法原理也很简单：</p><ul><li>创建新对象，对象的颜色被标记为白色，并加入到对象链表中。</li><li>标记阶段，取出对象链表中未扫描的元素，标记为黑色，并遍历该对象关联的其他对象，也标记为黑色。</li><li>回收阶段，遍历所有对象，如果是白色，则认为该对象没有被引用，逐个回收；否则加入重新加入到对象链表等待下一轮GC检查。</li></ul><p>这种垃圾收集器被称为“stop-the-world”（全局暂停）式的收集器，其垃圾回收过程中是不能被打断的，因为你无法在标记与清除的过程中对新加入的对象进行标记判断，无法确认新对象到底应该是白色还是黑色。假设在 GC 回收阶段，如果把新对象标记为白色，那么该对象会在没有遍历其关联对象的情况下被回收；如果被标记为黑色，那么这个对象本轮并没有被扫描就被认为不能回收。所以，在双色清除算法中，标记阶段和回收阶段必须合并在一起才能完成。</p><p>正因为双标记清除算法不能被打断，所以其每次GC操作的代价都非常大。GC 过程中，程序必须停下来，不能做任何其他操作。</p><h3 id="三色增量标记清除算法"><a href="#三色增量标记清除算法" class="headerlink" title="三色增量标记清除算法"></a>三色增量标记清除算法</h3><p>Lua 5.1 使用了<strong>增量式的三色标记清除算法</strong>（Thi-Color-Incremental Mark and Sweep）,这种算法与前面的相比，每个对象新增加了一种颜色，这样的好处在于：它不必在要求GC阶段停止主程序的运行，这个GC过程是增量的，可以被终端再恢复并继续运行。3中颜色分类如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 白色，表示对象没有被GC标记过，任何对象创建时的默认状态，如果GC扫描结束后任然是白色，则说明该对象没有被引用，可以被回收。</span><br><span class="line">- 灰色，表示对象已经被GC标记过，但该对象关联的其他对象还没有没访问标记过。</span><br><span class="line">- 黑色，表示对象已经被GC标记过，且该对象关联的其他对象也被访问标记过。</span><br></pre></td></tr></table></figure><p>引入灰色节点后，算法不再要去一次性完整的执行完毕，而是把已经扫描但是其引用的还未扫描的对象置为灰色。在标记过程中，只要还要元素是灰色，则算法标记过程会一直持续下去，即使中间被打断并去执行其他操作，也不会受影响。</p><h3 id="紧急垃圾回收"><a href="#紧急垃圾回收" class="headerlink" title="紧急垃圾回收"></a>紧急垃圾回收</h3><p>Lua 5.2 引入了紧急垃圾收集（emergency collection），当内存分配失败时，Lua 会强制进行一次完整的垃圾收集，然后再次尝试重新分配。这种紧急功能可以发生在程序进行内存分配的任意时刻。</p><h2 id="控制垃圾回收"><a href="#控制垃圾回收" class="headerlink" title="控制垃圾回收"></a>控制垃圾回收</h2><p>Lua 提供了函数 <code>collectgarbage ([opt [, arg]])</code> 来让我们可以辅助垃圾收集器进行一些额外的控制。该函数第一个参数是一个可选字符串，用来说明执行何种操作，而有些选项需要第二个参数：</p><ul><li>“collect”: 做一次完整的垃圾收集循环，如果不提供任何参数，这将是默认选项。</li><li>“isrunning”: 返回表示收集器是否在工作的布尔值。</li><li>“stop”: 停止垃圾收集器的自动运行，直到再次调用<code>restart</code>前，只能显示的调用垃圾收集器。</li><li>“restart”: 重启垃圾收集器到自动运行。</li><li>“count”: 以 KB 字节数为单位返回 Lua 使用的总内存数。其结果为浮点数，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数。</li><li>“step”: 单步运行垃圾收集器。 步长“大小”由 arg 控制，指定在分配了多少个字节后垃圾回收一个做什么。</li><li>“setpause”: 将 arg 设为收集器的间歇率。</li><li>“setstepmul”: 将 arg 设为收集器的 步进倍率。</li></ul><p>任何垃圾回收器都是使用CPU时间来换内存空间的。在极端情况下，垃圾收集器可能无法运行。但是，不消耗CPU时间将会消耗大量的内存空间。而在另外一种极端情况下，垃圾回收器可能在一次赋值后就得完成一次完整的垃圾收集。程序如果想使用尽可能小的内存，是要以付出大量的CPU计算量为代价的。</p><p><code>collectgarbage</code> 函数的 <code>setpause</code> 与 <code>setstepmul</code> 参数可以让我们在CPU与内存消耗之间找一个平衡点，以寻求尽可能大的运行效率。</p><p>参数 <code>setpause</code> 用于控制垃圾回收器在一次收集完成后需要等待多久时间再开始新一轮的收集。当其选项的值设为 0 时，表示上一次垃圾回收完成后立刻开始新一轮的收集工作；当选项值设为 200% 时，表示重启垃圾回收器前需要等待内存使用翻倍。如果想消耗更多的 CPU 时间去换取更低的内存消耗，可以把这个值设的小一点。</p><p>参数 <code>setstepmul</code> 控制对没分配 1KB 内存时垃圾回收器应该进行多少工作。该选项值越高则垃圾回收器使用的增量越小。其默认值为 200%，当参数值低于 100 % 时会使垃圾回收运行的很慢，以至于可能一次收集都完成不了；而当参数设置为 100000000% 这样巨大的值时，其表现将是一个非增量的垃圾回收器。</p><p>对于上面的一些参数来说，其默认值已经足够好了，而对于一些特殊应用来说，手工实验控制则可能更好，比如游戏应用中，某些关键阶段我们必须调用 <code>collectgarbage(&quot;stop&quot;)</code> 来停止回收，并在关键阶段执行完成后，再调用 <code>collectgarbage(&quot;restart&quot;)</code> 来重启垃圾收集器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lua 使用的是自动内存管理，所以我们不需要自己手动取删除创建后的对象，Lua 通过垃圾回收（garbage collection）的方式自动删除成为来及的对象，从而将程序员从内存管理的负担中解放出来。&lt;/p&gt;
&lt;p&gt;虽然在理想的环境中，垃圾回收对我们来说是不可见的，但其却不是万能的，比如某些关键的性能点，我们可能需要停止垃圾回收，或者让它只在特定的时间点运行，这就需要额外的垃圾回收方式来辅助。&lt;/p&gt;
&lt;p&gt;Lua 采用了弱引用表（weak table)、析构器（finalizer）和函数 collectgarbage 的机制来作为辅助垃圾回收。&lt;/p&gt;
&lt;h2 id=&quot;弱引用表&quot;&gt;&lt;a href=&quot;#弱引用表&quot; class=&quot;headerlink&quot; title=&quot;弱引用表&quot;&gt;&lt;/a&gt;弱引用表&lt;/h2&gt;&lt;p&gt;所谓弱引用（weak reference）是一种不在垃圾回收考虑范围内的对象引用。弱引用表允许收集 Lua 中还可以被程序访问的对象，它告知 Lua 语言一个引用不应该阻止对一个对象的回收机制。&lt;/p&gt;
&lt;p&gt;一个典型的内存泄漏的场景是如果我们在数组中存储一些活跃的对象，我们只需要把对象插入到数组中去即可，一旦对象成为了数组中一部分，在数组销毁之前，该对象是永远无法回收的，虽然数组中的对象可能没有任何其他地方引用它，但其仍然被数组引用，除非我们告诉 Lua 数组中的引用不应该阻止此对象的回收。&lt;/p&gt;
&lt;p&gt;表由键和值组成，键和值都是强引用，垃圾回收默认不会回收一个可访问的作为表中键和值的对象。而在一个弱引用表中，键和值都可以是弱引用，一旦某个键或值被回收，那么其对应的整个键值对也会被回收。&lt;/p&gt;
&lt;p&gt;一个表是否为弱引用表由其元表中的 &lt;code&gt;__mode&lt;/code&gt; 字段决定，其值应该是个字符串：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当字符串是 “k” 时，这个表的键是弱引用。&lt;/li&gt;
&lt;li&gt;当字符串是 “v” 时，这个表的值时弱引用。&lt;/li&gt;
&lt;li&gt;当字符串是 “kv” 时，表中的键和值都是弱引用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Lua入门教程" scheme="https://veinin.com/categories/Lua%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Lua编程" scheme="https://veinin.com/tags/Lua%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Lua 5.3" scheme="https://veinin.com/tags/Lua-5-3/"/>
    
      <category term="Lua垃圾回收" scheme="https://veinin.com/tags/Lua%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>Lua入门教程：元表与元方法</title>
    <link href="https://veinin.com/2018/12/22/programming_in_lua_11/"/>
    <id>https://veinin.com/2018/12/22/programming_in_lua_11/</id>
    <published>2018-12-22T13:35:05.000Z</published>
    <updated>2019-03-25T16:17:38.447Z</updated>
    
    <content type="html"><![CDATA[<p>Lua 语言中每中类型的值都有一套可预见的操作集合，比如可以将数字相加，将字符串连接，还可以在表中插入键值对。但我们却无法直接将两个表相加，无法对表进行直接比较，除非我们使用元表。<br>元表可以修改一个值在面对未知操作时的行为。例如，我们对两个表 a 和 b 执行 <code>a + b</code> 操作，Lua 在试图将两个表相加时，会检查其中某个表是否含有元表(metatable)，且元表中是否含有 <code>__add</code> 字段，如果 Lua 找到该字段，则调用该字段对应的值，这就是所有的元方法(metamethod)。</p><p>在元表中每个元方法的键的命名都是一个双下划线（__）加事件名的，键关联的那些值被称为元方法。上面说的 <code>_add</code> 就是元方法键名称，而对应的元方法值是执行加操作的函数。</p><h2 id="获取与设置元表"><a href="#获取与设置元表" class="headerlink" title="获取与设置元表"></a>获取与设置元表</h2><p>在 Lua 中每个值都可以有元表，而元表只是一个普通的Lua表。<br>每个表和用户数据类型都具有各自独立的元表，而其他类型的值则共享对于类型所属的同一个元表。<br>我们可以使用 <code>getmetatable</code> 获取一个表的元表，注意，刚创建的新表是没有元表的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(t))  <span class="comment">--&gt; nil</span></span><br></pre></td></tr></table></figure><p>另外，我们可以使用 <code>setmetatable</code> 来设置和修改任意表的元表：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t, t1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(t) == t1)    <span class="comment">--&gt; true</span></span><br></pre></td></tr></table></figure><p>在 Lua 中我们只能为表设置元表，如果要为其他类型值设置元表，则必须通过C代码或调试库完成。另外，字符串库为所有字符串都设置了同一个元表，而其他类型默认是没有元表的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="string">"hello"</span>))    <span class="comment">--&gt; table: 0106F578</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="string">"world"</span>))    <span class="comment">--&gt; table: 0106F578</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="literal">true</span>))       <span class="comment">--&gt; nil</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算术运算元方法"><a href="#算术运算元方法" class="headerlink" title="算术运算元方法"></a>算术运算元方法</h2><p>对于数学运算、位运算这些算术运算符，每一个操作都有唯一对应的元方法：</p><ul><li><strong>__add</strong>: + 操作。 如果任何不是数字的值（包括不能转换为数字的字符串）做加法， Lua 就会尝试调用该元方法。</li><li><strong>__sub</strong>: - 操作。 行为和 “add” 操作类似。</li><li><strong>__mul</strong>: * 操作。 行为和 “add” 操作类似。</li><li><strong>__div</strong>: / 操作。 行为和 “add” 操作类似。</li><li><strong>__mod</strong>: % 操作。 行为和 “add” 操作类似。</li><li><strong>__pow</strong>: ^ （次方）操作。 行为和 “add” 操作类似。</li><li><strong>__unm</strong>: - （取负）操作。 行为和 “add” 操作类似。</li><li><strong>__idiv</strong>: // （向下取整除法）操作。 行为和 “add” 操作类似。</li><li><strong>__band</strong>: &amp; （按位与）操作。 行为和 “add” 操作类似， 不同的是 Lua 会在任何一个操作数无法转换为整数时尝试取元方法。</li><li><strong>__bor</strong>: | （按位或）操作。 行为和 “band” 操作类似。</li><li><strong>__bxor</strong>: ~ （按位异或）操作。 行为和 “band” 操作类似。</li><li><strong>__bnot</strong>: ~ （按位非）操作。 行为和 “band” 操作类似。</li><li><strong>__shl</strong>: &lt;&lt; （左移）操作。 行为和 “band” 操作类似。</li><li><strong>__shr</strong>: &gt;&gt; （右移）操作。 行为和 “band” 操作类似。</li></ul><p>比如下面实现一个表用作集合操作，并对集合操作实现加法运算的元方法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> set = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> set_mt = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set.new</span><span class="params">(v)</span></span></span><br><span class="line">    <span class="keyword">local</span> set = <span class="built_in">setmetatable</span>(&#123;&#125;, set_mt)</span><br><span class="line">    <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(v) <span class="keyword">do</span></span><br><span class="line">        set[v] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">set_mt.<span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">local</span> ret = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span> ret[k] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(b) <span class="keyword">do</span> ret[k] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>然后，我们可以按以下方法对一个集合进行加法运算了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> s1 = set.new&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="keyword">local</span> s2 = set.new&#123;<span class="number">20</span>, <span class="number">50</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(s1)) <span class="comment">--&gt; table: 00E7E978</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(s2)) <span class="comment">--&gt; table: 00E7E978</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> s3 = s1 + s2</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(s3) <span class="keyword">do</span></span><br><span class="line">    t[#t + <span class="number">1</span>] = k</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"&#123;"</span> .. <span class="built_in">table</span>.<span class="built_in">concat</span>(t, <span class="string">", "</span>) .. <span class="string">"&#125;"</span>) <span class="comment">--&gt; &#123;40, 10, 20, 30, 50&#125;</span></span><br></pre></td></tr></table></figure><h2 id="关系运算符元方法"><a href="#关系运算符元方法" class="headerlink" title="关系运算符元方法"></a>关系运算符元方法</h2><p>我们还可以指定关系运算符元方法，其主要包含以下几种操作：</p><ul><li><strong>__eq</strong>: == （等于）操作。仅在两个值都是表或都是完全用户数据时，且它们不是同一个对象时才尝试该元方法，调用的结果总会被转换为布尔量。</li><li><strong>__lt</strong>: &lt; （小于）操作。 仅在两个值不全为整数也不全为字符串时才尝试元方法，调用的结果总会被转换为布尔量。</li><li><strong>__le</strong>: &lt;= （小于等于）操作。 和其它操作不同， 小于等于操作可能用到两个不同的事件。 首先，像 “lt” 操作的行为那样，Lua 在两个操作数中查找 <code>__le</code> 元方法，如果一个元方法都找不到，就会再次查找 <code>__lt</code> 元方法，Lua 会将 a &lt;= b 转化为 not (b &lt; a)；a ~= b 转换为 not (a == b)；a &gt; b 转换为 b &lt; a；a &gt;= b 转换为 b &lt; a。</li></ul><p>我们可以尝试为上面集合增加一个集合相等操作：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set_mt.<span class="built_in">__eq</span> = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> b[k] <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(b) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> a[k] <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>然后我们对集合进行比较：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> s1 = set.new&#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">local</span> s2 = set.new&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">local</span> s3 = set.new&#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1 == s2) <span class="comment">--&gt; false</span></span><br><span class="line"><span class="built_in">print</span>(s1 == s3) <span class="comment">--&gt; true</span></span><br></pre></td></tr></table></figure><h2 id="index-与-newindex-元方法"><a href="#index-与-newindex-元方法" class="headerlink" title="index 与 newindex 元方法"></a><strong>index 与 </strong>newindex 元方法</h2><p>Lua 提供了一种能改变表在<strong>访问</strong>和<strong>修改</strong>表中不存在字段时的行为方式。</p><h3 id="index-元方法"><a href="#index-元方法" class="headerlink" title="__index 元方法"></a>__index 元方法</h3><p>当我们访问一个表中不存在的字段时，通常情况下会返回 nil。但实际上，这样的访问方式会引发解释器取查找一个名为 <code>__index</code> 的元方法。如果没有找到这个元方法，则会直接返回 nil，否则会由这个元方法来提供最终的结果。</p><p>下面代码首先定义了一个原型 <code>prototype</code> 用来表示窗口坐标和大小信息，然后定义了一个 <code>new</code> 构造函数来产生一个对象，返回的对象直接设置成了元表 <code>mt</code>，该元表定义了元方法 __index，访问该元方法默认是直接访问 <code>prototype</code> 表的熟悉：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">prototype = &#123;x = <span class="number">0</span>, y = <span class="number">0</span>, width = <span class="number">100</span>, height = <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"></span><br><span class="line">mt.<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(_, key)</span></span></span><br><span class="line">    <span class="keyword">return</span> prototype[key]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(o)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(o, mt)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>然后我们可以调用函数 new 创建新对象，并指定对象的宽度和高度属性，可以预见的是，新对象并不包含坐标 x 和 y 的值，当我们访问不存在的 x 值时会触发直接访问 <code>__index</code> 元方法，并返回 <code>prototype</code> 的默认值 0：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = new&#123;width = <span class="number">50</span>, heigh = <span class="number">50</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(w.x) <span class="comment">--&gt; 0</span></span><br></pre></td></tr></table></figure><p><code>__index</code> 虽然叫做元方法，但不一定非得是一个函数，它还可以是一个表。当元方法是一个函数时，Lua 会把当前表和不存在的参数名作为参数调用该函数；当元方法是一个表时，Lua 会直接访问这个表。<br>上面例子中，我们把 <code>__index</code> 字段直接设置为 <code>prototype</code> 时，访问不存在的值时，会直接返回 <code>prototype</code> 对应的值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__index</span> = prototype</span><br></pre></td></tr></table></figure><h3 id="index-元方法与-rawget-函数"><a href="#index-元方法与-rawget-函数" class="headerlink" title="__index 元方法与 rawget 函数"></a>__index 元方法与 rawget 函数</h3><p>有时候我们希望访问一个表时，不调用 <code>__index</code> 元方法，那么我们可以使用 <code>rawget (table, index)</code> 函数，该函数会在不触发任何元方法的情况下直接获取 <code>table[index]</code> 的值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = new&#123;width = <span class="number">50</span>, heigh = <span class="number">50</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(w, <span class="string">"x"</span>)) <span class="comment">--&gt; nil</span></span><br></pre></td></tr></table></figure><p>可以看到上面代码使用 <code>rawget</code> 访问 x 属性时，并不会触发对元方法 <code>__index</code> 的访问，而是直接返回了 nil。</p><h3 id="newindex-元方法"><a href="#newindex-元方法" class="headerlink" title="__newindex 元方法"></a>__newindex 元方法</h3><p><code>__newindex</code> 与 <code>__index</code> 类似，不同之处在于 <code>__newindex</code> 用于表的更新操作，而 <code>__index</code> 用于表的查询操作。<br>当对一个表中不存在的索引赋值时，解释器就会触发 <code>__newindex</code> 元方法，如果这个元方法存在则会直接调用它，而不会继续执行赋值操作。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, key, value)</span></span></span><br><span class="line">    <span class="built_in">error</span>(<span class="string">"attempt to update a nonexistent field"</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = new&#123;width = <span class="number">50</span>, height = <span class="number">50</span>&#125;</span><br><span class="line">obj.name = <span class="string">"Window"</span> <span class="comment">-- 赋值不存在的键时，产生错误</span></span><br></pre></td></tr></table></figure><p>上面例子中，我们可以使用 <code>__newindex</code> 元方法来拦截对不存在的字段的赋值操作，当不存在的 <code>name</code> 字段赋值时，会触发 <code>__newindex</code> 元方法，并抛出一个赋值错误的异常。</p><h3 id="newindex-元方法与-rawset-函数"><a href="#newindex-元方法与-rawset-函数" class="headerlink" title="__newindex 元方法与 rawset 函数"></a>__newindex 元方法与 rawset 函数</h3><p>与函数 <code>rawget</code> 类似，原始函数 <code>rawset (t, k, v)</code> 允许我们绕过元方法，直接对某个表进行赋值操作。其中参数 t 必须时一张表，当我们调用 <code>rawset(t, k, v)</code> 时，其等价于 <code>t[k] = v</code>，但不会触发任何元方法。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, key, value)</span></span></span><br><span class="line">    <span class="keyword">if</span> key == <span class="string">"name"</span> <span class="keyword">and</span> <span class="built_in">type</span>(value) ~= <span class="string">"string"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">"the assignment must be of type string"</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">rawset</span>(t, key, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = new&#123;width = <span class="number">50</span>, height = <span class="number">50</span>&#125;</span><br><span class="line">obj.name = <span class="number">1</span> <span class="comment">-- 非字符串类型，产生错误</span></span><br></pre></td></tr></table></figure><p>上面例子中，当我们对对象的 <code>name</code> 字段赋值时，会触发 <code>__newindex</code> 元方法，该函数会检查 <code>name</code> 字段的值是否为字符串类型，如果不是则会抛出错误，否则执行正常赋值操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lua 语言中每中类型的值都有一套可预见的操作集合，比如可以将数字相加，将字符串连接，还可以在表中插入键值对。但我们却无法直接将两个表相加，无法对表进行直接比较，除非我们使用元表。&lt;br&gt;元表可以修改一个值在面对未知操作时的行为。例如，我们对两个表 a 和 b 执行 &lt;code&gt;a + b&lt;/code&gt; 操作，Lua 在试图将两个表相加时，会检查其中某个表是否含有元表(metatable)，且元表中是否含有 &lt;code&gt;__add&lt;/code&gt; 字段，如果 Lua 找到该字段，则调用该字段对应的值，这就是所有的元方法(metamethod)。&lt;/p&gt;
&lt;p&gt;在元表中每个元方法的键的命名都是一个双下划线（__）加事件名的，键关联的那些值被称为元方法。上面说的 &lt;code&gt;_add&lt;/code&gt; 就是元方法键名称，而对应的元方法值是执行加操作的函数。&lt;/p&gt;
&lt;h2 id=&quot;获取与设置元表&quot;&gt;&lt;a href=&quot;#获取与设置元表&quot; class=&quot;headerlink&quot; title=&quot;获取与设置元表&quot;&gt;&lt;/a&gt;获取与设置元表&lt;/h2&gt;&lt;p&gt;在 Lua 中每个值都可以有元表，而元表只是一个普通的Lua表。&lt;br&gt;每个表和用户数据类型都具有各自独立的元表，而其他类型的值则共享对于类型所属的同一个元表。&lt;br&gt;我们可以使用 &lt;code&gt;getmetatable&lt;/code&gt; 获取一个表的元表，注意，刚创建的新表是没有元表的：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;t = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;getmetatable&lt;/span&gt;(t))  &lt;span class=&quot;comment&quot;&gt;--&amp;gt; nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另外，我们可以使用 &lt;code&gt;setmetatable&lt;/code&gt; 来设置和修改任意表的元表：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;t1 = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;setmetatable&lt;/span&gt;(t, t1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;getmetatable&lt;/span&gt;(t) == t1)    &lt;span class=&quot;comment&quot;&gt;--&amp;gt; true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 Lua 中我们只能为表设置元表，如果要为其他类型值设置元表，则必须通过C代码或调试库完成。另外，字符串库为所有字符串都设置了同一个元表，而其他类型默认是没有元表的：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;getmetatable&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;))    &lt;span class=&quot;comment&quot;&gt;--&amp;gt; table: 0106F578&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;getmetatable&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;world&quot;&lt;/span&gt;))    &lt;span class=&quot;comment&quot;&gt;--&amp;gt; table: 0106F578&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;getmetatable&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;))       &lt;span class=&quot;comment&quot;&gt;--&amp;gt; nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Lua入门教程" scheme="https://veinin.com/categories/Lua%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Lua编程" scheme="https://veinin.com/tags/Lua%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Lua 5.3" scheme="https://veinin.com/tags/Lua-5-3/"/>
    
      <category term="元表" scheme="https://veinin.com/tags/%E5%85%83%E8%A1%A8/"/>
    
      <category term="元方法" scheme="https://veinin.com/tags/%E5%85%83%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua入门教程：模块与包</title>
    <link href="https://veinin.com/2018/12/20/programming_in_lua_10/"/>
    <id>https://veinin.com/2018/12/20/programming_in_lua_10/</id>
    <published>2018-12-20T12:34:15.000Z</published>
    <updated>2019-03-25T16:16:50.666Z</updated>
    
    <content type="html"><![CDATA[<p>Lua 从 5.1 版本开始为模块与包定义了一系列规则，这些规则不需要引入额外的功能特性。对用户来说，一个模块就是一些代码，这些代码可以通过 require 函数加载。</p><p>值得注意的是，从 Lua 5.2 开始编写模块的建议方式已经发生改变，而不在是 Lua 5.1 中的 module(“mymodule”, package.seall) 。现在根据推荐的是创建一个本地表，将所有模块函数放入其中并返回表，其最大的区别是不会再使用全局命名空间来注册模块。</p><h2 id="模块的基本方法"><a href="#模块的基本方法" class="headerlink" title="模块的基本方法"></a>模块的基本方法</h2><p>定义一个简单的模块，该模块在文件 <code>test_module.lua</code> 中，其模块有两个函数 <code>foo</code> 和 <code>bar</code>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test_module.lua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"foo"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br></pre></td></tr></table></figure><a id="more"></a><p>另外，还有一种编写模块的方法是把所有函数定义为局部变量，然后在最后构造模块并返回一个表：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test_module.lua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"foo"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    foo = foo,</span><br><span class="line">    bar = bar,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种编写模块的方式与上一种运行结果是一样的，其优点是无需在每个函数前使用表示符 M. 或类似的这种东西，最后再显示的导出相应的表。但这种方式有一个缺点就是导出表处在模块的最后，我们需要把导出的名字都写两边，会有点冗余。</p><p>当然，不管怎么，最后我们都能通过 require 函数获取到模块并使用它：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- module_main.lua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tm = <span class="built_in">require</span> <span class="string">"test_module.lua"</span></span><br><span class="line"></span><br><span class="line">tm.foo() <span class="comment">--&gt; foo</span></span><br><span class="line">tm.bar() <span class="comment">--&gt; bar</span></span><br></pre></td></tr></table></figure><h2 id="require-函数"><a href="#require-函数" class="headerlink" title="require 函数"></a>require 函数</h2><p>require 只是一个简单的加载模块的函数，我们如果需要使用某个模块，我们只需向其传入模块名作为参数，就可以获取指定的模块代码。 require 使用方式通常有两种：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用括号</span></span><br><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span>(<span class="string">"test_module"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不使用括号</span></span><br><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span> <span class="string">"tet_module"</span></span><br></pre></td></tr></table></figure><p>这两种方式并没有什么差异性，它们的运行方式是一样的。但对于 require 执行方式，我们还是有必要了解以下其运行原理的：</p><ul><li>首先 rquire 函数调用时，会去一个叫做 package.loaded 的全局表中查找模块是否已经加载，如果已经加载则返回对于的值。</li><li>如果 package.loaded 没有找到对于的模块名，则会进一步搜索具有自定模块名的 Lua 文件（搜索路径由 package.path 决定），如果找打对于文件则调用 loadfile 函数加载。</li><li>进一步，如果找不到指定模块名的 Lua 文件，那么会继续搜索对于名称的的 C 标准库文件（搜索路径由 package.cpath 决定），如果找到 C 标准库，则会使用 package.loadlib 函数进行加载。</li><li>最后，如果找到模块由返回值，那么 require 会返回这个值，并保存在表 package.loaded 中，以便下次加载时返回相同的值。如果找到的模块没有任何返回值，返回值会设置为 true。</li></ul><p>因为由 package.loaded 的存在，除了第一次加载会执行一系列搜索模块规则外，后续的调用都会直接返回 package.loaded 中的值，如果我们希望再次强制加载一此模块，以达到比如重新更新模块的代码，我们可以这样做：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>.modname = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span> <span class="string">"modname"</span></span><br></pre></td></tr></table></figure><h2 id="require-搜索路径"><a href="#require-搜索路径" class="headerlink" title="require 搜索路径"></a>require 搜索路径</h2><p>require 使用的路径是一组模板，其中每一项都指定了如何将模块名转换为文件名的方式，其中每一个模板都是一个包含了可选问好的文件名， require 会将传入的模块名替换每一个问号，然后再一次检查每一项是否存在该文件名，如果目标不存在，则检查下一个模板。我们可以看下面这组路径：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Lua\bin\lua\?;D:\Lua\bin\lua\?\?.lua;</span><br></pre></td></tr></table></figure><p>如果使用 require “test” 加载模块，则会将上面路径转换为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\Lua\bin\lua\test</span><br><span class="line">D:\Lua\bin\lua\test\test.lua</span><br></pre></td></tr></table></figure><p>前面提到了 require 用于搜索 Lua 文件路径的变量是 package.path，其默认值初始化后会设置为环境变量 <code>LUA_PATH_5_3</code> 的值，如果没有 <code>LUA_PATH_5_3</code> 这个环境变量则会尝试找到 <code>LUA_PATH</code> 这个变量进行设置。</p><p>对于 C 标准库的路径其用变量名叫做 package.cpath，其默认值来自环境变量 <code>LUA_CPATH_5_3</code> 或者 <code>LUA_CPATH</code>。需要注意的是，package.cpath 的值在 POSIX 系统和 Windows 系统中是由差异的，比如在 POSIX 系统中，其典型的值为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./?.so;/usr/<span class="keyword">local</span>/lib/lua/<span class="number">5.3</span>/?.so</span><br></pre></td></tr></table></figure><p>可以看到 POSIX 系统中，库名称都是 .so 结尾，而在 Windows 中会变成 .dll：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\?.dll;D:\Lua\lua53\lib\?dll</span><br></pre></td></tr></table></figure><p>另外，我们还需要了解函数 <code>package.searchpath(name, path)</code> 函数，该函数实现了搜索库的所有规则，我们可以传入一个模块名和路径来搜索文件，该函数会返回抵押给存在的文件，如果不存在则会返回 nil 和无法加载成功的错误信息。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">path</span> = <span class="string">".\\?.dll;D:\\lua\\lib\\?.dll"</span></span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">package</span>.searchpath(<span class="string">"test"</span>, <span class="built_in">path</span>))</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">        no file <span class="string">'.\test.dll'</span></span><br><span class="line">        no file <span class="string">'D:\lua\lib\test.dll'</span></span><br></pre></td></tr></table></figure><h2 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h2><p>加载器的作用是用来搜索 Lua 文件或者 C 标准库文件。在变量数组 <code>package.searchers</code> 中存放了 require 所需要使用的所有类型的加载器，当查找一个模块是，require 会按次序使用这些加载器，并传入模块名进行搜索。如果某个加载器找到模块，则停止搜索并返回，如果使用完所有加载器都没有找到模块，则 require 函数会抛出异常。</p><p>Lua 用四个查找器函数初始化 <code>package.searchers</code> 表：</p><ul><li>第一个查找器就是简单的在 package.preload 表中查找加载器。</li><li>第二个查找器用于查找 Lua 库文件，它使用变量 package.path 中的路径来做查找工作。</li><li>第三个查找器用于查找 C 库文件，它使用变量 package.cpath 中的路径来做查找工作。</li><li>第四个查找器我们称之为一体化加载器，它从 C 库路径中查找指定模块的根名字，比如请求 a.b.c　时，它将查找 a 这个 C 库，如果找到，再加载函数，这个例子中则是 <code>luaopen_a_b_c</code>。利用这个机制，可以把若干 C 子模块打包进单个库，每个子模块都可以有原本的加载函数名。</li></ul><p>除了上面所说的加载器之外，我们也可以为一些特殊模块定义预加载器，预加载查找器会使用要给名为 <code>package.preload</code> 的表来映射模块名称和加载函数，当加载指定模块时，如果检查到 <code>package.preload</code> 定义了预加载器函数，则会直接使用该函数作为模块加载，并使用其返回值返回。</p><h2 id="子模块与包"><a href="#子模块与包" class="headerlink" title="子模块与包"></a>子模块与包</h2><p>在一个负责的软件系统中，其一般会包含多个软件模块，每个模块又会分配多个子模块，而 Lua 是支持这种具有层次结构的模块分配的。比如，一个名为 <code>mod.sub</code> 的模块是模块 <code>mod</code> 的一个子模块 <code>sub</code>，我们可以看下面这样的树形结构的模块示意：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">    mod</span><br><span class="line">        sub</span><br><span class="line">    mod2</span><br><span class="line">        sub2</span><br><span class="line">        sub3</span><br></pre></td></tr></table></figure><p>当搜索一个子模块时，函数 require 会将点转换为对于操作系统中的分隔符，如 POSIX 操作系统中的斜杠或 Windows 操作系统中的反斜杠。转换完成后，再对搜索路径的问号进行替换，然后走上面介绍的的模块搜索流程。如下面路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\?.lua;D:\Lua\?.lua;</span><br></pre></td></tr></table></figure><p>当调用 <code>require &quot;a.b&quot;</code> 时，会生成以下搜索路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.\a\b.lua</span><br><span class="line">D:\Lua\a\b.lua;</span><br><span class="line">D:\Lua\a\b\init.lua;</span><br></pre></td></tr></table></figure><p>这种搜索行为可以让我们很容易的把一个模块中的所有文件放置到同一个目录下，比如模块 m、m.a、m.b 对于的文件可以分别时 m/init.lua、m/a.lua、m/b.lua，而目录 m 可以放置在合适的任意位置，其他模块搜索只需要设置其搜索路径即可。</p><p>另外，C 语言中名称是不能包含点，因此在编写 C 标准库时，子模块 a.b 是无法导出函数 lua_a.b的，这时，require 函数会将点替换为下划线，即名为 lua_a_b 的 C 标准库函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lua 从 5.1 版本开始为模块与包定义了一系列规则，这些规则不需要引入额外的功能特性。对用户来说，一个模块就是一些代码，这些代码可以通过 require 函数加载。&lt;/p&gt;
&lt;p&gt;值得注意的是，从 Lua 5.2 开始编写模块的建议方式已经发生改变，而不在是 Lua 5.1 中的 module(“mymodule”, package.seall) 。现在根据推荐的是创建一个本地表，将所有模块函数放入其中并返回表，其最大的区别是不会再使用全局命名空间来注册模块。&lt;/p&gt;
&lt;h2 id=&quot;模块的基本方法&quot;&gt;&lt;a href=&quot;#模块的基本方法&quot; class=&quot;headerlink&quot; title=&quot;模块的基本方法&quot;&gt;&lt;/a&gt;模块的基本方法&lt;/h2&gt;&lt;p&gt;定义一个简单的模块，该模块在文件 &lt;code&gt;test_module.lua&lt;/code&gt; 中，其模块有两个函数 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- test_module.lua&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt; M = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;M.foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;M.bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; M&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Lua入门教程" scheme="https://veinin.com/categories/Lua%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Lua编程" scheme="https://veinin.com/tags/Lua%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Lua 5.3" scheme="https://veinin.com/tags/Lua-5-3/"/>
    
  </entry>
  
  <entry>
    <title>Lua入门教程：编译、执行和错误</title>
    <link href="https://veinin.com/2018/12/17/programming_in_lua_09/"/>
    <id>https://veinin.com/2018/12/17/programming_in_lua_09/</id>
    <published>2018-12-17T13:13:20.000Z</published>
    <updated>2019-03-25T16:16:47.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dofile-与-loadfile-函数"><a href="#dofile-与-loadfile-函数" class="headerlink" title="dofile 与 loadfile 函数"></a>dofile 与 loadfile 函数</h2><p>dofile 是一个辅助函数，函数 loadfile 才完成了真正的核心工作。 两个函数都是从文件中加载 Lua 代码，但它不会运行，只是编译代码，然后把编译后的代码作为函数返回。<br>与 dofile 不同，loadfile 不会抛出异常，只会返回错误码。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dofile</span><span class="params">(filename)</span></span></span><br><span class="line">    <span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(filename))</span><br><span class="line">    <span class="keyword">return</span> f()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="load-函数"><a href="#load-函数" class="headerlink" title="load 函数"></a>load 函数</h2><p>与 loadfile 类似，但该函数是从一个字符串中读取代码。</p><p>编写用后即弃的代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">s = <span class="string">"i = i + 1"</span></span><br><span class="line"><span class="built_in">load</span>(s)() <span class="comment">--&gt; 1</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>该函数加载的代码如果有语法错误，load 会返回 nil 和 错误信息，所以最好使用 assert：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(<span class="built_in">load</span>(s))()</span><br></pre></td></tr></table></figure><p>laod 加载编译时不会设计词法定界，该函数总是在全局环境中编译代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">32</span></span><br><span class="line"><span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">f = <span class="built_in">load</span>(<span class="string">"i = i + 1; print(i)"</span>)</span><br><span class="line">g = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> i = i + <span class="number">1</span>; <span class="built_in">print</span>(i) <span class="keyword">end</span></span><br><span class="line">f() <span class="comment">--&gt; 33</span></span><br><span class="line">g() <span class="comment">--&gt; 1</span></span><br></pre></td></tr></table></figure><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>Lua 会在遇到非预期的情绪时引发错误，如将非数值类型相加，对不是函数的值进行调用等。</p><p>也可以调用函数 error 并传入一个错误信息来作为参数引发一个错误：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">"n"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="built_in">error</span>(<span class="string">"invalid input"</span>) <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当然上面这种情况更简单的代码结构是使用 assert 函数来完成，assert 函数检查第一个参数是否为真，如果为真则返回该参数，否则引发一个错误，并用第二个参数作为错误提示信息：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">"n"</span>), <span class="string">"invalid input"</span>)</span><br></pre></td></tr></table></figure><p>Lua 中要给函数发现某个错误是，在进行异常处理时有两种选择：</p><ul><li>返回错误代码（nil 或是 false）</li><li>通过函数 error 引发一个错误。</li></ul><p>通常容易避免的错误应该引发错误，否则应该返回错误码。</p><h2 id="错误处理和异常"><a href="#错误处理和异常" class="headerlink" title="错误处理和异常"></a>错误处理和异常</h2><p>要执行一段代码并捕获一段错误(try-catch)可以使用pcall函数，该函数以一种保护模式调用它的第一个参数，如果没有发生错误会返回true和调用函数的返回参数，否则返回false和错误信息。<br>我们可以通过 error(throw an exception) 来抛出异常，并通过 pcall 来捕获 (catch) 异常。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ok, msg = <span class="built_in">pcall</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    some code</span><br><span class="line">    <span class="keyword">if</span> unexpected_condition <span class="keyword">then</span> <span class="built_in">error</span>() <span class="keyword">end</span></span><br><span class="line">    some code</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok <span class="keyword">then</span></span><br><span class="line">    regular code</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">error</span>-handing code</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>另外，error 函数还有第2个可选参数 level，用于只想函数调用层次中的哪层函数报告错误，以说明谁应该为错误负责。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(str)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(str) ~= <span class="string">"string"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">"string expected"</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    regualr code</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>最后，我们如果希望错误发生时获得更多的调试信息，比如发生错误时一个完整的函数调用栈信息。<br>pcall 如果发生错误时，部分的调用栈已经被破坏了（从pcall到出错部分），如果希望得到一个完整的有意义的栈回溯，则必须在函数 pcall 返回前先将调用栈构好。<br>为了实现上面的需求，我们可以使用 xpcall 函数，该函数第二个参数是一个消息处理函数，当错误发生时，Lua 会在调用栈展开前调用这个消息处理函数，我们可以使用 debug.traceback 来获取更多错误信息。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">error_handler</span><span class="params">(msg)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>(<span class="built_in">tostring</span>(msg), <span class="number">2</span>))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">xpcall</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    some code</span><br><span class="line">    <span class="keyword">if</span> unexpected_c  ondition <span class="keyword">then</span> <span class="built_in">error</span>() <span class="keyword">end</span></span><br><span class="line">    some code</span><br><span class="line"><span class="keyword">end</span>, error_handler)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;dofile-与-loadfile-函数&quot;&gt;&lt;a href=&quot;#dofile-与-loadfile-函数&quot; class=&quot;headerlink&quot; title=&quot;dofile 与 loadfile 函数&quot;&gt;&lt;/a&gt;dofile 与 loadfile 函数&lt;/h2&gt;&lt;p&gt;dofile 是一个辅助函数，函数 loadfile 才完成了真正的核心工作。 两个函数都是从文件中加载 Lua 代码，但它不会运行，只是编译代码，然后把编译后的代码作为函数返回。&lt;br&gt;与 dofile 不同，loadfile 不会抛出异常，只会返回错误码。&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dofile&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(filename)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt; f = &lt;span class=&quot;built_in&quot;&gt;assert&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;loadfile&lt;/span&gt;(filename))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;load-函数&quot;&gt;&lt;a href=&quot;#load-函数&quot; class=&quot;headerlink&quot; title=&quot;load 函数&quot;&gt;&lt;/a&gt;load 函数&lt;/h2&gt;&lt;p&gt;与 loadfile 类似，但该函数是从一个字符串中读取代码。&lt;/p&gt;
&lt;p&gt;编写用后即弃的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;i = i + 1&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;load&lt;/span&gt;(s)() &lt;span class=&quot;comment&quot;&gt;--&amp;gt; 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Lua入门教程" scheme="https://veinin.com/categories/Lua%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Lua编程" scheme="https://veinin.com/tags/Lua%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Lua 5.3" scheme="https://veinin.com/tags/Lua-5-3/"/>
    
  </entry>
  
  <entry>
    <title>Lua入门教程：数值</title>
    <link href="https://veinin.com/2018/12/15/programming_in_lua_01/"/>
    <id>https://veinin.com/2018/12/15/programming_in_lua_01/</id>
    <published>2018-12-15T12:12:33.000Z</published>
    <updated>2019-03-25T16:16:45.096Z</updated>
    
    <content type="html"><![CDATA[<p>Lua 5.2 以及之前的版本，所有数值类型都是以双精度浮点数表示，并且所有浮点型数值最大都是 <code>2^54</code>，但是 Lua 5.3 版本引入了整形，最大可用 64 位表示。</p><h2 id="数值表示方式"><a href="#数值表示方式" class="headerlink" title="数值表示方式"></a>数值表示方式</h2><p>Lua 数值默认是十进制表示，除了整形之外，其他小数或者指数都会当做浮点型数值。我们可以使用函数 <code>type</code> 来获数值类型，他们都是使用 <code>number</code> 表示数值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>         <span class="comment">--&gt; 1</span></span><br><span class="line">&gt; <span class="number">1.0</span>       <span class="comment">--&gt; 1.0</span></span><br><span class="line">&gt; <span class="number">1.2e5</span>     <span class="comment">--&gt; 120000.0</span></span><br><span class="line">&gt; <span class="number">0.2e4</span>     <span class="comment">--&gt; 2000.0</span></span><br><span class="line">&gt; <span class="number">0xff</span>      <span class="comment">--&gt; 255</span></span><br><span class="line">&gt; <span class="built_in">type</span>(<span class="number">1</span>)   <span class="comment">--&gt; number</span></span><br><span class="line">&gt; <span class="built_in">type</span>(<span class="number">1.0</span>) <span class="comment">--&gt; number</span></span><br></pre></td></tr></table></figure><p>在 Lua 5.3 中为了区分整形和浮点型数值，引入了 <code>math.type</code> 函数，如果是整形该函数返回 <code>integer</code>，浮点型则返回 <code>float</code>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">type</span>(<span class="number">1</span>)      <span class="comment">--&gt; integer</span></span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">type</span>(<span class="number">1.0</span>)    <span class="comment">--&gt; float</span></span><br></pre></td></tr></table></figure><p>同时为了方便判断是否可以把一个数转换到整数，Lua 5.3 引入了 <code>math.tointeger</code> 函数，如果目标可以转换为一个整数，返回该整数，否则返回 <code>nil</code> ：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">math</span>.tointeger(<span class="number">3.0</span>)   <span class="comment">--&gt; 3</span></span><br><span class="line">&gt; <span class="built_in">math</span>.tointeger(<span class="number">3.1</span>)   <span class="comment">--&gt; nil</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><p>Lua 5.3 引入整形后，如果我们对两个整形进行加(+)、减(-)、乘(*)、除(/)、取负数(-)操作，其结果任然是整形。并且为了方便我们对整数进行除法运算，引入了一个新的 <code>float</code> 除法运算符 <code>//</code>，该运算符会对得到的商向负无穷取整，从而保证结果是一个整形。而如果我们忽略整形和浮点型之间的区别，那么其运算规则和其他的 5.x 版本没有任何差别：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&gt; <span class="number">1</span> + <span class="number">1</span>     <span class="comment">--&gt; 2</span></span><br><span class="line">&gt; <span class="number">1</span> + <span class="number">1.0</span>   <span class="comment">--&gt; 2.0</span></span><br><span class="line">&gt; <span class="number">1.0</span> + <span class="number">1.0</span> <span class="comment">--&gt; 2.0</span></span><br><span class="line">&gt; <span class="number">6</span> // <span class="number">3</span>    <span class="comment">--&gt; 2</span></span><br><span class="line">&gt; <span class="number">-6</span> // <span class="number">-3</span>  <span class="comment">--&gt; 2</span></span><br><span class="line">&gt; <span class="number">2.0</span> // <span class="number">2</span>  <span class="comment">--&gt; 1.0</span></span><br><span class="line">&gt; <span class="number">1</span> // <span class="number">0.5</span>  <span class="comment">--&gt; 2.0</span></span><br><span class="line">&gt; <span class="number">1</span> + <span class="number">0.0</span>   <span class="comment">--&gt; 1.0</span></span><br><span class="line">&gt; <span class="number">1.0</span> | <span class="number">0</span>   <span class="comment">--&gt; 1</span></span><br></pre></td></tr></table></figure><h2 id="数值关系运算"><a href="#数值关系运算" class="headerlink" title="数值关系运算"></a>数值关系运算</h2><p>我们可以使用 Lua 的关系运算符大于（&gt;）、小于（&lt;）、大于且等于（&gt;=）、小于且等于（&lt;=）以及不等于（~=）对数数值进行关系运算：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span> &lt; <span class="number">2</span>     <span class="comment">--&gt; true</span></span><br><span class="line">&gt; <span class="number">1</span> &gt; <span class="number">2</span>     <span class="comment">--&gt; false</span></span><br><span class="line">&gt; <span class="number">2</span> &gt;= <span class="number">2</span>    <span class="comment">--&gt; true</span></span><br><span class="line">&gt; <span class="number">3</span> &lt;= <span class="number">4</span>    <span class="comment">--&gt; true</span></span><br><span class="line">&gt; <span class="number">4</span> ~= <span class="number">4</span>    <span class="comment">--&gt; false</span></span><br><span class="line">&gt; <span class="number">5.0</span> ~= <span class="number">5</span>  <span class="comment">--&gt; false</span></span><br><span class="line">&gt; <span class="number">1.0</span> == <span class="number">1</span>  <span class="comment">--&gt; true</span></span><br></pre></td></tr></table></figure><h2 id="数值运算符优先级"><a href="#数值运算符优先级" class="headerlink" title="数值运算符优先级"></a>数值运算符优先级</h2><p>Lua 中操作符的优先级从高优先级到低优先级排序表示如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line">一元运算符 (<span class="keyword">not</span>   #     -     ~)</span><br><span class="line">*     /     //    %</span><br><span class="line">+     -</span><br><span class="line">..</span><br><span class="line">&lt;&lt;    &gt;&gt;</span><br><span class="line">&amp;</span><br><span class="line">~</span><br><span class="line">|</span><br><span class="line">&lt;     &gt;     &lt;=    &gt;=    ~=    ==</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line"><span class="keyword">or</span></span><br></pre></td></tr></table></figure><p>通常，你可以用括号来改变运算次序。连接操作符 (‘..’) 和乘方操作 (‘^’) 是从右至左的。 其它所有的操作都是从左至右。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span> + <span class="number">2</span> == <span class="number">2</span> * <span class="number">3</span> // <span class="number">2</span>      <span class="comment">--&gt;  (1 + 2) == (2 * 3) // 2</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span> <span class="keyword">or</span> <span class="number">2</span>             <span class="comment">--&gt;  (1 and 3) or 2</span></span><br><span class="line">&gt; <span class="number">-1</span> ^ <span class="number">2</span>                   <span class="comment">--&gt;  -(1^2)</span></span><br><span class="line">&gt; <span class="number">1</span> + <span class="number">2</span> &gt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>Lua 5.3 版本开始提供针对数值类型的一组标准位运算符，与算术运算符不同的是，位运算只能用于整形数值。</p><p>位运算符包括：</p><ul><li><strong>&amp;</strong>，按位与</li><li><strong>|</strong>，按位或</li><li><strong>~</strong>，按位异或</li><li><strong>&gt;&gt;</strong>，右移</li><li><strong>&lt;&lt;</strong>，左移</li><li><strong>~</strong>，按位取反</li></ul><p>下面例子中的位运算符使用了函数 string.format 来输出十六进制形式的结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%s"</span>, <span class="number">0xff</span> &amp; <span class="number">0xabcd</span>) <span class="comment">--&gt; cd</span></span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%s"</span>, <span class="number">0xff</span> | <span class="number">0xabcd</span>) <span class="comment">--&gt; abcd</span></span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%x"</span>, <span class="number">0xaaaa</span> ~ <span class="number">-1</span>)   <span class="comment">--&gt; ffffffffffff5555</span></span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%x"</span>, ~<span class="number">0</span>)            <span class="comment">--&gt; ffffffffffffffff</span></span><br></pre></td></tr></table></figure><h2 id="数学库"><a href="#数学库" class="headerlink" title="数学库"></a>数学库</h2><p>除了前面提到 Lua 5.3 新增的 <code>math.type</code>、<code>math.tointeger</code> 函数外，Lua 还提供了其他一系列基础的数学操作函数库给我们，基本能满足我们日常编程的大部分需求。</p><h3 id="基本数值运算函数"><a href="#基本数值运算函数" class="headerlink" title="基本数值运算函数"></a>基本数值运算函数</h3><ul><li>math.abs(x)，返回 x 的绝对值。</li><li>math.acos(x)，返回 x 的反余弦值（用弧度表示）。</li><li>math.asin(x)，返回 x 的反正弦值（用弧度表示）。</li><li>math.atan(x)，返回 y/x 的反正切值（用弧度表示）。</li><li>math.ceil(x)，返回不小于 x 的最小整数值。</li><li>math.cos(x)，返回 x 的余弦（假定参数是弧度）。</li><li>math.deg(x)，将角 x 从弧度转换为角度。</li><li>math.exp(x)，返回 ex 的值 （e 为自然对数的底）。</li><li>math.floor(x)，返回不大于 x 的最大整数值。</li><li>math.fmod(x)，返回 x 除以 y，将商向零圆整后的余数。 (integer/float)</li><li>math.log(x)，返回以指定底的 x 的对数。 默认的 base 是 e （因此此函数返回 x 的自然对数）。</li><li>math.modf(x)，返回 x 的整数部分和小数部分。 第二个结果一定是浮点数。</li><li>math.rad(x)，将角 x 从角度转换为弧度。</li><li>math.sin(x)，返回 x 的正弦值（假定参数是弧度）。</li><li>math.sqrt(x)，返回 x 的平方根。</li><li>math.tan(x)，返回 x 的正切值。</li><li>math.ult(x)，如果整数 m 和 n 以无符号整数形式比较， m 在 n 之下，返回布尔真否则返回假。</li><li>math.min(x, …)，返回参数中最小的值， 大小由 Lua 操作 &lt; 决定。</li><li>math.max(x, …)，返回参数中最大的值， 大小由 Lua 操作 &lt; 决定。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">abs</span>(<span class="number">-10</span>)     <span class="comment">--&gt; 10</span></span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">floor</span>(<span class="number">2.33</span>)  <span class="comment">--&gt; 2</span></span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">floor</span>(<span class="number">-2.33</span>) <span class="comment">--&gt; -3</span></span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">ceil</span>(<span class="number">2.33</span>)   <span class="comment">--&gt; 3</span></span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">ceil</span>(<span class="number">-2.33</span>)  <span class="comment">--&gt; -2</span></span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">modf</span>(<span class="number">2.3</span>)    <span class="comment">--&gt; 2   0.3</span></span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">modf</span>(<span class="number">-2.3</span>)   <span class="comment">--&gt; -2  -0.3</span></span><br></pre></td></tr></table></figure><h3 id="数值返回表示"><a href="#数值返回表示" class="headerlink" title="数值返回表示"></a>数值返回表示</h3><p>前面说过，Lua 5.3 使用 64 位来存储整数值，其最大值为 2^63 - 1，数学库中可以使用 <code>math.maxinteger</code> 与 <code>math.mininteger</code> 来表示整数的最大值和最小值。另外 Lua 使用 <code>math.huge</code> 这个值来表示最大的数，这个值比我们能用到的所有数值都要大。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">pi</span>               <span class="comment">--&gt; 3.1415926535898 (π 的值)</span></span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">huge</span>             <span class="comment">--&gt; inf</span></span><br><span class="line">&gt; <span class="built_in">math</span>.maxinteger       <span class="comment">--&gt; 9223372036854775807</span></span><br><span class="line">&gt; <span class="built_in">math</span>.mininteger       <span class="comment">--&gt; -9223372036854775808</span></span><br><span class="line">&gt; <span class="built_in">math</span>.maxinteger + <span class="number">1</span>   <span class="comment">--&gt; -9223372036854775808</span></span><br><span class="line">&gt; <span class="built_in">math</span>.mininteger - <span class="number">1</span>   <span class="comment">--&gt; 9223372036854775807</span></span><br><span class="line">&gt; <span class="built_in">math</span>.maxinteger &lt; <span class="built_in">math</span>.<span class="built_in">huge</span>   <span class="comment">--&gt; true</span></span><br></pre></td></tr></table></figure><p>再次强调，Lua 中所有双精度浮点型的值最大只能用 <code>2^53 - 1</code> 表示，如果超过这个数值，进行数值运算则会造成精度损失：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">9007199254740992</span> + <span class="number">0.0</span> == <span class="number">9007199254740992</span>    <span class="comment">--&gt; true</span></span><br><span class="line">&gt; <span class="number">9007199254740993</span> + <span class="number">0.0</span> == <span class="number">9007199254740993</span>    <span class="comment">--&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>Lua 使用 <code>math.random ([m [, n]])</code> 来产生伪随机数，其有 3 种随机数产生方式：</p><ul><li>不带任何参数时，返回一个 [0, 1) 区间内一致分布的浮点伪随机数。</li><li>两个整数 m 与 n 调用时， math.random 返回一个 [m, n] 区间 内一致分布的整数伪随机数。值 n-m 不能是负数，且必须在 Lua 整数的表示范围内。）</li><li>当调用 math.random(n) 时，其等价于 math.random(1, n)。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">random</span>()     <span class="comment">--&gt; 0.56356811523438</span></span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, <span class="number">4</span>) <span class="comment">--&gt; 1</span></span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">4</span>)    <span class="comment">--&gt; 4</span></span><br></pre></td></tr></table></figure><p>作为伪随机数函数，我们每次重新启动 Lua 虚拟机时，其产生随机数都会与上次启动时一模一样，比如在游戏中，我们每次重启游戏后，其产生的随机数都会和上一次启动时一模一样，这其实不是我们所想要的，为了使程序每次启动时都会有不同的随机数产生，我们就需要使用 <code>math.randomseed (x)</code> 函数来初始化随机数生成器。当我们调用次函数后，后面的所有随机数都是基于此函数设置的种子生成的。</p><p>通常来说，对于随机数种子，如果没有特殊需求，那么我们直接使用 <code>os.time()</code> 获取当前系统时间来当做随机数种子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="built_in">os</span>.<span class="built_in">time</span>())</span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">random</span>() <span class="comment">--&gt; 0.84405517578125</span></span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="built_in">os</span>.<span class="built_in">time</span>())</span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">random</span>() <span class="comment">--&gt; 0.79620361328125</span></span><br></pre></td></tr></table></figure><p>但是有时候，我们必须设置特殊的随机数种子来让随机数表现出一致性，比如 Moba 游戏中，通常很多数值都是客户端进行运算，如果我们希望一局游戏中所有客户端产生的随机数都是一致的，那么我们可以让所有客户端在开始战斗前都统一设置一个随机数种子，那么不同的玩家客户端在同一局游戏中产生的所有随机数都会是一致的：</p><p>游戏客户端A:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="number">111231254123</span>)</span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">random</span>() <span class="comment">--&gt; 0.63229370117188</span></span><br></pre></td></tr></table></figure><p>游戏客户端B：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="number">111231254123</span>)</span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">random</span>() <span class="comment">--&gt; 0.63229370117188</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lua 5.2 以及之前的版本，所有数值类型都是以双精度浮点数表示，并且所有浮点型数值最大都是 &lt;code&gt;2^54&lt;/code&gt;，但是 Lua 5.3 版本引入了整形，最大可用 64 位表示。&lt;/p&gt;
&lt;h2 id=&quot;数值表示方式&quot;&gt;&lt;a href=&quot;#数值表示方式&quot; class=&quot;headerlink&quot; title=&quot;数值表示方式&quot;&gt;&lt;/a&gt;数值表示方式&lt;/h2&gt;&lt;p&gt;Lua 数值默认是十进制表示，除了整形之外，其他小数或者指数都会当做浮点型数值。我们可以使用函数 &lt;code&gt;type&lt;/code&gt; 来获数值类型，他们都是使用 &lt;code&gt;number&lt;/code&gt; 表示数值：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;         &lt;span class=&quot;comment&quot;&gt;--&amp;gt; 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;       &lt;span class=&quot;comment&quot;&gt;--&amp;gt; 1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;1.2e5&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;--&amp;gt; 120000.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;0.2e4&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;--&amp;gt; 2000.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;0xff&lt;/span&gt;      &lt;span class=&quot;comment&quot;&gt;--&amp;gt; 255&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;--&amp;gt; number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;--&amp;gt; number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 Lua 5.3 中为了区分整形和浮点型数值，引入了 &lt;code&gt;math.type&lt;/code&gt; 函数，如果是整形该函数返回 &lt;code&gt;integer&lt;/code&gt;，浮点型则返回 &lt;code&gt;float&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;built_in&quot;&gt;math&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)      &lt;span class=&quot;comment&quot;&gt;--&amp;gt; integer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;built_in&quot;&gt;math&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)    &lt;span class=&quot;comment&quot;&gt;--&amp;gt; float&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同时为了方便判断是否可以把一个数转换到整数，Lua 5.3 引入了 &lt;code&gt;math.tointeger&lt;/code&gt; 函数，如果目标可以转换为一个整数，返回该整数，否则返回 &lt;code&gt;nil&lt;/code&gt; ：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;built_in&quot;&gt;math&lt;/span&gt;.tointeger(&lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;--&amp;gt; 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;built_in&quot;&gt;math&lt;/span&gt;.tointeger(&lt;span class=&quot;number&quot;&gt;3.1&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;--&amp;gt; nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Lua入门教程" scheme="https://veinin.com/categories/Lua%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Lua编程" scheme="https://veinin.com/tags/Lua%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Lua 5.3" scheme="https://veinin.com/tags/Lua-5-3/"/>
    
  </entry>
  
  <entry>
    <title>玩转终端软件 Hyper</title>
    <link href="https://veinin.com/2018/11/30/hyper-windows-tutorial/"/>
    <id>https://veinin.com/2018/11/30/hyper-windows-tutorial/</id>
    <published>2018-11-29T17:20:00.000Z</published>
    <updated>2018-11-29T17:21:40.171Z</updated>
    
    <content type="html"><![CDATA[<p>相信有很多人开发环境是我 Windows 上面，有时候又不得不面临在 Windows 上面开发 Linux 环境的程序。还好 Windows 10 系统为我们提供了一个叫 WSL（Windows Subsystem for Linux） 的子系统。但是，尽管微软已经很努力得在改善 Windows 开发环境了，但我们却始终得不到一个比较简单易用得终端软件，最起码你用 Window 自带得终端来操作 Linux 系统还是会觉得缺了点什么。</p><p>目前市面上很多终端软件都比 Windows 自带终端好太多，比如这篇文章就介绍了 20 个比较好用终端软件：</p><p><a href="https://www.slant.co/topics/1552/~best-terminal-emulators-for-windows" target="_blank" rel="noopener">THE BEST 1 OF 20 OPTIONS</a></p><p>之前用过一个不错得软件叫做 <a href="http://cmder.net/" target="_blank" rel="noopener">Cmder</a>，但它不是今天得主角，我们今天要介绍得是另一款更符合我口味得终端软件 Hyper。</p><h2 id="获取并安装-Hyper"><a href="#获取并安装-Hyper" class="headerlink" title="获取并安装 Hyper"></a>获取并安装 Hyper</h2><p>你可以在一下几个地方获取到 Hyper：</p><ul><li>官方网站：<a href="http://cmder.net/" target="_blank" rel="noopener">入口</a></li><li>Github：<a href="https://github.com/zeit/hyper" target="_blank" rel="noopener">入口</a></li></ul><p>下载到二进制安装包后，直接安装就可以运行，本文运行环境是 Windows。</p><h2 id="基础插件安装"><a href="#基础插件安装" class="headerlink" title="基础插件安装"></a>基础插件安装</h2><p>Hyper 本身是支持插件系统的，在安装扩展插件时，你需要先安装 Hyper 命令行程序，你可以点击菜单，选择 <code>Plugin</code> 选项，点击 <code>Install Hyper CLI command in PATH</code>。</p><p><img src="/images/hyper/insall-path.png" alt="install"></p><p>其官方在首页推荐了4个比较易用的插件，推荐直接全部安装。安装地址请点击 <a href="https://hyper.is/plugins" target="_blank" rel="noopener">链接</a>。其中4款插件分别为：</p><ul><li><a href="https://hyper.is/plugins/hypercwd" target="_blank" rel="noopener">hypercwd</a>，它可以让你的终端在新建标签页时，保持上一个终端的目录地址。安装命令： <code>hyper i hypercwd</code>。</li><li><a href="https://hyper.is/plugins/hyper-search" target="_blank" rel="noopener">hyper-search</a>，它可以让你搜索整个终端的所有文本内容。安装命令： <code>hyper i hyper-search</code>。</li><li><a href="https://hyper.is/plugins/hyper-pane" target="_blank" rel="noopener">hyper-pane</a>，增强窗口导航，对于支持多个页签的软件来说这是个利器。安装命令： <code>hyper i hyper-pane</code>。</li><li><a href="https://hyper.is/plugins/hyper-pane" target="_blank" rel="noopener">hyperpower</a>，这是一个让你的终端变得更加绚丽的插件，当然这么炫酷的效果是不是会影响你的工作呢，还是要视个人情而定。安装命令： <code>hyper i hyperpower</code>。</li></ul><p><img src="https://cloud.githubusercontent.com/assets/13041/16820268/13c9bfe6-4905-11e6-8fe4-baf8fc8d9293.gif" alt="hyperpower"></p><a id="more"></a><h2 id="主题插件安装"><a href="#主题插件安装" class="headerlink" title="主题插件安装"></a>主题插件安装</h2><p>Hyper 支持插件系统，自然就少不了主题了，官方首页推荐了4种同颜色的主题，你可以直接在<a href="https://hyper.is/themes" target="_blank" rel="noopener">主题地址</a>查看并安装。</p><p><img src="/images/hyper/themes.png" alt="install"></p><p>当然，上面的满足不了你，你也可以去在上面的主题地址中的页签 <code>NEWEST</code> 找到更多主题，或者你也可以直接去 GitHub 搜索，抑或是你自己写一个主题插件。总之，你最终会找到一款符合你的主题皮肤。</p><h2 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h2><p>GitHub 有一个项目叫做 <a href="https://github.com/bnb/awesome-hyper" target="_blank" rel="noopener">awesome-hyper</a>，其列出了 Hyper 社区中精选的软件包、主题和相关有趣的资源列表，比如下面这款当你输入 <code>git push</code> 成功执行后，终端会出现火箭动画：</p><p><img src="https://user-images.githubusercontent.com/6589909/28026422-9dc92218-655b-11e7-8852-3ee8d57c87d5.gif" alt="git-push"></p><h2 id="Hyper-集成-WSL"><a href="#Hyper-集成-WSL" class="headerlink" title="Hyper 集成 WSL"></a>Hyper 集成 WSL</h2><p>通常我们在使用 WSL 工作时，希望启动终端时就进入 WSL bash 内部，Windows 中有一个 base.exe 程序可以让我们在启动终端后输入 <code>bash</code> 后进入 WSL 终端。<br>但这一步实在太繁琐了，有了 Hyper，我们只需要改动一下配置文件，上面这步就可以直接省略。</p><p>现在，你只需打开 Hyper 设置页面文件，这一步需要从菜单 Edit -&gt; Preferences 进入，然后编辑 <code>shell</code> 和 <code>shellArgs</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell: 'C:\\Windows\\System32\\wsl.exe',</span><br><span class="line">shellArgs: [],</span><br></pre></td></tr></table></figure><p>再次从新打开 Hyper，你会发现默认已经进入了 base 终端页面。</p><h2 id="使用-zsh-代替-bash"><a href="#使用-zsh-代替-bash" class="headerlink" title="使用 zsh 代替 bash"></a>使用 zsh 代替 bash</h2><p>通常 Linux 服务器上面默认使用的命令模式是 <code>bash</code>，除了 <code>bash</code> 之外，还有很多其他诸如 <code>zsh</code>、<code>csh</code>、<code>fish</code>等，这其中，我认为 <code>zsh</code> 增强功能（标签完成和拼写错误修正）会很吸引人。</p><h3 id="安装-zsh-和-oh-my-zsh"><a href="#安装-zsh-和-oh-my-zsh" class="headerlink" title="安装 zsh 和 oh-my-zsh"></a>安装 zsh 和 oh-my-zsh</h3><p>虽然 <code>zsh</code> 配置很繁琐，但这一步已经有人帮你完成了，GitHub 上面有一个项目叫做 <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a> 就是专门用来管理配置 <code>zsh</code> 的一个框架。</p><p>在使用 <code>oh-my-zsh</code> 之前，你需要安装 <code>zsh</code>，各个平台安装的方式可能不一样，你可以通过这个 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH" target="_blank" rel="noopener">链接</a> 查看 <code>zsh</code> 安装方式。</p><p>有了 <code>zsh</code> 后，要安装 <code>oh-my-zsh</code>，你还需要用 <code>wget</code> 或者 <code>curl</code> 来辅助安装：</p><ul><li>通过 curl 安装，<code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></li><li>通过 wget 安装，<code>sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</code></li></ul><p>安装完成后，你可以通过命令 <code>chsh -s /bin/zsh</code> 设置 <code>zsh</code> 为默认的 shell。</p><h3 id="安装自动补全功能"><a href="#安装自动补全功能" class="headerlink" title="安装自动补全功能"></a>安装自动补全功能</h3><p>使用 <code>zsh</code> 我认为第一个吸引我的重要插件就是 <a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">zsh-autosuggestions</a>。它会自动为你的终端命令提供补全建议，让你能更加快速的完成命令输入，有了它，你再也不用一遍遍的按 <code>tab</code> 来加快你的命令输入了。</p><p><code>zsh-autosuggestions</code> 安装文档你可以点击这个<a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md" target="_blank" rel="noopener">链接</a> 进入查看，比如使用 Git 安装步骤如下：</p><p>使用 Git 把项目从仓库 Clone 下来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>将以下内容添加到 <code>.zshrc</code> 文件内：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br></pre></td></tr></table></figure><p>重新开启终端会话，你就可以享受 <code>zsh-autosuggestions</code> 给你带来的便利了。</p><p><img src="/images/hyper/auosuggestions.gif" alt="install"></p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p><code>Oh My Zsh</code> 附带了大量的插件和主题，你可以利用它们可以进一步增强和美化你的终端功能。要想配置主题和插件，你可以直接修改 <code>~/.zshrc</code> 文件。</p><p>对于插件启用，你可以编辑 <code>plugins</code> 输入你想要加载的插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins =（</span><br><span class="line">  git</span><br><span class="line">  bundler</span><br><span class="line">  dotenv</span><br><span class="line">  osx</span><br><span class="line">  rake</span><br><span class="line">  rbenv</span><br><span class="line">  ruby</span><br><span class="line">）</span><br></pre></td></tr></table></figure><p>对于主题，你也可以编辑文件 <code>~/.zshrc</code>，在 <code>ZSH_THEME</code> 修改主题名称即可，链接 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes" target="_blank" rel="noopener">External themes</a> 提供了大部分主题的样式，你可以直接修改参数后即可看到主题效果，比如 <code>agnoster</code> 主题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME="agnoster"</span><br></pre></td></tr></table></figure><p>修改完成后，你的终端会变成这个样子：</p><p><img src="/images/hyper/agnoster.png" alt="install"></p><p>请注意，很多主题如果你无法显示预期效果，那是因为响应的主题系统字体没有安装，你需要正确的安装了 <a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">Powerline字体</a> 字体才会显示出来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细阐述了如何安装 Hyper 终端软件，其中包括配置 Hyper 插件和主题设置，并讲述了如何使用 Hyper 完全代替 Windows 的默认终端软件 CMD。<br>最后，介绍了一种使用 zsh 来代替 bash 的方法，你可以让你的终端功能更加强大易用。<br>用一句时髦的话来总结：Hyper 长得很漂亮哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信有很多人开发环境是我 Windows 上面，有时候又不得不面临在 Windows 上面开发 Linux 环境的程序。还好 Windows 10 系统为我们提供了一个叫 WSL（Windows Subsystem for Linux） 的子系统。但是，尽管微软已经很努力得在改善 Windows 开发环境了，但我们却始终得不到一个比较简单易用得终端软件，最起码你用 Window 自带得终端来操作 Linux 系统还是会觉得缺了点什么。&lt;/p&gt;
&lt;p&gt;目前市面上很多终端软件都比 Windows 自带终端好太多，比如这篇文章就介绍了 20 个比较好用终端软件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.slant.co/topics/1552/~best-terminal-emulators-for-windows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;THE BEST 1 OF 20 OPTIONS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前用过一个不错得软件叫做 &lt;a href=&quot;http://cmder.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cmder&lt;/a&gt;，但它不是今天得主角，我们今天要介绍得是另一款更符合我口味得终端软件 Hyper。&lt;/p&gt;
&lt;h2 id=&quot;获取并安装-Hyper&quot;&gt;&lt;a href=&quot;#获取并安装-Hyper&quot; class=&quot;headerlink&quot; title=&quot;获取并安装 Hyper&quot;&gt;&lt;/a&gt;获取并安装 Hyper&lt;/h2&gt;&lt;p&gt;你可以在一下几个地方获取到 Hyper：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官方网站：&lt;a href=&quot;http://cmder.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;入口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github：&lt;a href=&quot;https://github.com/zeit/hyper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;入口&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下载到二进制安装包后，直接安装就可以运行，本文运行环境是 Windows。&lt;/p&gt;
&lt;h2 id=&quot;基础插件安装&quot;&gt;&lt;a href=&quot;#基础插件安装&quot; class=&quot;headerlink&quot; title=&quot;基础插件安装&quot;&gt;&lt;/a&gt;基础插件安装&lt;/h2&gt;&lt;p&gt;Hyper 本身是支持插件系统的，在安装扩展插件时，你需要先安装 Hyper 命令行程序，你可以点击菜单，选择 &lt;code&gt;Plugin&lt;/code&gt; 选项，点击 &lt;code&gt;Install Hyper CLI command in PATH&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/hyper/insall-path.png&quot; alt=&quot;install&quot;&gt;&lt;/p&gt;
&lt;p&gt;其官方在首页推荐了4个比较易用的插件，推荐直接全部安装。安装地址请点击 &lt;a href=&quot;https://hyper.is/plugins&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;。其中4款插件分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hyper.is/plugins/hypercwd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hypercwd&lt;/a&gt;，它可以让你的终端在新建标签页时，保持上一个终端的目录地址。安装命令： &lt;code&gt;hyper i hypercwd&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hyper.is/plugins/hyper-search&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hyper-search&lt;/a&gt;，它可以让你搜索整个终端的所有文本内容。安装命令： &lt;code&gt;hyper i hyper-search&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hyper.is/plugins/hyper-pane&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hyper-pane&lt;/a&gt;，增强窗口导航，对于支持多个页签的软件来说这是个利器。安装命令： &lt;code&gt;hyper i hyper-pane&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hyper.is/plugins/hyper-pane&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hyperpower&lt;/a&gt;，这是一个让你的终端变得更加绚丽的插件，当然这么炫酷的效果是不是会影响你的工作呢，还是要视个人情而定。安装命令： &lt;code&gt;hyper i hyperpower&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/13041/16820268/13c9bfe6-4905-11e6-8fe4-baf8fc8d9293.gif&quot; alt=&quot;hyperpower&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hyper" scheme="https://veinin.com/categories/Hyper/"/>
    
    
      <category term="Hyper" scheme="https://veinin.com/tags/Hyper/"/>
    
      <category term="Shell" scheme="https://veinin.com/tags/Shell/"/>
    
      <category term="Zsh" scheme="https://veinin.com/tags/Zsh/"/>
    
      <category term="CMD" scheme="https://veinin.com/tags/CMD/"/>
    
  </entry>
  
  <entry>
    <title>AI 行为树设计与实现-实现篇</title>
    <link href="https://veinin.com/2018/08/08/ai_behavior_tree_design_and_implementation_02/"/>
    <id>https://veinin.com/2018/08/08/ai_behavior_tree_design_and_implementation_02/</id>
    <published>2018-08-08T13:15:00.000Z</published>
    <updated>2018-08-11T14:34:14.682Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中，我们主要介绍了有限状态机和行为树的各自特点以及他们之间的优劣势，本文着重讲解如何实现一个可用的行为树，手动实现一个行为树的库，这个库代码不到200行，代码库采用面向对象方式实现，语言采用的是 Lua，当然你也可以翻译成其他任何你顺手的语言。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>行为树时一个树形结构，我们AI系统要做的是执行每个节点，所以我们最开始必须先抽象一个节点出来，该节点作为所有其他类型节点的父节点：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Node = class(<span class="string">'Node'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node:ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.blackboard = opts.blackboard</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node:doAction</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Node</span><br></pre></td></tr></table></figure><p>我们可以看到，节点拥有一个可选的成员变量 <code>blackboard</code>，我们称它为黑板，你可以搜索查看设计模式关于 <a href="https://www.google.com.hk/search?hl=zh-CN&amp;q=%E9%BB%91%E6%9D%BF%E6%A8%A1%E5%BC%8F&amp;gws_rd=ssl" target="_blank" rel="noopener">黑板模式</a> 的详细介绍。</p><p>引入黑板，是因为很多节点在处理AI逻辑时是需要对数据进行处理，黑板中包含了整个行为树可以操作的数据结构。比如上一节我们提到的关于一个NPC守夜巡逻的实现中，整个行为树要处理的对象其实是NPC，NPC打伞、NPC巡逻动作其实是NPC自身的一个行为，而行为树各个节点要处理的目标就是存放在黑板中的这个NPC。</p><p>我们实现的行为树节点对外部来说只有一个入口 <code>doAction</code> 函数，下面实现的所有其他类型的行为树节点都继承自 <code>Node</code> 节点。</p><a id="more"></a><h2 id="节点执行状态"><a href="#节点执行状态" class="headerlink" title="节点执行状态"></a>节点执行状态</h2><p>上一章我们解释了行为树包含两大类子节点：控制节点与行为节点。</p><ul><li>控制节点，这类节点没有任何游戏内的具体逻辑实现，只是为了控制行为节点的执行；</li><li>行为节点，这是涉及我们游戏内的具体游戏逻辑的节点，行为节点通常会在执行完成后，返回执行成功与否，拥有行为节点的父节点，也就是控制节点，会根据行为节点的返回值，做出相应的控制。</li></ul><p>为了更加明白的阐述，我们举个例子，例如上一节提到的NPC夜晚巡逻的AI，我们把“是否晚上”、“巡逻”这种节点称为行为节点，行为节点需要返回一些执行结果，如“是否晚上”节点返回为真，则控制节点再运行“巡逻”行为。</p><p>所以，在进入详细代码设计之前，所有节点的执行，都是需要定义一些返回状态常量值的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> BTConst = &#123;&#125;</span><br><span class="line"></span><br><span class="line">BTConst.SUCCESS = <span class="number">0</span></span><br><span class="line">BTConst.FAIL = <span class="number">1</span></span><br><span class="line">BTConst.WAIT = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BTConst</span><br></pre></td></tr></table></figure><p>行为树的节点，通常需要以上三种执行状态，执行节点成功、失败以及等待，对于等待状态，是因为一些节点单次执行并没有成功，需要等待下一次的执行时间到来以继续执行。</p><h2 id="控制节点实现"><a href="#控制节点实现" class="headerlink" title="控制节点实现"></a>控制节点实现</h2><p>对于一个行为树系统，其核心部分主要是其提供的控制节点，通过控制节点，我们可根据自己的游戏需求拓展出一套相对应的条件与行为节点。我们必须再度强调控制节点是与具体的游戏逻辑是无关的，它只负责整个行为树的逻辑控制。</p><p>本文的代码采用面向对象开发，实现语言采用 Lua。在实现控制节点前，我们先看看控制节点的类结构：</p><p><img src="/images/btree/behavior_node.png" alt="behavior_node"></p><p>从图中我们可以看到，控制节点核心包含选择节点（Selector）、序列节点（Sequence）和平行节点（Parallel），它们都继承自一个组合节点（Composite）。</p><h3 id="组合节点-Coposite"><a href="#组合节点-Coposite" class="headerlink" title="组合节点(Coposite)"></a>组合节点(Coposite)</h3><p>组合节点可以看作是一个节点的集合，可以组合多个子节点。行为树的控制节点都是组合各类行为节点的父节点，然后按一定的规则执行它们。我们先实现一个组合节点：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Composite = class(<span class="string">'Composite'</span>, Node)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Conposite:ctor</span><span class="params">()</span></span></span><br><span class="line">    self.children = &#123;&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Composite:addChild</span><span class="params">(node)</span></span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(self.children, node)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Composite</span><br></pre></td></tr></table></figure><p>组合节点成员只有一个，那就是一个孩子节点的集合，我们可以往组合节点上面添加任意数量的孩子节点。</p><h3 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h3><p>选择节点，顾名思义，就是需要从众多的子节点中选择一个可以执行成功的节点，如果子节点执行成功，则跳出执行，并且下次执行时继续从头开始。<br>选择在行为树中运用的频率比其他两个控制节点来说要更多，因为游戏AI系统中充斥着各种不同情况，我们的AI系统需要从中选择一个合理的路径执行。<br>比如下图某个NPC的AI是选择巡逻还是休息：</p><p><img src="/images/btree/selector.png" alt="selector"></p><p>选择节点代码来实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Selector = Class(<span class="string">'Selector'</span>, Composite)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Selector:ctor</span><span class="params">()</span></span></span><br><span class="line">    self.index = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">reset</span><span class="params">(self)</span></span></span><br><span class="line">    self.index = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Selector:doAction</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> size = #self.children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> BTConst.SUCCESS</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.index &gt; size <span class="keyword">then</span></span><br><span class="line">        reset(self)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = self.index, size <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> ret = self.children[i]:doAction()</span><br><span class="line">        self.index = self.index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret == BTConst.SUCCESS <span class="keyword">then</span></span><br><span class="line">            reset(self)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">elseif</span> ret == BTConst.WAIT <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    reset(self)</span><br><span class="line">    <span class="keyword">return</span> BTConst.FAIL</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Selector</span><br></pre></td></tr></table></figure><p>上面代码中，选择节点的策略是先从第一个子节点开始执行，如果遇到某个节点执行成功，则重置执行节点的位置，并直接返回，那么下次再进入该节点后，会直接从第一个子节点开始执行。<br>如果执行某个节点是等待状态，则直接返回，下次重新进入该节点执行时，会直接从等待的那个节点继续执行。<br>如果所有节点都未成功或没有等待，则返回失败，并重置执行位置，下次将会从头开始执行。</p><h3 id="序列节点"><a href="#序列节点" class="headerlink" title="序列节点"></a>序列节点</h3><p>序列节点执行是有序的，它会从从到尾依次执行其子节点，当碰到一个子节点失败是会被打断，并且立刻返回，剩下的节点将不会继续执行。<br>序列节点的特性适合于执行一系列连续的操作，如果某个操作执行失败，则后续的操作会被打断。<br>如NPC在选择巡逻还是休息的AI中，在判断巡逻时，需要判断是白天还是晚上，如果满足条件，则巡逻，否则休息：</p><p><img src="/images/btree/sequence.png" alt="sequence"></p><p>序列节点代码来实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Sequence = class(<span class="string">'Sequence'</span>, Composite)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sequence:ctor</span><span class="params">()</span></span></span><br><span class="line">    self.index = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">reset</span><span class="params">(self)</span></span></span><br><span class="line">    self.index = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sequence:doAction</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> size = #self.children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> BTConst.SUCCESS</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.index &gt; size <span class="keyword">then</span></span><br><span class="line">        reset(self)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = self.index size <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> ret = self.children[i]:doAction()</span><br><span class="line">        self.index = self.index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret == BTConst.WAIT <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">elseif</span> ret == BTConst.FAIL <span class="keyword">then</span></span><br><span class="line">            reset(self)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    reset(self)</span><br><span class="line">    <span class="keyword">return</span> BTConst.SUCCESS</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Sequence</span><br></pre></td></tr></table></figure><p>上面代码选择从头开始执行各个子节点，遇到某个节点等待，则跳出，下次继续执行剩余节点。<br>如果某个节点执行失败，则重置执行位置，并返回，下次执行时，会从头开始。<br>最后，在所有节点都执行成功后，重置执行位置，并返回执行成功，下次执行时，从头继续开始。</p><h3 id="平行节点"><a href="#平行节点" class="headerlink" title="平行节点"></a>平行节点</h3><p>平行节点与序列节点类似，但平行节点，每次执行时都会把所有子节点执行一边，然后统计其执行结果，根据平行节点执行策略，返回相应的结果。<br>平行节点影响执行结果返回会有好几种策略：</p><ul><li>FAIL_ON_ONE，只要有一个子节点执行返回失败，则执行结果就会返回失败状态。</li><li>FAIL_ON_ALL，所有子节点执行失败了，执行结果才会返回失败，否则算做成功。</li></ul><p>平行节点运用于执行一系列不被其他节点影响还的操作，如NPC巡逻AI中，在平行节点中有两个子节点，一个是选择天气，一个是选择守夜巡逻，天气系统中只会影响NPC是否需要打伞，而守夜巡逻分支影响NPC是否需要巡逻，着两个节点会独立的运行，它们之间不会相互影响的，</p><p><img src="/images/btree/parallel.png" alt="parallel"></p><p>平行节点代码来实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> FAIL_ON_ONE = <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> FAIL_ON_ALL = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> Parallel = class(<span class="string">'Parallel'</span>, Composite)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parallel:ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.policy = opts <span class="keyword">and</span> opts.policy <span class="keyword">or</span> FAIL_ON_ONE</span><br><span class="line">    self.waits = &#123;&#125;</span><br><span class="line">    self.succ = <span class="number">0</span></span><br><span class="line">    self.fail = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">reset</span><span class="params">(self)</span></span></span><br><span class="line">    self.waits = &#123;&#125;</span><br><span class="line">    self.succ = <span class="number">0</span></span><br><span class="line">    self.fail = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">checkPolicy</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="keyword">if</span> self.policy == FAIL_ON_ONE <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> self.fail &gt; <span class="number">0</span> <span class="keyword">and</span> BTConst.FAIL <span class="keyword">or</span> BTConst.SUCCESS</span><br><span class="line">    <span class="keyword">elseif</span> self.policy == FAIL_ON_ALL <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> self.succ &gt; <span class="number">0</span> <span class="keyword">and</span> BTConst.SUCCESS <span class="keyword">or</span> BTConst.FAIL</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parallel:doAction</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> size = #self.children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> BTConst.SUCCESS</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> ret</span><br><span class="line">    <span class="keyword">local</span> rest = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> origin = #self.waits &gt; <span class="number">0</span> <span class="keyword">and</span> self.waits <span class="keyword">or</span> self.children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #origin <span class="keyword">do</span></span><br><span class="line">        ret = origin[i]:doAction()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret == BTConst.SUCCESS <span class="keyword">then</span></span><br><span class="line">            self.succ = self.succ + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elseif</span> ret == BTConst.WAIT <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">table</span>.<span class="built_in">insert</span>(rest, origin[i])</span><br><span class="line">        <span class="keyword">elseif</span> ret == BTConst.FAIL <span class="keyword">then</span></span><br><span class="line">            self.fail = self.fail + <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> #rest &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        self.waits = rest</span><br><span class="line">        <span class="keyword">return</span> BTConst.WAIT</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    ret = checkPolicy(self)</span><br><span class="line">    reset(self)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面代码中，首先声明了平行节点执行策略 <code>FAIL_ON_ONE</code> 与 <code>FAIL_ON_ALL</code>。平行节点定义了3个类成员 <code>waits</code> 表示执行等待的节点，<code>succ</code> 表示执行成功的节点数量，<code>fail</code> 表示执行失败的节点数量。<br>节点开始执行前先获取执行起点，如果有等待执行的节点，有优先执行等待节点；如果没有等待的节点，则从头开始执行各个子节点。<br>子节点执行成功、失败，则记录，如果是带状态则记录到等待列表 <code>rest</code> 中，并在执行完成后，检查 <code>rest</code>，如果存在等待节点，则直接返回，下次继续执行等待节点。<br>如果所有节点执行都返回成功或失败，则根据记录从节点策略中获取返回状态码，并重置所有执行记录，等待下一次重新开始执行。</p><h3 id="装饰节点"><a href="#装饰节点" class="headerlink" title="装饰节点"></a>装饰节点</h3><p>装饰节点可以作为额外的附加条件，例如，时间间隔控制、频率控制、触发概率、结果取反、错误处理等待。<br>比如我一个怪物使用某个技能，我们实现了使用技能的行为节点，但我们需要对这个使用技能的行为节点增加节点触发概率，这种情况下，我们就可以使用装饰节点来扩充原有的行为节点。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Decorator = class(<span class="string">'Decorator'</span>, Node)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Decorator:ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.child = opts.child</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Decorator:setChild</span><span class="params">(node)</span></span></span><br><span class="line">    self.child = node</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Decorator</span><br></pre></td></tr></table></figure><p>上面装饰节点中，存储了一个装饰子节点，这个子节点将作为被装饰的对象。</p><h3 id="循环节点"><a href="#循环节点" class="headerlink" title="循环节点"></a>循环节点</h3><p>循环节点根据条件不停循环执行子节点，直到子节点返回成功，然后检查循环条件，判断自己是否继续循环。比如巡逻AI中，根节点就是一个循环节点，默认情况下，循环节点会移植运行下去，直到循环节点运行成功，比如我们需求在NPC进行巡逻后，就结束AI的运行等等。</p><p><img src="/images/btree/loop.png" alt="loop"></p><p>我们看下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Loop = Class(<span class="string">'Loop'</span>, Decorator)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Loop:ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.loopCond = data.loopCond</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Loop:doAction</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> ret = self.child:doAction()</span><br><span class="line">    <span class="keyword">if</span> ret ~= BTConst.SUCCESS <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.loopCond <span class="keyword">and</span> self.loopCond(self.blackboard) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> BTConst.WAIT</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BTConst.SUCCESS</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Loop</span><br></pre></td></tr></table></figure><p>循环节点也是一个装饰节点，其有一个循环检查条件节点用于在子节点执行成功后检查，</p><h2 id="行为节点实现"><a href="#行为节点实现" class="headerlink" title="行为节点实现"></a>行为节点实现</h2><p>有了控制节点后，我们剩下的就是实现行为节点了，行为节点可能每个游戏都会不一样，这主要是因为每个游戏AI可能都不同，具体需求到来时，才针对性的实现，所以行为节点通常依托于控制节点，其只会作为叶子节点使用。</p><h3 id="条件节点"><a href="#条件节点" class="headerlink" title="条件节点"></a>条件节点</h3><p>条件节点的作用是判定，如NPC巡逻AI中，天气判定、打伞判定、时间判定都是一个条件节点。先看条件节点实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Condition = class(<span class="string">'Condition'</span>, Node)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Condition:ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.umpire = opts.umpire</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Condition:doAction</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> self.umpire <span class="keyword">and</span> self.umpire(self.blackboard) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> BTConst.SUCCESS</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BTConst.FAIL</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Condition</span><br></pre></td></tr></table></figure><p>条件节点有一个成员变量 <code>umpire</code> ，我们把他视为一个“裁判员”，用来判定某个条件是否成立。这个变量在 Lua 中实现为一个函数，我们可以自定义一个函数，然后根据上面的接口创建一个条件，比如创建判定天气为晴天的条件节点：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> isSunny = <span class="function"><span class="keyword">function</span><span class="params">(blackboard)</span></span></span><br><span class="line">    <span class="keyword">return</span> blackboard.world.weather == <span class="string">"Sunny"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> isSunnyCondition = Condition.new(isSunny)</span><br><span class="line">isSunnyCondition.doAction()</span><br></pre></td></tr></table></figure><p>可以看到上面创建一个判定天晴的条件节点是分成简单的，判定条件参数传入的是一个“黑板”成员，里面保存着AI需要的数据对象，比如上面代码中，我们可以直接通过黑板获取到世界<code>world</code>对象，来获取当前天气。</p><h3 id="动作节点"><a href="#动作节点" class="headerlink" title="动作节点"></a>动作节点</h3><p>动作节点人如其名，只会执行相应的动作，具体执行什么动作，也是根据游戏 AI 需求去重新实现的，比如我们的巡逻AI中，NPC 执行打伞、收伞、巡逻等一系列的动作。动作节点只需要继承自 Node 节点，然后实现 <code>doAction</code> 内容即可，如一个 NPC 的巡逻动作：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> PatrolAction = class(<span class="string">'PatrolAction'</span>, Node)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PatrolAction:doAction</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> npc = self.blackboard.npc</span><br><span class="line">    npc:GoPatrol()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> PatrolAction</span><br></pre></td></tr></table></figure><p>上面巡逻动作节点实现很简单，只需要执行时，从黑板中获取到NPC对象，然后调用NPC巡逻函数 <code>GoPatrol</code>，NPC就开始进行巡逻了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章节，我们的行为树核心代码基本全部实现，对于AI不太复杂的游戏，这些代码基本可用了，当然我们也可以根据上面代码在项目需求满足不了的情况下，继续拓展不同类型、不同功能的节点，比如可以支持权值的选择节点等等。下一节，我们将根据这些代码来实现一个具体的 NPC 巡逻 AI。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中，我们主要介绍了有限状态机和行为树的各自特点以及他们之间的优劣势，本文着重讲解如何实现一个可用的行为树，手动实现一个行为树的库，这个库代码不到200行，代码库采用面向对象方式实现，语言采用的是 Lua，当然你也可以翻译成其他任何你顺手的语言。&lt;/p&gt;
&lt;h2 id=&quot;节点&quot;&gt;&lt;a href=&quot;#节点&quot; class=&quot;headerlink&quot; title=&quot;节点&quot;&gt;&lt;/a&gt;节点&lt;/h2&gt;&lt;p&gt;行为树时一个树形结构，我们AI系统要做的是执行每个节点，所以我们最开始必须先抽象一个节点出来，该节点作为所有其他类型节点的父节点：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt; Node = class(&lt;span class=&quot;string&quot;&gt;&#39;Node&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node:ctor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(opts)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.blackboard = opts.blackboard&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node:doAction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Node&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以看到，节点拥有一个可选的成员变量 &lt;code&gt;blackboard&lt;/code&gt;，我们称它为黑板，你可以搜索查看设计模式关于 &lt;a href=&quot;https://www.google.com.hk/search?hl=zh-CN&amp;amp;q=%E9%BB%91%E6%9D%BF%E6%A8%A1%E5%BC%8F&amp;amp;gws_rd=ssl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黑板模式&lt;/a&gt; 的详细介绍。&lt;/p&gt;
&lt;p&gt;引入黑板，是因为很多节点在处理AI逻辑时是需要对数据进行处理，黑板中包含了整个行为树可以操作的数据结构。比如上一节我们提到的关于一个NPC守夜巡逻的实现中，整个行为树要处理的对象其实是NPC，NPC打伞、NPC巡逻动作其实是NPC自身的一个行为，而行为树各个节点要处理的目标就是存放在黑板中的这个NPC。&lt;/p&gt;
&lt;p&gt;我们实现的行为树节点对外部来说只有一个入口 &lt;code&gt;doAction&lt;/code&gt; 函数，下面实现的所有其他类型的行为树节点都继承自 &lt;code&gt;Node&lt;/code&gt; 节点。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="https://veinin.com/categories/AI/"/>
    
    
      <category term="AI" scheme="https://veinin.com/tags/AI/"/>
    
      <category term="行为树" scheme="https://veinin.com/tags/%E8%A1%8C%E4%B8%BA%E6%A0%91/"/>
    
      <category term="状态机" scheme="https://veinin.com/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>AI 行为树设计与实现-理论篇</title>
    <link href="https://veinin.com/2018/08/07/ai_behavior_tree_design_and_implementation_01/"/>
    <id>https://veinin.com/2018/08/07/ai_behavior_tree_design_and_implementation_01/</id>
    <published>2018-08-07T10:36:00.000Z</published>
    <updated>2018-08-11T11:05:08.175Z</updated>
    
    <content type="html"><![CDATA[<p>一个典型的 AI 系统通常包含：感知、导航和决策三个子系统。对于游戏来说，感知系统是可以“作弊”的，不需要NPC真的去“感知”世界，系统可以告诉NPC世界是怎么的。所以，对于导航系统，不再属于本文的讨论范畴。而决策系统才是让NPC看起来可以有自己的意图和信念的，所以本文讨论的是决策系统。</p><p>一个 AI 决策系统模型看起来是这样的：</p><p><img src="/images/btree/decision.png" alt="decision"></p><p>最开始，游戏 AI 的决策系统往往会这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(自己)</span><br><span class="line">    case '血量充足':</span><br><span class="line">        攻击();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    case '快死了':</span><br><span class="line">        加血();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ‘死了’:</span><br><span class="line">        游戏结束();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>随机计算机硬件的不断提升，可以分配给 AI 运算的 CPU 时间越来越长，我们对游戏 AI 的要求也自然提高了，比如我们可以相处这样的策略：有多个敌人时，使用群体技能；只有单个敌人时，使用强力的单体攻击；魔法低于50时，吃药补魔法；血量低于100时，吃个大的血瓶回血。</p><p>于是，AI 程序员在上面的需求到来的时候，不得不继续扩充上的 swtich 条件，然后在 case 里面增加自己的逻辑。可以想象，如果一个 Moba 类游戏中，一个地狱难度的电脑的 AI 需要根据场上的情况使用各种策略。当策划的需求越来越多，很快，一个带有上万行的代码函数就横空出世啦。如果这时候遇到了一个 Bug ，不要说修复，仅仅是阅读这个函数的代码都恐怕让人觉得畏惧了。</p><p>毫无疑问，当一个函数遇到大量的状态转换判断的时候，很容易让整个程序崩溃，不过经过后辈们前赴后继的努力，目前市面上关于游戏的 AI 有了更加精简的代码手段。比如常见 的 AI 模型：FSM（有限状态机）和 Behavior Tree（行为树）。</p><h2 id="有限状态机（FMS）"><a href="#有限状态机（FMS）" class="headerlink" title="有限状态机（FMS）"></a>有限状态机（FMS）</h2><p>相对于 <code>switch - case</code> 来说， FSM 编程与人类的思维相似，更易于梳理，更加灵活。当每种状态封装后，就不在会有一个“中央”函数来控制所有的逻辑，每个状态只要管好自己的业务就行。这样，一个复杂的决策系统就被切割成了两子系统，不同的状态以及状态之间的转换。切割后的子系统与原有的系统被大大简化，从而使得代码变得可以维护。FSM 在相当多的游戏中已经被应用，甚至 Unreal Engine 的脚本语言是直接支持状态编程的。</p><p>当游戏中的NPC决策并不太复杂时候，FSM是非常有效的。比如 Half-Life 这款游戏，里面的AI被业界称赞了很久，而其中的AI就是通过FSM来实现的。</p><h3 id="有限状态机举例"><a href="#有限状态机举例" class="headerlink" title="有限状态机举例"></a>有限状态机举例</h3><p>我们接下来通过一个简单的例子来认识一下FSM。比如一个AI文字表述如下：</p><p>1.平时的状态是巡逻</p><ol start="2"><li>如果遇到敌人之后打量一下敌人</li><li>如果敌人比自己弱小，那就打攻击</li><li>如果敌人比自己强大，那就跑逃跑</li></ol><p>那么这个可以很自然的转换成 FSM，然后进行编程实现，我们可以看看整个 AI 流程图：</p><p><img src="/images/btree/fms.png" alt="fms"></p><h3 id="有限状态机缺点"><a href="#有限状态机缺点" class="headerlink" title="有限状态机缺点"></a>有限状态机缺点</h3><p>虽然FSM简洁，和人的直觉思维相近，但是FSM也是有缺点的：</p><ul><li>由于我们所能做的仅是编辑从一状态到另一状态的转换，而无法做出更高层次的模式功能，所以会导致我们发现自己总是在构建相似的行为，这会花费我们大部分时间。</li><li>使用 FSM 实现目标导向的行为需要做很多工作。这是一个大问题，因为大部分有针对性的AI 需要处理长远目标。</li><li>FSM 难以并发。当并行运行多个状态机，要么死锁，要么我们通过手工编辑来确保它们在某个程度上能够兼容。</li><li>大规模支持较差，即使是分层的有限状态机，也难以大规模扩展。它们往往是在其中夹杂一大块逻辑代码，而非行为编辑模块化。</li><li>用 FSM 实现任何设计都需要做大量工作，需要花费设计师的大量时间(并非编程时间)，甚至最终这还会成行为中的 bugs 的来源。</li></ul><h2 id="行为树（Behavior-Tree）"><a href="#行为树（Behavior-Tree）" class="headerlink" title="行为树（Behavior Tree）"></a>行为树（Behavior Tree）</h2><p>行为树是在Next-Gen AI中提出的模型，虽说是Next-Gen AI，但距其原型提出已有约10年时间。其中Spore(孢子)，Crysis(孤岛危机)2，Red Dead Redemption(荒野大镖客：救赎)等就是用行为树作为它们的AI模型。而越来越多的引擎也都开始直接支持行为树，比如 Cry Engine, Havok等。</p><p>对于用行为树定模型构造的AI系统来说，每次执行AI时 ，系统都会从根节点遍历整个树，父节点执行子节点，子节点执行完后将结果返回父节点，然后父节点根据子节点的结果来决定接下来怎么做。</p><p>所谓树，那么其就存在很多节点，而对于行为树来说，它把基本节点类型分为两大类：</p><h3 id="控制节点"><a href="#控制节点" class="headerlink" title="控制节点"></a>控制节点</h3><p>在行为树中我们所看到的所有父节点都被称为控制节点。控制节点是行为树的核心部分，它与具体的游戏是无关的，它只负责整个行为树的逻辑控制。其包含以下几种类型：</p><ul><li>选择节点(Selector)：属于组合节点，顺序执行子节点，只要碰到一个子节点返回true，则停止继续执行，并返回true，否则返回false，类似于程序中的逻辑或。</li><li>顺序节点(Sequence)：属于组合节点，顺序执行子节点，只要碰到一个子节点返回false，则停止继续执行，并返回false，否则返回true，类似于程序中的逻辑与。</li><li>平行节点(Parallel)：提供了平行的概念，无论子节点返回值是什么都会遍历所有子节点。所以不需要像 Selector/Sequence 那样预判哪个 Child Node 应摆前，哪个应摆后。Parallel Node增加方便性的同时，也增加实现和维护复杂度。</li><li>组合节点(Coposite)：可以组合多个子节点。</li><li>装饰节点(Decoraor)：可以作为某种节点的一种额外的附加条件，如允许次数限制，时间限制，错误处理等。</li><li>循环节点(Loop)：循环执行相应的动作，并返回结果。</li></ul><h3 id="行为节点"><a href="#行为节点" class="headerlink" title="行为节点"></a>行为节点</h3><p>行为树的行为定义都在行为节点中，也就是我们说的叶子节点。行为节点是与我们的具体需求相关的，不同的需求定义会有不同的行为节点。</p><ul><li>条件节点(Condition)：属于叶子节点，判断条件是否成立。</li><li>动作节点(Action)：属于叶子节点，执行动作，一般返回true。</li></ul><p>当然，如果有更多需求，也可以自己继续拓展，通过控制与行为节点的组合，最终，会产生一颗行为树，它看起来会是这样的：</p><p><img src="/images/btree/behavior_tree.png" alt="behavior_tree"></p><h3 id="行为树举例"><a href="#行为树举例" class="headerlink" title="行为树举例"></a>行为树举例</h3><p>我们可以来看一个行为树构造 AI 的例子，这个AI的逻辑文字表述为：</p><p>1.一个NPC在晚上需要执行守夜巡逻的任务。<br>2.如果到了白天，那么NPC需要休息。<br>3.如果天下雨的话，则需要打伞。<br>4.如果天气变晴，处在打伞状态下的人需要把伞收起。</p><p>通过以上条件，我们可以转换成一颗行为树：</p><p><img src="/images/btree/behavior_tree_npc.png" alt="behavior_tree_npc"></p><h3 id="行为树优缺点"><a href="#行为树优缺点" class="headerlink" title="行为树优缺点"></a>行为树优缺点</h3><p>行为树模型看似简单，但是以下几个优点让行为树目前变成了复杂AI的主流模型：</p><ul><li>静态性。越复杂的功能越需要简单的基础，否则最后连自己都玩不过来。即使系统需要某些”动态”性，也应该尽量使用静态的行为树来表示。静态性直接带来的好处就是整棵树的规划无需再运行时动态调整，大大方便设计人员和编程人员，并且大大减少诡异的bug，同时这也为很多优化和预编辑都带来方便。</li><li>直观性。行为树可以方便地把复杂的AI知识条目组织得非常直观。默认的组合节点处理子节点的迭代方式就像是处理一个预设优先策略队列，也非常符合人类的正常思考模式：先最优再次优。此外，行为树编辑器对优秀的程序员来说也是唾手可得。</li><li>复用性。各种节点，包括叶子节点，可复用性都极高。</li><li>扩展性。可以容易地为项目量身定做新的组合节点或修饰节点。还可以积累一个项目相关的节点库，长远来说非常有价值。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个典型的 AI 系统通常包含：感知、导航和决策三个子系统。对于游戏来说，感知系统是可以“作弊”的，不需要NPC真的去“感知”世界，系统可以告诉NPC世界是怎么的。所以，对于导航系统，不再属于本文的讨论范畴。而决策系统才是让NPC看起来可以有自己的意图和信念的，所以本文讨论的是决策系统。&lt;/p&gt;
&lt;p&gt;一个 AI 决策系统模型看起来是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/btree/decision.png&quot; alt=&quot;decision&quot;&gt;&lt;/p&gt;
&lt;p&gt;最开始，游戏 AI 的决策系统往往会这样写：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt;(自己)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &#39;血量充足&#39;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        攻击();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &#39;快死了&#39;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        加血();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ‘死了’:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        游戏结束();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="AI" scheme="https://veinin.com/categories/AI/"/>
    
    
      <category term="AI" scheme="https://veinin.com/tags/AI/"/>
    
      <category term="行为树" scheme="https://veinin.com/tags/%E8%A1%8C%E4%B8%BA%E6%A0%91/"/>
    
      <category term="状态机" scheme="https://veinin.com/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记：游戏 UI 半自动化开发流程</title>
    <link href="https://veinin.com/2018/07/31/dev_notes-game-UI-semi-automated-development/"/>
    <id>https://veinin.com/2018/07/31/dev_notes-game-UI-semi-automated-development/</id>
    <published>2018-07-31T12:10:00.000Z</published>
    <updated>2018-08-01T14:39:59.893Z</updated>
    
    <content type="html"><![CDATA[<p>最近着手试了下我们客户端 UI 开发，发现整个流程对于开发人员来说并不是很友好，我们游戏客户端代码基本使用 Lua 语言进行，引擎则采用 Unity。对于 UI 模块目前有一套基本的 MVC 模式的开发流程，但这个开发模式的边界并没有处理很好，导致开发过程中异常艰难。编写代码的人员有时也会很懵逼，因为实现的方式可以有多种多样。</p><p>在了解了整个旧有的开发流程后，我发现个问题，其中由UI编辑到代码编写，这个流程中，大部分过程都是重复行工作，而针对这一部分重复行工作通过一些小工具可以让UI开发流程实现半自动化。</p><p>所谓半自动化，无非就是，开发人员不需要编写基本的UI代码，基础UI代码可以自动生成，包括整个开发流程中使用的各个UI窗口的组件都可以自动生成代码。</p><p>另外，因为UI编写过程中进程资源修改、代码修改，我希望都可以在修改完后立刻可以看到效果，而不是重启游戏。</p><p>下面是我对于一个半自动化的UI开发流程整理笔记。</p><a id="more"></a><h2 id="UI-编辑流程"><a href="#UI-编辑流程" class="headerlink" title="UI 编辑流程"></a>UI 编辑流程</h2><p>我们的 UI 编辑是一个独立的项目工程，通常一个功能的 UI 编辑会由策划完成一部分工作，程序人员拿过来，按需求再整理 UI 资源、编写代码即可。</p><ol><li>编辑器项目结构</li></ol><p>在UI编辑器中，其文件结构看起来是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">UIProject</span><br><span class="line">    -&gt; Assert</span><br><span class="line">        -&gt; PublicPrefabs - 公共UI</span><br><span class="line">        -&gt; PulibcResources - 公共资源</span><br><span class="line">        -&gt; Texture - 纹理</span><br><span class="line">        -&gt; UI</span><br><span class="line">            -&gt; LoginWindow - 登陆窗口UI</span><br><span class="line">                -&gt; Prefabs</span><br><span class="line">            -&gt; EquipWinodw - 装备窗口UI</span><br><span class="line">                -&gt; Prefabs</span><br><span class="line">            -&gt; TeamWindow  - 组队窗口UI</span><br><span class="line">                -&gt; Prefabs</span><br><span class="line">                    -&gt; TeamCreateView - 队伍创建窗口</span><br><span class="line">                    -&gt; TeamMemberView - 队员窗口</span><br><span class="line">                    -&gt; TeamMemberItem - 队员窗口队伍信息</span><br><span class="line">                    -&gt; ...</span><br><span class="line">                -&gt;  UI资源1.png</span><br><span class="line">                -&gt;  UI资源2.png</span><br><span class="line">                -&gt;  ...</span><br><span class="line">            -&gt; ...</span><br></pre></td></tr></table></figure><p>比如在一个组队功能UI里面，其他包含一个文件夹（TeamWindow），该文件夹下包含了多个UI用到的私有美术资源图片、纹理等。Window 文件夹下，有一个 Prefabs 文件夹，用来保存该功能所用到的所有子UI。</p><p>比如上面队伍窗口（TeamWindow）在UI设计中看起来是这样的：</p><p><img src="/images/mvc/mvc_ui_design.png" alt="mvc"></p><p>其包含3个View文件，两个主要窗口，CreateView用来创建队伍窗口，MemberView用来显示队伍成员窗口，而MemberItem用来显示队伍成员窗口下的队员详细。</p><p>2.UI文件打包</p><p>编辑好的UI会统一打包成一个文件，方便使用代码做资源一次性加载。比如上面TeamWindow，打包后一个统一的资源包文件，包含了上面所示的队伍UI下面的所有子窗口。</p><h2 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h2><p>原有的UI开发流程是使用 MVC 设计模式的，采用这个模式，如果能处理好，开发起来也是会很顺畅的。</p><p>对于 MVC，我们先用一张图来展示：</p><p><img src="/images/mvc/mvc_pattern.png" alt="mvc"></p><p>在 Unity UI 开发中引入 MVC 设计模式，它看起来是这样的：</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><ul><li>其只是用来保存数据用的，其不能访问 View 或 Controller。</li><li>它可以被 Controller 和 View 直接访问。</li></ul><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><ul><li>其只是游戏中能用户看到的 UI 布局。</li><li>View 可以处理 UI 点击逻辑、处理外面传进来的数据，可以访问和修改 Model。</li><li>在 Unity 中，每个 UI 资源的 Prefab 文件都会生成一个与之对应的 View 源代码文件。</li></ul><h3 id="Conroller"><a href="#Conroller" class="headerlink" title="Conroller"></a>Conroller</h3><ul><li>负责控制单个模块内所有 View 资源的加载、显示、关闭、数据更新、分组、层级控制等。</li><li>其持有所有 View 和 Model 对象。</li><li>其销毁后，所有View 和 Model 都会自动销毁。</li></ul><h2 id="MVC-实现"><a href="#MVC-实现" class="headerlink" title="MVC 实现"></a>MVC 实现</h2><p>对于上面所示的MVC模式，我们结合相关MVC特性，用实际代码来展示，下面实例统一采用 Lua 语言，并使用面向对象概念来设计。</p><h3 id="实现一个-Controller-接口"><a href="#实现一个-Controller-接口" class="headerlink" title="实现一个 Controller 接口"></a>实现一个 Controller 接口</h3><p>Controller 是一个UI功能的控制中心，其控制当前Window下的所有UI的加载、显示、隐藏，以及数据保存、清理、传递工作。<br>默认情况下所有子UI（UIView子类）都是会自动被其销毁的，其资源、数据都会在最后一个窗口关闭后自动清理掉。</p><p>Controller 接口完整生命周期示例图如下：</p><p><img src="/images/mvc/mvc_controller_life_cycle.png" alt="mvc"></p><p>实现的 Controller 接口代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIController = Class(<span class="string">'UIController'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.isInit         = <span class="literal">false</span></span><br><span class="line">    self.isPersistent   = opts.isPersistent <span class="comment">-- 是否持久化 model 数据，如果为 true，不会销毁 model 数据</span></span><br><span class="line">    self.prefabsName    = opts.prefabsName  <span class="comment">-- UI 打包后的资源名称</span></span><br><span class="line">    self.assets         = &#123;&#125;                <span class="comment">-- 已经加载的资源</span></span><br><span class="line"></span><br><span class="line">    self.model          = &#123;&#125;                <span class="comment">-- model 数据</span></span><br><span class="line"></span><br><span class="line">    self.viewClasses    = &#123;&#125;                <span class="comment">-- view 资源对应的子类，未实例化</span></span><br><span class="line">    self.openViews      = &#123;&#125;                <span class="comment">-- 已经打开的 view</span></span><br><span class="line">    self.openViewCount  = &#123;&#125;                <span class="comment">-- 已经打开的 view 数量</span></span><br><span class="line">    self.lastOpenData   = <span class="literal">nil</span>               <span class="comment">-- 上次打开 view 时的数据（未初始化时需要先保存打开时数据，初始化完成后再打开）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:IsInit</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> self.isInit</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">OnLoad</span><span class="params">(self, assets)</span></span></span><br><span class="line">    <span class="keyword">for</span> _, asset <span class="keyword">in</span> <span class="built_in">ipairs</span>(assets) <span class="keyword">do</span></span><br><span class="line">        self.assets[asset.name] = asset</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self.isInit = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">next</span>(self.viewClasses) <span class="keyword">then</span></span><br><span class="line">        self:OnInitView()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.lastOpenData <span class="keyword">then</span></span><br><span class="line">        self.Open(<span class="built_in">unpack</span>(self.lastOpenData))</span><br><span class="line">        self.lastOpenData = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        self:OnDefaultOpen()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Init</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> self:IsInit() <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    LoadManager:LoadPrefab(self.prefabsName, <span class="function"><span class="keyword">function</span><span class="params">(assets)</span></span></span><br><span class="line">        OnLoad(self, assets)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:OnInitView</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:RegisterView</span><span class="params">(class)</span></span></span><br><span class="line">    <span class="built_in">assert</span>(self.viewClasses[class.name] == <span class="literal">nil</span>)</span><br><span class="line">    self.viewClasses[class.name] = class</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">CreateView</span><span class="params">(self, name)</span></span></span><br><span class="line">    <span class="keyword">local</span> class = self.viewClasses[name]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> class <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> view = class.New()</span><br><span class="line">    view.controller = self</span><br><span class="line">    view.model      = self.model</span><br><span class="line"></span><br><span class="line">    self.openViews[name] = view</span><br><span class="line">    self.openViewCount = self.openViewCount + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">GetView</span><span class="params">(self, name)</span></span></span><br><span class="line">    <span class="keyword">local</span> view = self.openViews[name]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> view <span class="keyword">then</span></span><br><span class="line">        view = CreateView(self, name)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> view <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> view:IsState(UIConst.LIFESTATE.NONE) <span class="keyword">then</span></span><br><span class="line">        UIHelper.InitView(self, view)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Open</span><span class="params">(name, ...)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self:IsInit() <span class="keyword">then</span></span><br><span class="line">        self.lastOpenData = &#123;name, ...&#125;</span><br><span class="line">        self:Init()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> view = GetView(self, name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> view <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> view:IsState(UIConst.LIFESTATE.SHOW) <span class="keyword">then</span></span><br><span class="line">        view:Update(...)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        view:Open(...)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Close</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> view <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    GameObject.Destroy(view.gameObject)</span><br><span class="line"></span><br><span class="line">    self.openViews[name] = <span class="literal">nil</span></span><br><span class="line">    self.openViewCount = self.openViewCount - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.openViewCount == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        self:Dispose()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Dispose</span><span class="params">()</span></span></span><br><span class="line">    self.isInit = <span class="literal">false</span></span><br><span class="line">    self.assets = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    LoadManager:RemovePrefab(self.prefabsName)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.isPersistent <span class="keyword">then</span></span><br><span class="line">        self.model = &#123;&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self:OnDispose()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:OnDispose</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIController</span><br></pre></td></tr></table></figure><p>根据上面生命周期实例图和代码实现，我们可以看到 Contoller 入口有两个，一个是外部打开指定 View，一个是外部关闭指定 View。</p><p>当外部需要打开指定 View 时，我们先检查当前 Controller 是否初始化完成，如果未初始化，则先临时保存打开时的数据，然后再走初始化 Controller 逻辑，加载 UI 资源。</p><p>当加载 UI 资源完成后，我们通过 View 的名称，调用 <code>GetView()</code> 函数获取一个 View 对象，如果 View 对象未创建，则走创建对象逻辑 <code>CreateView()</code>，并调用 View 初始化逻辑（下一节详解）。</p><p>获取到 View 对象后，如果 View 是打开状态则调用 <code>UIView.Update(...)</code> 函数更新，关闭状态则调用 <code>UIView:Open(...)</code> 函数打开。</p><p>UIController 对外暴露一个公共接口：</p><ul><li><code>UIController.Open(name, ...)</code>，用于外部打开指定 View 。</li><li><code>UIController.RegisterView(class)</code>，用于注册一个 View 子类，通过其来实例化相应的 UI 窗口。</li><li><code>UIController.Close(view)</code>，用于关闭一个 View，这个接口用于 View 为了关闭自己而调用。</li></ul><p>UIController 作为一个父类，需要子类重写以下接口：</p><ul><li><code>UIController.OnInitView()</code>，初始化所有View，调用 <code>RegisterView</code> 注册指定 View。</li><li><code>UIController.OnDispose()</code>，销毁整个 Controller 的后续处理。</li></ul><h3 id="实现一个-View-接口"><a href="#实现一个-View-接口" class="headerlink" title="实现一个 View 接口"></a>实现一个 View 接口</h3><p>View 接口是所有UI资源窗口的父类，子类通过继承方式实现一个UI子窗口显示。<br>View 子类可以直接访问和修改 model 数据，另外，我希望在 View 中能间接调用 Controller 打开其他窗口。</p><p>View 接口完整生命周期示例图如下：</p><p><img src="/images/mvc/mvc_view_life_cycle.png" alt="mvc"></p><p>根据上面生命周期实例图，我们可以看出整个 View 对象从初始化到关闭的完整生命周期流程。我们把 View 生命周期状态分为3部分：</p><ul><li>NONE，未初始化状态</li><li>HIDE，隐藏状态</li><li>SHOW，打开状态</li></ul><p>根据上面的状态图，我们先实现 View 接口代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIView = Class(<span class="string">'UIView'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Ctor</span><span class="params">()</span></span></span><br><span class="line">    self.controller    = <span class="literal">nil</span> <span class="comment">-- 持有 View 的 UIController 对象</span></span><br><span class="line">    self.model         = <span class="literal">nil</span> <span class="comment">-- View 持有的 Model 数据，与 UIController 共享</span></span><br><span class="line"></span><br><span class="line">    self.gameObject    = <span class="literal">nil</span>   <span class="comment">-- 引擎对象，该对象保存着UI资源</span></span><br><span class="line">    self.isAutoDestroy = <span class="literal">false</span> <span class="comment">-- 是否自动销毁，默认关闭时直接销毁对象，如果不自动销毁，关闭动作时隐藏</span></span><br><span class="line">    self.layer         = UIConst.LAYER.MIDDLE   <span class="comment">-- UI 层级（高、中、低）</span></span><br><span class="line">    self.lifeState     = UIConst.LIFESTATE.NONE <span class="comment">-- UI 生命周期状态</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:IsState</span><span class="params">(state)</span></span></span><br><span class="line">    <span class="keyword">return</span> self.lifeState == state</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Init</span><span class="params">()</span></span></span><br><span class="line">    self.gameObject:SetActive(<span class="literal">false</span>)</span><br><span class="line">    self.lifeState = UIConst.LIFESTATE.HIDE</span><br><span class="line">    self:OnInit()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OpenView</span><span class="params">(name, ...)</span></span></span><br><span class="line">    self.controller:Open(name, ...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Open</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self:IsState(UIConst.LIFESTATE.HIDE) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self.lifeState = UIConst.LIFESTATE.SHOW</span><br><span class="line">    self.gameObject:SetActive(<span class="literal">true</span>)</span><br><span class="line">    self:OnShow(...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Update</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self:IsState(UIConst.LIFESTATE.SHOW) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self:OnUpdate(...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Close</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self:IsState(UIConst.LIFESTATE.SHOW) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self:OnHide()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.isAutoDestroy <span class="keyword">then</span></span><br><span class="line">        self.controller:Close(self)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        self.gameObject:SetActive(<span class="literal">false</span>)</span><br><span class="line">        self.lifeState = UIConst.LIFE_STATE.HIDE</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OnInit</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OnShow</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OnUpdate</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OnHide</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIView</span><br></pre></td></tr></table></figure><p>View 初始化时，会从引擎底层加载 UI 编辑器指定的 UI 组件到 View 对象，这一步是 Contoller 在创建 View 时执行的，我们可以看到 <code>UIContoller.GetView()</code> 函数调用时，判断当前 View 对象如果是未初始化状态则调用帮助函数 <code>UIHelper.InitView()</code> 加载所有 UI 组件对象，其加载代码看起来时这样的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIHelper = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Lua 封装的 UI 组件对象</span></span><br><span class="line"><span class="keyword">local</span> UI_TYPES = &#123;</span><br><span class="line">    [<span class="string">'UIButton'</span>]        = <span class="built_in">require</span>(<span class="string">"game.ui.component.UIButton"</span>),</span><br><span class="line">    [<span class="string">'UILabel'</span>]         = <span class="built_in">require</span>(<span class="string">"game.ui.component.UILabel"</span>),</span><br><span class="line">    [<span class="string">'UIInputField'</span>]    = <span class="built_in">require</span>(<span class="string">"game.ui.component.UIInputField"</span>),</span><br><span class="line">    <span class="comment">-- 其他 UI 组件...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建引擎 UI 对象</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">CreateCSObject</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- TODO 创建引擎UI对象，设置其层级关系</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化所以 UI 组件Lua对象</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">InitComponents</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="keyword">local</span> components = view.gameObject.components</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, component <span class="keyword">in</span> <span class="built_in">ipairs</span>(components) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> uiLuaClass = UI_TYPES[component.typeName]</span><br><span class="line">        <span class="keyword">if</span> uiLuaClass <span class="keyword">then</span></span><br><span class="line">            view[component.key] = uiLuaClass.New(component.value)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化 UIView 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIHelper.InitView</span><span class="params">(view)</span></span></span><br><span class="line">    view.gameObject = CreateCSObject(view)</span><br><span class="line"></span><br><span class="line">    InitComponents(view)</span><br><span class="line"></span><br><span class="line">    view:Init()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIHelper</span><br></pre></td></tr></table></figure><p>在我们可以看到所有 UI 组件都在 Lua 层有一个简单的封装对象，我们在 UI 编辑器指定 UI 组件名称和类型后，在加载完 View 对象后，其 UI 组件就被赋予给了 View 对象。下面给出了一个按钮组件的简单封装实例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIButton = Class(<span class="string">'UIButton'</span>, UIBehaviour)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIButton:SetText</span><span class="params">(name)</span></span></span><br><span class="line">    self.core.text = name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIButton:SetEnable</span><span class="params">(isEnable)</span></span></span><br><span class="line">    self.core:SetEnable(isEnable)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIButton:AddListener</span><span class="params">(callback, delayTime)</span></span></span><br><span class="line">    delayTime = delayTime <span class="keyword">or</span> <span class="number">0.3</span></span><br><span class="line">    self.event.onClickLua = callback</span><br><span class="line">    self.event.clickDelayTime = delayTime</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIButton</span><br></pre></td></tr></table></figure><p>View 初始化完成后，每次打开时，都会传入打开时需要的数据，我们根据状态，把数据传给不同的处理函数。当前 UI 处于打开状态时调用 <code>UIView.Open()</code>；处于显示状态，则调用 <code>UIView.Update()</code>。最后可以使用 <code>UIView.Close()</code> 关闭 View。</p><p>UIView 对外暴露一个公共接口：</p><ul><li><code>UIView.Init()</code>，初始化 View，初始化完成后调用一次 <code>UIView.OnInit()</code>。</li><li><code>UIView.Open(...)</code>，当 View 处于隐藏状态时，打开 View，最终会调用 <code>UIView.OnShow()</code> 处理。</li><li><code>UIView.Update(...)</code>，当 View 处于打开状态时，更新 View 数据，最终会调用 <code>UIView.OnUpdate()</code> 处理。</li><li><code>UIView.Close(...)</code>，用于关闭当前 UI，并调用 <code>UIView.OnHide()</code> 处理 View 隐藏后逻辑，其资源清理逻辑最终会交给 Controller 执行。</li><li><code>UIView.OpenView(name)</code>，用于打开其他 View，其打开逻辑会交给 Controller 执行。</li></ul><p>UIView 作为一个父类，需要子类重写以下接口：</p><ul><li><code>UIView.OnInit()</code>，初始化View，我们需要做一些 UI 组件事件注册逻辑处理，如果某个按钮点击后的逻辑，因为这些逻辑固定不变的，整个 View 生命周期只会调用过一次。</li><li><code>UIView.OnShow()</code>，如果 View 隐藏状态，在打开 View 时，会调用此函数，并传入打开 UI 时需要处理的数据。</li><li><code>UIView.OnUpdate()</code>，如果 View 打开状态，在打开 View 时，会调用此函数，并传入打开 UI 时需要处理的数据。</li><li><code>UIView.OnHide()</code>，当 View 被调用 UIView.Close(…) 时，在销毁前，会被调用，需要在此函数内处理关闭 View 时的逻辑。</li></ul><h2 id="View-分组"><a href="#View-分组" class="headerlink" title="View 分组"></a>View 分组</h2><p>在复杂的游戏 UI 功能开发时，常常遇到这些的问题：</p><ul><li>同一个 UI 窗口内，我们希望某一组 UI 是互斥的，即同一时间内，Controller 只能打开该组内的某一个 View，如果同组有其他 View 打开则先关闭一打开的 View。</li><li>有一些 UI 分组，在某个指定 UI 关闭后，其分组内的任何 UI 只要打开都会自动关闭。</li></ul><p>看到这些需求后，我们很快想到使用一颗树来管理这些 UI View 分组。其分组示例图如下：</p><p><img src="/images/mvc/mvc_view_group.png" alt="mvc"></p><p>从图中我们可以看到，这是一个树形结构的 UI 分组，有一个根节点，子节点之间是分层的，每一层节点之间可以设置未互斥状态，即同一时间内，只能被打开一个。<br>有了这个树形结构，当某个节点被关闭后，我们可以很快获取到这个节点的所有子节点，并关闭它们。</p><p>于是可以设计一个 UI 分组代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Tree = <span class="built_in">require</span> <span class="string">"game.foundation.Tree"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> UIGroupTree = Class(<span class="string">'UIGroupTree'</span>, Tree)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIGroupTree:Ctor</span><span class="params">()</span></span></span><br><span class="line">    self.isExclusion = <span class="literal">true</span> <span class="comment">-- 子节点是否互斥，默认未互斥</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIGroupTree:SetExclusion</span><span class="params">(isExclusion)</span></span></span><br><span class="line">    self.isExclusion = isExclusion</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIGroupTree:IsExclusion</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> self.isExclusion</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIGroupTree:AddChildUI</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="keyword">return</span> self.NewChild(view.name)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIGroupTree</span><br></pre></td></tr></table></figure><p>代码中树形结构 <code>Tree</code> 实现请参考外部 <a href="https://gist.github.com/Veinin/a9fbf71f6a82938100dff7fbff501495" target="_blank" rel="noopener">链接</a>。</p><p>然后我们拓展 Contoller 接口实现：</p><ul><li>加入新的成员变量 group (UIGroupTree类型)</li><li>加入创建 UI 分组对象函数，<code>UIController.NewGroup(view)</code>，用于创建一个分组。</li><li>加入新的抽象函数 <code>UIController.OnInitGroup()</code>，子类如需要UI分组，则重写该函数，该函数在 Controller 初始化时被调用。</li><li>打开某个 UI 时检查 View 对象是否分组、分组是否互斥、是否有互斥 View 已打开，如果打开则关闭互斥 View。</li><li>关闭某个 UI 时检查 View 对象是否分组，当前节点是否存在子节点，子节点是否有打开情况，如果打开则关闭 View。</li></ul><p>扩展 Controller 的代码实现如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIGroupTree = <span class="built_in">require</span> <span class="string">"game.ui.group.UIGroupTree"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> UIController:Ctor()</span><br><span class="line">    <span class="comment">-- 上面已实现代码省略...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">OnLoad</span><span class="params">(self, assets)</span></span></span><br><span class="line">    <span class="comment">-- 上面已实现代码省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">next</span>(self.viewClasses) <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- ...</span></span><br><span class="line">        self:OnInitGroup()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:OnInitGroup</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- 子类实现</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个UI分组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:NewGroup</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="built_in">assert</span>(self.group == <span class="literal">nil</span>, <span class="string">"不允许创建多个分组"</span>)</span><br><span class="line">    self.group = UIGroupTree.New(view.name)</span><br><span class="line">    <span class="keyword">return</span> self.group</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查互斥</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">CheckExclusion</span><span class="params">(self, view)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.group <span class="keyword">or</span> self.openViewCount == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> name = view.name</span><br><span class="line">    <span class="keyword">local</span> node = self.group:FindChild(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> parent = node:GetParent()</span><br><span class="line">    <span class="keyword">if</span> #parent == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> parent:IsExclusion() <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> childName</span><br><span class="line">    <span class="keyword">local</span> childView</span><br><span class="line">    <span class="keyword">for</span> _, child <span class="keyword">in</span> <span class="built_in">ipairs</span>(parent) <span class="keyword">do</span></span><br><span class="line">        childName = child.name</span><br><span class="line">        childView = self.openViews[childName]</span><br><span class="line">        <span class="keyword">if</span> childName ~= name <span class="keyword">and</span> childView <span class="keyword">then</span> <span class="comment">-- 如果打开则关闭</span></span><br><span class="line">            self:Close(childView)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Open</span><span class="params">(name, ...)</span></span></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 打开前检查分组互斥</span></span><br><span class="line">    CheckExclusion(self, view)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> view:IsState(UIConst.LIFESTATE.SHOW) <span class="keyword">then</span></span><br><span class="line">        view:Update(...)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        view:Open(...)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查子节点关闭</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">CheckCloseChild</span><span class="params">(self, view)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.group <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> name = view.name</span><br><span class="line">    <span class="keyword">local</span> node = self.group:FindChild(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> childView</span><br><span class="line">    node:IterativeChildren(<span class="function"><span class="keyword">function</span><span class="params">(child)</span></span></span><br><span class="line">        childView = self.openViews[child.value]</span><br><span class="line">        <span class="keyword">if</span> childView <span class="keyword">then</span>  <span class="comment">-- 如果子节点打开则关闭</span></span><br><span class="line">            self:Close(childView)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Close</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.openViewCount == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        self:Dispose()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">-- 还有打开的 View，检查是否其子节点，并关闭</span></span><br><span class="line">        CheckCloseChild(self, view)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIController</span><br></pre></td></tr></table></figure><p>有了上面扩展实现的代码，我们就实现分组示例图中展示的分组结构：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyTestController:OnInitGroup</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> root = self:NewGroup(UIView1)</span><br><span class="line">    root:AddChild(UIView2)</span><br><span class="line">    root:AddChild(UIView3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> child = root:AddChild(UIView4)</span><br><span class="line">    child:AddChild(UIView5)</span><br><span class="line">    child:AddChild(UIView6)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="UI-开发半自动化"><a href="#UI-开发半自动化" class="headerlink" title="UI 开发半自动化"></a>UI 开发半自动化</h2><p>我们知道，游戏 UI 开发，很多固定的流程其实是可以省略的：</p><ul><li>UI 编辑完成后，开始写业务代码时，可以将所有基础代码全部生成，比如上面的 Controller 子类和每个窗口的 View 子类。</li><li>每个 View 类型，我们设计时其会对应 UI 编辑器的一个界面，且 UI 编辑器里面的所有组件，都是可以读取到的，在 Unity 中，我们保存为 Prefab 文件，而这个文件可以帮助我们设计一个自动生成代码的工具。</li><li>每次修改 UI 增加了新的组件后，我们希望原有的已经编辑的代码可以保留，在编辑器中刷新一下代码，能将新增加的控件基础代码直接加入到相应的代码文件里面。</li><li>每次修改完 UI 资源后，然后对应改完代码后，不希望在游戏中重启客户端才能看到效果，所以，我们加入了热更机制，任何代码都是可以热更新的，那么 UI 开发人员编码阶段将会非常方便。</li></ul><p>综上考虑，因为我们项目很多人使用 <strong>IntelliJ IDEA</strong> 配合一个不错的 Lua 插件 <strong>EmmyLua</strong>， 相对来说使用 Lua 开发还是比较顺畅的。所以决定在 <strong>IntelliJ IDEA</strong> 平台上开发一个为项目定制的 UI 开发插件（当然现在一些主流的代码编辑器都支持插件编写，你可以很容易在其他编辑器中实现这些内容）。</p><p>在UI编辑完成后，开发人员，建立 UI 功能开发文件夹后，右键菜单点击生成代码，插件自动生成 UIController 和 UIView 对应子类。</p><p>比如一个组队功能包含以下 UI 文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> TeamWindow</span><br><span class="line">    -&gt; Prefabs</span><br><span class="line">        -&gt; CreateView.prefab</span><br><span class="line">        -&gt; MemberView.prefab</span><br><span class="line">        -&gt; MemberItem.prefab</span><br></pre></td></tr></table></figure><p>生成的代码文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> team</span><br><span class="line">    -&gt; contoller</span><br><span class="line">        -&gt; TeamController.lua</span><br><span class="line">    -&gt; views</span><br><span class="line">        -&gt; CreateView.lua</span><br><span class="line">        -&gt; MemberView.lua</span><br><span class="line">    -&gt; protocol</span><br><span class="line">        -&gt; TeamProtocol.lua -- 协议文件，项目定制</span><br></pre></td></tr></table></figure><p>下面是 Contoller 实例 <code>TeamController.lua</code> 文件内容，该文件自动生成了很多基础的代码，需要填写的地方只剩下分组（如需要）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIController = <span class="built_in">require</span> <span class="string">"game.ui.core.UIController"</span></span><br><span class="line"><span class="keyword">local</span> CreateView = <span class="built_in">require</span> <span class="string">"game.ui.team.views.CreateView"</span></span><br><span class="line"><span class="keyword">local</span> MemberView = <span class="built_in">require</span> <span class="string">"game.ui.team.views.MemberView"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> TeamController = Class(<span class="string">'TeamController'</span>, UIController)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TeamController:OnInitView</span><span class="params">()</span></span></span><br><span class="line">    self:RegisterView(CreateView)</span><br><span class="line">    self:RegisterView(MemberView)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">funciton TeamController:OnInitGroup()</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TeamController</span><br></pre></td></tr></table></figure><p>下面是一个 View 实例 CreateView.lua 文件内容，其基本的组件代码全部通过编辑器UI文件自动生成，开发人员只需要在对应的 UI 组件填入相对于的业务逻辑即可：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIView = <span class="built_in">require</span> <span class="string">"game.ui.core.UIView"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> CreateView = Class(<span class="string">'CreateView'</span>, UIView)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:Ctor</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:OnInit</span><span class="params">()</span></span></span><br><span class="line">    self.closeButton:AddListener(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        self:Close()</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    self.cofirmButton:AddListener(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="comment">-- 开发人员实现创建队伍逻辑</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:OnShow</span><span class="params">(...)</span></span></span><br><span class="line">    self.nameInputField:SetText()</span><br><span class="line">    self.fightINputField:SetText()</span><br><span class="line">    self.levelInputField:SetText()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:OnUpdate</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:OnHide</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CreateView</span><br></pre></td></tr></table></figure><p>为了对比，下面展示以下 <code>CreateView.lua</code> 对应 <code>CreateView.prefab</code> 文件结构：</p><p><img src="/images/mvc/create_view.png" alt="mvc"></p><p>可以看出这个 UI 有5个需要处理的组件，两个按钮（关闭、确定），3个输入文本框（队伍名称、队伍战力、最低等级）。我们可以很容易从编辑的 prefab 文件中提取到里面的 UI 组件，然后通过插件直接生成代码文件。</p><p>有了上面的这些自动生成的代码，剩下的工作，其实就是填写一些基础的业务逻辑，那些重复性的工作工具已经可以帮你很好的完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文阐述了一个半自动化工作的游戏 UI 编写流程，并给出了实现步骤。<br>游戏 UI 开发流程存在大部分重复工作，我们稍微花点时间，其实是可以把这些重复工作自动化的，剩下的工作，无非就是填写下业务逻辑代码。<br>可以预见的是，开发这么一套半自动化的工具其实不到一周时间，其实是可以很容易搞定的，并且后续的 UI 开发效率其实是提升了一个档次。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近着手试了下我们客户端 UI 开发，发现整个流程对于开发人员来说并不是很友好，我们游戏客户端代码基本使用 Lua 语言进行，引擎则采用 Unity。对于 UI 模块目前有一套基本的 MVC 模式的开发流程，但这个开发模式的边界并没有处理很好，导致开发过程中异常艰难。编写代码的人员有时也会很懵逼，因为实现的方式可以有多种多样。&lt;/p&gt;
&lt;p&gt;在了解了整个旧有的开发流程后，我发现个问题，其中由UI编辑到代码编写，这个流程中，大部分过程都是重复行工作，而针对这一部分重复行工作通过一些小工具可以让UI开发流程实现半自动化。&lt;/p&gt;
&lt;p&gt;所谓半自动化，无非就是，开发人员不需要编写基本的UI代码，基础UI代码可以自动生成，包括整个开发流程中使用的各个UI窗口的组件都可以自动生成代码。&lt;/p&gt;
&lt;p&gt;另外，因为UI编写过程中进程资源修改、代码修改，我希望都可以在修改完后立刻可以看到效果，而不是重启游戏。&lt;/p&gt;
&lt;p&gt;下面是我对于一个半自动化的UI开发流程整理笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://veinin.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="半自动化，游戏UI开发，Unity" scheme="https://veinin.com/tags/%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%8C%E6%B8%B8%E6%88%8FUI%E5%BC%80%E5%8F%91%EF%BC%8CUnity/"/>
    
      <category term="MVC" scheme="https://veinin.com/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-线程同步精要</title>
    <link href="https://veinin.com/2018/06/25/programming_with_posix_pthreads_08/"/>
    <id>https://veinin.com/2018/06/25/programming_with_posix_pthreads_08/</id>
    <published>2018-06-25T06:11:13.000Z</published>
    <updated>2018-07-12T14:44:50.554Z</updated>
    
    <content type="html"><![CDATA[<p>本章节摘录自陈硕 《Linux多线程服务端编程:使用muduoC++网络库》 第二章关于线程同步笔记。</p><h2 id="线程同步四项原则"><a href="#线程同步四项原则" class="headerlink" title="线程同步四项原则"></a>线程同步四项原则</h2><p>线程同步的四项原则，按重要性排列：</p><ul><li>首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑 <code>immutable</code> 对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。</li><li>其次是使用高级的并发编程构件，如 <code>TaskQueue</code>、<code>Producer-ConsumerQueue</code>、<code>CountDownLatch</code> 等等。</li><li>最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。</li><li>除了使用 <code>atomic</code> 整数之外，不自己编写 <code>lock-free</code> 代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如<code>spin lock</code> vs <code>mutex</code>。</li></ul><a id="more"></a><h2 id="互斥器（mutex）"><a href="#互斥器（mutex）" class="headerlink" title="互斥器（mutex）"></a>互斥器（mutex）</h2><p>互斥器（mutex）是使用得最多的同步原语，粗略地说，它保护了临界区，任何一个时刻最多只能有一个线程在此 mutex 划出的临界区内活动。单独使用 mutex 时，我们主要为了保护共享数据。</p><p>主要原则：</p><ul><li>在C++中，应该使用用<code>RAII</code>手法封装<code>mutex</code>的创建、销毁、加锁、解锁这四个操作。Java里的 <code>synchronized</code> 语句和C#的 <code>using</code> 语句也有类似的效果，即保证锁的生效期间等于一个作用域（scope），不会因异常而忘记解锁。</li><li>只用非递归的 <code>mutex</code>（即不可重入的mutex）。</li><li>不手工调用 <code>lock()</code> 和 <code>unlock()</code> 函数，</li><li>在每次构造 <code>Guard</code> 对象的时候，思考一路上（调用栈上）已经持有的锁，防止因加锁顺序不同而导致死锁（deadlock）。</li></ul><p>次要原则：</p><ul><li>不使用跨进程的 <code>mutex</code>，进程间通信只用 TCPsockets。</li><li>加锁、解锁在同一个线程，线程a不能去 <code>unlock</code> 线程b已经锁住的 <code>mutex</code>（RAII自动保证）。 别忘了解锁（RAII自动保证）。</li><li>不重复解锁（RAII自动保证）。</li><li>必要的时候可以考虑用 <code>PTHREAD_MUTEX_ERRORCHECK</code> 来排错。</li></ul><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>互斥器（mutex）是加锁原语，用来排他性地访问共享数据，它不是等待原语。在使用 mutex 的时候，我们一般都会期望加锁不要阻塞，总是能立刻拿到锁。然后尽快访问数据，用完之后尽快解锁，这样才能不影响并发性和性能。</p><p>如果需要等待某个条件成立，我们应该使用条件变量（conditionvariable）。条件变量顾名思义是一个或多个线程等待某个布尔表达式为真，即等待别的线程“唤醒”它。条件变量只有一种正确使用的方式，几乎不可能用错。</p><p>对于wait端：</p><ul><li>必须与 <code>mutex</code> 一起使用，该布尔表达式的读写需受此mutex保护。</li><li>在 <code>mutex</code> 已上锁的时候才能调用 <code>wait()</code>。</li><li>把判断布尔条件和 <code>wait()</code> 放到 <code>while</code> 循环中。</li></ul><p>对于 signal/broadcast 端：</p><ul><li>不一定要在 <code>mutex</code> 已上锁的情况下调用 <code>signal</code>（理论上）。</li><li>在 <code>signal</code> 之前一般要修改布尔表达式。</li><li>修改布尔表达式通常要用 <code>mutex</code> 保护（至少用作fullmemorybarrier）。</li><li>注意区分 <code>signal</code> 与 <code>broadcast</code>： <code>broadcast</code> 通常用于表明状态变化，<code>signal</code> 通常用于表示资源。</li></ul><p>条件变量是非常底层的同步原语，很少直接使用，一般都是用它来实现高层的同步措施，如 <code>BlockingQueue&lt;T&gt;</code> 或 <code>CountDownLatch</code>。</p><p>倒计时（CountDownLatch）是一种常用且易用的同步手段。它主要有两种用途：</p><ul><li>主线程发起多个子线程，等这些子线程各自都完成一定的任务之后，主线程才继续执行。通常用于主线程等待多个子线程完成初始化。</li><li>主线程发起多个子线程，子线程都等待主线程，主线程完成其他一些任务之后通知所有子线程开始执行。通常用于多个子线程等待主线程发出“起跑”命令。</li></ul><h2 id="不要使用读写锁和信号量"><a href="#不要使用读写锁和信号量" class="headerlink" title="不要使用读写锁和信号量"></a>不要使用读写锁和信号量</h2><p>读写锁（Readers-Writerlock，简写为rwlock）是个看上去很美的抽象，它明确区分了 read 和 write 两种行为。</p><p>初学者常干的一件事情是，一见到某个共享数据结构频繁读而很少写，就把 mutex 替换为 rwlock。甚至首选 rwlock 来保护共享状态，这不见得是正确的。</p><ul><li>从正确性方面来说，一种典型的易犯错误是在持有 readlock 的时候修改了共享数据。这通常发生在程序的维护阶段，为了新增功能，程序员不小心在原来 readlock 保护的函数中调用了会修改状态的函数。这种错误的后果跟无保护并发读写共享数据是一样的。</li><li>从性能方面来说，读写锁不见得比普通 mutex 更高效。无论如何 readerlock 加锁的开销不会比 mutexlock 小，因为它要更新当前 reader 的数目。如果临界区很小，锁竞争不激烈，那么 mutex 往往会更快。</li><li>readerlock 可能允许提升为 writerlock，也可能不允许提升。如果处理不好容易导致程序崩溃和死锁。</li><li>通常 readerlock 是可重入的，writerlock 是不可重入的。但是为了防止 writer 饥饿，writerlock通常会阻塞后来的readerlock，因此 readerlock 在重入的时候可能死锁。另外，在追求低延迟读取的场合也不适用读写锁。</li></ul><p>对于信号量（Semaphore），陈硕认为信号量不是必备的同步原语，因为条件变量配合互斥器可以完全替代其功能，而且更不易用错。<br>信号量的另一个问题在于它有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能。</p><h2 id="归纳与总结"><a href="#归纳与总结" class="headerlink" title="归纳与总结"></a>归纳与总结</h2><p>作者认为，应该先把程序写正确（并尽量保持清晰和简单），然后再考虑性能优化，如果确实还有必要优化的话。这在多线程下仍然成立。让一个正确的程序变快，远比“让一个快的程序变正确”容易得多。</p><p>“效率”并不是我的主要考虑点，我提倡正确加锁而不是自己编写 <code>lock-free</code>算法（使用原子整数除外），更不要想当然地自己发明同步设施。在没有实测数据支持的情况下，妄谈哪种做法效率更高是靠不住的，不能听信传言或凭感觉“优化”。很多人误认为用锁会让程序变慢，其实真正影响性能的不是锁，而是锁争用（lockcontention）。</p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章节摘录自陈硕 《Linux多线程服务端编程:使用muduoC++网络库》 第二章关于线程同步笔记。&lt;/p&gt;
&lt;h2 id=&quot;线程同步四项原则&quot;&gt;&lt;a href=&quot;#线程同步四项原则&quot; class=&quot;headerlink&quot; title=&quot;线程同步四项原则&quot;&gt;&lt;/a&gt;线程同步四项原则&lt;/h2&gt;&lt;p&gt;线程同步的四项原则，按重要性排列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑 &lt;code&gt;immutable&lt;/code&gt; 对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。&lt;/li&gt;
&lt;li&gt;其次是使用高级的并发编程构件，如 &lt;code&gt;TaskQueue&lt;/code&gt;、&lt;code&gt;Producer-ConsumerQueue&lt;/code&gt;、&lt;code&gt;CountDownLatch&lt;/code&gt; 等等。&lt;/li&gt;
&lt;li&gt;最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。&lt;/li&gt;
&lt;li&gt;除了使用 &lt;code&gt;atomic&lt;/code&gt; 整数之外，不自己编写 &lt;code&gt;lock-free&lt;/code&gt; 代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如&lt;code&gt;spin lock&lt;/code&gt; vs &lt;code&gt;mutex&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-线程扩展</title>
    <link href="https://veinin.com/2018/06/20/programming_with_posix_pthreads_07/"/>
    <id>https://veinin.com/2018/06/20/programming_with_posix_pthreads_07/</id>
    <published>2018-06-20T14:12:24.000Z</published>
    <updated>2018-07-12T14:44:39.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栅栏（Barriers）"><a href="#栅栏（Barriers）" class="headerlink" title="栅栏（Barriers）"></a>栅栏（Barriers）</h2><p>barrier 字面意思时栅栏，barrier 是将一组成员保持在一起的一种方式，它可以实现让一组线程等待至某个状之后再全部同时执行。一个 barrier 通常被用来确保某些井行算法中的所有合作线程在任何线程可以继续运行之前到达算法中的一个特定点。</p><p>barrier 的核心是一个计数器，我们可以称之为“阈值”，即在一个 barrier 上必须等待的线程数。计时器计算着当前线程的返回数量，如果数量未达到指定点，那么之前返回的线程都必须继续等待，直到最后一个线程返回，才能开始下一步。</p><a id="more"></a><p>你可以查看源文件 <code>barrier.h</code> 、<code>barrier.c</code>、<code>barrier_main.c</code>，这是一个比较容易理解的实现。</p><p>另外 Pthreads 在 POSIX.14 草案标准（一个 “POSIX 标准子集”）中新增加了 Barriers 变量，其 API 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(<span class="keyword">pthread_barrier_t</span> * <span class="keyword">restrict</span> barrier, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br></pre></td></tr></table></figure><p>源文件 <code>pthread_barrier.c</code> 是一个 Pthreads barrier 的简单实例。</p><h2 id="读-写锁（Read-Write-Lock）"><a href="#读-写锁（Read-Write-Lock）" class="headerlink" title="读/写锁（Read-Write Lock）"></a>读/写锁（Read-Write Lock）</h2><p>读/写锁很像一个互斥量，它是阻止多个线程同时修改共享数据的另外一种方。但是不同于互斥量的是它区分读数据和写数据。一个互斥量排除所有的其他线程，而一个读/写锁如果线程不需要改变数据，则允许多个线程同时读数据。当一个线程需要更新缓存数据是，则必须以独占的方式进行，其他只读线程都不能继续占有锁。</p><p>读/写锁被用来保护经常需要读但是通常不需要修改的信息（读多写少）。当写锁被释放时，如果读数据者和写数据者同时正在等待存取，则读数据者被优先给予访问权。因为潜在地允许许多线程同时完成工作，读访问优先有利于并发。</p><p>文件 <code>rwlock.h</code> 、<code>rwlock.c</code>、<code>rwlock_main.c</code> 演示了如何使用标准的 Pthreads 互斥量和状况变量实现读写锁， 这是相对容易理解的可移植的实现。</p><p>另外，在最新版本的 <code>X/Open XSH5 [UNIX98]</code> 标准中，Pthreads 增加了读写锁的支持，读写锁的数据类型为 <code>pthread_rwlock_t</code>，如果需要静态分配该类型数据，那么可通过<code>PTHREAD_RWLOCK_INITIALIZER</code> 宏来初始化它。Pthreads 读写锁 API 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> lock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * <span class="keyword">restrict</span> lock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> * <span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * <span class="keyword">restrict</span> lock, <span class="keyword">const</span> struct timespec * <span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * <span class="keyword">restrict</span> lock, <span class="keyword">const</span> struct timespec * <span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br></pre></td></tr></table></figure><p>你可以查看源文件 <code>pthread_rwlock.c</code>，这是简单的 Pthread 读写锁的使用实例。</p><h2 id="自旋锁（Spin-Locks）"><a href="#自旋锁（Spin-Locks）" class="headerlink" title="自旋锁（Spin Locks）"></a>自旋锁（Spin Locks）</h2><p>自旋锁（Spinlock）也是一种锁，自旋锁在线程尝试获取它时，会在一个循环中不停等待（旋转），同时反复检查锁是否可用。由于线程始终保持活动状态且并没有执行有用的任务，因此使用这种锁时将产生一种忙碌的等待情况。</p><p>因为在一些多线程场景中我们需要避免操作系统进程的重新调度或者上下文的切换开销，所以如果线程仅仅只是短时间内被阻塞，那么使用自旋锁将是一种非常有效的方式。但是，如果你的程序需要比较长的时间保持锁的使用，那么自旋锁将会变的浪费，因为它会阻止其他线程运行。线程持有锁的时间越长，操作系统调度程序在保持锁定时中断线程的风险就越大。在这种情况下，其他线程将会不停“旋转”（反复尝试获取锁定），而持有锁的线程没有进行释放。结果将是无限期推迟，直到持有锁的线程完成并释放它。</p><p>下面是一个自旋锁的实现方式，该实现中使用了 GCC 提供的原子操作的相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> lock;</span><br><span class="line">&#125; <span class="keyword">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spinlock_init</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sl-&gt;lock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spinlock_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;sl-&gt;lock, <span class="number">1</span>)) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">spinlock_trylock</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __sync_lock_test_and_set(&amp;sl-&gt;lock, <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spinlock_unlock</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __sync_lock_release(&amp;sl-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spinlock_destroy</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) sl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以查看源文件 <code>spinlock.h</code> 和 <code>spinlock_main.c</code>，这是一个自旋锁的简单使用实例，演示了10个线程并发使用自旋锁修改单一数据流程。</p><p>另外，Pthreads 也提供了自旋锁的实现，其 API 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock, <span class="keyword">int</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br></pre></td></tr></table></figure><p>你可以在源文件 <code>pthread_spinlock.c</code> 中查看对自旋锁的使用实例。</p><h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><p>信号量是由 EW Dijkstra 在20世纪60年代后期设计的编程结构。Dijkstra 的模型是铁路运营。考虑一段铁路，其中存在单个轨道，在该轨道上一次只允许一列火车。</p><p>信号量同步此轨道上的行程。火车必须在进入单轨之前等待，直到信号量处于允许旅行的状态。当火车进入轨道时，信号量改变状态以防止其他列车进入轨道。离开这段赛道的火车必须再次改变信号量的状态，以允许另一列火车进入。</p><p>在计算机版本中，信号量似乎是一个简单的整数。线程等待许可继续，然后通过对信号量执行<code>P操作</code>来发出线程已经继续的信号。</p><p>线程必须等到信号量的值为正，然后通过从值中减去1来更改信号量的值。完成此操作后，线程执行<code>V操作</code>，通过向该值加1来更改信号量的值。这些操作必须以原子方式进行。在<code>P操作</code>中，信号量的值必须在值递减之前为正，从而产生一个值，该值保证为非负值，并且比递减之前的值小1。</p><h3 id="信号量-API"><a href="#信号量-API" class="headerlink" title="信号量 API"></a>信号量 API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure><p>信号量初始化函数中，pshared的值为零，则不能在进程之间共享信号量。如果pshared的值非零，则可以在进程之间共享信号量。值 value 之名，<br>其中，<code>sem_post</code> 以原子方式递增sem指向的信号量。调用后，当信号量上的任何线程被阻塞时，其中一个线程被解除阻塞。<br>使用 <code>sem_wait</code> 来阻塞调用线程，直到sem指向的信号量计数变为大于零，然后原子地减少计数。</p><h3 id="信号量解决生产者与消费者问题"><a href="#信号量解决生产者与消费者问题" class="headerlink" title="信号量解决生产者与消费者问题"></a>信号量解决生产者与消费者问题</h3><p>生产者和消费者问题是并发编程中标准的，众所周知的一个小问题。在一个缓冲区中，分为将项目放入缓冲区生产者，从缓冲区中取出项目的消费者。</p><p>在缓冲区有可用空间之前，生产者不能在缓冲区中放置东西。在生产者写入缓冲区之前，消费者不能从缓冲区中取出东西。</p><p>你可以查看源文件 <code>pthread-semaphore.c</code>，这是一个使用信号量解决生产者、消费者问题的实例。</p><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p>工作队列是一组线程间分派工作的方法，创建工作队列时，可以指定需要的最大并发级别（最大线程数量）。</p><p>依据工作量的要求，线程将被开始或停止。没有发现任何请求的一个线程将等待一段时间后终止。最优的时间段取决于在你的系统上创建一个新线程的开销、维护一个不做任何工作的线程的系统资源的开销，以及你将再次需要线程的可能性。</p><p>源文件 <code>workq.h</code> 、<code>workq.c</code> 和 <code>workq_main.c</code> 显示了一个工作队列管理器的实现。</p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栅栏（Barriers）&quot;&gt;&lt;a href=&quot;#栅栏（Barriers）&quot; class=&quot;headerlink&quot; title=&quot;栅栏（Barriers）&quot;&gt;&lt;/a&gt;栅栏（Barriers）&lt;/h2&gt;&lt;p&gt;barrier 字面意思时栅栏，barrier 是将一组成员保持在一起的一种方式，它可以实现让一组线程等待至某个状之后再全部同时执行。一个 barrier 通常被用来确保某些井行算法中的所有合作线程在任何线程可以继续运行之前到达算法中的一个特定点。&lt;/p&gt;
&lt;p&gt;barrier 的核心是一个计数器，我们可以称之为“阈值”，即在一个 barrier 上必须等待的线程数。计时器计算着当前线程的返回数量，如果数量未达到指定点，那么之前返回的线程都必须继续等待，直到最后一个线程返回，才能开始下一步。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
</feed>
