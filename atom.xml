<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Veinin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://veinin.com/"/>
  <updated>2018-04-19T14:03:33.042Z</updated>
  <id>https://veinin.com/</id>
  
  <author>
    <name>Veinin Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 快速上手 - 文件</title>
    <link href="https://veinin.com/2018/04/19/python-practice-files/"/>
    <id>https://veinin.com/2018/04/19/python-practice-files/</id>
    <published>2018-04-19T13:35:00.000Z</published>
    <updated>2018-04-19T14:03:33.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="os-path-模块"><a href="#os-path-模块" class="headerlink" title="os.path 模块"></a>os.path 模块</h2><p>os.path 模块包含了许多与文件名和文件路径相关的有用函数。<br>例如， 你已经使用了 os.path.join()来构建所有操作系统上都有效的路径。<br>因为 os.path 是 os 模块中的模块， 所以只要执行 import os 就可以导入它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br></pre></td></tr></table></figure><h2 id="文件与文件路径"><a href="#文件与文件路径" class="headerlink" title="文件与文件路径"></a>文件与文件路径</h2><p>在 Windows 上， 路径书写使用倒斜杠作为文件夹之间的分隔符。但在 OS X 和Linux 上， 使用正斜杠作为它们的路径分隔符。<br>如果想要程序运行在所有操作系统上，在编写 Python 脚本时， 就必须处理这两种情况。<br>Python 使用 <code>os.path.join()</code> 函数来做这件事很简单。<br>如果将单个文件和路径上的文件夹名称的字符串传递给它， <code>os.path.join()</code> 就会返回一个文件路径的字符串</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;usr&apos;, &apos;bin&apos;, &apos;spam&apos;)</span><br><span class="line">&apos;usr\\bin\\spam&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; myFiles = [&apos;a.txt&apos;, &apos;b.txt&apos;, &apos;c.txt&apos;]</span><br><span class="line">&gt;&gt;&gt; for fileName in myFiles:</span><br><span class="line">        print(os.path.join(&apos;C:\\Users\\App&apos;, fileName))</span><br><span class="line"></span><br><span class="line">C:\Users\App\a.txt</span><br><span class="line">C:\Users\App\b.txt</span><br><span class="line">C:\Users\App\c.txt</span><br></pre></td></tr></table></figure><h2 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h2><p>每个运行在计算机上的程序， 都有一个“ 当前工作目录”， 或 cwd。<br>利用 <code>os.getcwd()</code> 函数，可以取得当前工作路径的字符串， 并可以利用 <code>os.chdir()</code> 改变它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.getcwd()</span><br><span class="line">&apos;C:\\Users\\Ansh&apos;</span><br><span class="line">&gt;&gt;&gt; os.chdir(&apos;C:\\App&apos;)</span><br><span class="line">&gt;&gt;&gt; os.getcwd()</span><br><span class="line">&apos;C:\\App&apos;</span><br></pre></td></tr></table></figure><h2 id="创建新文件夹"><a href="#创建新文件夹" class="headerlink" title="创建新文件夹"></a>创建新文件夹</h2><p>可以用 <code>os.makedirs()</code> 函数创建新文件夹（ 目录）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(&apos;C:\\Users\\Ansh\\Desktop\\Test&apos;)</span><br></pre></td></tr></table></figure></p><h2 id="处理绝对路径和相对路径"><a href="#处理绝对路径和相对路径" class="headerlink" title="处理绝对路径和相对路径"></a>处理绝对路径和相对路径</h2><p>有两种方法指定一个文件路径。</p><ul><li>“绝对路径”， 总是从根文件夹开始。</li><li>“相对路径”，它相对于程序的当前工作目录。<br>还有点（ .）和点点（ ..）文件夹。它们不是真正的文件夹，而是可以在路径中使用的特殊名称。</li></ul><p>os.path 模块提供了一些函数， 返回一个相对路径的绝对路径， 以及检查给定的路径是否为绝对路径。</p><ul><li>调用 <code>os.path.abspath(path)</code> 将返回参数的绝对路径的字符串。</li><li>调用 <code>os.path.isabs(path)</code> ，如果参数是一个绝对路径，就返回 True，如果参数是一个相对路径，就返回 False。</li><li>调用 <code>os.path.relpath(path, start)</code> 将返回从 start 路径到 path 的相对路径的字符串。如果没有提供 start，就使用当前工作目录作为开始路径。</li><li>调用 <code>os.path.dirname(path)</code> 将返回一个字符串，它包含 path 参数中最后一个斜杠之前的所有内容。</li><li>调用 <code>os.path.basename(path)</code> 将返回一个字符串，它包含 path 参数中最后一个斜杠之后的所有内容。</li><li>调用 <code>os.path.split()</code> 获得一个路径的目录名称和基本名称， 会返回两个字符串的元组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)</span><br><span class="line">&apos;C:\\App&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.\\Scripts&apos;)</span><br><span class="line">&apos;C:\\App\\Scripts&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.isabs(&apos;.&apos;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; os.path.isabs(os.path.abspath(&apos;.&apos;))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; os.path.relpath(&apos;C:\\Windows&apos;, &apos;C:\\&apos;)</span><br><span class="line">&apos;Windows&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.relpath(&apos;C:\\Windows&apos;, &apos;C:\\spam\\eggs&apos;)</span><br><span class="line">&apos;..\\..\\Windows&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; path = &apos;C:\\Windows\\System32\\calc.exe&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.basename(path)</span><br><span class="line">&apos;calc.exe&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.dirname(path)</span><br><span class="line">&apos;C:\\Windows\\System32&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.split(path)</span><br><span class="line">(&apos;C:\\Windows\\System32&apos;, &apos;calc.exe&apos;)</span><br><span class="line">&gt;&gt;&gt; path.split(os.path.sep)</span><br><span class="line">[&apos;C:&apos;, &apos;Windows&apos;, &apos;System32&apos;, &apos;calc.exe&apos;]</span><br></pre></td></tr></table></figure><h2 id="文件大小和文件夹内容"><a href="#文件大小和文件夹内容" class="headerlink" title="文件大小和文件夹内容"></a>文件大小和文件夹内容</h2><p>一旦有办法处理文件路径， 就可以开始搜集特定文件和文件夹的信息。</p><ul><li>调用 <code>os.path.getsize(path)</code> 将返回 path 参数中文件的字节数。</li><li>调用 <code>os.listdir(path)</code> 将返回文件名字符串的列表，包含 path 参数中的每个文件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.getsize(&apos;C:\\Windows\\System32\\calc.exe&apos;)</span><br><span class="line">26112L</span><br><span class="line">&gt;&gt;&gt; os.listdir(&apos;C:\\App\\Python27&apos;)</span><br><span class="line">[&apos;DLLs&apos;, &apos;Doc&apos;, &apos;include&apos;, &apos;Lib&apos;, &apos;libs&apos;, &apos;LICENSE.txt&apos;, &apos;NEWS.txt&apos;, &apos;python.exe&apos;, &apos;pythonw.exe&apos;, &apos;README.txt&apos;, &apos;Scripts&apos;, &apos;tcl&apos;, &apos;Tools&apos;, &apos;w9xpopen.exe&apos;]</span><br></pre></td></tr></table></figure><h2 id="检查路径有效性"><a href="#检查路径有效性" class="headerlink" title="检查路径有效性"></a>检查路径有效性</h2><p>如果你提供的路径不存在， 许多 Python 函数就会崩溃并报错。 <code>os.path</code> 模块提供了一些函数，用于检测给定的路径是否存在，以及它是文件还是文件夹。</p><ul><li>调用 <code>os.path.exists(path)</code> ，返回所指的文件或文件夹是否存在。</li><li>调用 <code>os.path.isfile(path)</code> ，返回目标是否一个文件。</li><li>调用 <code>os.path.isdir(path)</code> ，返回目标是否一个文件夹。</li></ul><h2 id="打开并读写文件"><a href="#打开并读写文件" class="headerlink" title="打开并读写文件"></a>打开并读写文件</h2><p>在 Python 中， 读写文件有 3 个步骤：</p><ul><li>调用 <code>open()</code> 函数， 返回一个 File 对象。</li><li>调用 File 对象的 <code>read()</code> 或 <code>write()</code> 方法。</li><li>调用 File 对象的 <code>close()</code> 方法，关闭该文件。</li></ul><p>打开文件 <code>open()</code> 方法，“读模式”、“ 写模式” 和 “添加模式”。如果打开文件时用读模式，就不能写入文件。而写模式将覆写原有的文件。添加模式将在已有文件的末尾添加文本。<br><code>open</code> 方法有第二个可选参数，如果不传则是读模式打开， 参数 ‘w’ 将使用写模式打开，而参数 ‘a’ 将以添加模式打开。</p><p>对于读取文件，还可以使用 <code>readlines()</code> 方法， 从该文件取得一个字符串的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; helloFile = open(&apos;C:\\Users\\Ansh\\Desktop\\hello.txt&apos;)</span><br><span class="line">&gt;&gt;&gt; helloContent = helloFile.read()</span><br><span class="line">&gt;&gt;&gt; helloContent</span><br><span class="line">&apos;Hello, World!&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; textFile = open(&apos;C:\\Users\\Ansh\\Desktop\\text.txt&apos;)</span><br><span class="line">&gt;&gt;&gt; for line in textFile.readlines():</span><br><span class="line">        print(line.strip())</span><br><span class="line"></span><br><span class="line">When, in disgrace with fortune and men&apos;s eyes,</span><br><span class="line">I all alone beweep my outcast state,</span><br><span class="line">And trouble deaf heaven with my bootless cries,</span><br><span class="line">And look upon myself and curse my fate,</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; baconFile = open(&apos;bacon.txt&apos;, &apos;w&apos;)</span><br><span class="line">&gt;&gt;&gt; baconFile.write(&apos;Hello world!\n&apos;)</span><br><span class="line">&gt;&gt;&gt; baconFile.close()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; baconFile = open(&apos;bacon.txt&apos;, &apos;a&apos;)</span><br><span class="line">&gt;&gt;&gt; baconFile.write(&apos;Bacon is not a vegetable.&apos;)</span><br><span class="line">&gt;&gt;&gt; baconFile.close()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; baconFile = open(&apos;bacon.txt&apos;)</span><br><span class="line">&gt;&gt;&gt; print(baconFile.read())</span><br><span class="line">Hello world!</span><br><span class="line">Bacon is not a vegetable.</span><br><span class="line">&gt;&gt;&gt; baconFile.close()</span><br></pre></td></tr></table></figure><h2 id="使用-shelve-模块保存变量"><a href="#使用-shelve-模块保存变量" class="headerlink" title="使用 shelve 模块保存变量"></a>使用 shelve 模块保存变量</h2><p>你可以将 Python 程序中的变量保存到二进制的 shelf 文件中。这样， 程序就可以从硬盘中恢复变量的数据。 shelve 模块让你在程序中添加“ 保存”和“ 打开” 功能。</p><p>要利用 shelve 模块读写数据，首先要导入它。<br>调用函数 <code>shelve.open()</code> 并传入一个文件名，然后将返回的值保存在一个变量中。可以对这个变量的 shelf 值进行修改，就像它是一个字典一样。<br>当你完成时，在这个值上调用 close()。最后，在当前的工作目录下会生成一个对应的二进制文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shelfFile = shelve.open(&apos;mydata&apos;)</span><br><span class="line">cats = [&apos;Zophie&apos;, &apos;Pooka&apos;, &apos;Simon&apos;]</span><br><span class="line">shelfFile[&apos;cats&apos;] = cats</span><br><span class="line">shelfFile.close()</span><br></pre></td></tr></table></figure><p>然后，可以使用 shelve 模块， 重新打开这些文件并取出数据。<br>shelf 值不必用读模式或写模式打开，因为它们在打开后，既能读又能写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shelfFile = shelve.open(&apos;mydata&apos;)</span><br><span class="line">print(shelfFile[&apos;cats&apos;])    # [&apos;Zophie&apos;, &apos;Pooka&apos;, &apos;Simon&apos;]</span><br><span class="line">shelfFile.close()</span><br></pre></td></tr></table></figure><h2 id="shutil-模块"><a href="#shutil-模块" class="headerlink" title="shutil 模块"></a>shutil 模块</h2><p>shutil（或称为 shell 工具）模块中包含一些函数，让你在 Python 程序中复制、移动、改名和删除文件。<br>要使用 shutil 的函数，首先需要 <code>import shutil</code>。</p><h3 id="复制文件和文件夹"><a href="#复制文件和文件夹" class="headerlink" title="复制文件和文件夹"></a>复制文件和文件夹</h3><p>调用 <code>shutil.copy(source, destination)</code>，将路径 source 处的文件复制到路径 destination处的文件夹。<br>如果 destination 是一个文件名，它将作为被复制文件的新名字。该函数返回一个字符串，表示被复制文件的路径。<br>另外，可以使用 <code>shutil.copytree()</code> 复制整个文件夹里面包含的文件夹和文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import shutil, os</span><br><span class="line"></span><br><span class="line">os.chdir(&apos;C:\\&apos;)</span><br><span class="line">shutil.copy(&apos;C:\\Users\\Ansh\\Desktop\\hello.txt&apos;, &apos;C:\\temp&apos;)</span><br><span class="line">shutil.copy(&apos;C:\\temp\\hello.txt&apos;, &apos;C:\\temp\\hello2.txt&apos;)</span><br><span class="line"></span><br><span class="line">shutil.copytree(&apos;C:\\temp&apos;, &apos;C:\\Users\\Ansh\\Desktop\\temp_backup&apos;)</span><br></pre></td></tr></table></figure><h3 id="移动或改名文件和文件夹"><a href="#移动或改名文件和文件夹" class="headerlink" title="移动或改名文件和文件夹"></a>移动或改名文件和文件夹</h3><p>调用 <code>shutil.move(source, destination)</code>， 将路径 source 处的文件夹移动到路径 destination。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutil.move(&apos;C:\\temp&apos;, &apos;C:\\Users\\Ansh\\Desktop&apos;)</span><br><span class="line">shutil.move(&apos;C:\\text.txt&apos;, &apos;C:\\Users\\Ansh\\Desktop\\temp&apos;)</span><br></pre></td></tr></table></figure><h3 id="永久删除文件和文件夹"><a href="#永久删除文件和文件夹" class="headerlink" title="永久删除文件和文件夹"></a>永久删除文件和文件夹</h3><p>利用 os 模块中的函数，可以删除一个文件或一个空文件夹。但利用 shutil 模块，可以删除一个文件夹及其所有的内容。</p><ul><li>调用 <code>os.unlink(path)</code> 将删除 path 处的文件。</li><li>调用 <code>os.rmdir(path)</code> 将删除 path 处的文件夹。</li><li>调用 <code>shutil.rmtree(path)</code> 将删除 path 处的文件夹，它包含的所有文件和文件夹都会被删除。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for filename in os.listdir(&apos;C:\\Users\\Ansh\\Desktop&apos;):</span><br><span class="line">    if filename.endswith(&apos;.txt&apos;):</span><br><span class="line">        os.unlink(filename)</span><br><span class="line"></span><br><span class="line">os.makedirs(&apos;Test&apos;)</span><br><span class="line">os.rmdir(&apos;Test&apos;)</span><br><span class="line"></span><br><span class="line">shutil.rmtree(&apos;temp_back&apos;)</span><br></pre></td></tr></table></figure><h2 id="遍历目录树"><a href="#遍历目录树" class="headerlink" title="遍历目录树"></a>遍历目录树</h2><p>如果你需要对某个文件夹中的所有文件改名， 包括该文件夹中所有子文件夹中的所有文件。也就是说， 你希望遍历目录树， 处理遇到的每个文件。<br>写程序完成这件事，可能需要一些技巧。 好在， Python 提供了一个 <code>os.walk()</code> 函数， 替你处理这个过程。<br><code>os.walk()</code> 函数被传入一个字符串值，即一个文件夹的路径。你可以在一个 for循环语句中使用 os.walk()函数，遍历目录树。</p><p><code>os.walk()</code> 在循环的每次迭代中，返回 3 个值：</p><ul><li>当前文件夹名称的字符串。</li><li>当前文件夹中子文件夹的字符串的列表。</li><li>当前文件夹中文件的字符串的列表。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">path = &apos;C:\\Users\\Ansh\\Desktop\\Source\\lua-5.3.4&apos;</span><br><span class="line"></span><br><span class="line">for folderName, subFolders, fileNames in os.walk(path):</span><br><span class="line">    print(&apos;The current folder is &apos; + folderName)</span><br><span class="line"></span><br><span class="line">    for subFolder in subFolders:</span><br><span class="line">        print(&apos;Sub folder of &apos; + folderName + &apos; : &apos; + subFolder)</span><br><span class="line"></span><br><span class="line">    for fileName in fileNames:</span><br><span class="line">        print(&apos;File inside &apos; + folderName + &quot; : &quot; + fileName)</span><br></pre></td></tr></table></figure><h2 id="使用-zipfile-模块压缩文件"><a href="#使用-zipfile-模块压缩文件" class="headerlink" title="使用 zipfile 模块压缩文件"></a>使用 zipfile 模块压缩文件</h2><p>我们经常需要对一组文件进行压缩，减少它的大小，然后在网络上进行传输。ZIP 文件（ 带有.zip 文件扩展名）， 它可以包含许多其他文件的压缩内容。<br>在 Python 程序可以利用 <code>zipfile</code> 模块中的函数创建和打开（或解压） ZIP 文件。</p><h3 id="创建和添加到-ZIP-文件"><a href="#创建和添加到-ZIP-文件" class="headerlink" title="创建和添加到 ZIP 文件"></a>创建和添加到 ZIP 文件</h3><p>要创建你自己的压缩 ZIP 文件， 必须以“写模式”打开 ZipFile 对象，即传入’w’作为第二个参数。<br>如果向 ZipFile 对象的 <code>write()</code> 方法传入一个路径， Python 就会压缩该路径所指的文件， 将它加到 ZIP 文件中。<br><code>write()</code> 方法的第一个参数是一个字符串， 代表要添加的文件名。第二个参数是“压缩类型”参数，它告诉计算机使用怎样的算法来压缩文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import zipfile</span><br><span class="line"></span><br><span class="line">newZip = zipfile.ZipFile(&apos;new.zip&apos;, &quot;w&quot;)</span><br><span class="line">newZip.write(&apos;myCats.py&apos;, compress_type=zipfile.ZIP_DEFLATED)</span><br><span class="line">newZip.close()</span><br></pre></td></tr></table></figure><h3 id="读取-ZIP-文件"><a href="#读取-ZIP-文件" class="headerlink" title="读取 ZIP 文件"></a>读取 ZIP 文件</h3><p>可以使用 <code>zipfile.ZipFile()</code> 函数读取要给 ZIP 文件， 向它传入一个字符串， 表示.zip 文件的文件名。<br>ZipFile 对象有一个 <code>namelist()</code> 方法，返回 ZIP 文件中包含的所有文件和文件夹的字符串的列表。<br>可以把文件或文件夹名称传递给 ZipFile 对象的 <code>getinfo()</code> 方法来返回一个关于特定文件的 ZipInfo 对象。<br>通过 ZipInfo 对象可以读取到保存的归档文件的有用信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">readZip = zipfile.ZipFile(&apos;new.zip&apos;)</span><br><span class="line">print(readZip.namelist())</span><br><span class="line"></span><br><span class="line">catsFileInfo = readZip.getinfo(&apos;myCats.py&apos;)</span><br><span class="line">print(catsFileInfo.file_size)</span><br><span class="line">print(catsFileInfo.compress_size)</span><br><span class="line"></span><br><span class="line">readZip.close()</span><br></pre></td></tr></table></figure><h3 id="加压缩-ZIP-文件"><a href="#加压缩-ZIP-文件" class="headerlink" title="加压缩 ZIP 文件"></a>加压缩 ZIP 文件</h3><p>ZipFile 对象的 <code>extractall()</code> 方法从 ZIP 文件中解压缩所有文件和文件夹， 放到当前工作目录中。<br>可以使用 <code>extractall()</code> 方法从 ZIP 文件中解压缩所有文件。<br>也可以使用 <code>extract()</code> 方法从 ZIP 文件中解压缩单个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extractZip = zipfile.ZipFile(&apos;new.zip&apos;)</span><br><span class="line">extractZip.extractall()</span><br><span class="line">extractZip.extract(&apos;myCats.py&apos;, &apos;.\\temp&apos;)</span><br><span class="line">extractZip.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;os-path-模块&quot;&gt;&lt;a href=&quot;#os-path-模块&quot; class=&quot;headerlink&quot; title=&quot;os.path 模块&quot;&gt;&lt;/a&gt;os.path 模块&lt;/h2&gt;&lt;p&gt;os.path 模块包含了许多与文件名和文件路径相关的有用函数。&lt;br&gt;例如， 你已经使用了 os.path.join()来构建所有操作系统上都有效的路径。&lt;br&gt;因为 os.path 是 os 模块中的模块， 所以只要执行 import os 就可以导入它。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import os&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;文件与文件路径&quot;&gt;&lt;a href=&quot;#文件与文件路径&quot; class=&quot;headerlink&quot; title=&quot;文件与文件路径&quot;&gt;&lt;/a&gt;文件与文件路径&lt;/h2&gt;&lt;p&gt;在 Windows 上， 路径书写使用倒斜杠作为文件夹之间的分隔符。但在 OS X 和Linux 上， 使用正斜杠作为它们的路径分隔符。&lt;br&gt;如果想要程序运行在所有操作系统上，在编写 Python 脚本时， 就必须处理这两种情况。&lt;br&gt;Python 使用 &lt;code&gt;os.path.join()&lt;/code&gt; 函数来做这件事很简单。&lt;br&gt;如果将单个文件和路径上的文件夹名称的字符串传递给它， &lt;code&gt;os.path.join()&lt;/code&gt; 就会返回一个文件路径的字符串&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python 文件" scheme="https://veinin.com/tags/Python-%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Git 教程 - 分支</title>
    <link href="https://veinin.com/2018/04/01/git-tutorial-branching/"/>
    <id>https://veinin.com/2018/04/01/git-tutorial-branching/</id>
    <published>2018-04-01T06:26:00.000Z</published>
    <updated>2018-04-01T13:18:44.374Z</updated>
    
    <content type="html"><![CDATA[<p>有人把 Git 的分支模型称为它的”必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。</p><h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>前面提过，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。在进行提交操作时，Git 会保存一个提交对象（commit object）。</p><p>该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。</p><p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向<strong>最后</strong>那个提交对象的 master 分支。它会在每次的提交操作中自动向前移动。</p><p><img src="/images/git/branch-and-history.png" alt=""></p><a id="more"></a><h2 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h2><p>Git 使用命令 <code>git branch</code> 创建一个新分支，创建新分支后，会在当前所在的提交对象上创建一个新指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure><p><img src="/images/git/head-to-master.png" alt=""></p><p>如图，分支会有一个名为 HEAD 的特殊指针，用来标明当前所处的分支。</p><p>可以使用 <code>git log</code> 查看各个分支当前所指的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --decorate</span><br><span class="line">2f2ff67 (HEAD -&gt; master, origin/master, testing) modify the theme</span><br></pre></td></tr></table></figure><h2 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h2><p><code>git branch</code> 命令仅仅是创建一个新分支，并不会自动切换到新分支中去。如果要切换到一个已存在的分支，你需要使用 git checkout 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$git checkout testing</span><br><span class="line">Switched to branch &apos;testing&apos;</span><br><span class="line"></span><br><span class="line">$ git log --oneline --decorate</span><br><span class="line">2f2ff67 (HEAD -&gt; testing, origin/master, master) modify the theme</span><br></pre></td></tr></table></figure><p>通过 <code>git log</code> 再次查看后，我们可以看到 HEAD 指针已经指向了刚刚创建的新分支 <code>testing</code>。</p><p><img src="/images/git/head-to-testing.png" alt=""></p><p>如果我们在当前所处分支进行提交，那么 HEAD 分支随着提交操作自动向前移动，HEAD 仍然指向运行 git checkout 时所指的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim README.md</span><br><span class="line">$ git commit -a -m &apos;made a change&apos;</span><br></pre></td></tr></table></figure><p><img src="/images/git/advance-testing.png" alt=""></p><p>这是如果我们再切换回 master 分支，并且更改后提交，那么在 master 分支也会产生新的提交对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">$ vim README.md</span><br><span class="line">$ git commit -a -m &apos;made other changes&apos;</span><br></pre></td></tr></table></figure><p><img src="/images/git/advance-master.png" alt=""></p><p>以上各个分支切换工作，你只需要熟悉 <code>branch</code>、<code>checkout</code> 和 <code>commit</code> 命令，就可以在不同分支间来回切换和工作，并在时机成熟后合并它们。</p><p>最后，你可以通过 <code>git log</code> 来查看分叉历史，他会输出你提交的历史、各个分支指向的分支分叉情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">λ git log --oneline --decorate --graph --all</span><br><span class="line">* 92cd086 (HEAD -&gt; master) made other changes</span><br><span class="line">| * b5c6792 (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* 2f2ff67 (origin/master) modify the theme</span><br></pre></td></tr></table></figure><h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>Git 在当前所处分支中使用 <code>git merge</code> 命令来合并其他分支。</p><p>实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p><ul><li><p>开发某个网站。为实现某个新的需求，创建一个分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch &quot;iss53&quot;</span><br></pre></td></tr></table></figure></li><li><p>在这个分支上开展工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &apos;added a new footer [issue 53]&apos;</span><br></pre></td></tr></table></figure></li></ul><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p><ul><li><p>切换到你的线上分支（production branch）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure></li><li><p>为这个紧急任务新建一个分支，并在其中修复它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix</span><br><span class="line">Switched to a new branch &apos;hotfix&apos;</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &apos;fixed the broken email address&apos;</span><br></pre></td></tr></table></figure></li><li><p>在测试通过之后，切换回线上分支，然后合并这个修补分支，并将改动推送到线上分支,最后删除 <code>hotfix</code> 分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure></li><li><p>切换回你最初工作的分支上，继续工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout iss53</span><br><span class="line">Switched to branch &quot;iss53&quot;</span><br></pre></td></tr></table></figure></li></ul><p>在上面这个典型的使用 Git 分支的工作流中，我们使用了一个带有 -b 参数的 git checkout 命令来创建一个新分支，它等价于执行了<code>git branch</code> 和 <code>git checkout</code> 两个命令。</p><h2 id="分支合并冲突解决"><a href="#分支合并冲突解决" class="headerlink" title="分支合并冲突解决"></a>分支合并冲突解决</h2><p>在分支合并的适合，如果涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure></p><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br></pre></td></tr></table></figure></p><p>Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line"> please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure></p><p>冲突的地方使用<code>=======</code>来区分，你所处的 HEAD 指向的版本在这个区段的上半部分，合并过来的分支在这个区段的下半部分。</p><p>你可以修改冲突的地方，保留你认为何时的内容，并且删除冲突的其余部分，如上面例子，我们需要保留下半部分提交内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line"> please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>在所有冲突解决完成后，你可以再次输入 <code>git commit</code> 来完成这次合并提交。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表，其中 <code>master</code> 分支前的 <code>*</code> 号代表当前 HEAD 所指向的分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure></p><p>如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">* master  92cd086 made other changes</span><br><span class="line">  testing b5c6792 made a change</span><br></pre></td></tr></table></figure></p><p>使用 -merged 与 –no-merged 这两个选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支，。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --no-merged</span><br><span class="line">  testing</span><br><span class="line">$ git merge testing</span><br><span class="line">$ git branch --merged</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure></p><p>包含未合并的分支时，尝试使用 git branch -d 命令删除它时会失败，如果你确定要删除并丢弃那些工作，你可以使用 <code>-D</code> 选项强制删除。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有人把 Git 的分支模型称为它的”必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。&lt;/p&gt;
&lt;h2 id=&quot;分支简介&quot;&gt;&lt;a href=&quot;#分支简介&quot; class=&quot;headerlink&quot; title=&quot;分支简介&quot;&gt;&lt;/a&gt;分支简介&lt;/h2&gt;&lt;p&gt;前面提过，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。在进行提交操作时，Git 会保存一个提交对象（commit object）。&lt;/p&gt;
&lt;p&gt;该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。&lt;/p&gt;
&lt;p&gt;Git 的分支，其实本质上仅仅是指向提交对象的可变指针。Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向&lt;strong&gt;最后&lt;/strong&gt;那个提交对象的 master 分支。它会在每次的提交操作中自动向前移动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/git/branch-and-history.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://veinin.com/categories/Git/"/>
    
    
      <category term="Git 教程" scheme="https://veinin.com/tags/Git-%E6%95%99%E7%A8%8B/"/>
    
      <category term="Git 安装" scheme="https://veinin.com/tags/Git-%E5%AE%89%E8%A3%85/"/>
    
      <category term="Git 分支" scheme="https://veinin.com/tags/Git-%E5%88%86%E6%94%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git 教程 - 基础操作</title>
    <link href="https://veinin.com/2018/04/01/git-tutorial-basics/"/>
    <id>https://veinin.com/2018/04/01/git-tutorial-basics/</id>
    <published>2018-04-01T02:25:00.000Z</published>
    <updated>2018-04-02T16:45:24.344Z</updated>
    
    <content type="html"><![CDATA[<p>在获得 Git 后你需要学会使用 Git 完成各种<strong>工作中</strong>将要使用的各种基本命令。<br>例如配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改。<br>更进一步，你应该学会如何配置 Git 来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。</p><h2 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h2><p>取得 Git 项目仓库有两种方法。</p><ul><li>在现有项目或目录下导入所有文件到 Git 中。</li><li>从一个服务器克隆一个现有的 Git 仓库。</li></ul><h3 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h3><p>如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><a id="more"></a><p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。但你的项目里的文件还没有被跟踪。</p><p>如果你已经有一些文件需要让 Git 仓库来进行版本控制的话，你可使用 <code>git add</code> 命令来追踪指定文件，然后用 <code>git commit</code> 提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m &apos;initial project version&apos;</span><br></pre></td></tr></table></figure><p>如果你需要追踪指定某一类型的文件，<code>git add</code> 是支持通配符的，例如所有 <code>.c</code> 的文件：<code>git add *.c</code>；当然你也可以指定添加某些文件。</p><h2 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h2><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，你可以使用到 <code>git clone</code> 命令。<br>与其他 VCS 系统（如 Subversion）的 <code>checkout</code> 不同，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。<br>当 <code>git clone</code> 执行完后，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p><p>克隆仓库的命令格式是 git clone [url]，比如克隆一个 blog 项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:Veinin/blog.git</span><br></pre></td></tr></table></figure><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:Veinin/blog.git myblog</span><br></pre></td></tr></table></figure><p>克隆命令除了支持 <code>https://</code> 协议外，你还可以使用 <code>git://</code> 协议或者使用 SSH 传输协议 <code>user@host:path/to/repo.git</code></p><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>你工作目录下的每一个文件都不外乎这两种状态：</p><ul><li>已跟踪，是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。</li><li>未跟踪，已跟踪文件以外的所有其它文件都属于未跟踪文件。</li></ul><p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：</p><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>可以用 <code>git status</code> 命令来查看当前文件状态。刚克隆下来的项目，你的工作目录是相当干净的。如果你使用该命令，会得到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>此时，你的所有追踪文件都是未修改的，该明显显示了当前所在分支，分支名为 <code>master</code>。</p><p>随后，你可能想创建新文件，比如 README 文件，创建完后，如果你使用 <code>git status</code>，你讲看到一个未跟踪的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;My Project&apos; &gt; README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">    README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>上面的 <code>Untracked files</code> 为未跟踪文件列表，未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件。</p><h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure><p>然后使用 <code>git status</code> 命令，你会看到 README 文件已被追踪，且处于暂存状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure><p>只要在 <code>Changes to be committed</code> 这行下面的文件，就说明是已暂存状态。</p><h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><p>如果你修改了一个名为 CONTRIBUTING.md 的已被跟踪的文件，然后运行 git status 命令，会看到下面内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>文件 CONTRIBUTING.md 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。<br>要暂存这次更新，需要运行 <code>git add</code> 命令。这是个多功能命令：</p><ul><li>可以用它开始跟踪新文件。</li><li>把已跟踪的文件放到暂存区。</li><li>用于合并时把有冲突的文件标记为已解决状态等。</li></ul><p>我们运行 git add 将”CONTRIBUTING.md”放到暂存区，文件又会变成已暂存状态，然后再看看 git status 的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>假设此时，你想要在 CONTRIBUTING.md 里再加条注释， 重新编辑存盘后，准备好提交。 不过且慢，再运行 git status 看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ vim CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>现在 CONTRIBUTING.md 文件同时出现在暂存区和非暂存区。实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本。<br>如果你现在提交，CONTRIBUTING.md 的版本是你最后一次运行 git add 命令时的那个版本，而不是你运行 git commit 时，在工作目录中的当前版本。<br>所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p>git status 命令的输出十分详细，但其用语有些繁琐。你可以使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M README</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure><p>简介标识分为 5 种：</p><ul><li><code>M</code>，出现在右边表示该文件被修改了但是还没放入暂存区。</li><li><code>M</code>，出现在靠左边表示该文件被修改了并放入了暂存区。 </li><li><code>MM</code>，表示被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</li><li><code>??</code>，新增未追踪文件。</li><li><code>A</code> ，新添加到暂存区的文件。</li></ul><h3 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h3><p><code>git status</code> 命令显示可能还过于模块，但你可以用 <code>git diff</code> 命令来查看你具体修改了什么地方。</p><p>查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 4464ea4..83bfa15 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br></pre></td></tr></table></figure><p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --cached</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git add README.md</span><br><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 4464ea4..83bfa15 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br></pre></td></tr></table></figure><p>如果对上面暂存 <code>README.md</code> 文件再编辑，运行 <code>git status</code> 会看到暂存前后的两个版本。运行 <code>git diff</code> 将看到暂存前后的变化，而用 <code>git diff --cached</code> 将查看已经暂存起来的变化。</p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。<br>可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。 </p><p>文件 .gitignore 的格式规范如下：</p><ul><li>所有空行或者以 # 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob（shell 正则表达式） 模式匹配。例如星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符等等。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.a</span><br><span class="line">!lib.a</span><br><span class="line">/TODO</span><br><span class="line">build/</span><br><span class="line">doc/*.txt</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>如果暂存区域已经准备妥当可以提交了。准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><p>这种方式会启动文本编辑器以便输入本次提交的说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#new file:   README</span><br><span class="line">#modified:   CONTRIBUTING.md</span><br><span class="line">#</span><br><span class="line">~</span><br><span class="line">&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C</span><br></pre></td></tr></table></figure><p>默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。</p><p>另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;modify the README file&quot;</span><br><span class="line">[master 463dc4f] modify the README file</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后再提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ rm PROJECTS.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    PROJECTS.md</span><br></pre></td></tr></table></figure><p>然后再运行 git rm 记录此次移除文件的操作。注意，如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git rm PROJECTS.md</span><br><span class="line">rm &apos;PROJECTS.md&apos;</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    deleted:    PROJECTS.md</span><br></pre></td></tr></table></figure><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。为达到这一目的，使用 –cached 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached README</span><br></pre></td></tr></table></figure><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。 比方说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm log/\*.log</span><br></pre></td></tr></table></figure><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么。</p><p>要在 Git 中对文件改名，可以使用 <code>git mv</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git mv README.md README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure><p>它会恰如预期般正常工作。但实际上运行 <code>git mv</code> 相当于运行了以下 3 条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure><h2 id="Git-查看提交历史"><a href="#Git-查看提交历史" class="headerlink" title="Git 查看提交历史"></a>Git 查看提交历史</h2><p>你也许想回顾下提交历史，可以使用 <code>git log</code> 命令来查看。默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 2f2ff67cb4e8731dad9bb1b8ec4f0963c0368870</span><br><span class="line">Author: Veinin Guo &lt;Veinin@users.noreply.github.com&gt;</span><br><span class="line">Date:   Fri Mar 30 00:46:23 2018 +0800</span><br><span class="line"></span><br><span class="line">    modify the theme</span><br><span class="line"></span><br><span class="line">commit 633e5f7e0cbf87fba2e922956667c9cb627bd4a0</span><br><span class="line">Author: Veinin Guo &lt;Veinin@users.noreply.github.com&gt;</span><br><span class="line">Date:   Fri Mar 30 00:39:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    initialize commit</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>git log 有许多选项可以帮助你搜寻你所要找的提交：</p><ul><li>使用选项 <code>-p</code>，用来显示每次提交的内容差异。 </li><li>可以加上 <code>-2</code> 来仅显示最近两次提交。</li><li>使用 <code>--stat</code> 选项查看每次提交的简略的统计信息。</li><li>使用 <code>--pretty</code> 这个选项可以指定使用不同于默认格式的方式展示提交历史。 比如用 <code>--pretty=oneline</code> 将每个提交放在一行显示。另外还有 short，full 和 fuller 可以用</li><li>使用 <code>--pretty=format</code> 来定制要显示的记录格式，具体格式可以参考 Git 帮助文档。</li><li>按照时间作限制的选项 <code>--since</code> 和 <code>--until</code>，比如列出最近两周内的提交记录：<code>$ git log --since=2.weeks</code>；或具体到某一天：<code>git log --since=2008-03-30</code>。</li></ul><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>在任何一个阶段，你都有可能想要撤消某些操作。</p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令尝试重新提交：<br>在上次提交后马上执行了此命令，那么快照会保持不变，而你所修改的只是提交信息。例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;initial commit&apos;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如果你想取消暂存的指定文件，可以使用 <code>git reset HEAD &lt;file&gt;...</code> 来操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">$ git reset HEAD README.md</span><br></pre></td></tr></table></figure><h3 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h3><p>如果你并不想保留对某个文件的修改，可以使用 <code>git checkout -- &lt;file&gt;...</code> 将文件还原成上次提交时的样子。<strong>请注意</strong>，这个命令是非常危险，除非你确实不想修改那个文件，否则不要使用这个命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">$ git checkout -- README.md</span><br></pre></td></tr></table></figure><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。<br>管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。</p><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。<br>如果你已经克隆了自己的仓库，那么至少应该能看到 <code>origin</code> - 这是 Git 给你克隆的仓库服务器的默认名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。如果你的远程仓库不止一个，该命令会将它们全部列出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/Veinin/blog.git (fetch)</span><br><span class="line">origin  https://github.com/Veinin/blog.git (push)</span><br></pre></td></tr></table></figure></p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit</span><br><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure><p>现在你可以在命令行中使用字符串 pb 来代替整个 URL。例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>。</p><h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>从远程仓库中获得数据，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><p>如果你有一个分支设置为跟踪一个远程分支，可以使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。</p><h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push [remote-name] [branch-name]</code>。 当你想要将 master 分支推送到 origin 服务器时，那么运行这个命令就可以将你所做的备份到服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。否则，你的推送就会毫无疑问地被拒绝。</p><h3 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show [remote-name]</code> 命令。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">λ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/chenshuo/muduo.git</span><br><span class="line">  Push  URL: https://github.com/chenshuo/muduo.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    backport   new (next fetch will store in remotes/origin)</span><br><span class="line">    cpp11      new (next fetch will store in remotes/origin)</span><br><span class="line">    cpp17      tracked</span><br><span class="line">    cpp98      tracked</span><br><span class="line">    experiment stale (use &apos;git remote prune&apos; to remove)</span><br><span class="line">    gh-pages   tracked</span><br><span class="line">    mac        tracked</span><br><span class="line">    master     tracked</span><br><span class="line">  Local branch configured for &apos;git pull&apos;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &apos;git push&apos;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure><p>这条命令会列出你执行 <code>git push</code>、<code>git pull</code> 会推送到哪个分支。<br>也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 <code>git pull</code> 时哪些分支会自动合并。</p><h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>如果想要重命名引用的名字可以运行 <code>git remote rename</code> 去修改一个远程仓库的简写名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p>如果因为一些原因想要移除一个远程仓库， 可以使用 <code>git remote rm</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p><h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p>在 Git 中列出已有的标签是非常简单直观的。 只需要输入 <code>git tag</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">λ git tag   </span><br><span class="line">v0.1.0      </span><br><span class="line">v0.1.1      </span><br><span class="line">v0.1.2      </span><br><span class="line">...</span><br><span class="line">v0.9.7      </span><br><span class="line">v0.9.8      </span><br><span class="line">v1.0.0      </span><br><span class="line">v1.0.1      </span><br><span class="line">...</span><br><span class="line">v2.0.0-beta</span><br></pre></td></tr></table></figure><p>你也可以使用特定的模式查找标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">λ git tag -l v1.0.*</span><br><span class="line">v1.0.0</span><br><span class="line">v1.0.0-rc1</span><br><span class="line">v1.0.0-rc2</span><br><span class="line">v1.0.1</span><br><span class="line">v1.0.2</span><br></pre></td></tr></table></figure><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p><h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>附注标签是存储在 Git 数据库中的一个完整对象。其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。通常建议创建附注标签，这样你可以拥有以上所有信息。<br>创建附注标签，只需在在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1.0 -m &quot;new version&quot; </span><br><span class="line">$ git tag</span><br><span class="line">v0.1.0</span><br></pre></td></tr></table></figure><p>使用 <code>git show</code> 命令可以看到标签信息与对应的提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">λ git show v0.1.0</span><br><span class="line">tag v0.1.0</span><br><span class="line">Tagger: veinin &lt;veininguo@gmail.com&gt;</span><br><span class="line">Date:   Fri Mar 30 18:14:44 2018 +0800</span><br><span class="line"></span><br><span class="line">new version</span><br><span class="line"></span><br><span class="line">commit 2f2ff67cb4e8731dad9bb1b8ec4f0963c0368870</span><br><span class="line">Author: Veinin Guo &lt;Veinin@users.noreply.github.com&gt;</span><br><span class="line">Date:   Fri Mar 30 00:46:23 2018 +0800</span><br><span class="line"></span><br><span class="line">    modify the theme</span><br></pre></td></tr></table></figure><h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。 创建轻量标签，不需要使用任何选项，只需要提供标签名字：<br>如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，可以使用轻量标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.0.1</span><br><span class="line">$ git tag</span><br><span class="line">v0.0.1</span><br><span class="line">v0.1.0</span><br></pre></td></tr></table></figure><p>如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.0.1</span><br><span class="line">commit 2f2ff67cb4e8731dad9bb1b8ec4f0963c0368870</span><br><span class="line">Author: Veinin Guo &lt;Veinin@users.noreply.github.com&gt;</span><br><span class="line">Date:   Fri Mar 30 00:46:23 2018 +0800</span><br><span class="line"></span><br><span class="line">    modify the theme</span><br></pre></td></tr></table></figure><h3 id="后期标签"><a href="#后期标签" class="headerlink" title="后期标签"></a>后期标签</h3><p>可以对过去的某个提交记录打标签，当你忘记给某个时间点的提交打标签时，你可以使用提交记录的校验和（或部分）来重新打上标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">2f2ff67cb4e8731dad9bb1b8ec4f0963c0368870 modify the theme</span><br><span class="line">6d434e8c571342290ffa15d8852a9487db63b7e1 modify the theme</span><br><span class="line">633e5f7e0cbf87fba2e922956667c9cb627bd4a0 initialize commit</span><br><span class="line">ba67864882e13b588bb5061f334d8a23b7dc29b3 initialize commit</span><br><span class="line">d5a38f1858b5af96f3338060b8f13071a878b17b first commit</span><br><span class="line"></span><br><span class="line">$ git tag -a v0.0.2 633e5f7 -m &quot;initial version&quot;</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line">v0.0.1</span><br><span class="line">v0.0.2</span><br><span class="line">v0.1.0</span><br></pre></td></tr></table></figure><h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样，你可以运行 <code>git push origin [tagname]</code> 命令推送一个标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v0.1.0</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 166 bytes | 0 bytes/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/Veinin/blog.git</span><br><span class="line"> * [new tag]         v0.1.0 -&gt; v0.1.0</span><br></pre></td></tr></table></figure><p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项，这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">λ git push origin --tags</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 161 bytes | 0 bytes/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/Veinin/blog.git</span><br><span class="line"> * [new tag]         v0.0.1 -&gt; v0.0.1</span><br><span class="line"> * [new tag]         v0.0.2 -&gt; v0.0.2</span><br></pre></td></tr></table></figure><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>在 Git 中你并不能真的检出一个标签，但你可以指定某个新标签来创建新的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b version2 v0.0.2</span><br><span class="line">Switched to a new branch &apos;version2&apos;</span><br></pre></td></tr></table></figure><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>删除一个标签分两种：</p><ul><li>删除本地标签：<code>git tag -d 标签名</code></li><li>删除远程仓库标签：<code>git push origin :ref/tag/标签名</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1.0</span><br><span class="line">Deleted tag &apos;v0.1.0&apos; (was 729a196)</span><br><span class="line"></span><br><span class="line">$ git push origin :refs/tags/v0.0.1</span><br><span class="line">To https://github.com/Veinin/blog.git</span><br><span class="line"> - [deleted]         v0.0.1</span><br></pre></td></tr></table></figure><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>使用别名小技巧可以使你的 Git 体验更简单、容易、熟悉。<br>如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br><span class="line">$ git config --global alias.unstage &apos;reset HEAD --&apos;</span><br><span class="line">$ git config --global alias.last &apos;log -1 HEAD&apos;</span><br></pre></td></tr></table></figure><p>有了这些别名后，当你输入 <code>git co</code> 时，它就对应了 <code>git checkout</code> 命令，所以，如果你把你常用的一些命令设置为别名，那将对你很有帮助。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，你可以完成所有基本的 Git 本地操作：创建或者克隆一个仓库、做更改、暂存并提交这些更改、浏览你的仓库从创建到现在的所有更改的历史。<br>下一步，本书将介绍 Git 的杀手级特性：分支模型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在获得 Git 后你需要学会使用 Git 完成各种&lt;strong&gt;工作中&lt;/strong&gt;将要使用的各种基本命令。&lt;br&gt;例如配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改。&lt;br&gt;更进一步，你应该学会如何配置 Git 来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。&lt;/p&gt;
&lt;h2 id=&quot;获取-Git-仓库&quot;&gt;&lt;a href=&quot;#获取-Git-仓库&quot; class=&quot;headerlink&quot; title=&quot;获取 Git 仓库&quot;&gt;&lt;/a&gt;获取 Git 仓库&lt;/h2&gt;&lt;p&gt;取得 Git 项目仓库有两种方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在现有项目或目录下导入所有文件到 Git 中。&lt;/li&gt;
&lt;li&gt;从一个服务器克隆一个现有的 Git 仓库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;在现有目录中初始化仓库&quot;&gt;&lt;a href=&quot;#在现有目录中初始化仓库&quot; class=&quot;headerlink&quot; title=&quot;在现有目录中初始化仓库&quot;&gt;&lt;/a&gt;在现有目录中初始化仓库&lt;/h3&gt;&lt;p&gt;如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Git" scheme="https://veinin.com/categories/Git/"/>
    
    
      <category term="Git 教程" scheme="https://veinin.com/tags/Git-%E6%95%99%E7%A8%8B/"/>
    
      <category term="Git 安装" scheme="https://veinin.com/tags/Git-%E5%AE%89%E8%A3%85/"/>
    
      <category term="Git 基础" scheme="https://veinin.com/tags/Git-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Git 教程 - 起步</title>
    <link href="https://veinin.com/2018/04/01/git-tutorial-started/"/>
    <id>https://veinin.com/2018/04/01/git-tutorial-started/</id>
    <published>2018-04-01T02:10:00.000Z</published>
    <updated>2018-04-01T03:01:23.352Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 内核开源项目有着为数众广的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</p><ul><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li></ul><p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在你开始使用 Git 前，需要将它安装在你的计算机上。 即便已经安装，最好将它升级到最新的版本。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>使用 yum：<code>sudo yum install git</code><br>使用 apt-get：<code>sudo apt-get install git</code></p><h3 id="Mac-上安装"><a href="#Mac-上安装" class="headerlink" title="Mac 上安装"></a>Mac 上安装</h3><p>可以使用二进制安装程序。 官方维护的 OSX Git 安装程序可以在 Git 官方网站下载，网址为 <a href="http://git-scm.com/download/mac。" target="_blank" rel="noopener">http://git-scm.com/download/mac。</a></p><h3 id="Windows-上安装"><a href="#Windows-上安装" class="headerlink" title="Windows 上安装"></a>Windows 上安装</h3><p>官方版本可以在 Git 官方网站下载。 地址为 <a href="http://git-scm.com/download/win" target="_blank" rel="noopener">http://git-scm.com/download/win</a><br>简单的方法是安装 GitHub for Windows。 地址为 <a href="https://desktop.github.com/" target="_blank" rel="noopener">https://desktop.github.com/</a></p><h2 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h2><p>在开始学习 Git 的时候，请努力分清你对其它版本管理系统的已有认识，如 Subversion 和 Perforce 等；这么做能帮助你使用工具时避免发生混淆。 Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。</p><h3 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h3><p>相比传统的版本管理系统（CVS、Subversion、Perforce、Bazaar 等等），它们将保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。<br>反之，Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个快照流。</p><h3 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h3><p>因为你在本地磁盘上就有项目的完整历史，所以在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。<br>例如：</p><ul><li>你可以不需外连到服务器去获取历史，浏览项目的历史。</li><li>离线或者没有 VPN 时，几乎可以进行任何操作。</li></ul><h3 id="Git-保证完整性"><a href="#Git-保证完整性" class="headerlink" title="Git 保证完整性"></a>Git 保证完整性</h3><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p><h3 id="Git-一般只添加数据"><a href="#Git-一般只添加数据" class="headerlink" title="Git 一般只添加数据"></a>Git 一般只添加数据</h3><p>你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。一旦你提交快照到 Git 中，就难以再丢失数据。</p><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：</p><ul><li>已提交（committed），表示数据已经安全的保存在本地数据库中。</li><li>已修改（modified），表示修改了文件，但还没保存到数据库中。</li><li>已暂存（staged），表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li></ul><p>Git 项目的三个工作区域的概念：</p><ul><li>Git 仓库，是 Git 用来保存项目的元数据和对象数据库的地方。</li><li>工作目录，工作目录是对项目的某个版本独立提取出来的内容。</li><li>暂存区域，是一个文件，保存了下次将提交的文件列表信息。</li></ul><p>工作目录中保存着的特定版本文件，就属于已提交状态。<br>如果作了修改并颐和园已放入暂存区域，就属于已暂存状态。<br>如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。</p><h2 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h2><p>Git 有多种使用方式。 你可以使用原生的命令行模式，也可以使用 GUI 模式。 但只有在命令行模式下你才能执行 Git 的 所有 命令。</p><h3 id="获得帮助"><a href="#获得帮助" class="headerlink" title="获得帮助"></a>获得帮助</h3><p>使用 Git 命令行时有三种方法可以找到 Git 命令的使用手册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure><p>例如，如果想要获得 config 命令的手册，可以: <code>$ git help config</code></p><h3 id="初次运行配置"><a href="#初次运行配置" class="headerlink" title="初次运行配置"></a>初次运行配置</h3><p>初次安装 Git 的系统上，首先需要做几件事来定制你的 Git 环境。 每台计算机上只需要配置一次。</p><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ul><li>/etc/gitconfig 文件，包含系统上每一个用户及他们仓库的通用配置。</li><li>~/.gitconfig 或 ~/.config/git/config 文件，只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。</li><li>当前使用仓库的 Git 目录中的 config 文件（就是 .git/config），针对该仓库的配置。</li></ul><p>每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Veinin Guo&quot;</span><br><span class="line">$ git config --global user.email veininguo@gmail.com</span><br></pre></td></tr></table></figure><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">rebase.autosquash=true</span><br><span class="line">credential.helper=manager</span><br><span class="line">user.name=veinin</span><br><span class="line">user.email=veininguo@gmail.com</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你也可以通过输入 <code>git config &lt;key&gt;</code> 来检查 Git 的某一项配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">veinin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 内核开源项目有着为数众广的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。&lt;/p&gt;
&lt;p&gt;到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;速度&lt;/li&gt;
&lt;li&gt;简单的设计&lt;/li&gt;
&lt;li&gt;对非线性开发模式的强力支持（允许成千上万个并行开发的分支）&lt;/li&gt;
&lt;li&gt;完全分布式&lt;/li&gt;
&lt;li&gt;有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://veinin.com/categories/Git/"/>
    
    
      <category term="Git 教程" scheme="https://veinin.com/tags/Git-%E6%95%99%E7%A8%8B/"/>
    
      <category term="Git 安装" scheme="https://veinin.com/tags/Git-%E5%AE%89%E8%A3%85/"/>
    
      <category term="Git 基础" scheme="https://veinin.com/tags/Git-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记：游戏中属性定义、策划公式处理方案</title>
    <link href="https://veinin.com/2018/03/24/dev-notes-designer-formula-processing-solution-in-game/"/>
    <id>https://veinin.com/2018/03/24/dev-notes-designer-formula-processing-solution-in-game/</id>
    <published>2018-03-24T13:28:00.000Z</published>
    <updated>2018-03-24T13:50:02.180Z</updated>
    
    <content type="html"><![CDATA[<p>在游戏设计中，策划喜欢通过表格来制定自己的数值方案，通常一个游戏制作会有几十上百张不同功能的表格，这些表格通常采用Excel制定。大部分时候，策划更想要的是自己来操作所有数值，而不需要程序为其各种需求去正对性的通过代码来实现。</p><p>这样做有几个好处：</p><ul><li>1.策划可以独立拓展自己的业务，而不依赖于程序。</li><li>2.程序可以更加专心于自己的逻辑功能，而不用去特意维护策划的数值变动需求。</li><li>3.工作内容分离，减少沟通成本，更加提升工作效率，让各部门更加专注于自己所处的领域。</li></ul><p>在游戏日常开发中，有两个典型的应用场景，一个是角色的属性，一个是计算这些属性的公式，最后还需要通过这些属性在战斗中通过公式生成伤害数值。如果涉及复杂的战斗系统，通常一个角色的战斗属性可能会有上百种，而计算这些属性的公式，也可能成百上千。这里就会产生几个问题：属性、公式由程序去定义，还是策划自己去主导？属性、公式通过某种方式定义出来了，程序如何去使用？</p><a id="more"></a><p>最近和策划一起讨论了下，最终给出了解决方案，属性、公式都有策划去配置，但公式需要简化，于是我们先给出了两张表格。</p><h3 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h3><p>一个属性字典，对于程序来说，特别设计属性服务器、客户端传输的过程，我们可以通过一个唯一ID、类型进行，只要客户端、服务器都拥有这么一张属性字典，那么将很容易对属性进行传输：</p><table><thead><tr><th style="text-align:center">属性ID</th><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">初值</th><th style="text-align:center">描述</th><th style="text-align:center">成长公式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">strength</td><td style="text-align:center">int</td><td style="text-align:center">5</td><td style="text-align:center">力量</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">pdCorrect</td><td style="text-align:center">float</td><td style="text-align:center">1.2</td><td style="text-align:center">物理伤害修正系数</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">physicalDamage</td><td style="text-align:center">int</td><td style="text-align:center">20</td><td style="text-align:center">物理基础伤害</td><td style="text-align:center">公式1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">physicalCritical</td><td style="text-align:center">int</td><td style="text-align:center">15</td><td style="text-align:center">物理暴击率</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">physicalCriticalDec</td><td style="text-align:center">int</td><td style="text-align:center">10</td><td style="text-align:center">物理暴击抵抗率</td><td style="text-align:center"></td></tr></tbody></table><h3 id="公式表"><a href="#公式表" class="headerlink" title="公式表"></a>公式表</h3><p>一张公式表，由策划去配置，但程序得把策划的公式翻译成程序能读懂的代码。</p><table><thead><tr><th style="text-align:center">公式ID</th><th style="text-align:center">公式名称</th><th style="text-align:center">公式内容</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">physicalDamage</td><td style="text-align:center">40 <em> (level </em> pdCorrect + 1) * rand(1, 1.5)</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">physicalCriticalRate</td><td style="text-align:center">max(min(a.physicalCritical / 10 - t.physicalCriticalDec), 20), 0)</td></tr></tbody></table><h3 id="函数支持"><a href="#函数支持" class="headerlink" title="函数支持"></a>函数支持</h3><p>另外，对于策划来说，要通过公式来操作属性数据，特别是战斗中产生的伤害数据，就要求我们有一些简单函数支持，比如在Lua中，一些数学公式：<code>math.min</code>、<code>math.ceil</code>、<code>math.random</code> 等等。而对策划来说，大部分其实是不懂编程的，因此我们需要更加简化函数名称的设计。最终，我们得出需要以下函数的支持：</p><ul><li>min(…) ，返回参数中的最小值，如 min(1, 5, 2) ，会得到数值 1</li><li>max(…)，返回参数中的最大值，如 max(4, 10, 3)，会得到数值 10</li><li>rand(m, n)，当不带参数时，返回 [0,1] 区间内的浮点伪随机数，当以两个整数 m 与 n 调用时，返回一个 [m, n] 区间内的一致分布的伪随机数。如 rand(1, 10)，产生1-10区间内的一个随机数。</li><li>ceil(x)，返回不等于 x 的最小整数。如 ceil(1.55)，会得到数值 2</li><li>float(x)，返回不大于 x 的最大整数值，如 flooat(1.55)，会得到数值 1</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>有了上面这些，程序就可以编写工具，把策划配置的公式，导出成程序能够识别的公式函数了，比如：<br>怪物的随等级增长物理伤害公式：40 <em> (等级 </em> 物理伤害修正系数 + 1) * rand(1, 1.5)<br>怪物的物理暴击计算：max(min(怪物暴击率 / 10 - 目标暴击抵抗率 / 10, 25), 0)</p><p>那么其最终需要转换成代码公式函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> formula = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 怪物物理伤害公式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formula.physicalDamage</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">40</span> * (a.level * a.pdCorrect + <span class="number">1</span>) * <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, <span class="number">1.5</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 怪物暴击几率公式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formula.physicalCriticalRate</span><span class="params">(a, t)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">math</span>.<span class="built_in">max</span>(<span class="built_in">math</span>.<span class="built_in">min</span>(a.physicalCritical / <span class="number">10</span> - t.physicalCriticalDec), <span class="number">20</span>), <span class="number">0</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> formulas = &#123;</span><br><span class="line">    [<span class="number">1</span>] = formula.physicalDamage,</span><br><span class="line">    [<span class="number">2</span>] = formula.physicalCriticalRate,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formula.exec</span><span class="params">(id, ...)</span></span></span><br><span class="line">    <span class="keyword">return</span> formula[id](...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> formula</span><br></pre></td></tr></table></figure><p>有了上面的表格，外加生成的公式，我们很容易计算出一个怪物的基础属性或战斗中产生的伤害数值：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> formula = <span class="built_in">require</span> <span class="string">"formula"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> monster = &#123;</span><br><span class="line">     level = <span class="number">3</span>,</span><br><span class="line">     strength = <span class="number">5</span>,</span><br><span class="line">     pdCorrect = <span class="number">1.3</span>,</span><br><span class="line">     physicalDamage = <span class="number">15</span>,</span><br><span class="line">     physicalCritical = <span class="number">35</span>,</span><br><span class="line">     physicalCriticalDec = <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> target = &#123;</span><br><span class="line">     level = <span class="number">2</span>,</span><br><span class="line">     strength = <span class="number">5</span>,</span><br><span class="line">     pdCorrect = <span class="number">1.3</span>,</span><br><span class="line">     physicalDamage = <span class="number">20</span>,</span><br><span class="line">     physicalCritical = <span class="number">35</span>,</span><br><span class="line">     physicalCriticalDec = <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 得出怪物物理伤害</span></span><br><span class="line"><span class="keyword">local</span> damage = formula.exec(<span class="number">1</span>, monster)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 得出怪物物理暴击率</span></span><br><span class="line"><span class="keyword">local</span> criticalRate = formula.exec(<span class="number">2</span>, monster, target)</span><br></pre></td></tr></table></figure></p><p>最终，通过这套方案的实现，程序不用再去代码里维护各种各样的公式，策划也不在需要程序来帮忙维护公式，如果需求变动，只需要更改下表格，然后重新生成一份新公式就行；如果有新属性增加，只需要在表格中创建以个新的属性值，然后不管是角色，还是战斗中都能应用到新增加的变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在游戏设计中，策划喜欢通过表格来制定自己的数值方案，通常一个游戏制作会有几十上百张不同功能的表格，这些表格通常采用Excel制定。大部分时候，策划更想要的是自己来操作所有数值，而不需要程序为其各种需求去正对性的通过代码来实现。&lt;/p&gt;
&lt;p&gt;这样做有几个好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.策划可以独立拓展自己的业务，而不依赖于程序。&lt;/li&gt;
&lt;li&gt;2.程序可以更加专心于自己的逻辑功能，而不用去特意维护策划的数值变动需求。&lt;/li&gt;
&lt;li&gt;3.工作内容分离，减少沟通成本，更加提升工作效率，让各部门更加专注于自己所处的领域。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在游戏日常开发中，有两个典型的应用场景，一个是角色的属性，一个是计算这些属性的公式，最后还需要通过这些属性在战斗中通过公式生成伤害数值。如果涉及复杂的战斗系统，通常一个角色的战斗属性可能会有上百种，而计算这些属性的公式，也可能成百上千。这里就会产生几个问题：属性、公式由程序去定义，还是策划自己去主导？属性、公式通过某种方式定义出来了，程序如何去使用？&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://veinin.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="游戏角色属性设计" scheme="https://veinin.com/tags/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E5%B1%9E%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="游戏策划公式设计" scheme="https://veinin.com/tags/%E6%B8%B8%E6%88%8F%E7%AD%96%E5%88%92%E5%85%AC%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记：MMORPG场景同步AOI解决方案</title>
    <link href="https://veinin.com/2018/03/23/dev-notes-mmorpg-aoi-algorithm/"/>
    <id>https://veinin.com/2018/03/23/dev-notes-mmorpg-aoi-algorithm/</id>
    <published>2018-03-23T11:20:00.000Z</published>
    <updated>2018-04-01T07:47:18.876Z</updated>
    
    <content type="html"><![CDATA[<p>MMO 游戏，需要解决的最重要的问题之一，就是如何把游戏世界中各种状态的改变通知给需要知道这条信息的玩家。<br>为此，需要为每个玩家设定一个AOI（Area Of Interest），当一个对象状态发生改变时，需要将信息广播出去，那些AOI覆盖到这条消息的玩家都会收到这条广播消息。</p><p>AOI 主要作用有两：<br>第一，服务器上的玩家或 NPC 状态发生改变时，将消息广播到附近的玩家。<br>第二，当玩家接近NPC时，进入NPC警戒区域，AOI 模块将消息发送给NPC，NPC再做出相应的AI反应。</p><p>目前游戏中 AOI 实现主要有3种：<br>第一种，最容易也是最笨的一种，玩家定期同步自己状态给服务器，服务器定期比较所有对象间的关系，发现可以触发 AOI 事件就发送消息。写法简单，不容易出错，但如果处理不好，效率往往是最低的。</p><a id="more"></a><h2 id="空间切割网格算法"><a href="#空间切割网格算法" class="headerlink" title="空间切割网格算法"></a>空间切割网格算法</h2><p>把整个场景用等分大的格子划分成一个个小区域，对象进入、退出、移动时都需要更新相应的格子对象列表。这种算法插入、删除对象都非常快，时间复杂度为O（1）。缺点是当对象在格子直接移动时，需要消耗大量计算时间。目前《幻想西游》采用的是这种算法。</p><h3 id="场景划分"><a href="#场景划分" class="headerlink" title="场景划分"></a>场景划分</h3><p>场景大小：200 <em> 200<br>格子大小：50 </em> 50<br>场景中需要划分等分大小的格子数： 200 / 50 <em> 200 </em> 50 = 16 个</p><p>效果如下图所示：<br><img src="/images/aoi/01.png" alt=""></p><h3 id="世界坐标与格子坐标"><a href="#世界坐标与格子坐标" class="headerlink" title="世界坐标与格子坐标"></a>世界坐标与格子坐标</h3><p>每个格子有对于的格子坐标，每个世界坐标可以轻易的转换成格子坐标。<br>世界坐标 (x, y) 转换成格子坐标公式为：(math.floor(x/gridWeidth), math.floor(y/gridHeight))<br>如世界坐标为 (80, 50)，转换后对应格子坐标为 (2, 1)。</p><h3 id="划分九宫格"><a href="#划分九宫格" class="headerlink" title="划分九宫格"></a>划分九宫格</h3><p>每个格子都需要维护该格子内的对象信息，同时也需要维护关心该格子的观察者信息。<br>当对象处于场景某个格子时，该对象会有 9 个自己所关心的格子，对象可以观察并收到自己关心区域的 AOI 事件。<br>当然，对象所处的格子也会被其他格子的对象所关心。也就是说一个格子里面的对象可以作为观察者，观察周围格子内对象；同时也是被观察者，被其他格子内的对象所观察。<br><img src="/images/aoi/02.png" alt=""><br>如图所示，当对象所进入格子 (2, 2) 时（红色区域），那么其关心的周围 9 个格子（浅蓝色区域）中任何一个发生 AOI 事件时，它都会收到相应的 AOI 事件消息。</p><h3 id="对象进入场景"><a href="#对象进入场景" class="headerlink" title="对象进入场景"></a>对象进入场景</h3><p>通知对象所处周围9个格子的其他对象 进入 AOI 事件。</p><h3 id="对象离开场景"><a href="#对象离开场景" class="headerlink" title="对象离开场景"></a>对象离开场景</h3><p>与进入相反，通知对象所处九宫格的其他对象 离开 AOI 事件。</p><h3 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h3><p>如果对象格子变更时，如图所示，对象纵向移动由(2, 2) 移动到 (3, 2)，45度角移动由 (2, 2) 移动到 (3, 3）：<br><img src="/images/aoi/03.png" alt=""><br>会产生3种格子：</p><ul><li>对象离开视野的格子（灰色格子），通知对象离开 AOI 事件。</li><li>对象进入视野的格子（橙色格子），通知对象进入 AOI 事件。</li><li>取所有需要操作的格子的交集（浅蓝色格子），通知对象移动 AOI 事件。</li></ul><h2 id="十字链表算法"><a href="#十字链表算法" class="headerlink" title="十字链表算法"></a>十字链表算法</h2><p>场景维护着两个双向链表（如果3D空间，则增加第3条），分别对应着 X 轴 和 Y 轴。<br>每个链表对象的坐标按从小到大排列，也就是 X 坐标值越小，排在越前面，Y轴同理。<br>此算法对象短距离移动时，很节省计算量，但涉及长距离移动时，计算量会非常大。</p><h3 id="对象进入场景-1"><a href="#对象进入场景-1" class="headerlink" title="对象进入场景"></a>对象进入场景</h3><p>遍历 X 轴 和 Y 轴两个链表，找出新增对象在两个轴中所处的位置，将新对象加入到指定位置，并根据新对象的通知范围（可动态设定）获得需要通知对象集合，发送 进入 AOI 事件。</p><h3 id="对象离开场景-1"><a href="#对象离开场景-1" class="headerlink" title="对象离开场景"></a>对象离开场景</h3><p>对象进入场景后，在 X 轴 和 Y 轴各保存了两个节点位置，可以通过这个位置，获取指定范围的的对象集合，发送 离开 AOI 事件。</p><p>###对象移动<br>与格字算法类似，对象移动后也会会产生3种对象集合：</p><ul><li>更新位置前的集合，通知 离开 AOI 事件。</li><li>更新位置后的集合，通知 进入 AOI 事件。</li><li>取上面两个集合的交集，通知对象 移动 AOI 事件。</li></ul><p>处理上面产生事件顺序与格字算法相同。</p><h2 id="分层-AOI"><a href="#分层-AOI" class="headerlink" title="分层 AOI"></a>分层 AOI</h2><p>有了AOI算法，并不意味着能有满意的效果，假设场景里面放入10000人，那么按分布情况来说，即使有AOI算法，也会很糟糕，你会看到满屏幕的人，密密麻麻，卡的要死。这种情况下，玩家体验会很糟糕，所以可能需要进一步优化。<br>目前市面上见得比较多的解决方案有几种，一种是对单个场景分线，复制多个相同的场景副本，玩家随机进入某个场景的副本，以此来达到分流的目的。<br>另外一种方案，是从梦幻西游手游服务器AOI设计方案中看到的，设计一个分层AOI概念，也就是单个场景创建多个AOI对象。把玩家分通过某个规则，分在不同的层次。当人数增多时，可以动态进行分层，人数少的时候可以把层数合并回来，然后就是让玩家在人少的时候也能看到几个人，人多的时候还是看到几个人。这种优化放过来后，这是同一台服务器，效果大概是这样的，你在同一层里看到的都是你关心的人。这个感受就很好了。<br><img src="/images/aoi/04.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MMO 游戏，需要解决的最重要的问题之一，就是如何把游戏世界中各种状态的改变通知给需要知道这条信息的玩家。&lt;br&gt;为此，需要为每个玩家设定一个AOI（Area Of Interest），当一个对象状态发生改变时，需要将信息广播出去，那些AOI覆盖到这条消息的玩家都会收到这条广播消息。&lt;/p&gt;
&lt;p&gt;AOI 主要作用有两：&lt;br&gt;第一，服务器上的玩家或 NPC 状态发生改变时，将消息广播到附近的玩家。&lt;br&gt;第二，当玩家接近NPC时，进入NPC警戒区域，AOI 模块将消息发送给NPC，NPC再做出相应的AI反应。&lt;/p&gt;
&lt;p&gt;目前游戏中 AOI 实现主要有3种：&lt;br&gt;第一种，最容易也是最笨的一种，玩家定期同步自己状态给服务器，服务器定期比较所有对象间的关系，发现可以触发 AOI 事件就发送消息。写法简单，不容易出错，但如果处理不好，效率往往是最低的。&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://veinin.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MMORPG" scheme="https://veinin.com/tags/MMORPG/"/>
    
      <category term="AOI" scheme="https://veinin.com/tags/AOI/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 字符串</title>
    <link href="https://veinin.com/2018/03/18/python-practice-strings/"/>
    <id>https://veinin.com/2018/03/18/python-practice-strings/</id>
    <published>2018-03-18T08:46:00.000Z</published>
    <updated>2018-03-24T15:00:56.181Z</updated>
    
    <content type="html"><![CDATA[<p>文本是程序需要处理的最常见的数据形式。涉及字符串的操作不仅仅是使用+操作符连接两个字符串，你还可以从字符串中提取部分字符串， 添加或删除空白字符， 将字母转换成小写或大写， 检查字符串的格式是否正确。你甚至可以编写 Python 代码访问剪贴板， 复制或粘贴文本。</p><h2 id="处理字符串"><a href="#处理字符串" class="headerlink" title="处理字符串"></a>处理字符串</h2><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><p>在Python中构建一个字符串相当简单：以单引号开始和结束。<br>如果字符串里面也使用单引号的话，则需要使用双引号开始和结束来表示一个字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"I found hi's very selfish."</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>“转义字符” 让你输入一些字符，它们用其他方式是不可能放在字符串里的。转义字符包含一个倒斜杠（\）， 紧跟着是想要添加到字符串中的字符。<br>常用的转移字符包括:\’(单引号)、 \”(双引号)、 \t(制表符)、 \(倒斜杠)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'I found hi\'s very selfish.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">"I found hi's very selfish."</span></span><br></pre></td></tr></table></figure><h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><p>在字符串开始的引号之前加上 r， 那么它就成为了一个原始字符串。“原始字符串” 会完全忽略所有的转义字符， 打印出字符串中所有的倒斜杠。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">r'That is Carol\'s cat.'</span>)</span><br></pre></td></tr></table></figure><h3 id="用三重引号的多行字符串"><a href="#用三重引号的多行字符串" class="headerlink" title="用三重引号的多行字符串"></a>用三重引号的多行字符串</h3><p>虽然可以用\n转义字符将换行放入一个字符串，但使用多行字符串通常更容易。<br>在 Python 中，多行字符串的起止是 3 个单引号或 3 个双引号。“三重引号” 之间的所有引号、 制表符或换行， 都被认为是字符串的一部分。 Python 的代码块缩进规则不适用于多行字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'''Dear Alice,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Eve's cat has been arrested for catnapping.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Sincerely,</span></span><br><span class="line"><span class="string">Bob'''</span>)</span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>虽然井号字符（#） 表示这一行是注释， 但多行字符串常常用作多行注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""This is a test Python program.</span></span><br><span class="line"><span class="string">Written by Al Sweigart al@inventwithpython.com</span></span><br><span class="line"><span class="string">This program was designed for Python 3, not Python 2.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""This is a multiline comment to help</span></span><br><span class="line"><span class="string">    explain what the spam() function does."""</span></span><br><span class="line">    print(<span class="string">'Hello!'</span>)</span><br></pre></td></tr></table></figure><h3 id="字符串下标和切片"><a href="#字符串下标和切片" class="headerlink" title="字符串下标和切片"></a>字符串下标和切片</h3><p>字符串像列表一样，可以使用下标和切片。<br>字符串切片并不能修改原来的字符串。但可以从一个变量中获取切片，记录在另一个变量中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'Hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[<span class="number">1</span>]</span><br><span class="line"><span class="string">'e'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[<span class="number">-2</span>]</span><br><span class="line"><span class="string">'d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="string">'Hell'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[:<span class="number">5</span>]</span><br><span class="line"><span class="string">'Hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text[<span class="number">4</span>:]</span><br><span class="line"><span class="string">'o world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text2 = text[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="string">'Hello'</span></span><br></pre></td></tr></table></figure><h3 id="字符串使用-in-和-not-in-操作符"><a href="#字符串使用-in-和-not-in-操作符" class="headerlink" title="字符串使用 in 和 not in 操作符"></a>字符串使用 in 和 not in 操作符</h3><p>像列表一样， in 和 not in 操作符也可以用于字符串。用 in 或 not in 连接两个字符串得到的表达式， 将求值为布尔值 True 或 False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span> <span class="keyword">in</span> <span class="string">'Veinin Guo'</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'Veinin Guo'</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span> <span class="keyword">in</span> <span class="string">'Veinin Guo'</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h2><p>某些字符串需要转换、分析然后产生新的字符串，字符串内置了一些常用的方法。<br><strong>注意</strong>：Python 中所有字符串操作方法并不会改变字符串本身的属性，而是返回一个操作后的新字符串。</p><h3 id="upper-、-lower-、-isupper-和-islower"><a href="#upper-、-lower-、-isupper-和-islower" class="headerlink" title="upper()、 lower()、 isupper()和 islower()"></a>upper()、 lower()、 isupper()和 islower()</h3><p>upper()和 lower() 方法会返回一个新字符串，所有字母都被相应地转换为大写或小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; text = &apos;Hello World!&apos;</span><br><span class="line">&gt;&gt;&gt; print(text.upper())</span><br><span class="line">HELLO WORLD!</span><br><span class="line">&gt;&gt;&gt; print(text.lower())</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>isupper()和islower()方法用来判断字符串是否至少有要给字母，并且所有字母都是大写或小写，相应地如果成立就会返回布尔值 True，否则返回 False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello world'</span>.isupper()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'HELLO WORLD'</span>.isupper()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello'</span>.islower()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'hello'</span>.islower()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="isX-方法"><a href="#isX-方法" class="headerlink" title="isX 方法"></a>isX 方法</h3><p>为了能判断字符串的特点，提供了一些常用的以 <code>is</code> 开头的方法。</p><ul><li>isalpha() 如果字符串非空，且只包含字母，则返回 True</li><li>isalnum() 如果字符串非空，且只包含字母和数字，则返回 True</li><li>isdecimal() 如果字符串非空，且只包含数字，则返回 True</li><li>isspace() 如果字符串非空，且只包含空格、换行和制表符，则返回 True</li><li>istitle() 如果字符串包含以大写字母开头且后面字母都是小写字母的单词，则返回 True</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc'</span>.isalpha()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc123'</span>.isalpha()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc123'</span>.isalnum()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc123'</span>.isdecimal()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'10088'</span>.isdecimal()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'  '</span>.isspace()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'I Am From China'</span>.istitle()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'I am from China'</span>.istitle()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="startswith-和-endswith"><a href="#startswith-和-endswith" class="headerlink" title="startswith() 和 endswith()"></a>startswith() 和 endswith()</h3><p>startswith() 和 endswith() 用来判断某个字符串以某个字符串开始或结束，成立则返回 True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello World'</span>.startswith(<span class="string">'Hello'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello World'</span>.startswith(<span class="string">'nihao'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello World'</span>.endswith(<span class="string">'World'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="join-和-split"><a href="#join-和-split" class="headerlink" title="join() 和 split()"></a>join() 和 split()</h3><p>join() 方法用来将一个字符串列表中的每个字符串连接成一个新的字符串。<br>而 split() 方法与 join() 方法刚好相反，它会将一个字符串按制定分隔符进行分割，返回一个分割后的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">', '</span>.join([<span class="string">'java'</span>, <span class="string">'python'</span>, <span class="string">'golang'</span>])</span><br><span class="line"><span class="string">'java, python, golang'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'I am from China'</span>.split()</span><br><span class="line">[<span class="string">'I'</span>, <span class="string">'am'</span>, <span class="string">'from'</span>, <span class="string">'China'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABCDEFGEFGEFG'</span>.split(<span class="string">'E'</span>)</span><br><span class="line">[<span class="string">'ABCD'</span>, <span class="string">'FG'</span>, <span class="string">'FG'</span>, <span class="string">'FG'</span>]</span><br></pre></td></tr></table></figure><h3 id="使用-rjust-、-ljust-和-center-方法对齐文本"><a href="#使用-rjust-、-ljust-和-center-方法对齐文本" class="headerlink" title="使用 rjust()、 ljust() 和 center() 方法对齐文本"></a>使用 rjust()、 ljust() 和 center() 方法对齐文本</h3><p>rjust() 和 ljust() 方法使用向左或向右插入空格的方式返回一个字符串的填充版本。而 center() 方法则是让字符串文本居中。<br>上面三个方法都接受两个参数，第一个参数指定填充数量。第二个参数，指定填充的字符，默认是填充空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span>.ljust(<span class="number">20</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="string">'Veinin--------------'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span>.rjust(<span class="number">20</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="string">'--------------Veinin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span>.center(<span class="number">20</span>)</span><br><span class="line"><span class="string">'       Veinin       '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Veinin'</span>.center(<span class="number">20</span>, <span class="string">'#'</span>)</span><br><span class="line"><span class="string">'#######Veinin#######'</span></span><br></pre></td></tr></table></figure><h3 id="使用-strip-、-rstrip-和-lstrip-方法删除空白字符"><a href="#使用-strip-、-rstrip-和-lstrip-方法删除空白字符" class="headerlink" title="使用 strip()、 rstrip() 和 lstrip() 方法删除空白字符"></a>使用 strip()、 rstrip() 和 lstrip() 方法删除空白字符</h3><p>strip()、 rstrip() 和 lstrip() 三个方法分别对一个字符串的两边、右边和左边的空白字符进行删除操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'   Veinin Guo   '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.strip()</span><br><span class="line"><span class="string">'Veinin Guo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.rstrip()</span><br><span class="line"><span class="string">'   Veinin Guo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.lstrip()</span><br><span class="line"><span class="string">'Veinin Guo   '</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本是程序需要处理的最常见的数据形式。涉及字符串的操作不仅仅是使用+操作符连接两个字符串，你还可以从字符串中提取部分字符串， 添加或删除空白字符， 将字母转换成小写或大写， 检查字符串的格式是否正确。你甚至可以编写 Python 代码访问剪贴板， 复制或粘贴文本。&lt;/p&gt;
&lt;h2 id=&quot;处理字符串&quot;&gt;&lt;a href=&quot;#处理字符串&quot; class=&quot;headerlink&quot; title=&quot;处理字符串&quot;&gt;&lt;/a&gt;处理字符串&lt;/h2&gt;&lt;h3 id=&quot;双引号&quot;&gt;&lt;a href=&quot;#双引号&quot; class=&quot;headerlink&quot; title=&quot;双引号&quot;&gt;&lt;/a&gt;双引号&lt;/h3&gt;&lt;p&gt;在Python中构建一个字符串相当简单：以单引号开始和结束。&lt;br&gt;如果字符串里面也使用单引号的话，则需要使用双引号开始和结束来表示一个字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;I found hi&#39;s very selfish.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 字典</title>
    <link href="https://veinin.com/2018/03/18/python-practice-dictionaries/"/>
    <id>https://veinin.com/2018/03/18/python-practice-dictionaries/</id>
    <published>2018-03-18T08:10:00.000Z</published>
    <updated>2018-03-24T14:09:51.148Z</updated>
    
    <content type="html"><![CDATA[<p>字典数据类型提供了一种灵活的访问和组织数据的方式。<br>像列表一样，“字典”是许多值的集合。但不像列表的下标， 字典的索引可以使用许多不同数据类型， 不只是整数。 字典的索引被称为“键”，键及其关联的值称为“键-值”对。<br>字典仍然可以用整数值作为键， 就像列表使用整数值作为下标一样， 但它们不必从 0 开始， 可以是任何数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myCat = &#123;<span class="string">'size'</span>: <span class="string">'fat'</span>, <span class="string">'color'</span>: <span class="string">'gray'</span>, <span class="string">'disposition'</span>: <span class="string">'loud'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myCat[<span class="string">'size'</span>]</span><br><span class="line"><span class="string">'fat'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'My cat has '</span> + myCat[<span class="string">'color'</span>] + <span class="string">' fur.'</span></span><br><span class="line"><span class="string">'My cat has gray fur.'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ticket = &#123;<span class="number">12306</span>: <span class="string">'websites'</span>, <span class="number">123456</span>: <span class="string">'phone number'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ticket[<span class="number">12306</span>]</span><br><span class="line"><span class="string">'websites'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ticket[<span class="number">123456</span>]</span><br><span class="line"><span class="string">'phone number'</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="字典与列表"><a href="#字典与列表" class="headerlink" title="字典与列表"></a>字典与列表</h2><p>确定两个列表是否相同时， 表项的顺序很重要。<br>字典不像列表，字典中的表项是不排序的，键-值对输入的顺序并不重要。<br>因为字典是不排序的， 所以不能像列表那样切片。<br>尽管字典是不排序的，但可以用任意值作为键，这一点让你能够用强大的方式来组织数据。<br>尝试访问字典中不存在的键， 将导致 KeyError 出错信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'cats'</span>, <span class="string">'dogs'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">'dogs'</span>, <span class="string">'cats'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'age'</span>: <span class="number">25</span>, <span class="string">'firstName'</span>: <span class="string">'Veinin'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c == d</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'lastName'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'lastName'</span></span><br></pre></td></tr></table></figure><h2 id="keys-、-values-和-items-方法"><a href="#keys-、-values-和-items-方法" class="headerlink" title="keys()、 values()和 items()方法"></a>keys()、 values()和 items()方法</h2><p>有 3 个字典方法，它们将返回类似列表的值，分别对应于字典的键、值和键-值对：keys()、 values()和 items()。<br>这些方法返回的值不是真正的列表，它们不能被修改，没有append()方法。但这些数据类型（分别是 dict_keys、 dict_values 和 dict_items）可以用于for 循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'lastName'</span>: <span class="string">'Guo'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> person.keys():</span><br><span class="line">        print(k)</span><br><span class="line"></span><br><span class="line">firstName</span><br><span class="line">lastName</span><br><span class="line">age</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> v <span class="keyword">in</span> person.values():</span><br><span class="line">        print(v)</span><br><span class="line"></span><br><span class="line">Veinin</span><br><span class="line">Guo</span><br><span class="line"><span class="number">18</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> person.items():</span><br><span class="line">        print(k, v)</span><br><span class="line"></span><br><span class="line">firstName Veinin</span><br><span class="line">lastName Guo</span><br><span class="line">age <span class="number">18</span></span><br></pre></td></tr></table></figure><h2 id="检查字典中是否存在键或值"><a href="#检查字典中是否存在键或值" class="headerlink" title="检查字典中是否存在键或值"></a>检查字典中是否存在键或值</h2><p>in 和 not in 操作符可以检查值是否存在于列表中。也可以利用这些操作符，检查某个键或值是否存在于字典中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'lastName'</span>: <span class="string">'Guo'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'name'</span> <span class="keyword">in</span> person</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'sex'</span> <span class="keyword">not</span> <span class="keyword">in</span> person</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><p>在访问一个键的值之前，检查该键是否存在于字典中，这很麻烦。好在，字典有一个 get()方法，它有两个参数：要取得其值的键，以及如果该键不存在时，返回的备用值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'lastName'</span>: <span class="string">'Guo'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"I'm "</span> + str(person.get(<span class="string">'age'</span>, <span class="number">0</span>)) + <span class="string">'.'</span></span><br><span class="line"><span class="string">"I'm 18."</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'His height is '</span> + str(person.get(<span class="string">'height'</span>, <span class="number">188</span>)) + <span class="string">'cm.'</span></span><br><span class="line"><span class="string">'His height is 188cm.'</span></span><br></pre></td></tr></table></figure><h2 id="setdefault-方法"><a href="#setdefault-方法" class="headerlink" title="setdefault()方法"></a>setdefault()方法</h2><p>你常常需要为字典中某个键设置一个默认值，当该键没有任何值时使用它。<br>setdefault()方法的第一个参数，是要检查的键。第二个参数，是如果该键不存在时要设置的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = &#123;<span class="string">'firstName'</span>: <span class="string">'Veinin'</span>, <span class="string">'lastName'</span>: <span class="string">'Guo'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person.setdefault(<span class="string">'height'</span>, <span class="number">180</span>)</span><br><span class="line"><span class="number">180</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'His height is '</span> + str(person.get(<span class="string">'height'</span>, <span class="number">188</span>)) + <span class="string">'cm.'</span>)</span><br><span class="line">His height <span class="keyword">is</span> <span class="number">180</span>cm.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字典数据类型提供了一种灵活的访问和组织数据的方式。&lt;br&gt;像列表一样，“字典”是许多值的集合。但不像列表的下标， 字典的索引可以使用许多不同数据类型， 不只是整数。 字典的索引被称为“键”，键及其关联的值称为“键-值”对。&lt;br&gt;字典仍然可以用整数值作为键， 就像列表使用整数值作为下标一样， 但它们不必从 0 开始， 可以是任何数字。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myCat = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;size&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;fat&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;color&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;gray&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;disposition&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;loud&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myCat[&lt;span class=&quot;string&quot;&gt;&#39;size&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;fat&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&#39;My cat has &#39;&lt;/span&gt; + myCat[&lt;span class=&quot;string&quot;&gt;&#39;color&#39;&lt;/span&gt;] + &lt;span class=&quot;string&quot;&gt;&#39; fur.&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;My cat has gray fur.&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ticket = &amp;#123;&lt;span class=&quot;number&quot;&gt;12306&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;websites&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;123456&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;phone number&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ticket[&lt;span class=&quot;number&quot;&gt;12306&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;websites&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ticket[&lt;span class=&quot;number&quot;&gt;123456&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;phone number&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 列表</title>
    <link href="https://veinin.com/2018/03/18/python-practice-list/"/>
    <id>https://veinin.com/2018/03/18/python-practice-list/</id>
    <published>2018-03-18T07:50:00.000Z</published>
    <updated>2018-03-24T14:10:00.527Z</updated>
    
    <content type="html"><![CDATA[<p>列表和元组可以包含多个值，这样编写程序来处理大量数据就变得更容易。而且，由于列表本身又可以包含其他列表，所以可以用它们将数据安排成层次结构。</p><h2 id="列表数据类型"><a href="#列表数据类型" class="headerlink" title="列表数据类型"></a>列表数据类型</h2><p>“列表” 是一个值， 它包含多个字构成的序列。列表用左方括号开始， 右方括号结束，即[]。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="用下标取得列表中的单个值"><a href="#用下标取得列表中的单个值" class="headerlink" title="用下标取得列表中的单个值"></a>用下标取得列表中的单个值</h2><p>列表后面方括号内的整数被称为“下标”。列表中第一个值的下标是 0，第二个值的下标是 1，第三个值的下标是 2，依此类推。<br>如果使用的下标超出了列表中值的个数， Python 将给出 IndexError 出错信息。<br>列表也可以包含其他列表值。这些列表的列表中的值， 可以通过多重下标来访问。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, [<span class="string">'red and blue'</span>, <span class="string">'red and green'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">0</span>]</span><br><span class="line">red</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>]</span><br><span class="line">green</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">2</span>]</span><br><span class="line">blue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>] + colors[<span class="number">2</span>]</span><br><span class="line">greenblue</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pcolors[<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">red <span class="keyword">and</span> green</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">5</span>]</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure></p><h2 id="负数下标"><a href="#负数下标" class="headerlink" title="负数下标"></a>负数下标</h2><p>虽然下标从 0 开始并向上增长，但也可以用负整数作为下标。整数值−1 指的是列表中的最后一个下标， −2 指的是列表中倒数第二个下标，以此类推。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-1</span>]</span><br><span class="line">blue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-3</span>]</span><br><span class="line">red</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-1</span>] + colors[<span class="number">-3</span>]</span><br><span class="line">bluered</span><br></pre></td></tr></table></figure></p><h2 id="用-len-取得列表的长度"><a href="#用-len-取得列表的长度" class="headerlink" title="用 len()取得列表的长度"></a>用 len()取得列表的长度</h2><p>len()函数将返回传递给它的列表中值的个数， 就像它能计算字符串中字符的个数一样。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(colors)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p><h2 id="用下标改变列表中的值"><a href="#用下标改变列表中的值" class="headerlink" title="用下标改变列表中的值"></a>用下标改变列表中的值</h2><p>可以使用列表的下标来改变下标处的值。例如， <code>spam[1] = &#39;aardvark&#39;</code> 意味着“将列表 spam 下标 1 处的值赋值为字符串’aardvark’。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>] = <span class="string">'red and blue'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>]</span><br><span class="line"><span class="string">'red and blue'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-1</span>] = <span class="string">'blue and red'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(colors[<span class="number">-1</span>])</span><br><span class="line">blue <span class="keyword">and</span> red</span><br></pre></td></tr></table></figure></p><h2 id="列表连接和列表复制"><a href="#列表连接和列表复制" class="headerlink" title="列表连接和列表复制"></a>列表连接和列表复制</h2><p>操作符可以连接两个列表， 得到一个新列表， 就像它将两个字符串合并成一个新字符串一样。 *操作符可以用于一个列表和一个整数，实现列表的复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><h2 id="用-del-语句从列表中删除值"><a href="#用-del-语句从列表中删除值" class="headerlink" title="用 del 语句从列表中删除值"></a>用 del 语句从列表中删除值</h2><p>del 语句将删除列表中下标处的值， 表中被删除值后面的所有值， 都将向前移动一个下标。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> colors[<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>, <span class="string">'green'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> colors[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="列表用于循环"><a href="#列表用于循环" class="headerlink" title="列表用于循环"></a>列表用于循环</h2><p>在 for 循环中可以使用 range(len(someList))， 来迭代列表的每一个下标。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(colors)):</span><br><span class="line">        print(<span class="string">'Index : '</span> + str(i) + <span class="string">" in color is: "</span> + colors[i])</span><br><span class="line"></span><br><span class="line">Index : <span class="number">0</span> <span class="keyword">in</span> color <span class="keyword">is</span>: red</span><br><span class="line">Index : <span class="number">1</span> <span class="keyword">in</span> color <span class="keyword">is</span>: green</span><br><span class="line">Index : <span class="number">2</span> <span class="keyword">in</span> color <span class="keyword">is</span>: blue</span><br></pre></td></tr></table></figure></p><h2 id="in-和-not-in-操作符"><a href="#in-和-not-in-操作符" class="headerlink" title="in 和 not in 操作符"></a>in 和 not in 操作符</h2><p>利用 in 和 not in 操作符， 可以确定一个值否在列表中。 像其他操作符一样， in和 not in 用在表达式中， 连接两个值： 一个要在列表中查找的值， 以及待查找的列表。这些表达式将求值为布尔值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'red'</span> <span class="keyword">in</span> colors</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'black'</span> <span class="keyword">not</span> <span class="keyword">in</span> colors</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><h2 id="多重赋值技巧"><a href="#多重赋值技巧" class="headerlink" title="多重赋值技巧"></a>多重赋值技巧</h2><p>多重赋值技巧是一种快捷方式， 让你在一行代码中， 用列表中的值为多个变量赋值。<br>所以不必像这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">red = colors[<span class="number">0</span>]</span><br><span class="line">green = colors[<span class="number">1</span>]</span><br><span class="line">blue = colors[<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p>可有使用如下技巧：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">red, green, blue = colors</span><br></pre></td></tr></table></figure></p><p>最后要注意变量的数目和列表的长度必须严格相等， 否则 Python 将给出 ValueError。</p><h2 id="增强赋值"><a href="#增强赋值" class="headerlink" title="增强赋值"></a>增强赋值</h2><p>针对+、 -、 *、 /和%操作符， 都有增强的赋值操作符。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">a += <span class="number">1</span></span><br><span class="line">a -= <span class="number">2</span></span><br><span class="line">a *= <span class="number">2</span></span><br><span class="line">a /= <span class="number">2</span></span><br><span class="line">a %= <span class="number">5</span></span><br><span class="line"></span><br><span class="line">print(a) <span class="comment"># 9.0</span></span><br></pre></td></tr></table></figure></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法和函数是一回事，只是它是调用在一个值上。方法部分跟在这个值后面，以一个句点分隔。<br>每种数据类型都有它自己的一组方法。例如， 列表数据类型有一些有用的方法，用来查找、 添加、 删除或操作列表中的值。</p><h3 id="用-index-方法在列表中查找值"><a href="#用-index-方法在列表中查找值" class="headerlink" title="用 index()方法在列表中查找值"></a>用 index()方法在列表中查找值</h3><p>列表值有一个 index()方法， 可以传入一个值， 如果该值存在于列表中， 就返回它的下标。如果该值不在列表中， Python 就报 ValueError。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.index(<span class="string">'red'</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.index(<span class="string">'black'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: <span class="string">'black'</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> list</span><br></pre></td></tr></table></figure></p><h3 id="用-append-和-insert-方法在列表中添加值"><a href="#用-append-和-insert-方法在列表中添加值" class="headerlink" title="用 append()和 insert()方法在列表中添加值"></a>用 append()和 insert()方法在列表中添加值</h3><p>使用append()方法调用， 可以将参数添加到列表末尾。<br>insert()方法可以在列表任意下标处插入一个值。 insert()方法的第一个参数是新值的下标， 第二个参数是要插入的新值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.append(<span class="string">'black'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.insert(<span class="number">1</span>, <span class="string">'orange'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>, <span class="string">'orange'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="用-remove-方法从列表中删除值"><a href="#用-remove-方法从列表中删除值" class="headerlink" title="用 remove()方法从列表中删除值"></a>用 remove()方法从列表中删除值</h3><p>给 remove()方法传入一个值，它将从被调用的列表中删除。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'orange'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.remove(<span class="string">'black'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.remove(<span class="string">'orange'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="用-sort-方法将列表中的值排序"><a href="#用-sort-方法将列表中的值排序" class="headerlink" title="用 sort()方法将列表中的值排序"></a>用 sort()方法将列表中的值排序</h3><p>数值的列表或字符串的列表， 能用 sort()方法排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors</span><br><span class="line">[<span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'red'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>也可以指定 reverse 关键字参数为 True， 让 sort()按逆序排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>排序注意事项：</p><ul><li>首先， sort()方法当场对列表排序。不要写出 colors = colors.sort()这样的代码。</li><li>其次， 不能对既有数字又有字符串值的列表排序，因为 Python 不知道如何比较它们。</li><li>第三， sort()方法对字符串排序时， 使用“ASCII 字符顺序”， 而不是实际的字典顺序。这意味着大写字母排在小写字母之前。因此在排序时， 小写的 a 在大写的 Z 之后。</li></ul><h2 id="类似列表的类型：字符串和元组"><a href="#类似列表的类型：字符串和元组" class="headerlink" title="类似列表的类型：字符串和元组"></a>类似列表的类型：字符串和元组</h2><p>列表并不是唯一表示序列值的数据类型。例如， 字符串和列表实际上很相似，只要你认为字符串是单个文本字符的列表。对列表的许多操作， 也可以作用于字符串：按下标取值、 切片、 用于 for 循环、 用于 len()， 以及用于 in 和 not in 操作符。<br>需要注意的是：字符串是“不可变的”， 它不能被更改。尝试对字符串中的一个字符重新赋值， 将导致 TypeError 错误。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'Veinin'</span>                                    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">0</span>]                                        </span><br><span class="line"><span class="string">'V'</span>                                             </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">-1</span>]                                       </span><br><span class="line"><span class="string">'n'</span>                                             </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'in'</span> <span class="keyword">in</span> name                                           </span><br><span class="line"><span class="keyword">True</span>                                         </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'p'</span> <span class="keyword">not</span> <span class="keyword">in</span> name                      </span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">0</span>] = <span class="string">'A'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure></p><p>字符串是“不可变的”， 它不能被更改。<br>“改变” 一个字符串的正确方式， 是使用切片和连接。构造一个“新的” 字符串， 从老的字符串那里复制一些部分。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'Veinin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newName = <span class="string">'Jali'</span> + name[<span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name</span><br><span class="line"><span class="string">'Veinin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newName</span><br><span class="line"><span class="string">'Jaliin'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="元组数据类型"><a href="#元组数据类型" class="headerlink" title="元组数据类型"></a>元组数据类型</h2><p>除了两个方面，“元组” 数据类型几乎与列表数据类型一样。<br>首先， 元组输入时用圆括号()， 而不是用方括号[]。<br>其次，元组像字符串一样， 是不可变的。 元组不能让它们的值被修改、 添加或删除。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = (<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">0</span>]</span><br><span class="line"><span class="string">'red'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">-2</span>]</span><br><span class="line"><span class="string">'green'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">(<span class="string">'green'</span>, <span class="string">'blue'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors[<span class="number">2</span>] = <span class="string">'black'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure></p><p>如果需要元组值的一个可变版本， 使用函数函数 list() 将元组转换成列表就很方便。 相反也可以使用 tuple() 函数将列表转换成元组。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>对于字符串和整数值赋值操作，将执行拷贝操作，赋值后二者是不同的变量，保存了不同的值。<br>但列表不是这样的。 当你将列表赋给一个变量时，实际上是将列表的“引用”赋给了该变量。引用是一个值，指向某些数据。列表引用是指向一个列表的值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">40</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar = foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="number">0</span>] = <span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo</span><br><span class="line">[<span class="number">120</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar</span><br><span class="line">[<span class="number">120</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="传递引用"><a href="#传递引用" class="headerlink" title="传递引用"></a>传递引用</h2><p>当函数被调用时， 参数的值被复制给变元。对于列表以及字典， 这意味着变元得到的是引用的拷贝。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">something</span><span class="params">(arr)</span>:</span></span><br><span class="line"><span class="meta">... </span>    arr.append(<span class="number">4</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>something(arr)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></p><h2 id="copy-和-deepcopy-函数"><a href="#copy-和-deepcopy-函数" class="headerlink" title="copy()和 deepcopy() 函数"></a>copy()和 deepcopy() 函数</h2><p>在处理列表和字典时，尽管传递引用常常是最方便的方法， 但如果函数修改了传入的列表或字典， 你可能不希望这些变动影响原来的列表或字典。要做到这一点，Python 提供了名为 copy 的模块， 其中包含 copy()和 deepcopy()函数。<br>第一个函数copy.copy()， 可以用来复制列表或字典这样的可变值， 而不只是复制引用。<br>如果要复制的列表中包含了列表， 那就使用 copy.deepcopy()函数来代替。deepcopy()函数将同时复制它们内部的列表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">110</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">120</span></span><br><span class="line">print(a) <span class="comment"># [110, 2, 3, [120, 5, 6]]</span></span><br><span class="line">print(b) <span class="comment"># [1, 2, 3, [120, 5, 6]]</span></span><br><span class="line"></span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line">c[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">print(a) <span class="comment"># [110, 2, 3, [120, 5, 6]]</span></span><br><span class="line">print(c) <span class="comment"># [110, 2, 3, [4, 5, 6]]</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列表和元组可以包含多个值，这样编写程序来处理大量数据就变得更容易。而且，由于列表本身又可以包含其他列表，所以可以用它们将数据安排成层次结构。&lt;/p&gt;
&lt;h2 id=&quot;列表数据类型&quot;&gt;&lt;a href=&quot;#列表数据类型&quot; class=&quot;headerlink&quot; title=&quot;列表数据类型&quot;&gt;&lt;/a&gt;列表数据类型&lt;/h2&gt;&lt;p&gt;“列表” 是一个值， 它包含多个字构成的序列。列表用左方括号开始， 右方括号结束，即[]。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;colors = [&lt;span class=&quot;string&quot;&gt;&#39;red&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;green&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;blue&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 函数</title>
    <link href="https://veinin.com/2018/03/18/python-practice-functions/"/>
    <id>https://veinin.com/2018/03/18/python-practice-functions/</id>
    <published>2018-03-18T07:29:00.000Z</published>
    <updated>2018-03-24T14:09:57.972Z</updated>
    
    <content type="html"><![CDATA[<p>Python 提供了这样一些内建函数，但你也可以编写自己的函数。“函数”就像一个程序内的小程序。</p><h2 id="使用-def-语句定义一个函数"><a href="#使用-def-语句定义一个函数" class="headerlink" title="使用 def 语句定义一个函数"></a>使用 def 语句定义一个函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Veinin'</span>)</span><br><span class="line">    print(<span class="string">'Veinin Guo'</span>)</span><br><span class="line">    print(<span class="string">'Hello trere.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    hello()</span><br><span class="line">    print(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>定义一个函数时可以自己定义接收参数，传入的参数值，放在函数的括号之间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Hello '</span> + name)</span><br><span class="line"></span><br><span class="line">hello(<span class="string">'Veinin'</span>)</span><br><span class="line">hello(<span class="string">'Jalin'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="返回值和-return-语句"><a href="#返回值和-return-语句" class="headerlink" title="返回值和 return 语句"></a>返回值和 return 语句</h2><p>函数调用求值的结果， 称为函数的“返回值”。<br>用 def 语句创建函数时， 可以用 return 语句指定应该返回什么值。 return 语句包含以下部分：</p><ul><li>return 关键字；</li><li>函数应该返回的值或表达式。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAnswer</span><span class="params">(answerNumber)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> answerNumber == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'It is certain'</span></span><br><span class="line">    <span class="keyword">elif</span> answerNumber == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'It is decidedly so'</span></span><br><span class="line">    <span class="keyword">elif</span> answerNumber == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Yes'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'No'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = random.randint(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">fortune = getAnswer(r)</span><br><span class="line">print(fortune)</span><br></pre></td></tr></table></figure></li></ul><h2 id="None-值"><a href="#None-值" class="headerlink" title="None 值"></a>None 值</h2><p>在 Python 中有一个值称为 None，它表示没有值。 None 是 NoneType 数据类型的唯一值。<br>像布尔值 True和 False 一样， None 必须大写首字母 N。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spam = <span class="keyword">None</span></span><br><span class="line">print(<span class="keyword">None</span> == spam)</span><br><span class="line"></span><br><span class="line">spam = <span class="string">'Hello'</span></span><br><span class="line">print(<span class="keyword">None</span> == spam)</span><br></pre></td></tr></table></figure></p><h2 id="关键字参数和-print"><a href="#关键字参数和-print" class="headerlink" title="关键字参数和 print()"></a>关键字参数和 print()</h2><p>print()函数有可选的变元 end 和 sep， 分别指定在参数末尾打印什么，以及在参数之间打印什么来隔开它们。<br>默认情况下，print()函数自动在传入的字符串末尾添加了换行符。<br>可以设置 end 关键字参数，将它变成另一个字符串。例如，如果程序像这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Hello'</span>, end=<span class="string">''</span>)</span><br><span class="line">print(<span class="string">'World'</span>)</span><br></pre></td></tr></table></figure></p><p>print()传入多个字符串值时，该函数就会自动用一个空格分隔它们。可以传入 sep 关键字参数， 替换掉默认的分隔字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'cats'</span>, <span class="string">'dogs'</span>, <span class="string">'mice'</span>)</span><br><span class="line">cats dogs mice</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Red'</span>, <span class="string">'Green'</span>, <span class="string">'Blue'</span>)</span><br><span class="line">Red Green Blue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Red'</span>, <span class="string">'Green'</span>, <span class="string">'Blue'</span>, sep=<span class="string">','</span>)</span><br><span class="line">Red,Green,Blue</span><br></pre></td></tr></table></figure></p><h2 id="局部和全局作用域"><a href="#局部和全局作用域" class="headerlink" title="局部和全局作用域"></a>局部和全局作用域</h2><p>在被调用函数内赋值的变元和变量，处于该函数的“局部作用域”。在所有函数之外赋值的变量，属于“全局作用域”。<br>处于局部作用域的变量，被称为“局部变量”。处于全局作用域的变量，被称为“全局变量”。</p><p>作用域很重要， 理由如下：</p><ul><li><p>全局作用域中的代码不能使用任何局部变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    eggs = <span class="number">31337</span></span><br><span class="line"></span><br><span class="line">spam()</span><br><span class="line">print(eggs) <span class="comment"># NameError: name 'eggs' is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>局部作用域可以访问全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Veinin'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello, '</span> + name)</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure></li><li><p>一个函数的局部作用域中的代码，不能使用其他局部作用域中的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    eggs = <span class="number">99</span></span><br><span class="line">    bacon()</span><br><span class="line">    print(eggs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bacon</span><span class="params">()</span>:</span></span><br><span class="line">    ham = <span class="number">101</span></span><br><span class="line">    print(eggs) <span class="comment"># NameError: name 'eggs' is not defined</span></span><br><span class="line"></span><br><span class="line">spam()</span><br></pre></td></tr></table></figure></li><li><p>如果在不同的作用域中，你可以用相同的名字命名不同的变量。也就是说，可<br>以有一个名为 spam 的局部变量，和一个名为 spam 的全局变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    eggs = <span class="string">'spam local'</span></span><br><span class="line">    print(eggs) <span class="comment"># prints 'spam local'</span></span><br><span class="line"></span><br><span class="line">eggs = <span class="string">'global'</span></span><br><span class="line">spam()</span><br><span class="line">print(eggs) <span class="comment"># prints 'global'</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="global-语句"><a href="#global-语句" class="headerlink" title="global 语句"></a>global 语句</h2><p>如果需要在一个函数内修改全局变量， 就使用 global 语句。它就告诉 Python，在这个函数中， 某个值指的是全局变量， 所以不要用这个名字创建一个局部变量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> eggs</span><br><span class="line">    eggs = <span class="string">'spam'</span></span><br><span class="line"></span><br><span class="line">eggs = <span class="string">'global'</span></span><br><span class="line">spam()</span><br><span class="line">print(eggs)</span><br></pre></td></tr></table></figure></p><p>有 4 条法则， 来区分一个变量是处于局部作用域还是全局作用域：</p><ul><li>1．如果变量在全局作用域中使用（即在所有函数之外），它就总是全局变量。</li><li>2．如果在一个函数中，有针对该变量的 global 语句，它就是全局变量。</li><li>3．否则，如果该变量用于函数中的赋值语句，它就是局部变量。</li><li>4．但是，如果该变量没有用在赋值语句中，它就是全局变量。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> eggs</span><br><span class="line">    eggs = <span class="string">'spam'</span> <span class="comment"># this is the global</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bacon</span><span class="params">()</span>:</span></span><br><span class="line">    eggs = <span class="string">'bacon'</span> <span class="comment"># this is the local</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ham</span><span class="params">()</span>:</span></span><br><span class="line">    print(eggs) <span class="comment"># this is the global</span></span><br><span class="line"></span><br><span class="line">eggs = <span class="number">42</span> <span class="comment"># this is the global</span></span><br><span class="line">spam()</span><br><span class="line">print(eggs)</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在 Python 程序中遇到错误， 或“异常”， 如果不处理，意味着整个程序崩溃。<br>而我们希望程序能检测错误， 处理它们，然后继续运行。</p><p>以下代码，当试图用一个数除以零时，就会发生 <code>ZeroDivisionError: division by zero</code> 错误提示。从而导致后面代码中断运行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">devide</span><span class="params">(divideBy)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span> / divideBy</span><br><span class="line"></span><br><span class="line">print(devide(<span class="number">2</span>))</span><br><span class="line">print(devide(<span class="number">0</span>))</span><br><span class="line">print(devide(<span class="number">22</span>))</span><br></pre></td></tr></table></figure></p><p>我们可以使用 try 和 except 语句来处理错误。那些可能出错的语句被放在 try 子句中。如果错误发生，程序执行就转到接下来的 except 子句开始处。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">devide</span><span class="params">(divideBy)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span> / divideBy</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        print(<span class="string">'Error: Invalid argument.'</span>)</span><br><span class="line"></span><br><span class="line">print(devide(<span class="number">2</span>))</span><br><span class="line">print(devide(<span class="number">0</span>))</span><br><span class="line">print(devide(<span class="number">22</span>))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 提供了这样一些内建函数，但你也可以编写自己的函数。“函数”就像一个程序内的小程序。&lt;/p&gt;
&lt;h2 id=&quot;使用-def-语句定义一个函数&quot;&gt;&lt;a href=&quot;#使用-def-语句定义一个函数&quot; class=&quot;headerlink&quot; title=&quot;使用 def 语句定义一个函数&quot;&gt;&lt;/a&gt;使用 def 语句定义一个函数&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Veinin&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Veinin Guo&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Hello trere.&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hello()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 快速上手 - 控制流</title>
    <link href="https://veinin.com/2018/03/18/python-practice-flow-control/"/>
    <id>https://veinin.com/2018/03/18/python-practice-flow-control/</id>
    <published>2018-03-18T07:22:00.000Z</published>
    <updated>2018-04-19T13:36:01.225Z</updated>
    
    <content type="html"><![CDATA[<p>程序就是一系列指令。但编程真正的力量不仅在于运行（或“执行”） 一条接一条的指令， 就像周末的任务清单那样。根据表达式求值的结果，程序可以决定跳过指令， 重复指令， 或从几条指令中选择一条运行。实际上， 你几乎永远不希望程序从第一行代码开始， 简单地执行每行代码， 直到最后一行。“控制流语句” 可以决定在什么条件下执行哪些 Python 语句。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>“布尔” 数据类型只有两种值： True 和 False。 Boolean（布尔） 的首字母大写， 因为这个数据类型是根据数学家 George Boole 命名的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = <span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>true</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;pyshell#2&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">true</span><br><span class="line">NameError: name <span class="string">'true'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> = <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">SyntaxError: assignment to keyword</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h2><p>“比较操作符” 比较两个值，求值为一个布尔值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">42</span> == <span class="number">42</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">42</span> == <span class="number">99</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> != <span class="number">3</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> != <span class="number">2</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><h2 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h2><p>3 个布尔操作符（and、 or 和 not） 用于比较布尔值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">and</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="keyword">False</span> <span class="keyword">or</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">(<span class="number">4</span> &lt; <span class="number">5</span>) <span class="keyword">and</span> (<span class="number">5</span> &lt; <span class="number">6</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><h2 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>if 语句的子句（也就是紧跟 if 语句的语句块），将在语句的条件为 True 时执行。如果条件为 False，子句将跳过。<br>if 语句包含以下部分：</p><ul><li>if 关键字；</li><li>条件（即求值为 True 或 False 的表达式）；</li><li>冒号；</li><li>在下一行开始，缩进的代码块（称为 if 子句）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">'Alice'</span>:</span><br><span class="line">    print(<span class="string">'Hi, Alice.'</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="else-语句"><a href="#else-语句" class="headerlink" title="else 语句"></a>else 语句</h3><p>if 子句后面有时候也可以跟着 else 语句。只有 if 语句的条件为 False 时， else子句才会执行。<br>lse 语句中包<br>含下面部分：</p><ul><li>else 关键字；</li><li>冒号；</li><li>在下一行开始，缩进的代码块（称为 else 子句）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">'Alice'</span>:</span><br><span class="line">    print(<span class="string">'Hi, Alice.'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Hello, stranger.'</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="elif-语句"><a href="#elif-语句" class="headerlink" title="elif 语句"></a>elif 语句</h3><p>有时候可能你希望，“许多” 可能的子句中有一个被执行。 elif 语句是“否则如果”，总是跟在 if 或另一条 elif 语句后面。<br>在代码中， elif 语句<br>总是包含以下部分：</p><ul><li>elif 关键字；</li><li>条件（即求值为 True 或 False 的表达式）；</li><li>冒号；</li><li>在下一行开始，缩进的代码块（称为 elif 子句）。</li></ul><h3 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h3><p>while 语句总是包含下面几<br>部分：</p><ul><li>关键字；</li><li>条件（求值为 True 或 False 的表达式）；</li><li>冒号；</li><li>从新行开始，缩进的代码块（称为 while 子句）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spam = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> spam &lt; <span class="number">5</span>:</span><br><span class="line">    print(<span class="string">'Hello, world.'</span>)</span><br><span class="line">    spam = spam + <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><p>如果执行遇到 break 语句，就会马上退出 while 循环子句。在代码中， break 语句仅包含 break 关键字。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(<span class="string">'Please type your name.'</span>)</span><br><span class="line">    name = input()</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">'Veinin'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(<span class="string">'Thank you!'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h3><p>像 break 语句一样， continue 语句用于循环内部。如果程序执行遇到 continue语句，就会马上跳回到循环开始处，重新对循环条件求值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(<span class="string">'Who are your?'</span>)</span><br><span class="line">    name = input()</span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">'Veinin'</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(<span class="string">'Hello, Veinin. What is the password?'</span>)</span><br><span class="line">    password = input()</span><br><span class="line">    <span class="keyword">if</span> password == <span class="string">'123'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(<span class="string">'Access granted.'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="for-循环和-range-函数"><a href="#for-循环和-range-函数" class="headerlink" title="for 循环和 range()函数"></a>for 循环和 range()函数</h3><p>通过 for 循环语句和 range()函数来实现一个代码块执行固定次数。<br>for 语句看起来像 for i in range(5):这样， 总是包含以下部分：</p><ul><li>for 关键字；</li><li>一个变量名；</li><li>in 关键字；</li><li>调用 range()方法，最多传入 3 个参数；</li><li>冒号；</li><li>从下一行开始，缩退的代码块（称为 for 子句）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'My name is'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    print(<span class="string">'Jimmy Five Time ('</span> + str(i) + <span class="string">')'</span>)</span><br><span class="line">    </span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    total = total + num</span><br><span class="line">print(total)</span><br></pre></td></tr></table></figure></li></ul><h3 id="range-的开始、-停止和步长参数"><a href="#range-的开始、-停止和步长参数" class="headerlink" title="range()的开始、 停止和步长参数"></a>range()的开始、 停止和步长参数</h3><p>下列代码 <code>range</code> 函数中，第一个参数是 for 循环变量开始的值， 第二个参数是上限， 但不包含它， 也就是循环停止的数字。第三个参数是“步长”。 步长是每次迭代后循环变量增加的值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><p>Python 程序可以调用一组基本的函数， 这称为“内建函数”， 包括你见到过的print()、 input()和 len()函数。 Python 也包括一组模块，称为“标准库”。每个模块都是一个 Python 程序， 包含一组相关的函数， 可以嵌入你的程序之中。例如， math模块有数学运算相关的函数， random 模块有随机数相关的函数， 等等。<br>在代码中，</p><p>import 语句包含以下部分：</p><ul><li>import 关键字；</li><li>模块的名称；</li><li>可选的更多模块名称，之间用逗号隔开。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    print(random.randint(<span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用逗号分隔符来导入多个模块"><a href="#使用逗号分隔符来导入多个模块" class="headerlink" title="使用逗号分隔符来导入多个模块"></a>使用逗号分隔符来导入多个模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random, sys, os, math</span><br></pre></td></tr></table></figure><h4 id="from-import-语句"><a href="#from-import-语句" class="headerlink" title="from import 语句"></a>from import 语句</h4><p>import 语句的另一种形式包括 from 关键字，之后是模块名称， import 关键字和<br>一个星号， 例如 <code>from random import *</code> 。<br>使用这种形式的 import 语句，调用 random模块中的函数时不需要 random.前缀。<br>但是， 使用完整的名称会让代码更可读， 所以最好是使用普通形式的 import 语句。</p><h3 id="用-sys-exit-提前结束程序"><a href="#用-sys-exit-提前结束程序" class="headerlink" title="用 sys.exit()提前结束程序"></a>用 sys.exit()提前结束程序</h3><p>通过调用 sys.exit()函数， 可以让程序终止或退出。因为这个函数在 sys 模块中，所以必须先导入 sys， 才能使用它。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(<span class="string">'Type exit to exit.'</span>)</span><br><span class="line">    response = input()</span><br><span class="line">    <span class="keyword">if</span> response == <span class="string">'exit'</span>:</span><br><span class="line">        sys.exit()</span><br><span class="line">    print(<span class="string">'You typed '</span> + response + <span class="string">'.'</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序就是一系列指令。但编程真正的力量不仅在于运行（或“执行”） 一条接一条的指令， 就像周末的任务清单那样。根据表达式求值的结果，程序可以决定跳过指令， 重复指令， 或从几条指令中选择一条运行。实际上， 你几乎永远不希望程序从第一行代码开始， 简单地执行每行代码， 直到最后一行。“控制流语句” 可以决定在什么条件下执行哪些 Python 语句。&lt;/p&gt;
&lt;h2 id=&quot;布尔值&quot;&gt;&lt;a href=&quot;#布尔值&quot; class=&quot;headerlink&quot; title=&quot;布尔值&quot;&gt;&lt;/a&gt;布尔值&lt;/h2&gt;&lt;p&gt;“布尔” 数据类型只有两种值： True 和 False。 Boolean（布尔） 的首字母大写， 因为这个数据类型是根据数学家 George Boole 命名的。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;spam = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;spam&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Traceback (most recent call last):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;File &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;pyshell#2&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NameError: name &lt;span class=&quot;string&quot;&gt;&#39;true&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; defined&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SyntaxError: assignment to keyword&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://veinin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://veinin.com/tags/Python/"/>
    
      <category term="编程" scheme="https://veinin.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>《小狗钱钱》读书笔记</title>
    <link href="https://veinin.com/2018/03/04/reading-notes-money-oder-das/"/>
    <id>https://veinin.com/2018/03/04/reading-notes-money-oder-das/</id>
    <published>2018-03-04T12:12:00.000Z</published>
    <updated>2018-03-04T12:21:15.600Z</updated>
    
    <content type="html"><![CDATA[<p>《小狗钱钱》讲述的是一个童话故事，一个普通小女孩吉娅发现一只受伤的拉布拉多犬，并把它带回了家，取名叫钱钱。可是，有谁会想到，这只普通的四脚动物却是一个真正的理财天才呢？吉娅和小狗成为了朋友，通过小狗钱钱的指导，最后吉娅成功实现了自己的梦想，它彻底改变了吉娅一家人的财富命运。<br>这是一本老少皆宜的理财入门书籍。作者是被誉为欧洲首席金钱教练博多·舍费尔。这本书会教你如何从小学会支配金钱，而不是受金钱的支配；如何像富人那样思考，正确地认识和使用金钱；如何进行理财投资，找到积累资产的方法，早日实现财务自由！</p><a id="more"></a><h2 id="梳理理财目标"><a href="#梳理理财目标" class="headerlink" title="梳理理财目标"></a>梳理理财目标</h2><p>中国的智者老子说过：“天下难事，必作于易；天下大事，必作于细”。你自己必须真的有“想要变得富有”这个愿望，所以你必须找到10个“想要变得富有”的梦想。然后找出3项你觉得最重要的梦想出来，并作为目标，<br>然后拿一本相册作为你的梦想相册。收集一些与自己的愿望有关的照片，把它们贴在相册里。我们要通过图片来思考。<br>最后为自己的每一个梦想各准备一个储蓄罐，比如银行卡子账户。一旦储蓄罐准备好，你就应当把省下的每一分钱放进去。</p><h2 id="撰写成功日记"><a href="#撰写成功日记" class="headerlink" title="撰写成功日记"></a>撰写成功日记</h2><p>你是否能挣到钱，最关键的并不是你有没有好点子，也不是你有多聪明，而是你的自信程度。你的自信程度决定了你是否相信自己的能力，是否相信你自己。假如你根本不相信你能做到的话，那么你就根本不会动手去做，而假如你不开始去做，那么你就什么也得不到。<br>自信是很容易梳理的，你只需要准备一个本子，给它取名叫‘成功日记’，然后每天都把当天所有做成功的事情记录进去。每次都写至少5条你的个人成果，任何小事都可以。</p><h2 id="坚持你的梦想"><a href="#坚持你的梦想" class="headerlink" title="坚持你的梦想"></a>坚持你的梦想</h2><p>不论在什么情况下，每天都坚持自己所做所想。不间断地设想我的未来。<br>当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。</p><h2 id="快速摆脱负债"><a href="#快速摆脱负债" class="headerlink" title="快速摆脱负债"></a>快速摆脱负债</h2><p>毁掉所有的信用卡。<br>在许可范围内按最低的分期付款数目标准支付。应当尽可能少地偿还贷款。分期付款额越高，每个月剩下的生活费就越少。许多人和银行约定的分期付款数额刚好在他们承受能力的上限，因此他们手里的钱一直很紧张。<br>将扣除生活费后剩下的钱的一半存起来，剩下的一半用于支付消费贷款。最好根本不申请消费贷款。<br>债务人都应该在自己的钱包里贴一张纸条，上面写着“这真的有必要吗”。这样的话，当他站在收银台前的时候，就会想到不应该花太多的钱。</p><h2 id="合理分配你挣到的钱"><a href="#合理分配你挣到的钱" class="headerlink" title="合理分配你挣到的钱"></a>合理分配你挣到的钱</h2><p>如果你想变得富有，你同时还要存钱，这笔钱是你绝不会再花的，只用利息进行消费，让你能依靠本金来生活。<br>拥有一只自己的“鹅”。鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。把50％的收入变的“鹅”，用来让鹅长大；40％放入梦想储蓄罐，用来帮助实现自己的目标；剩下的10％用来零花。</p><h2 id="进行明确的投资"><a href="#进行明确的投资" class="headerlink" title="进行明确的投资"></a>进行明确的投资</h2><p>应该把钱投资在安全的地方。<br>我的钱应该下很多“金蛋”。<br>我们要足够了解你的投资对象，投资应该简单明了，而且易于操作。<br>用72除以通货膨胀率，得出的数字就是你的钱在多少年后只值现在的一半。聪明的商人可不会让自己的钱只躺在银行里睡大觉，这样做根本没有什么利息。即使有，通货膨胀也会完全吞掉你的利息。<br>用72除以年收益率的百分比，得出的数字就是这笔钱翻一番的年数。如果你们投资的收益率是15％，差不多5年以后，钱就会翻一倍。</p><h2 id="如何挑选基金"><a href="#如何挑选基金" class="headerlink" title="如何挑选基金"></a>如何挑选基金</h2><p>基金应该至少有10年历史。假如它在这么长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。<br>应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。<br>对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。</p><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ul><li><p>不是试试看，而是去切实行动！如果你只是抱着试试看的心态，那么你只会以失败告终，你会一事无成。“尝试”纯粹是一种借口，你还没有做，就已经给自己想好了退路。不能试验，你只有两个选择——做或者不做。</p></li><li><p>学习就是认识新观念和新想法的过程。假如人们始终以同一种思维方式来考虑问题的话，那么始终只会得到同样的结果。因为我对你讲述的许多内容是你以前从未接触过的，所以我建议你，在你还没有做之前，不要轻易下结论。没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。</p></li><li><p>必须学会量入为出，否则有了更多的钱只会给他们带来更大的麻烦，因为支出往往会和收入一同增长，除非我们学会合理分配我们的财产。</p></li><li><p>要想过更幸福、更满意的生活，人就得改变自身。这和钱无关，金钱本身既不会使人幸福，也不会带来不幸。金钱是中性的，既不好，也不坏。只有当钱属于某一个人的时候，它才会对这个人产生好的影响或者坏的影响。钱可以被用于好的用途，也可以被用于坏的用途。一个幸福的人有了钱会更幸福；而一个悲观忧虑的人，钱越多，烦恼就越多。”</p></li><li><p>没有人能强迫你做你不愿意做的事情。只有你自己才能强迫自己去做。</p></li><li><p>最珍贵的礼物是我们自己争取来的。克服了丢面子的恐惧，世界就会向你敞开大门！</p></li><li><p>成功会使人骄傲。如果你骄傲自大，你就会停止学习。不学习，人就不会再进步。</p></li><li><p>对股票，每个人都知道一点点，可是很少有人清楚它到底是什么东西。</p></li><li><p>金融家有时候还真是一群奇怪的人。也许当他们随意地说出一串除了他们自己谁也听不懂的名词时，他们会觉得自己比较重要。但遗憾的是，许多人因此感到自己不懂投资。不懂的东西，人们是不相信的。而其实这些东西就是这么简单。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《小狗钱钱》讲述的是一个童话故事，一个普通小女孩吉娅发现一只受伤的拉布拉多犬，并把它带回了家，取名叫钱钱。可是，有谁会想到，这只普通的四脚动物却是一个真正的理财天才呢？吉娅和小狗成为了朋友，通过小狗钱钱的指导，最后吉娅成功实现了自己的梦想，它彻底改变了吉娅一家人的财富命运。&lt;br&gt;这是一本老少皆宜的理财入门书籍。作者是被誉为欧洲首席金钱教练博多·舍费尔。这本书会教你如何从小学会支配金钱，而不是受金钱的支配；如何像富人那样思考，正确地认识和使用金钱；如何进行理财投资，找到积累资产的方法，早日实现财务自由！&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="投资" scheme="https://veinin.com/tags/%E6%8A%95%E8%B5%84/"/>
    
      <category term="理财" scheme="https://veinin.com/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>《富爸爸，穷爸爸》读书笔记</title>
    <link href="https://veinin.com/2018/02/25/reading-notes-rich-dad-poor-dad/"/>
    <id>https://veinin.com/2018/02/25/reading-notes-rich-dad-poor-dad/</id>
    <published>2018-02-25T14:42:00.000Z</published>
    <updated>2018-03-04T12:13:53.003Z</updated>
    
    <content type="html"><![CDATA[<p>我们从小就听父母说，好好读书，好好上课，毕业了找一份好的工作。那好好上学真的可以找到好的工作吗？找到好的工作肯定会变富有吗？我想这些问题的答案都是否定的，谁能够一直坐在教室里听着那些枯燥乏味的教学内容，那些内容让我们只会运用于考试中，在生活中往往被我们给忽略了。我们如何才能让我们的生活不在为了金钱而忙碌，我们为什么不能让金钱为我们而工作呢！</p><p>因此，要学会管理风险，要学会投资，不要让我们的生活只留下房贷、车贷。不要生活在一种虚假的忙碌中，那样的生活没有意义，只会让我们在往后的生活中教育自己的后代：好好上学，好好读书，找个好工作。这样的生活在当今社会已经不实用了，没有谁会认为只有读书才有出路。</p><p>《富爸爸，穷爸爸》是一个真实的故事，作者罗伯特·清崎从人的个体出发分析富人之所以成为富人，穷人之所以成为穷人的自身因素，提出了一个全新的“财商”的概念。并向传统的学校教育提出挑战。</p><a id="more"></a><p>清崎有两个爸爸，其中一个有博士学位的是他的亲生爸爸，也是本书中的穷爸爸；另外一个初中都没有读完是他好友的爸爸，即本书中的富爸爸。两位爸爸都有非常高的收入，但是穷爸爸却常常为钱而烦恼，而富爸爸最后成为了夏威夷最富有的人。 富爸爸过世后给家里留下了很多的财产，而穷爸爸则为家人留下了很多没有还清的债务。之所以会出现这样的情况，是因为穷爸爸缺乏基本的财务知识。</p><p>而关于财务教育最大的问题是学校没有教过这门学科，所以我们对于财务的教育都来自家庭，而问题就在于除非你的父母是属于收入很高的1%的那一部分人，不然我们普通的家庭并不知道如何教自己的孩子财务方面的知识。而且他们也不会阅读像《富爸爸穷爸爸》这类的书籍。如果我们没有出身在那1%的家庭，那么我们可以向清崎来学习，学习“富爸爸”的观念，即不要做金钱的奴隶，要让金钱为我们工作。</p><h2 id="第一课：富人不为钱工作"><a href="#第一课：富人不为钱工作" class="headerlink" title="第一课：富人不为钱工作"></a>第一课：富人不为钱工作</h2><p>穷人和中产阶级为钱而工作。<br>起床，上班，付账，再起床，再上班，再付账……<br>他们的生活从此被这两种感觉所控制：恐惧和贪婪。给他们更多的钱，他们就会以更高的开支重复这种循环。这就是所谓的的‘老鼠赛跑’。<br>人们自身的恐惧和无知使他们困在陷阱里，正是出于恐惧的心理，人们才想找一份安稳的工作。这些恐惧有：害怕付不起账单，害怕被解雇，害怕没有足够的钱，害怕重新开始。为了寻求保障，他们会学习某种专业，或是做生意，拼命为钱而工作。大多数人成了钱的奴隶，然后就把怒气发泄在他们老板身上。<br>他们不明白自己为什么老缺钱，于是以为多挣点钱就能解决问题，但几乎没有人意识到缺乏财商教育才是问题的关键。</p><h2 id="第二课：为什么要教授财务知识"><a href="#第二课：为什么要教授财务知识" class="headerlink" title="第二课：为什么要教授财务知识"></a>第二课：为什么要教授财务知识</h2><p>一个受过高等教育且事业有成的人，同时也可能是财务上的文盲。这种人往往太过努力地工作，因为他们只知道努力工作，却不知道如何让钱为他们工作。<br>如果人们认为钱能解决一切问题，恐怕他们的日子就不会太好过。只有知识才能解决问题并创造财富，那些不是靠财务知识挣来的钱也不会长久。<br>你必须明白资产和负债的区别，并且购买资产。如果你想致富，这一点你必须知道。富人获得资产，而穷人和中产阶级获得负债，只不过他们以为那些负债就是资产。<br>资产是能把钱放进你口袋里的东西。<br>负债是把钱从你口袋里取走的东西。<br>富人：增加收入，减少支出和负债，买入更多资产。<br>穷人：增加收入，增加支出和负债。<br>中产阶级：购买自以为是资产的负债。</p><h2 id="第三课：关注自己的事业"><a href="#第三课：关注自己的事业" class="headerlink" title="第三课：关注自己的事业"></a>第三课：关注自己的事业</h2><p>职业不等于你的事业。大多数人工作其实是为其他人，而非他们自己。首先他们要为公司的老板工作，其次是通过纳税为政府工作，最后是为向他们提供住房按揭贷款的银行工作。多关注自己的事业。存在财务问题的人经常耗费一生为别人工作，其中许多人在他们不能工作时就变得一无所有。<br>富人与穷人一个重要的区别就是：富人最后才买奢侈品，而穷人和中产阶级会先买下诸如大房子、珠宝、皮衣、宝石、游艇等奢侈品，因为他们想让自己看上去很富有。他们看上去的确很富有，但实际上他们已深陷贷款的陷阱之中。那些能给子孙留下遗产的人和那些能长期富有的人，就是先构筑资产项，然后才用资产所产生的收入购买奢侈品的，而穷人和中产阶级则用他们的血汗钱和本应该留给子孙的遗产来购买奢侈品。</p><p>真正的资产可以分为以下几类：</p><ul><li>1．不需我到场就可以正常运作的业务。我拥有它们，但由别人经营和管理。如果我必须在那儿工作，那它就不是我的事业而是我的职业了；</li><li>2．股票；</li><li>3．债券；</li><li>4．共同基金；</li><li>5．能够产生收入的房地产；</li><li>6．票据（借据）；</li><li>7．版税，如音乐、手稿、专利；</li><li>8．其他任何有价值、可产生收入或有增值潜力并且有很好销路的东西。</li></ul><h2 id="第四课：税收的历史和公司的力量"><a href="#第四课：税收的历史和公司的力量" class="headerlink" title="第四课：税收的历史和公司的力量"></a>第四课：税收的历史和公司的力量</h2><p>公司的避税优势：</p><ul><li>1.公司的某些收入可以用于税前收入支出</li><li>2.企业所得税率低于个人所得税率</li></ul><p>知识就是力量，而且钱越多，就越需要知识管理它，使它继续增加。没有这种知识，世界就会牵着你走。</p><p>财商是由4个方面的专门知识构成的：</p><ul><li>第一是会计，也就是我说的财务知识。</li><li>第二是投资，我把它称为钱生钱的科学。投资涉及策略和方案，这要右脑来做，是属于创造的部分。</li><li>第三是了解市场，它是供给与需求的科学。这要求了解受感情驱动的市场的“技术面”。</li><li>第四是法律。利用一个具有会计、投资和市场运营的企业会使你的财富实现爆炸性地增长。了解减税优惠政策和公司法的人会比雇员和小业主更快致富。<br>拥有公司的富人：挣钱、支出、缴税<br>为公司工作的人：挣钱、缴税、支出</li></ul><h2 id="第五课：富人的投资"><a href="#第五课：富人的投资" class="headerlink" title="第五课：富人的投资"></a>第五课：富人的投资</h2><p>我们都拥有巨大的潜能，然而，我们都拥有或多或少的自我怀疑的心理。过分的害怕和自我怀疑是毁掉我们才能的最大因素。成为财务上的天才既需要专业知识，又需要足够的勇气。<br>投资者分为两类：<br>第一类也是最普遍的一类，即进行一揽子投资的人。他们联系一家从事经营个人投资业务的中介机构，例如房地产公司、股票经纪人或财务规划师等，然后买下某些产品。这些产品可能是共同基金、房地产投资信托、股票或债券等。</p><p>第二类是自己创造投资机会的投资者。这种投资者通常会自行组织一项交易，好比一个人买来电脑零部件，然后自己组装，这有点像量身定做。<br>这类投资者，除了提高财商的4项基本技能，还必须具备3种主要技能，</p><ul><li>1．如何寻找其他人都忽视的机会。</li><li>2．如何增加资金。</li><li>3．怎样把精明的人组织起来。聪明的人往往会雇用比自己更聪明的人或与他们一起工作。当你需要建议的时候，你一定要确定你选择的是明智的顾问。</li></ul><h2 id="第六课：学会不为钱工作"><a href="#第六课：学会不为钱工作" class="headerlink" title="第六课：学会不为钱工作"></a>第六课：学会不为钱工作</h2><p>大部分人需要学习和掌握不止一项技能，只有这样他们的收入才能获得显著增长。财商是会计、投资、市场和法律等各方面知识和能力的综合。将上述4种技能结合起来，以钱生钱就会容易得多。当涉及钱的时候，只有一项技能的人不得不努力工作。<br>找一份稳定的工作。大部分人是为短期的工资和福利工作的，但从长期来看这种做法常常是具有灾难性的。<br>劝告年轻人在找工作时要看能从中学到什么，而不是只看能挣多少钱。在选择某种职业或陷入“老鼠赛跑”的陷阱之前，要仔细看看脚下的路，弄清楚自己到底想获得什么技能。<br>是建议他们要有长远的眼光。我承认为了金钱和生活安稳而工作是很重要，但我仍主张要再找一份工作，以便从中学到另一种技能。<br>我受过良好教育的爸爸工作越努力，就越具有竞争力，但同时他也更深地陷入专业特长的陷阱之中。虽然他的工资增长了，可他的选择机会却少了。直到失去了在政府中的工作，他才发现自己在职业选择上是多么被动。这就好比职业运动员因为突然受伤或是年龄太大而无法继续参加比赛一样，他们会失去曾经拥有的高收入工作，而有限的技能又使他们无法另辟蹊径。我想，</p><h2 id="克服困难"><a href="#克服困难" class="headerlink" title="克服困难"></a>克服困难</h2><p>掌握财务知识的人有时候还是不能积累丰厚的资产项，其主要原因有5个：</p><ul><li>1．恐惧心理。</li><li>2．愤世嫉俗。</li><li>3．懒惰。</li><li>4．不良习惯。</li><li>5．自负。</li></ul><h2 id="开始行动"><a href="#开始行动" class="headerlink" title="开始行动"></a>开始行动</h2><ul><li>1．我需要一个超现实的理由——精神的力量。</li><li>2．每天作出自己的选择——选择的力量。从理财的角度来说，我们每挣到一美元，就得到了一次选择自己是成为富人、穷人还是中产阶级的机会。我们花钱的习惯反映了我们是什么样的人，穷人之所以贫穷是因为他们有着不良的消费习惯。</li><li>3．慎重地选择朋友——关系的力量。首先，我不会把理财状况作为挑选朋友的标准。</li><li>4．掌握一种模式，然后再学习一种新的模式——快速学习的力量。面包师要按照一定的配方做面包，即使配方只是记在脑子里。挣钱也是一样的道理，这也是金钱有时被称做“面包圈”的原因。</li><li>5．首先支付自己——自律的力量。如果你控制不了自己，就别想着致富。<br>不要背上数额过大的债务包袱。要保持低支出。首先增加自己的资产，然后，再用资产项产生的现金流来买大房子或好车子。陷在“老鼠赛跑”中不是明智的选择。<br>当你资金短缺时，让压力去发挥作用，而不要动用你的储蓄或资本。利用这种压力来激发你的理财天赋，想出新办法挣到更多的钱，然后再支付账单。这样做，不但能让你赚到钱，还能提高你的财商。</li><li>6．给你的经纪人以优厚的报酬——好建议的力量。</li><li>7．做一个“印第安给予者”——无私的力量。</li><li>8．用资产来购买奢侈品——专注的力量。</li><li>9．对英雄的崇拜——神话的力量。</li><li>10．先予后取——给予的力量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们从小就听父母说，好好读书，好好上课，毕业了找一份好的工作。那好好上学真的可以找到好的工作吗？找到好的工作肯定会变富有吗？我想这些问题的答案都是否定的，谁能够一直坐在教室里听着那些枯燥乏味的教学内容，那些内容让我们只会运用于考试中，在生活中往往被我们给忽略了。我们如何才能让我们的生活不在为了金钱而忙碌，我们为什么不能让金钱为我们而工作呢！&lt;/p&gt;
&lt;p&gt;因此，要学会管理风险，要学会投资，不要让我们的生活只留下房贷、车贷。不要生活在一种虚假的忙碌中，那样的生活没有意义，只会让我们在往后的生活中教育自己的后代：好好上学，好好读书，找个好工作。这样的生活在当今社会已经不实用了，没有谁会认为只有读书才有出路。&lt;/p&gt;
&lt;p&gt;《富爸爸，穷爸爸》是一个真实的故事，作者罗伯特·清崎从人的个体出发分析富人之所以成为富人，穷人之所以成为穷人的自身因素，提出了一个全新的“财商”的概念。并向传统的学校教育提出挑战。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="理财" scheme="https://veinin.com/tags/%E7%90%86%E8%B4%A2/"/>
    
      <category term="富爸爸" scheme="https://veinin.com/tags/%E5%AF%8C%E7%88%B8%E7%88%B8/"/>
    
      <category term="穷爸爸" scheme="https://veinin.com/tags/%E7%A9%B7%E7%88%B8%E7%88%B8/"/>
    
  </entry>
  
  <entry>
    <title>《人类简史》读书笔记</title>
    <link href="https://veinin.com/2017/12/31/reading-notes-a-brief-history-of-humankind/"/>
    <id>https://veinin.com/2017/12/31/reading-notes-a-brief-history-of-humankind/</id>
    <published>2017-12-31T11:59:10.000Z</published>
    <updated>2017-12-31T03:03:03.098Z</updated>
    
    <content type="html"><![CDATA[<p>十万年前，地球上至少有六种不同的人。但今日，世界舞台为什么只剩下了我们自己？从只能啃食虎狼吃剩的残骨的猿人，到跃居食物链顶端的智人，从雪维洞穴壁上的原始人手印，到阿姆斯壮踩上月球的脚印，从认知革命、农业革命，到科学革命、生物科技革命，我们如何登上世界舞台成为万物之灵的？</p><p>这是以色列历史学家尤瓦尔·赫拉利成名作，这本书以不到500页的篇幅，从10万年前一直讲到了21世纪，为我们理清人类的发展脉络提供了一个充满哲思的全局视角。</p><a id="more"></a><p>在历史的路上，有三大重要革命：<br>大约7万年前，“认知革命”（CognitiveRevolution）让历史正式启动。<br>大约12000年前，“农业革命”（AgriculturalRevolution）让历史加速发展。<br>而到了大约不过是500年前，“科学革命”（ScientificRevolution）可以说是让历史画下句点而另创新局。<br>这本书的内容，讲述的就是这三大革命如何改变了人类和其他生物。</p><h2 id="认知革命"><a href="#认知革命" class="headerlink" title="认知革命"></a>认知革命</h2><p>人类是怎么从一种平凡无奇的动物走到食物链顶端的，认知革命带给了我们答案。</p><p>大约在240万年前的东非最早的人类开始演化，祖先是一种更早的猿属“Australopithecus”（南方古猿）。<br>大约200万年前，这些远古人类有一部分离开了家园而踏上旅程，足迹遍及北非、欧洲和亚洲的广大地带。北欧的森林白雪皑皑，印度尼西亚的热带丛林湿气蒸腾，想活命显然需要不同的特征，因此人类也开始朝着不同方向进化。于是人类发展出几个不同的物种，除了“智人”以外，还有比如在欧洲和西亚的“尼安德特人”，住在在东方亚洲的“直立人”等等。</p><p>如果不出意外，可能在今天我们可以看到多个不同的人种，多种人种共存其实会是常态。但是，意外出现了，大约7万年前，智人从东非扩张到阿拉伯半岛，并且很快席卷整个欧亚大陆，由于不同的人种之间的水火不容，互有反感，于是发生种族灭杀，当地的原生人种很快就会灭绝。大约3万年前尼安德特人退出了世界舞台，而到了12000年前，像小矮人般的人类也从弗洛里斯岛上永远消失，这种残酷的种族屠杀一直持续到了大约1万年前，终于，地球上的人种只剩下了智人一种。</p><p>因为智人迁移到其他地区，而造成其他人类物种的灭绝。那么为什么是智人，而不是其他人种呢？那是因为在大约7万年前，智人仿佛脱胎换骨，某次偶然的基因突变，改变了智人的大脑内部连接方式，让他们以前所未有的方式来思考，用完全新式的语言来沟通。他们的认知能力（学习、记忆、沟通）得到了革命性的发展，这时的智人已经和你我同样聪明、有创意、反应灵敏，他们产生了新的思维和沟通方式，这也是所谓的认知革命。</p><p>认知革命给智人带来了新的语言，这种新语言带来了最独特的功能–“讨论虚构的事物”。智人的语言并不是世界上的第一种语言。因为许多动物（包括所有的猿类和猴类）都会使用有声语言。例如，青猴（greenmonkey）就有各种不同的喊叫方式，传达不同的信息。不论是人类还是许多动物，都能大喊：“小心！有狮子！”。但在认知革命之后，智人就能够说出：“狮子是我们部落的守护神”。智人能够谈论并不真正存在的事物，相信一些不太可能的事情。于是传说、神话、神以及宗教也应运而生。</p><p>“虚构”这件事的重点不只在于让人类能够拥有想象，更重要的是可以“一起”想象，编织出种种共同的虚构故事，不管是《圣经》的《创世记》、澳大利亚原住民的“梦世记”（Dreamtime），甚至连现代所谓的国家其实也是种想象。这样的虚构故事赋予智人前所未有的能力，让我们得以集结大批人力、灵活合作。虽然一群蚂蚁和蜜蜂也会合作，但方式死板，而且其实只限近亲。至于狼或黑猩猩的合作方式，虽然已经比蚂蚁灵活许多，但仍然只能和少数其他十分熟悉的个体合作。智人的合作则是不仅灵活，而且能和无数陌生人合作。正因如此，才会是智人统治世界，蚂蚁只能吃我们的剩饭，而黑猩猩则被关在动物园和实验室里。</p><p>于人类共同的想象之外，这个宇宙中根本没有神、没有国家、没有钱、没有人权、没有法律，也没有正义。通过虚构的故事，就算是大批互不相识的人，只要同样相信相信某个故事，就能共同合作。无论是现代国家、中世纪的教堂、古老的城市，或者古老的部落，任何大规模人类合作的根基，都在于某种只存在于集体想象中的虚构故事。而这也使智人最后打破了团体的人数限制，<br>创造出了有数万居民的城市、有上亿人口的帝国，这也是智人成功的关键。</p><h2 id="农业革命"><a href="#农业革命" class="headerlink" title="农业革命"></a>农业革命</h2><p>人类曾有长达250万年的时间靠采集及狩猎维生，并不会特别干预动植物的生长情形。直立人、匠人或是尼安德特人都会采集野无花果、猎捕野绵羊，但不会去管究竟无花果树该长在哪，羊该在哪片草地吃草，又或是哪只公羊该跟母羊交配。</p><p>这一切在大约1万年前全然改观，人类开始投入几乎全部的心力，操纵着几种动植物的生命。从日升到日落，人类忙着播种、浇水、除草、牧羊，一心以为这样就能得到更多的水果、谷物和肉类。这是一场关于人类生活方式的革命：农业革命。</p><p>农业革命让人类的食物总量增加，但量的增加并不代表吃得更好、过得更悠闲，反而只是造成人口爆炸，而且产生一群养尊处优、娇生惯养的精英分子。普遍来说，农民的工作要比采集者更辛苦，而且到头来的饮食还要更糟。农业革命可说是史上最大的一桩骗局。</p><p>正是这些征收来的多余食粮，养活了政治、战争、艺术和哲学，建起了宫殿、堡垒、纪念碑和庙宇。在现代晚期之前，总人口有九成以上都是农民，日出而作、胼手胝足。他们生产出来的多余食粮养活了一小撮的精英分子：国王、官员、战士、牧师、艺术家和思想家，但历史写的几乎全是这些人的故事。于是，历史只告诉了我们极少数的人在做些什么，而其他绝大多数人的生活就是不停挑水耕田。</p><p>农业革命后几千年的历史，可以总结为一个问题：如果人类的基因里并没有大规模合作的生物本能，所有的合作网络究竟如何维系？简单的讲法，是人类创造出了由想象建构的秩序、发明了文字，以这两者补足我们基因中的不足。但对许多人来说，这些合作网络究竟是好是坏实在难说。网络背后那些想象的秩序既不中立也不公平，总把人分成一些其实并不存在的分类，并且排出上下等级。上等人享有各种权力和特权，而下等人有的只有歧视和压迫。</p><h2 id="人类统一融合"><a href="#人类统一融合" class="headerlink" title="人类统一融合"></a>人类统一融合</h2><p>农业革命之后，人类社会规模变得更大、更复杂，而维系社会秩序的虚构故事也更为细致完整。人类几乎从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照着这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化”。</p><p>每种文化都自成一格、和谐共存，而且都有独特的不变本质。每一群人都会有自己的世界观，和社会、法律及政治系统，而且各自运作顺畅，就像是行星绕着太阳一样。</p><p>从实际观点看，全球融合最关键的阶段就是过去这几个世纪。各大帝国成长，全球贸易强化，亚洲、非洲、美洲和大洋洲的人类形成紧密连接，于是印度菜里出现了墨西哥的辣椒，阿根廷的草原上漫步着来自西班牙的牛。</p><p>在过去的3000年间，人类有越来越多雄心勃勃的计划，想要实现这种世界一家的概念。他们发明货币、建筑帝国和传播宗教。</p><p>商业、帝国和全球性的宗教，最后终于将几乎每个智人都纳入了我们今天的全球世界。这个扩张和统一的过程并不是完全直线发展、一帆风顺。但纵观大局，可以看到从许多小文化到少数大文化再到最后的全球单一文化，应该是人类历史无法避免的结果。</p><h2 id="科学革命"><a href="#科学革命" class="headerlink" title="科学革命"></a>科学革命</h2><p>历史就这样从一个岔路走到下一个岔路，选择走某条道路而非另一条的原因总是神秘而不得而知。大约在公元1500年，历史做出了最重大的选择，改变的不只是人类的命运，而是地球上所有生命的命运。我们将它称为“科学革命”。</p><p>将人类带到阿拉莫戈多、带上月球的这段历史进程，称为“科学革命”。在这场革命中，人类因为将资源投入科学研究，取得了巨大的新力量。之所以说这是一场革命，是因为一直到大约公元1500年前，全球人类还不相信自己能在医疗、军事和经济方面再有什么突破。政府和富有的赞助者虽然也会将资金投入教育和作为奖学金，但一般来说只是为了维持现有能力，而不是取得新的能力。典型的前现代统治者会赞助牧师、哲学家和诗人，目的是请他们让他的统治合法化，并且维护社会秩序，而不是要他们发明新的药物、武器，或是刺激经济成长。</p><p>但在过去的500年中，人类越来越相信可以靠着投资科学研究提升人类的能力。而且这不只是盲目的信仰，而是经过了反复的证明。随着证据越来越多，手中握有资源的富人和政府也就越来越愿意投入科学。如果没有这些投资，人类永远不可能在月球上漫步，不可能操纵微生物，更不可能分裂原子。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>历史有太多的可能性，而许多的可能性最后都未成真。我们不难想象，历史其实很有可能就这样一代又一代地过去，而从未发生科学革命，就算没有基督教，没有古罗马帝国，没有金币，历史还是会继续发展下去。</p><p>在7万年前，智人还不过是一种微不足道的动物，在非洲的角落自顾自地生活。但就在接下来的几千年间，智人就成了整个地球的主人、生态系统的梦魇。时至今日，智人似乎只要再跨一步就能进入神的境界，不仅有望获得永恒的青春，更拥有创造和毁灭一切的神力。</p><p>但遗憾的是，智人在地球上的所作所为，实在没有太多令人自豪。虽然我们主宰了环境、增加了粮食产量、盖起城市、建立帝国，还创造了无远弗届的贸易网络，但全球的痛苦减少了吗？一次又一次，虽然整体人类的能力大幅提升，但却不一定能改善个别人类的福祉，而且常常还让其他动物深受其害。</p><p>拥有神的能力，但是不负责任、贪得无厌，而且连想要什么都不知道。天下危险，恐怕莫此为甚。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;十万年前，地球上至少有六种不同的人。但今日，世界舞台为什么只剩下了我们自己？从只能啃食虎狼吃剩的残骨的猿人，到跃居食物链顶端的智人，从雪维洞穴壁上的原始人手印，到阿姆斯壮踩上月球的脚印，从认知革命、农业革命，到科学革命、生物科技革命，我们如何登上世界舞台成为万物之灵的？&lt;/p&gt;
&lt;p&gt;这是以色列历史学家尤瓦尔·赫拉利成名作，这本书以不到500页的篇幅，从10万年前一直讲到了21世纪，为我们理清人类的发展脉络提供了一个充满哲思的全局视角。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="人类简史" scheme="https://veinin.com/tags/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"/>
    
      <category term="历史" scheme="https://veinin.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="人类学" scheme="https://veinin.com/tags/%E4%BA%BA%E7%B1%BB%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《拖延心理学》读书笔记</title>
    <link href="https://veinin.com/2017/12/02/reading-notes-procrastination/"/>
    <id>https://veinin.com/2017/12/02/reading-notes-procrastination/</id>
    <published>2017-12-02T08:15:00.000Z</published>
    <updated>2017-12-02T08:22:19.080Z</updated>
    
    <content type="html"><![CDATA[<p>拖延从根本上来说并不是一个时间管理方面或懒惰的问题，也不是一个道德问题，而是一个复杂的心理问题。根本而言，拖延的问题是一个人跟自身如何相处的问题，它反映的是一个人在自尊上的问题。</p><p>本书的第一部分中，我们对产生拖延的形形色色的根源进行了追溯，告诉我们为何会拖延。<br>在第二部分中，给出了一些帮助你采取行动的建议，教导我们如何去应对拖延症。我们的目标并不是消除拖延。很多时候对一些事情弃之不理反而对你最为有利；相反，这本书希望能够让你更加接受自己，由你自己来掌握取舍和得失。</p><a id="more"></a><h2 id="我们为何拖延"><a href="#我们为何拖延" class="headerlink" title="我们为何拖延"></a>我们为何拖延</h2><p>表面上看来，拖延症是因为懒，或者是对时间管理能力不足而造成的。而本书告诉了我们一个真正的原因，拖延症的成因主要是源于内心的恐惧。</p><p>由于家庭、性格、以及自己的各种经历，会导致人们产生各种各样的恐惧。很多拖延者并不能识别所有这些活跃于表面现象之下的情绪波动，因为他们利用拖延来逃避不舒服的感受。为了对付这些恐惧，我们产生了一种防卫机制来对抗恐惧，而拖延就是用来避免恐惧的。这样的反应模式一次次循环，让我们一次次的陷入了“拖延怪圈”中。</p><p>对于“拖延怪圈”，每个人都有自己不同的体验。你或许在几个星期、几个月，甚至几年时间内都挣扎在这个怪圈当中，或者，你也可能从头到尾只需要几个小时就经历了一个怪圈。</p><ol><li>“这次我想早点开始。”</li><li>“我得马上开始。”</li><li>“我不开始又怎么样呢？”<ul><li>a.“我应该早点开始。”</li><li>b.“我可以做任何事，除了这件……”</li><li>c.“我无法享受任何事情。”</li><li>d.“我希望没人发现。”</li></ul></li><li>“还有时间。”</li><li>“我这个人有毛病。”</li><li>最后的抉择：做还是不做。<ul><li>道路之一：不做</li><li>a.“我无法忍受了！”</li><li>b.“何必庸人自扰呢？”</li><li>道路之二：背水一战</li><li>a.“我不能再坐等了。”</li><li>b.“事情还没有这么糟，为什么当初我不早一点开始做呢？”</li><li>c.“把它做完就行了！”</li></ul></li><li>“我永远不会再拖延！”</li></ol><p>人们之所以产生拖延的不良习性，是因为他们害怕。他们害怕如果他们行动了，他们的行为会让他们陷入麻烦。他们担心如果展示了自己真实的一面，会有危险的结果等着他们。在所有无序和拖拉的背后，他们其实在害怕他们不被接受，以至于他们不仅躲开这个世界，甚至还躲开他们自己。虽然要忍受自责、自轻和对自己的反感是相当痛苦的，但是比起去看清真实的自我所带来的脆弱和无地自容，这样的感受或许更能够被承受得起，拖延是保护他们的盾牌。</p><h2 id="如何改变拖延"><a href="#如何改变拖延" class="headerlink" title="如何改变拖延"></a>如何改变拖延</h2><p>做出改变和学会一种新的行为模式是一个渐进的过程，这是一个可以预知的改变顺序，称为为“改变的阶段”。</p><ul><li>第一阶段，“前关注”，没有准备做出改变，甚至都没有想过要做改变。</li><li>第二阶段，“关注”，通过阅读这本书，你知道了拖延是因为恐惧，你开始思考是否准备采取行动。</li><li>第三阶段，“准备”，做了一点尝试，虽然没有完全投入其中。“好吧，我终于要开始锻炼身体了”。</li><li>第四阶段，“行动”，“我今天去健身房，感觉还不错”。</li></ul><p>当你迟迟不肯记账的时候，你可能是不想面对花费过大而收入过少的事实。<br>当你一直不回短信的时候，你可能在恐惧跟陌生人打交道。<br>当你迟迟不想写论文的时候，你可能是担心论文会占用所有的娱乐时间。</p><p>无论你的任何拖延是出于什么奇奇怪怪的原因，我们都应该坦然接受。慢慢来，不管你多么渴望改善自己，也不管你怎样努力，你不可能在第二天，或者下个星期，或者下个月，就一下子停止拖延了。</p><p>当我们再一次面对一件难事，大脑依然会收到恐惧信号，焦虑会立刻袭来，此时请提醒自己，不要重蹈覆辙，而是要改变心态，跳出拖延。</p><p>当你知道自己花钱太多，收入太少时，你可以提醒你自己，年轻人收入低，没关系，能进步就好。<br>当你害怕和陌生人打交道是，你可以告诉自己，很多人都在做这样的事情。</p><p>观察你内心的抵抗情绪，虽然你在处理拖延问题上开始有所进步，但是你可能还是会因为自己努力不够、进步不大或者没有完成自己设定的所有目标而对自己感到失望或者生气。或者，你也可能会觉得我们对你要求太多了。不管抵抗情绪采取什么样的形式表现出来，它会让你停留在原地停滞不前。</p><p>通过树立新的行为模式和思维方法，我们就可以舒缓恐惧所带来的焦虑和压力，而不是靠拖延来逃避恐惧。</p><p>除此之外，涉及一些具体的改变拖延方法方面，书中还给出了很多实用性的建议，比如：</p><ul><li>明确自己的目标与可行性的计划，启动一周试验。</li><li>学会更好的判断时间，提升你定是能力的技巧，让自己的时间观念通常跟“钟表时间”同步。</li><li>学会接受有益于你的人和事，学会结局那些没有意义的追求。</li><li>通过运动来启动你的状态，从拖延的麻痹状态中解救出来。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本书指出了人们之所以拖延的很多原因，认为拖延是心理问题。就像书中说的那样，光是认清楚拖延的根源还是不够的，你还必须做一些事情以防止拖延来主导你的生活，采用一些书中的建议，并行动起来。最后去尝试一种新的行为模式，感受自己的拖延，如实的去接受它，不再躲避，打破自己的拖延循环。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《拖延心理学》，<a href="https://book.douban.com/subject/4180711/" target="_blank" rel="noopener">豆瓣读书</a></li><li>速读《拖延心理学》，<a href="https://www.bilibili.com/video/av14625804/" target="_blank" rel="noopener">bilibili</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拖延从根本上来说并不是一个时间管理方面或懒惰的问题，也不是一个道德问题，而是一个复杂的心理问题。根本而言，拖延的问题是一个人跟自身如何相处的问题，它反映的是一个人在自尊上的问题。&lt;/p&gt;
&lt;p&gt;本书的第一部分中，我们对产生拖延的形形色色的根源进行了追溯，告诉我们为何会拖延。&lt;br&gt;在第二部分中，给出了一些帮助你采取行动的建议，教导我们如何去应对拖延症。我们的目标并不是消除拖延。很多时候对一些事情弃之不理反而对你最为有利；相反，这本书希望能够让你更加接受自己，由你自己来掌握取舍和得失。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="拖延症" scheme="https://veinin.com/tags/%E6%8B%96%E5%BB%B6%E7%97%87/"/>
    
      <category term="心理学" scheme="https://veinin.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《Linux 命令行与shell脚本编程大全》读书笔记（命令行部分）</title>
    <link href="https://veinin.com/2017/11/24/reading-notes-linux-command-lime/"/>
    <id>https://veinin.com/2017/11/24/reading-notes-linux-command-lime/</id>
    <published>2017-11-24T15:30:00.000Z</published>
    <updated>2017-11-26T15:36:17.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Linux"><a href="#什么是-Linux" class="headerlink" title="什么是 Linux"></a>什么是 Linux</h2><p>Linux可划分为以下四部分：</p><h3 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h3><ul><li>系统内存管理</li><li>软件程序管理</li><li>硬件设备管理</li><li>文件系统管理</li></ul><h3 id="GNU工具"><a href="#GNU工具" class="headerlink" title="GNU工具"></a>GNU工具</h3><p>GNU组织（GNU是GNU’s Not Unix的缩写），模仿Unix操作系统开发一系列标准的计算机系统工具，但没有可以运行它们的内核系统。</p><a id="more"></a><ul><li><p><strong>核心GNU工具</strong><br>该项目移植了很多常见的Unix系统命令行工具。供Linux系统使用的这组核心工具被称为coreutils（coreutilities）软件包。由三部分构成：用以处理文件的工具、用以操作文本的工具、用以管理进程的工具</p></li><li><p><strong>shell</strong><br>GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。 shell的核心是命令行提示符。命令行提示符是shell负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中执行。所有Linux发行版默认的shell都是bash shell。</p></li></ul><h3 id="图形化桌面环境"><a href="#图形化桌面环境" class="headerlink" title="图形化桌面环境"></a>图形化桌面环境</h3><ul><li>X Window系统</li><li>KDE桌面（K Desktop Environment， K桌面环境）</li><li>GNOME桌面（the GNU Network Object Model Environment， GNU网络对象模型环境）</li><li>Unity桌面……</li></ul><h3 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h3><h2 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a>Linux 发行版</h2><p>不同的Linux发行版通常归类为3种：</p><h3 id="完整的核心Linux发行版"><a href="#完整的核心Linux发行版" class="headerlink" title="完整的核心Linux发行版"></a>完整的核心Linux发行版</h3><p>核心Linux发行版含有内核、一个或多个图形化桌面环境以及预编译好的几乎所有能见到的Linux应用。它提供了一站式的完整Linux安装。</p><h3 id="特定用途的发行版"><a href="#特定用途的发行版" class="headerlink" title="特定用途的发行版"></a>特定用途的发行版</h3><p>它们通常基于某个主流发行版，但仅包含主流发行版中一小部分用于某种特定用途的应用程序。如许多特定用途的Linux发行版都是基于Debian Linux，但仅打包了完整Debian系统中的一小部分。</p><h3 id="LiveCD测试发行版"><a href="#LiveCD测试发行版" class="headerlink" title="LiveCD测试发行版"></a>LiveCD测试发行版</h3><p>它无需安装就可以看到Linux系统是什么样的。多数现代PC都能从CD启动，而不是必须从标准硬盘启动。基于这点，一些Linux发行版创建了含有Linux样本系统（称为Linux LiveCD）的可引导CD。</p><h2 id="bash-手册"><a href="#bash-手册" class="headerlink" title="bash 手册"></a>bash 手册</h2><p>man命令用来访问存储在Linux系统上的手册页面。在想要查找的工具的名称前面输入man命令，就可以找到那个工具相应的手册条目。<br>手册每个内容区域都分配了一个数字，从1开始，一直到9：<br>1：可执行程序或shell命令<br>2：系统调用<br>3：库调用<br>4：特殊文件<br>5：文件格式与约定<br>6：游戏<br>7：概览、约定及杂项<br>8：超级用户和系统管理员命令<br>9：内核例程</p><h2 id="过滤输出列表"><a href="#过滤输出列表" class="headerlink" title="过滤输出列表"></a>过滤输出列表</h2><p>ls命令能够识别标准通配符，并在过滤器中用它们进行模式匹配：</p><ul><li>问号（?）代表一个字符；</li><li>星号（*）代表零个或多个字符。</li><li><p>在特定位置上可能出现的两种字符，a或i:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l my_scr[ai]pt</span><br></pre></td></tr></table></figure></li><li><p>指定字符范围，例如字母范围[a – i]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l f[a-i]ll</span><br></pre></td></tr></table></figure></li><li><p>使用感叹号（!）将不需要的内容排除在外:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l f[!a]ll</span><br></pre></td></tr></table></figure></li></ul><h2 id="管理文件目录"><a href="#管理文件目录" class="headerlink" title="管理文件目录"></a>管理文件目录</h2><h3 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h3><ul><li>创建文件：touch</li><li>复制文件：cp</li><li>重命名文件：mv</li><li>删除文件：rm</li><li>链接文件：ln<br>在系统上维护同一文件的两份或多份副本，除了保存多份单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法。这种虚拟的副本就称为链接。</li></ul><h3 id="文件链接"><a href="#文件链接" class="headerlink" title="文件链接"></a>文件链接</h3><p>在Linux中有两种不同类型的文件链接：</p><h4 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h4><p>符号链接就是一个实实在在的文件，它指向存放在虚拟目录结构中某个地方的另一个文件。这两个通过符号链接在一起的文件，彼此的内容并不相同。<br>使用ln命令以及-s选项来创建符号链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s data_file sl_data_file</span><br></pre></td></tr></table></figure></p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件。引用硬链接文件等同于引用了源文件。<br>使用ln命令时不再需要加入额外的参数创建硬链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln code_file hl_code_file</span><br></pre></td></tr></table></figure></p><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><ul><li>显示文本文件中所有数据；cat</li><li>显示文本文件的内容，但会在显示每页数据之后停下来：more</li><li>more命令的升级版：less</li><li>显示文件最后几行的内容：tail</li><li>显示文件开头那些行的内容：head</li></ul><h3 id="处理目录"><a href="#处理目录" class="headerlink" title="处理目录"></a>处理目录</h3><ul><li>创建目录：mkdir New_Dir</li><li>创建多个目录和子目录，需要加入-p参数：mkdir -p New_Dir/Sub_Dir/Under_Dir</li><li>删除目录，只删除空目录：rmdir New_Dir</li><li>删除目录及其所有内容：rm -rf Small_Dir</li><li>查看文件类型：file my_file</li></ul><h2 id="处理数据文件"><a href="#处理数据文件" class="headerlink" title="处理数据文件"></a>处理数据文件</h2><h3 id="排序、搜索"><a href="#排序、搜索" class="headerlink" title="排序、搜索"></a>排序、搜索</h3><ul><li>排序数据：sort [options] [file]</li><li>搜索数据：grep [options] pattern [file]</li></ul><h3 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h3><p>Linux上的文件压缩工具：</p><ul><li>bzip2，采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码，文件扩展名：.bz2        </li><li>compress，最初的Unix文件压缩工具，已经快没人用了，文件扩展名：.Z  </li><li>gzip，GNU压缩工具，用Lempel-Ziv编码，文件扩展名：.gz </li><li>zip，Windows上PKZIP工具的Unix实现，文件扩展名：.zip</li></ul><p>gzip 软件包是GNU项目的产物，意在编写一个能够替代原先Unix中compress工具的免费版本。这个软件包含有下面的工具：</p><ul><li>gzip：用来压缩文件。</li><li>gzcat：用来查看压缩过的文本文件的内容。</li><li>gunzip：用来解压文件。</li></ul><h3 id="归档数据"><a href="#归档数据" class="headerlink" title="归档数据"></a>归档数据</h3><p>虽然zip命令能够很好地将数据压缩和归档进单个文件，但它不是Unix和Linux中的标准归档工具。目前，Unix和Linux上最广泛使用的归档工具是tar命令。</p><p>tar命令的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar function [options] object1 object2 ...</span><br></pre></td></tr></table></figure></p><p>function参数定义了tar命令应该做什么：</p><ul><li>-A –concatenate 将一个已有tar归档文件追加到另一个已有tar归档文件</li><li>-c –create 创建一个新的tar归档文件</li><li>-d –diff 检查归档文件和文件系统的不同之处</li><li>–delete 从已有tar归档文件中删除</li><li>-r –append 追加文件到已有tar归档文件末尾</li><li>-t –list 列出已有tar归档文件的内容</li><li>-u –update 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中</li><li>-x –extract 从已有tar归档文件中提取文件</li></ul><p>每个功能可用选项来针对tar归档文件定义一个特定行为：</p><ul><li>-C dir 切换到指定目录</li><li>-f file 输出结果到文件或设备file</li><li>-j 将输出重定向给bzip2命令来压缩内容</li><li>-p 保留所有文件权限</li><li>-v 在处理文件时显示文件</li><li>-z 将输出重定向给gzip命令来压缩内容</li></ul><p>列出归档内容：tar -tf test.tar<br>提取归档内容：tar -xvf test.tar<br>创建归档文件：tar -cvf test.tar test/ test2</p><h2 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h2><h3 id="探查进程"><a href="#探查进程" class="headerlink" title="探查进程"></a>探查进程</h3><p>当程序运行在系统上时，我们称之为进程（process）。想监测这些进程，需要熟悉ps命令的用法。<br>使用ps命令的关键不在于记住所有可用的参数，而在于记住最有用的那些参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 Aug21 ?        00:07:16 /usr/lib/systemd/systemd --system --deserialize 26</span><br><span class="line">root         2     0  0 Aug21 ?        00:00:04 [kthreadd]</span><br><span class="line">root         3     2  0 Aug21 ?        00:00:28 [ksoftirqd/0]</span><br><span class="line">root         7     2  0 Aug21 ?        00:00:00 [migration/0]</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li>-e参数指定显示所有运行在系统上的进程；</li><li>-f参数则扩展了输出，这些扩展的列包含了有用的信息。</li><li>-l参数，它会产生一个长格式输出。</li></ul><p>这些扩展的列包含了有用的信息：</p><ul><li>UID：启动这些进程的用户。</li><li>PID：进程的进程ID。</li><li>PPID：父进程的进程号（如果该进程是由另一个进程启动的）。</li><li>C：进程生命周期中的CPU利用率。</li><li>STIME：进程启动时的系统时间。</li><li>TTY：进程启动时的终端设备。</li><li>TIME：运行进程需要的累计CPU时间。</li><li>CMD：启动的程序名称。</li></ul><h3 id="实时监测进程"><a href="#实时监测进程" class="headerlink" title="实时监测进程"></a>实时监测进程</h3><p>想观察那些频繁换进换出的内存的进程趋势，top命令刚好适用这种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">top - 15:54:00 up 95 days, 10:46,  1 user,  load average: 0.14, 0.07, 0.06</span><br><span class="line">Tasks: 176 total,   1 running, 175 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :   602816 total,    65452 free,   248696 used,   288668 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   177264 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">  170 root      20   0       0      0      0 S  0.3  0.0  20:03.70 xfsaild/sda1</span><br><span class="line">14270 root      20   0  828800  24620   2880 S  0.3  4.1  19:15.48 dockerd</span><br><span class="line">16454 systemd+  20   0  888224  33020      0 S  0.3  5.5   7:18.88 mysqld</span><br><span class="line">31990 veining+  20   0  155620   2216   1500 R  0.3  0.4   0:00.04 top</span><br><span class="line">    1 root      20   0  193496   4944   2392 S  0.0  0.8   7:25.59 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S  0.0  0.0   0:04.07 kthreadd</span><br></pre></td></tr></table></figure><p>输出的第一部分显示的是系统的概况：</p><ul><li>第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载。</li><li>第二行显示了进程概要信息——top命令的输出中将进程叫作任务（task）：有多少进程处在运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）。</li><li>第三行显示了CPU的概要信息。 top根据进程的属主（用户还是系统）和进程的状态（运行、<br>空闲还是等待）将CPU利用率分成几类输出。</li><li>最后两行说明了系统内存的状态。第一行说的是系统的物理内存：总共有多少内存，当前用了多少，还有多少空闲。<br>后一行说的是同样的信息，不过是针对系统交换空间（如果分配了的话）的状态而言的。</li></ul><p>最后一部分显示了当前运行中的进程的详细列表，有些列跟ps命令的输出类似：</p><ul><li>PID：进程的ID。</li><li>USER：进程属主的名字。</li><li>PR：进程的优先级。</li><li>NI：进程的谦让度值。</li><li>VIRT：进程占用的虚拟内存总量。</li><li>RES：进程占用的物理内存总量。</li><li>SHR：进程和其他进程共享的内存总量。</li><li>S：进程的状态（D代表可中断的休眠状态， R代表在运行状态， S代表休眠状态， T代表跟踪状态或停止状态， Z代表僵化状态）。</li><li>%CPU：进程使用的CPU时间比例。</li><li>%MEM：进程使用的内存占可用内存的比例。</li><li>TIME+：自进程启动到目前为止的CPU时间总量。</li><li>COMMAND：进程所对应的命令行名称，也就是启动的程序名。</li></ul><h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><p>在Linux中，进程之间通过信号来通信。进程的信号就是预定义好的一个消息，进程能识别它并决定忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。</p><p>在Linux上有两个命令可以向运行中的进程发出进程信号。</p><ol><li>kill命令：kill 3940<br>kill命令可通过进程ID（PID）给进程发信号。默认情况下，kill命令会向命令行中列出的全部PID发送一个TERM信号。遗憾的是，你只能用进程的PID而不能用命令名，所以kill命令有时并不好用。</li><li>killall命令：killall http*<br>killall命令非常强大，它支持通过进程名而不是PID来结束进程。 killall命令也支持通配符，这在系统因负载过大而变得很慢时很有用。</li></ol><h2 id="管理磁盘"><a href="#管理磁盘" class="headerlink" title="管理磁盘"></a>管理磁盘</h2><p>Linux文件系统将所有的磁盘都并入一个虚拟目录下。在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作称为挂载（mounting）。如果用的Linux发行版不支持自动挂载和卸载可移动存储媒体，就必须手动完成。</p><h3 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a>mount命令</h3><p>Linux上用来挂载媒体的命令叫作mount。默认情况下， mount命令会输出当前系统上挂载的设备列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mount</span><br><span class="line">sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)</span><br><span class="line">proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=294632k,nr_inodes=73658,mode=755)</span><br><span class="line">securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)</span><br></pre></td></tr></table></figure></p><p>mount命令提供如下四部分信息：</p><ul><li>媒体的设备文件名</li><li>媒体挂载到虚拟目录的挂载点</li><li>文件系统类型</li><li>已挂载媒体的访问状态</li></ul><p>手动挂载媒体设备的基本命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t type device directory</span><br></pre></td></tr></table></figure></p><h3 id="umount命令"><a href="#umount命令" class="headerlink" title="umount命令"></a>umount命令</h3><p>从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。umount命令的格式非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [directory | device ]</span><br></pre></td></tr></table></figure></p><h3 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h3><p>有时你需要知道在某个设备上还有多少磁盘空间。df命令可以让你很方便地查看所有已挂载磁盘的使用情况<br>常用参数是-h，它会把输出中的磁盘空间按照用户易读的形式显示，通常用M来替代兆字节，用G替代吉字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ df</span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda1       10474496 8675760   1798736  83% /</span><br><span class="line">devtmpfs          294632       0    294632   0% /dev</span><br><span class="line">tmpfs             301408       0    301408   0% /dev/shm</span><br></pre></td></tr></table></figure></p><p>df命令会显示每个有数据的已挂载文件系统。命令输出如下：</p><ul><li>设备的设备文件位置；</li><li>能容纳多少个1024字节大小的块；</li><li>已用了多少个1024字节大小的块；</li><li>还有多少个1024字节大小的块可用；</li><li>已用空间所占的比例；</li><li>设备挂载到了哪个挂载点上。</li></ul><h3 id="du-命令"><a href="#du-命令" class="headerlink" title="du 命令"></a>du 命令</h3><p>du命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这一方法可用来快速判断系统上某个目录下是不是有超大文件。</p><p>能让du命令用起来更方便的几个命令行参数：</p><ul><li>-c：显示所有已列出文件总的大小。</li><li>-h：按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节。</li><li>-s：显示每个输出参数的总计。</li></ul><h2 id="理解Shell"><a href="#理解Shell" class="headerlink" title="理解Shell"></a>理解Shell</h2><h3 id="shell-的类型"><a href="#shell-的类型" class="headerlink" title="shell 的类型"></a>shell 的类型</h3><p>系统启动什么样的shell程序取决于你个人的用户ID配置，在/etc/passwd文件中。<br>默认的交互shell会在用户登录某个虚拟控制台终端或在GUI中运行终端仿真器时启动。不过还有另外一个默认shell是/bin/sh，它作为默认的系统shell，用于那些需要在启动时使用的系统shell脚本。</p><h3 id="shell-的父子关系"><a href="#shell-的父子关系" class="headerlink" title="shell 的父子关系"></a>shell 的父子关系</h3><p>用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell，是一个父shell。<br>在CLI提示符后输入/bin/bash命令或其他等效的bash命令时， 会创建一个新的shell程序。这个shell程序被称为子shell（child shell） 。</p><p>bash shell程序可使用命令行参数修改shell启动方式：</p><ul><li>-c string 从string中读取命令并进行处理</li><li>-i 启动一个能够接收用户输入的交互shell</li><li>-l 以登录shell的形式启动</li><li>-r 启动一个受限shell，用户会被限制在默认目录中</li><li><p>-s 从标准输入中读取命令</p></li><li><p>依次运行的一系列命令。这可以通过命令列表来实现，只需要在命令之间加入分号（;）即可：pwd ; ls ; cd /etc ; pwd ;</p></li><li>要想将命令置入后台模式，可以在命令末尾加上字符&amp;：sleep 3000&amp;</li><li>协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。使用coproc命令进行协程处理：coproc sleep 10</li></ul><h3 id="理解-shell-的内建命令"><a href="#理解-shell-的内建命令" class="headerlink" title="理解 shell 的内建命令"></a>理解 shell 的内建命令</h3><h4 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h4><p>外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、 /usr/bin、 /sbin或/usr/sbin中。<br>ps就是一个外部命令。你可以使用which和type命令找到它。<br>当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。外部命令ps很方便显示出它的父进程以及自己所对应的衍生子进程。</p><h4 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h4><p>内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。cd和exit命令都内建于bash shell。可以利用type命令来了解某个命令是否是内建的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ type ps</span><br><span class="line">ps is hashed (/usr/bin/ps)</span><br><span class="line">$</span><br><span class="line">$ type -a echo</span><br><span class="line">echo is a shell builtin</span><br><span class="line">echo is /bin/echo</span><br></pre></td></tr></table></figure></p><ul><li>查看最近用过的命令列表：history</li><li>为常用的命令（及其参数）创建另一个名称：alias</li><li>要查看当前可用的别名，使用alias命令以及选项-p：alias -p</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>Linux环境变量能帮你提升Linux shell体验。很多程序和脚本都通过环境变量来获取系统信息、存储临时数据和配置信息。在Linux系统上有很多地方可以设置环境变量，了解去哪里设置相应的环境变量很重要。<br>在涉及环境变量名时，如果要用到变量，使用$；如果要操作变量，不使用$。</p><p>在bash shell中，环境变量分为两类：</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的<br>shell可见。这让全局环境变量对那些所创建的子shell需要获取父shell信息的程序来说非常有用。<br>要查看全局变量，可以使用 <code>env</code> 或 <code>printenv</code> 命令。</p><p>要显示个别环境变量的值，可以使用 <code>printenv</code> 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ printenv HOME</span><br><span class="line">/home/veininguo</span><br></pre></td></tr></table></figure></p><p>也可以使用 <code>echo</code> 显示变量的值。在变量前面加上一个美元符（$）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $HOME</span><br><span class="line">/home/veininguo</span><br></pre></td></tr></table></figure></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部环境变量只能在定义它们的进程中可见。<br>在Linux系统并没有一个只显示局部环境变量的命令。 set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。</p><h3 id="设置用户定义变量"><a href="#设置用户定义变量" class="headerlink" title="设置用户定义变量"></a>设置用户定义变量</h3><p>可以在bash shell中直接设置自己的变量。</p><h4 id="设置局部用户定义变量"><a href="#设置局部用户定义变量" class="headerlink" title="设置局部用户定义变量"></a>设置局部用户定义变量</h4><p>创建在shell进程内可见的局部变量，但在子shell中无法使用用户定义变量。可以通过等号给环境变量赋值，值可以是数值或字符串。<br>所有的环境变量名均使用大写字母，如果是你自己创建的局部变量或是shell脚本，请使用小写字母。<br>变量名、等号和值之间没有空格，这一点非常重要。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable=&quot;Veinin Guo&quot;</span><br><span class="line">$ echo $my_variable</span><br><span class="line">Veinin Guo</span><br></pre></td></tr></table></figure></p><h4 id="设置全局环境变量"><a href="#设置全局环境变量" class="headerlink" title="设置全局环境变量"></a>设置全局环境变量</h4><p>在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。<br>创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。通过export命令来完成，变量名前面不需要加$。<br>子shell无法使用export命令改变父shell中全局环境变量的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable=&quot;I am Global now&quot;</span><br><span class="line">$ export my_variable</span><br><span class="line">$</span><br><span class="line">$ echo $my_variable</span><br><span class="line">I am Global now</span><br><span class="line">$</span><br><span class="line">$ bash</span><br><span class="line">$ echo $my_variable</span><br><span class="line">I am Global now</span><br><span class="line">$</span><br><span class="line">$ exit</span><br><span class="line">exit</span><br><span class="line">$ echo $my_variable</span><br><span class="line">I am Global now</span><br></pre></td></tr></table></figure></p><h4 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h4><p>可以用 <code>unset</code> 命令完成这个操作。在命令中引用环境变量时不要使用$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo $my_variable</span><br><span class="line">I am Global now</span><br><span class="line">$ unset my_variable</span><br><span class="line">$ echo $my_variable</span><br></pre></td></tr></table></figure></p><h3 id="设置-PATH-环境变量"><a href="#设置-PATH-环境变量" class="headerlink" title="设置 PATH 环境变量"></a>设置 PATH 环境变量</h3><p>在 shell 命令行界面中输入一个外部命令时， shell 必须搜索系统来找到对应的程序。PATH 环境变量定义了用于进行命令和程序查找的目录。PATH中的目录使用冒号分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/veininguo/.local/bin:/home/veininguo/bin</span><br></pre></td></tr></table></figure><p>把新的搜索目录添加到现有的PATH环境变量中，无需从头定义。PATH中各个目录之间是用冒号分隔的。你只需引用原来的PATH值，然后再给这个字符串添加新目录就行了。也将单点符也加入PATH环境变量，单点符代表当前目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/veininguo/.local/bin:/home/veininguo/bin</span><br><span class="line">$</span><br><span class="line">$ PATH=$PATH:/usr/games:/usr/local/games</span><br><span class="line">$</span><br><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/veininguo/.local/bin:/home/veininguo/bin:/usr/games:/usr/local/games</span><br><span class="line">$</span><br><span class="line">$ PATH=$PATH:.</span><br></pre></td></tr></table></figure><h3 id="定位系统环境变量"><a href="#定位系统环境变量" class="headerlink" title="定位系统环境变量"></a>定位系统环境变量</h3><p>在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作启动文件或环境文件。<br>在大多数发行版中，存储个人用户永久性bash shell变量的地方是$HOME/.bashrc文件。 </p><p>启动bash shell有3种方式：</p><ul><li>登录时作为默认登录shell，登录shell会从5个不同的启动文件里读取命令：</li></ul><ol><li>/etc/profile，是bash shell默认的的主启动文件。只要你登录了Linux系统， bash就会执行/etc/profile启动文件中的命令。</li><li>$HOME目录下的启动文件，剩下的启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环<br>境变量。大多数Linux发行版只用这四个启动文件中的一到两个：<br>$HOME/.bash_profile<br>$HOME/.bashrc<br>$HOME/.bash_login<br>$HOME/.profile</li></ol><ul><li><p>作为非登录shell的交互式shell<br>如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入bash时启动），那么你启动的shell叫作交互式shell。<br>交互式shell启动时，只会检查用户HOME目录中的.bashrc文件。</p></li><li><p>作为运行脚本的非交互shell<br>系统执行shell脚本时用的就是这种shell。不同的地方在于它没有命令行提示符。<br>但是当你在系统上运行脚本时，也许希望能够运行一些特定启动的命令，为了处理这种情况， bash shell提供了BASH_ENV环境变量。</p></li></ul><h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><p>要给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mytest=(one two three four five)</span><br></pre></td></tr></table></figure></p><p>引用一个单独的数组元素，就必须用代表它在数组中位置的数值索引值。索引值要用方括号括起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;mytest[2]&#125;</span><br><span class="line">three</span><br></pre></td></tr></table></figure></p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>缺乏安全性的系统不是完整的系统。系统中必须有一套能够保护文件免遭非授权用户浏览或修改的机制。 Linux沿用了Unix文件权限的办法，即允许用户和组根据每个文件和目录的安全性设置来访问文件。</p><h3 id="Linux-的安全性"><a href="#Linux-的安全性" class="headerlink" title="Linux 的安全性"></a>Linux 的安全性</h3><p>Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。用户对系统中各种对象的访问权限取决于他们登录系统时用的账户。用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是登录名。</p><h4 id="etc-passwd-文件"><a href="#etc-passwd-文件" class="headerlink" title="/etc/passwd 文件"></a>/etc/passwd 文件</h4><p>这个文件将用户的登录名匹配到对应的UID值，它包含了一些与用户有关的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">...</span><br><span class="line">veininguo:x:1000:1001::/home/veininguo:/bin/bash</span><br><span class="line">dockerroot:x:996:993:Docker User:/var/lib/docker:/sbin/nologin</span><br></pre></td></tr></table></figure><p>/etc/passwd文件的字段包含了如下信息：</p><ul><li>登录用户名</li><li>用户密码</li><li>用户账户的UID（数字形式）</li><li>用户账户的组ID（GID）（数字形式）</li><li>用户账户的文本描述（称为备注字段）</li><li>用户HOME目录的位置</li><li>用户的默认shell</li></ul><h4 id="etc-shadow-文件"><a href="#etc-shadow-文件" class="headerlink" title="/etc/shadow 文件"></a>/etc/shadow 文件</h4><p>/etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow文件，这让它比起/etc/passwd安全许多。<br>etc/shadow文件为系统上的每个用户账户都保存了一条记录。记录就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">veininguo:*:17399:0:99999:7:::</span><br></pre></td></tr></table></figure></p><p>每条记录中都有9个字段：</p><ul><li>与/etc/passwd文件中的登录名字段对应的登录名</li><li>加密后的密码</li><li>自上次修改密码后过去的天数密码（自1970年1月1日开始计算）</li><li>多少天后才能更改密码</li><li>多少天后必须更改密码</li><li>密码过期前提前多少天提醒用户更改密码</li><li>密码过期后多少天禁用用户账户</li><li>用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）</li><li>预留字段给将来使用</li></ul><h4 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h4><p>用来向Linux系统添加新用户的主要工具是useradd。系统默认值被设置在/etc/default/useradd文件中。</p><p>在创建新用户时，如果你不在命令行中指定具体的值， useradd命令就会使用-D选项所显示的那些默认值。这个例子列出的默认值如下：</p><ul><li>新用户会被添加到GID为100的公共组；</li><li>新用户的HOME目录将会位于/home/loginname；</li><li>新用户账户密码在过期后不会被禁用；</li><li>新用户账户未被设置过期日期；</li><li>新用户账户将bash shell作为默认shell；</li><li>系统会将/etc/skel目录下的内容复制到用户的HOME目录下；</li><li>系统为该用户账户在mail目录下创建一个用于接收邮件的文件。</li></ul><p>默认情况下，useradd命令不会创建HOME目录，但是-m命令行选项会使其创建HOME目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -m test</span><br><span class="line">$ sudo ls -al /home/test/</span><br><span class="line">total 12</span><br><span class="line">drwx------. 2 test test  62 Nov 26 13:18 .</span><br><span class="line">drwxr-xr-x. 4 root root  35 Nov 26 13:18 ..</span><br><span class="line">-rw-r--r--. 1 test test  18 Sep  6 16:25 .bash_logout</span><br><span class="line">-rw-r--r--. 1 test test 193 Sep  6 16:25 .bash_profile</span><br><span class="line">-rw-r--r--. 1 test test 231 Sep  6 16:25 .bashrc</span><br></pre></td></tr></table></figure><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>userdel可以从系统中删除用户， 加上-r参数， userdel会删除用户的HOME目录以及邮件目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$sudo userdel -r test</span><br><span class="line">$</span><br><span class="line">$ sudo ls -al /home/test/</span><br><span class="line">ls: cannot access /home/test/: No such file or directory</span><br></pre></td></tr></table></figure><h4 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h4><p>Linux提供了一些不同的工具来修改已有用户账户的信息：</p><ol><li><p>usermod，修改用户账户的字段，还可以指定主要组以及附加组的所属关系。常用参数如下：<br>-c修改备注字段。<br>-e修改过期日期。<br>-g修改默认的登录组。<br>-l修改用户账户的登录名。<br>-L锁定账户，使用户无法登录。<br>-p修改账户的密码。<br>-U解除锁定，使用户能够登录。</p></li><li><p>passwd和chpasswd<br>改变用户密码的一个简便方法就是用passwd命令。<br>如果需要为系统中的大量用户修改密码， chpasswd命令可以事半功倍。 </p></li><li><p>chsh、 chfn和chage<br>chsh、 chfn和chage工具专门用来修改特定的账户信息。<br>chsh命令用来快速修改默认的用户登录shell。<br>chfn命令提供了在/etc/passwd文件的备注字段中存储信息的标准方法。<br>chage命令用来帮助管理用户账户的有效期。</p></li></ol><h3 id="Linux-组"><a href="#Linux-组" class="headerlink" title="Linux 组"></a>Linux 组</h3><p>组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。<br>每个组都有唯一的GID——跟UID类似，在系统上这是个唯一的数值。</p><h4 id="etc-group-文件"><a href="#etc-group-文件" class="headerlink" title="/etc/group 文件"></a>/etc/group 文件</h4><p>/etc/group文件包含系统上用到的每个组的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/group</span><br><span class="line">root:x:0:</span><br><span class="line">bin:x:1:</span><br><span class="line">daemon:x:2:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>/etc/group文件有4个字段：</p><ul><li>组名</li><li>组密码</li><li>ID</li><li>属于该组的用户列表</li></ul><h4 id="创建新组"><a href="#创建新组" class="headerlink" title="创建新组"></a>创建新组</h4><p>groupadd命令可在系统上创建新组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd shared</span><br><span class="line">$ tail /etc/group</span><br><span class="line">docker:x:992:</span><br><span class="line">shared:x:1002:</span><br></pre></td></tr></table></figure></p><p>usermod命令将用户被分配到该组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -G shared test</span><br><span class="line">$</span><br><span class="line">$ tail /etc/group</span><br><span class="line">shared:x:1002:test</span><br><span class="line">test:x:1003:</span><br></pre></td></tr></table></figure></p><h4 id="修改组"><a href="#修改组" class="headerlink" title="修改组"></a>修改组</h4><p>groupmod命令可以修改已有组的GID（加-g选项）或组名（加-n选项）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupmod -n sharering shared</span><br><span class="line">$ tail /etc/group</span><br><span class="line">google-sudoers:x:1000:veininguo</span><br><span class="line">test:x:1003:</span><br><span class="line">sharering:x:1002:test</span><br></pre></td></tr></table></figure></p><h3 id="文件权限-1"><a href="#文件权限-1" class="headerlink" title="文件权限"></a>文件权限</h3><h4 id="文件权限符"><a href="#文件权限符" class="headerlink" title="文件权限符"></a>文件权限符</h4><p>ls命令可以用来查看Linux系统上的文件、目录和设备的权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">total 1693436</span><br><span class="line">drwxrwxr-x. 2 veininguo veininguo         6 Nov 21 16:08 data_file</span><br></pre></td></tr></table></figure></p><p>输出结果的第一个字段就是描述文件和目录权限的编码。<br>第一个字符代表了对象的类型：</p><ul><li>-代表文件</li><li>d代表目录</li><li>l代表链接</li><li>c代表字符型设备</li><li>b代表块设备</li><li>n代表网络设备</li></ul><p>之后有3组三字符的编码。每一组定义了3种访问权限：</p><ul><li>r代表对象是可读的</li><li>w代表对象是可写的</li><li>x代表对象是可执行的</li></ul><p>若没有某种权限，在该权限位会出现单破折线。这3组权限分别对应对象的3个安全级别：</p><ul><li>对象的属主</li><li>对象的属组</li><li>系统其他用户</li></ul><h4 id="改变权限"><a href="#改变权限" class="headerlink" title="改变权限"></a>改变权限</h4><p>chmod命令用来改变文件和目录的安全性设置：<code>chmod options mode file</code></p><p>chmod命令采用了另一种方法。下面是在符号模式下指定权限的格式：<code>[ugoa…][[+-=][rwxXstugo…]</code><br>第一组字符定义了权限作用的对象：</p><ul><li>u代表用户</li><li>g代表组</li><li>o代表其他</li><li>a代表上述所有</li></ul><p>现有权限基础上增加权限（+），还是在现有权限基础上移除权限（-），或是将权限设置成后面的值（=）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ chmod o+r newfile</span><br><span class="line">$ ls -lF newfile</span><br><span class="line">-rwxrw-r-- 1 rich rich 0 Sep 20 19:16 newfile</span><br><span class="line">$</span><br><span class="line">$ chmod u-x newfile</span><br><span class="line">$ ls -lF newfile</span><br><span class="line">-rw-rw-r-- 1 rich rich 0 Sep 20 19:16 newfile</span><br></pre></td></tr></table></figure></p><h4 id="改变所属关系"><a href="#改变所属关系" class="headerlink" title="改变所属关系"></a>改变所属关系</h4><p>chown命令用来改变文件的属主。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ chown dan newfile</span><br><span class="line">$ ls -l newfile</span><br><span class="line">-rw-rw-r-- 1 dan rich 0 Sep 20 19:16 newfile</span><br><span class="line">$</span><br><span class="line">$ chown dan.shared newfile</span><br><span class="line">$ ls -l newfile</span><br><span class="line">-rw-rw-r-- 1 dan shared 0 Sep 20 19:16 newfile</span><br></pre></td></tr></table></figure></p><p>chgrp命令可以更改文件或目录的默认属组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chgrp shared newfile</span><br><span class="line">$ ls -l newfile</span><br><span class="line">-rw-rw-r-- 1 rich shared 0 Sep 20 19:16 newfile</span><br></pre></td></tr></table></figure></p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>使用Linux系统时，需要作出的决策之一就是为存储设备选用什么文件系统。大多数Linux发行版在安装时会非常贴心地提供默认的文件系统，了解一下可用的选择有时也会有所帮助。</p><h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><ol><li>ext文件系统，最早的文件系统，叫作扩展文件系统 （extended filesystem，简记为ext）。</li><li>ext2文件系统，ext文件系统有不少限制，比如文件大小不得超过2 GB。ext文件系统就升级到了第二代扩展文件系统，叫作ext2。</li></ol><h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p>日志文件系统为Linux系统增加了一层安全性。它不再使用之前先将数据直接写入存储设备再更新索引节点表的做法，而是先将文件的更改写入到临时文件（称作日志， journal）中。在数据成功写到存储设备和索引节点表之后，再删除对应的日志条目。</p><ol><li>ext3文件系统，它采用和ext2文件系统相同的索引节点表结构，但给每个存储设备增加了一个日志文件，以将准备写入存储设备的数据先记入日志。</li><li>ext4文件系统，扩展ext3文件系统功能的结果是ext4文件系统。</li><li>Reiser文件系统。</li><li>JFS文件系统，最老的日志文件系统之一， 是IBM在1990年为其Unix衍生版AIX开发的。</li><li>XFS文件系统，美国硅图公司（SGI）最初在1994年为其商业化的IRIX Unix系统开发的。</li></ol><h3 id="写时复制文件系统"><a href="#写时复制文件系统" class="headerlink" title="写时复制文件系统"></a>写时复制文件系统</h3><p>写时复制（copy-on-write， COW）的技术。COW利用快照兼顾了安全性和性能。如果要修改数据，会使用克隆或可写快照。修改过的数据<br>并不会直接覆盖当前数据，而是被放入文件系统中的另一个位置上。即便是数据修改已经完成，之前的旧数据也不会被重写。</p><ol><li>ZFS文件系统，没有使用GPL许可。OpenZFS项目有可能改变这种局面。</li><li>Btrf文件系统，被称为B树文件系统。它是由Oracle公司于2007年开始研发的。 </li></ol><h3 id="操作文件系统"><a href="#操作文件系统" class="headerlink" title="操作文件系统"></a>操作文件系统</h3><p>创建分区：fdisk工具用来帮助管理安装在系统上的任何存储设备上的分区。<br>创建文件系统：每个文件系统命令都有很多命令行选项，允许你定制如何在分区上创建文件系统。</p><h3 id="逻辑卷管理"><a href="#逻辑卷管理" class="headerlink" title="逻辑卷管理"></a>逻辑卷管理</h3><p>如果硬盘上没有地方了，你就必须弄一个更大的硬盘，然后手动将已有的文件系统移动到新的硬盘上。Linux逻辑卷管理器（logical volume manager， LVM）软件包可以用来做动态地添加存储空间。</p><h2 id="安装软件程序"><a href="#安装软件程序" class="headerlink" title="安装软件程序"></a>安装软件程序</h2><p>Linux开发人员通过把软件打包成更易于安装的预编译包，在Linux上能见到的各种包管理系统（package management system， PMS），以及用来进行软件安装、管理和删除的命令行工具。</p><h3 id="基于-Debian-的系统"><a href="#基于-Debian-的系统" class="headerlink" title="基于 Debian 的系统"></a>基于 Debian 的系统</h3><p>dpkg命令是基于Debian系PMS工具的核心。包含在这个PMS中的其他工具有：</p><ul><li>apt-get</li><li>apt-cache</li><li>aptitude</li></ul><h3 id="基于-Red-Hat-的系统"><a href="#基于-Red-Hat-的系统" class="headerlink" title="基于 Red Hat 的系统"></a>基于 Red Hat 的系统</h3><p>和基于Debian的发行版类似，基于Red Hat的系统也有几种不同的可用前端工具。常见的有以下3种。</p><ul><li>yum：在Red Hat和Fedora中使用。</li><li>urpm：在Mandriva中使用。</li><li>zypper：在openSUSE中使用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Linux&quot;&gt;&lt;a href=&quot;#什么是-Linux&quot; class=&quot;headerlink&quot; title=&quot;什么是 Linux&quot;&gt;&lt;/a&gt;什么是 Linux&lt;/h2&gt;&lt;p&gt;Linux可划分为以下四部分：&lt;/p&gt;
&lt;h3 id=&quot;Linux内核&quot;&gt;&lt;a href=&quot;#Linux内核&quot; class=&quot;headerlink&quot; title=&quot;Linux内核&quot;&gt;&lt;/a&gt;Linux内核&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;系统内存管理&lt;/li&gt;
&lt;li&gt;软件程序管理&lt;/li&gt;
&lt;li&gt;硬件设备管理&lt;/li&gt;
&lt;li&gt;文件系统管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;GNU工具&quot;&gt;&lt;a href=&quot;#GNU工具&quot; class=&quot;headerlink&quot; title=&quot;GNU工具&quot;&gt;&lt;/a&gt;GNU工具&lt;/h3&gt;&lt;p&gt;GNU组织（GNU是GNU’s Not Unix的缩写），模仿Unix操作系统开发一系列标准的计算机系统工具，但没有可以运行它们的内核系统。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://veinin.com/tags/Linux/"/>
    
      <category term="Linux 命令行" scheme="https://veinin.com/tags/Linux-%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>《单核工作法》读书笔记</title>
    <link href="https://veinin.com/2017/11/12/reading-notes-monotasking/"/>
    <id>https://veinin.com/2017/11/12/reading-notes-monotasking/</id>
    <published>2017-11-12T15:30:00.000Z</published>
    <updated>2018-04-01T07:47:18.878Z</updated>
    
    <content type="html"><![CDATA[<p>《单核工作法图解》是Staffan先生多年自我管理实践与咨询经验的结晶，阅读这本书让人收获颇多。该书轻松易读，引用了大量<br>前沿研究，也提出了一系列可实践的方法。</p><p>自我管理方法不是科学，是技术。脑科学的研究日新月异，但多数人不会去阅读科研文献，就需要有人把这些新发现翻译成可操<br>作的技术，才能运用到生活中，所以自我管理方法也在随着科学的发展而不停前进。</p><p>正确的方法是一个方面，另一个重要的方面是，你能不能把正确的方法转化为持续的行动，并且养成长久的习惯。讲方法的<br>书其实用不着贪多求全，关键是看你能不能用起来。</p><a id="more"></a><p>怎样的方法是真正可以帮助我们的方法？两点心得与你分享：<br>一、它应是一套有逻辑的系统方法，而不光是鸡汤；<br>二、这套方法应当易于使用。</p><h2 id="果壳中的单核工作法"><a href="#果壳中的单核工作法" class="headerlink" title="果壳中的单核工作法"></a>果壳中的单核工作法</h2><h3 id="什么是单核工作法？"><a href="#什么是单核工作法？" class="headerlink" title="什么是单核工作法？"></a>什么是单核工作法？</h3><p><strong>快捷清单</strong> 是单核工作法的核心。它最多存放5项当前最重要的任务。如果还要添加更多的任务，就必须删掉原有任务。</p><p><strong>单核时段</strong> 只用于专心处理快捷清单上的一项任务。以全景闹钟作为单核时段的结束。</p><p><strong>全景闹钟</strong> 应该设置在分针的下一个竖直位置，例如9:00、9:30、10:00，但距离现在不少于25分钟。在闹钟响铃时，<br>把注意力从单核时段切换到全景时段。</p><p><strong>全景时段</strong> 期间查看所有的待办任务，并且思考“拉金问题”（Lakein’squestion）：此时此刻，我的时间最好用来做什么？</p><p><strong>颠倒优先级</strong> 是指把紧急任务排到重要任务之前，应该避免。完成最重要的任务，我们的长期目标才能实现。</p><h3 id="单核工作法的五大原理"><a href="#单核工作法的五大原理" class="headerlink" title="单核工作法的五大原理"></a>单核工作法的五大原理</h3><ul><li>原理1：已经开始的任务会无条件地占据我们每天的所思所想，直到被完成或删除。</li><li>原理2：多任务切换不仅会拖慢速度，而且注定会耗尽大脑能量。</li><li>原理3：我们应该负起区分优先级的责任，选出现在头号重要的事来做。因为会不断有各种事情出现在我们脑海中，值得做的事数不清。</li><li>原理4：经常休息、好好睡觉、锻炼身体、吃得健康——我们必须在这些事情上进行投资，才能在日常工作中稳步前进。</li><li>原理5：我们的方法必须适应环境；要根据自己最新的个人经验，一点一点调整。没有放之四海皆准的方法。</li></ul><h3 id="颠倒优先级"><a href="#颠倒优先级" class="headerlink" title="颠倒优先级"></a>颠倒优先级</h3><p>“我把问题分成两类：重要的和紧急的。紧急的问题不重要，重要的问题从来不紧急。”<br>把紧急任务放在重要任务之前做，就是颠倒优先级。<br>要事第一。你花在紧急事情上的时间越多，紧急工作就会堆积得越高。那些本来重要但不紧急的任务也会变成紧急任务。</p><h3 id="“我没时间”是谎言"><a href="#“我没时间”是谎言" class="headerlink" title="“我没时间”是谎言"></a>“我没时间”是谎言</h3><p>我们每天都有新的24小时，说“不”的原因并非缺少时间，真实原因是：我们给其他任务排了更高的优先级。因此，别再说“我没时间”了。<br>制定你的优先级顺序，就是要选择把时间用在哪里。一旦定下来就别不好意思。保持透明度，允许其他人直面和质疑你的优先级排序，他们也会尊重和接受你的“不”。千万别说“我没时间”了。</p><h3 id="全景闹钟"><a href="#全景闹钟" class="headerlink" title="全景闹钟"></a>全景闹钟</h3><p>使用计时器。使用单核工作法时，为了在全景模式和单核模式中切换，我们要在单核时段开始之前设置定时响铃的全景闹钟。闹钟响铃提醒我们重新评估优先级。</p><p><img src="/images/monotasking_01.png" alt=""></p><h2 id="削减待办任务"><a href="#削减待办任务" class="headerlink" title="削减待办任务"></a>削减待办任务</h2><p><strong>本周目的</strong> 把你的专注点放在“为什么”上。在这一周，你最想取得什么进展、得到什么收获、产出什么成果？把首要目的写入一张索引卡片，贴在工作间隔板上。每当迷茫的时候，本周目的可以提醒你。</p><p><strong>快捷清单</strong> 包含当前最重要的5项任务。每天早晨把它们写在一张纸上。如果还要添加更多的任务，必须去掉原有的——要么完成一项、要么直接删掉一项。</p><p><strong>集草器清单</strong> 收集一些未排序的任务和想法，都是你没有拒绝、但也不会马上做的事情。集草器清单则完全没有限制，也不排列优先级。你可以时不时添加内容进去。有什么点子就集中放在这里，免得一转身忘了。表格中的每项任务应该包括“目标、利益关系人、进入清单的日期”这三项属性。</p><p><strong>除草</strong> 是删掉集草器清单里的内容，每个星期都要做。除草是一项必要工作，以便保持清单可读、及时、可靠。你随时都可以根据需要在集草器清单里增加内容，但应该每周做一次批量清理。</p><p><img src="/images/monotasking_02.png" alt=""></p><h2 id="现在专注一件事"><a href="#现在专注一件事" class="headerlink" title="现在专注一件事"></a>现在专注一件事</h2><p><strong>多任务的误区</strong> 误导雇主们到处寻找三头六臂的人才，看谁有同时玩转很多事的本领。我们自以为能多线程处理任务，其实只是在多个任务间切换。任务切换会给手头的工作带来更多错误，拖慢速度。</p><p><strong>单核与全景</strong> 两种时段帮你建立节奏感。单核工作意味着聚焦放大一项且仅此一项任务；全景总览意味着放眼全局，选择当前最重要的一件事。我们要在这两种模式间互相切换。</p><p><strong>戒绝通知</strong> 的方法要求在单核工作期间关掉你能听到和看到的通知提醒。看一眼电子邮件之后要重新达到之前的工作状态，所花费的时间超过一分钟。自动推送的通知消息会引发服务生效应的负面作用，妨碍我们对有价值任务的专注。</p><p><strong>志愿者小时</strong> 是应对中断的一个实用策略。如果同事在上午找你讨论问题，可以引导他的需求，安排一次下午的会议。这样你就有继续工作的余地，也能为同事的问题提前做准备。</p><p><strong>时间压力</strong> 是自己给自己的。别人可能会说他的事情比较急，但时间压力是我们的内部事务。使用单核工作法，不用担心自己没有尽力，因为我们已将重要的任务排在紧急的任务之前。</p><p><img src="/images/monotasking_03.png" alt=""></p><h2 id="永不拖延"><a href="#永不拖延" class="headerlink" title="永不拖延"></a>永不拖延</h2><p><strong>时间不一致</strong> 是指人们在评估自己未来的忙碌程度时，会认为近期超忙，远期不那么忙。这是人类思维的误区。跳出误区的方法是，现在就做最重要的事，对紧急程度不作考虑。</p><p><strong>可支配时间</strong> 的浪费意味着，你本来有一段受保护的时间来处理最重要的任务，但却花在了其他事情上。我们必须确保足够珍视可支配时间的价值。浪费掉的时间不会再回来。</p><p><strong>服务生效应</strong> 让我们知道，未完成的任务更容易被记住。正确利用这个效应有助于停止拖延；错误使用则会让拖延更严重。可以动用潜意识思维来促使我们完成最重要的任务，而不是其他任务。</p><p><strong>自动坚持任务</strong> 是服务生效应的延伸。人类有一种强烈的意愿，想要完成被中断的任务。在下午下班前开始一项任务，这会鼓励你自己明天早晨回来继续做这件事。</p><p><strong>内在动力</strong> 比奖励和惩罚的影响更大。自主是为自己的选择负起责任。专精是一种不断渴求进步的心态。目的可以激发你成为比自己更伟大事物的一部分。</p><p><img src="/images/monotasking_04.png" alt=""></p><h2 id="循序渐进"><a href="#循序渐进" class="headerlink" title="循序渐进"></a>循序渐进</h2><p><strong>任务分解</strong> 可能是战胜拖延最有效的方式。开始做一项小任务，要比开始做一项大任务更容易。但要把大任务的整体目的牢记在心，而且不要提前把所有子任务规划得太详细。</p><p><strong>拉金问题</strong> ：“此时此刻我的时间最好用来做什么？”这是我们必须经常问自己的问题。要让工作取得成效，就必须经常检查成果并调整规划。</p><p><strong>时间盒子</strong> 是要先确定：什么时候开始，什么时候结束，专注在什么任务上。这与工作成果的多少好坏无关，纯粹与注意力有关。当然，良好的专注度会带来更高的产出。</p><p><strong>幼鸟先飞</strong> 让我们把想法尽早分享给别人，从而获得反馈。这些反馈有助于确定下一步行动的最佳方向：看，这些是已经实现的，接下来怎么做最好？</p><p><strong>虚假紧急</strong> 是一个坑人的骗局，让你把力气花在一些次要的任务上。它让你进入来者不拒的响应状态。但是用客观标准衡量，这些任务其实不重要，反而耽误事。它们让你忙来忙去，阻碍了真正的工作。</p><p><img src="/images/monotasking_05.png" alt=""></p><h2 id="简化协作"><a href="#简化协作" class="headerlink" title="简化协作"></a>简化协作</h2><p><strong>富足心态</strong> 是把你的时间、知识和人脉分享给同事。这不仅仅是助人为乐，他们也会回过头来分享给你。[1]对自己面前的选项有一个全面认识可以帮你打开局面，得到双赢的解决方案。</p><p><strong>相处的责任</strong> 我们都应该承担起来。要明白，职场中的每个人都是和你我一样的独立个体。通过认识到他们的强项和弱项所在，我们可以更好地在协作中获益。</p><p><strong>高效会议</strong> 要求你不仅仅是例行公事地逢会必到。这场会议有没有限定一项会议目的？你的贡献是否无关紧要？你自己组织会议时也要注意，如果没有清晰地描述出唯一的会议目的，就不要发出邀请。</p><p><strong>议会场合</strong> 着眼于未来、以更有创造性的方式来讨论事情。永远不要为过去的事件责怪任何人，不要为核心价值观争论不休。想想从这里出发该如何往前走，是一种更有建设性的思路。</p><p><strong>透明度</strong> 要求我们做到言出必践。如果这样还是落入了认知失调的陷阱，就必须后退一步，以开放的心态环顾四周，找出一条让各方共赢的新路径。</p><p><img src="/images/monotasking_06.png" alt=""></p><h2 id="给创意充电"><a href="#给创意充电" class="headerlink" title="给创意充电"></a>给创意充电</h2><p><strong>经常休息</strong> 不仅可以让大脑歇口气，还能够激活潜意识思维的创造力。当你休息回来时，经常会有很棒的新想法。</p><p><strong>充氧的大脑</strong> 是我们散步或运动时得到的效果。研究发现，成人如果每周进行150分钟的身体锻炼，就更不容易在白天昏昏欲睡，也更不容易出现注意力涣散的情况。</p><p><strong>健康饮食</strong> 会影响到我们思维、创意和正确记忆的能力。那些快速释放葡萄糖的食物会让我们的能量忽高忽低。水果、蔬菜、全麦食品和适量摄入的蛋白质能产生更稳定的输出，给大脑持续提供能量。</p><p><strong>充足睡眠</strong> 的原则已经被证实可以提高生产力、减少犯错。睡眠不足还意味着失去了快速眼动睡眠时间，导致难以完成记忆编码，无法对新记忆进行删除和整理。</p><p><strong>思考的时候拿支铅笔</strong> 能够补充我们极度有限的工作记忆。大脑的结构天生不适合同时思考两件事情，而写下来的笔记更有利于前瞻记忆对问题进行处理。</p><p><strong>思维导图</strong> 对长期记忆很有帮助。一项研究还显示它能提高批判性思维能力。我们的大脑喜欢在概念之间建立连接，可惜顺序结构的笔记和线性思维方式都做不到这一点。</p><p><img src="/images/monotasking_07.png" alt=""></p><p>本文大部分内容摘自：《单核工作法》，<a href="https://book.douban.com/subject/27177909/" target="_blank" rel="noopener">豆瓣读书</a>、<a href="http://www.ituring.com.cn/book/1925" target="_blank" rel="noopener">图灵社区</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《单核工作法图解》是Staffan先生多年自我管理实践与咨询经验的结晶，阅读这本书让人收获颇多。该书轻松易读，引用了大量&lt;br&gt;前沿研究，也提出了一系列可实践的方法。&lt;/p&gt;
&lt;p&gt;自我管理方法不是科学，是技术。脑科学的研究日新月异，但多数人不会去阅读科研文献，就需要有人把这些新发现翻译成可操&lt;br&gt;作的技术，才能运用到生活中，所以自我管理方法也在随着科学的发展而不停前进。&lt;/p&gt;
&lt;p&gt;正确的方法是一个方面，另一个重要的方面是，你能不能把正确的方法转化为持续的行动，并且养成长久的习惯。讲方法的&lt;br&gt;书其实用不着贪多求全，关键是看你能不能用起来。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时间管理" scheme="https://veinin.com/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
      <category term="单核工作法" scheme="https://veinin.com/tags/%E5%8D%95%E6%A0%B8%E5%B7%A5%E4%BD%9C%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Centos 从官方 Yum Repositories 安装 MySQL</title>
    <link href="https://veinin.com/2017/11/08/centos-install-mysql/"/>
    <id>https://veinin.com/2017/11/08/centos-install-mysql/</id>
    <published>2017-11-08T13:55:49.000Z</published>
    <updated>2017-11-08T14:12:47.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>2013年10月，MySQL开发团队正式启动了对 Yum 版本库的支持。这意味着您现在可以确保您拥有从源代码直接安装的最新版本的 MySQL！<br>本文将在全新的CentOS 6中安装 MySQL 5.7。5.7是当前默认最新版本，当然你也可以选择直接安装其他版本，可参考本文关于 <a href="http://localhost:8080/2017/11/08/centos-install-mysql/#选择指定版本安装" target="_blank" rel="noopener">选择指定版本安装</a>章节。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Yum 版本库文件需要从 MYSQL 开发者网站下载，安装完成后，使用 <code>yum update</code> 来确保你运行的是最新的MySQL版本，包括其安全更新，Yum 会帮你解决任何依赖关系，这使你安装过程变成很简单。</p><p>刚开始，你需要访问 <a href="https://dev.mysql.com/downloads/repo/" target="_blank" rel="noopener">MySQL Repositories</a> ，选择 <a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">MySQL Yum Repository</a>，根据你 CentOS 的版本，选择相应的下载链接，然后点击 Download。<br><img src="/images/02_centos_install_mysql_download.jpg" alt=""></p><p>右键 “No thanks, just start my download.” ， 点击 “复制链接地址”。<br><img src="/images/03_centos_install_mysql_link.jpg" alt=""></p><p>登录到您的服务器，根据复制的连接地址然后下载此文件。以下只是一个示例网址 - 你可能需要检查这个地址是否正确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el6-11.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>从本地文件中安装下载好的 rpm 文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum localinstall mysql57-community-release-el6-11.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>您现在已经在服务器上从官方存储库安装了，但尚未安装任何软件。存储库包括MySQL服务器，MySQL Workbench管理工具和ODBC驱动程序。让我们安装MySQL服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mysql-community-server</span><br></pre></td></tr></table></figure></p><p>启动 MySQL 服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysqld start</span><br></pre></td></tr></table></figure></p><p>配置MySQL在重新启动时自动启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chkconfig mysqld on</span><br><span class="line">chkconfig --list mysqld</span><br></pre></td></tr></table></figure></p><p>到此，你的MySQL服务已经安装完成。</p><hr><h2 id="重置-Root-密码"><a href="#重置-Root-密码" class="headerlink" title="重置 Root 密码"></a>重置 Root 密码</h2><p>如果你安装的是 MySQL 5.7 版本，root 密码会自动生成，并在启动日志 /var/log/mysqld.log 里面输出。</p><p>获取初始密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;password&quot; /var/log/mysqld.log</span><br><span class="line">2017-11-08T05:09:31.492454Z 1 [Note] A temporary password is generated for root@localhost: 1!Ta0EEis-yR</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">登录 root 账号，如果默认密码为空，请去除 -p 参数：</span><br><span class="line">mysql -uroot -p &apos;1!Ta0EEis-yR&apos;</span><br></pre></td></tr></table></figure><p>用你的新密码替换字符串 “ your_new_password “，如果你的版本是 5.6 或之前版本，请使用一下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.user SET Password=PASSWORD(&apos;your_new_password&apos;) WHERE User=&apos;root&apos;;</span><br><span class="line">flush privileges;</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p><p>如果你的版本是 5.7 版本，请使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER USER() IDENTIFIED BY &apos; your_new_password &apos;;</span><br></pre></td></tr></table></figure></p><p>如果提示：ERROR 1819 (HY000): Your password does not satisfy the current policy requirements，那是因为默认开启了简单密码检查政策，你可以通过以下命令关闭其功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password_policy=0;</span><br></pre></td></tr></table></figure></p><hr><h2 id="选择指定版本安装"><a href="#选择指定版本安装" class="headerlink" title="选择指定版本安装"></a>选择指定版本安装</h2><p>使用 MySQL Yum 存储库时，默认情况下选择最新的 GA 版本（当前为 MySQL 5.7）进行安装。</p><p>在 MySQL Yum 存储库中，MySQL社区服务器的不同版本托管在不同的子库中。最新的 GA 系列（目前是 MySQL 5.7）的子库是默认启用的，所有其他系列的子库（例如MySQL 5.6版本）默认是禁用的。可以使用以下命令查看 MySQL Yum 存储库中的所有子存储库，并查看其中哪些被启用或禁用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist all | grep mysql</span><br></pre></td></tr></table></figure></p><p>如果要安装最新的版本，不需要配置。如果要选择特定版本，请在运行安装命令之前，禁用最新 GA 版本的子库，并启用特定版本的子库。如果你的平台支持 yum-config-manager，你可以通过以下这些命令来实现，这些命令将禁用 5.7 版本的 subrepository，并启用5.6 版本的 subrepository：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --disable mysql57-community</span><br><span class="line">sudo yum-config-manager --enable mysql56-community</span><br></pre></td></tr></table></figure></p><p>除了使用 yum-config-manager 命令之外，还可以通过手动编辑 /etc/yum.repos.d/mysql-community.repo 文件来选择发行版，项目是一个典型的文件系列子库的条目信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysql57-community]</span><br><span class="line">name=MySQL 5.7 Community Server</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure></p><p>找到要配置的子库的条目，然后编辑该 enabled 选项。指定 enabled=0 禁用子库，或 enabled=1 启用子库。例如，要安装MySQL 5.6，请确保您拥有 enabled=0 MySQL 5.7版本的上述子目录条目，并且具有 enabled=1 MySQL 5.6版本的条目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Enable to use MySQL 5.6</span><br><span class="line">[mysql56-community]</span><br><span class="line">name=MySQL 5.6 Community Server</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-5.6-community/el/6/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure></p><p>最后再运行安装命令（mysql-community-server），那么你安装到的是你想要的指定版本的 MySQL。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;2013年10月，MySQL开发团队正式启动了对 Yum 版本库的支持。这意味着您现在可以确保您拥有从源代码直接安装的最新版本的 MySQL！&lt;br&gt;本文将在全新的CentOS 6中安装 MySQL 5.7。5.7是当前默认最新版本，当然你也可以选择直接安装其他版本，可参考本文关于 &lt;a href=&quot;http://localhost:8080/2017/11/08/centos-install-mysql/#选择指定版本安装&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;选择指定版本安装&lt;/a&gt;章节。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CentOS" scheme="https://veinin.com/tags/CentOS/"/>
    
      <category term="MySQL" scheme="https://veinin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Lua 表序列化与反序列化</title>
    <link href="https://veinin.com/2017/11/01/lua-serialize-table/"/>
    <id>https://veinin.com/2017/11/01/lua-serialize-table/</id>
    <published>2017-11-01T14:11:17.000Z</published>
    <updated>2017-11-01T14:49:03.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天看了下同事写的关于 Lua 序列化的代码，觉得代码存在几个问题，其主要欠缺以下几点：</p><h3 id="1-支持循环引用的-table，反序列后，能正确恢复循环引用状态，如："><a href="#1-支持循环引用的-table，反序列后，能正确恢复循环引用状态，如：" class="headerlink" title="1.支持循环引用的 table，反序列后，能正确恢复循环引用状态，如："></a>1.支持循环引用的 table，反序列后，能正确恢复循环引用状态，如：</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a.b = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, a&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="2-字符串内支持内嵌双引号、支持转义字，如一下字符串："><a href="#2-字符串内支持内嵌双引号、支持转义字，如一下字符串：" class="headerlink" title="2.字符串内支持内嵌双引号、支持转义字，如一下字符串："></a>2.字符串内支持内嵌双引号、支持转义字，如一下字符串：</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> s = <span class="string">"ss\"aa\"bb\ncc"</span></span><br></pre></td></tr></table></figure><p>序列化后我希望是这样子：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'ss"aa"bb\ncc'</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="3-Table-数组部分序列化后隐藏每个值得索引值，如："><a href="#3-Table-数组部分序列化后隐藏每个值得索引值，如：" class="headerlink" title="3.Table 数组部分序列化后隐藏每个值得索引值，如："></a>3.Table 数组部分序列化后隐藏每个值得索引值，如：</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure><p>如果保留数组的索引值，会是这样子：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;[<span class="number">1</span>]=<span class="number">4</span>,[<span class="number">2</span>]=<span class="number">7</span>,[<span class="number">3</span>]=<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure></p><p>为了更加节省空间，我希望的是这样子：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>对于以上几点要求，Google 搜了下，并没有找到满足上面需求的合适版本，于是在前人的基础上做了一些改进。<br>实现部分，序列化函数函数为 table.tostring。反序列化函数相对来说比较简单，可以直接通过函数loadstring进行加载，下面实现为函数 table.loadstring</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table.tostring</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">local</span> mark   = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> assign = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(tbl, parent)</span></span></span><br><span class="line">mark[tbl] = parent</span><br><span class="line"><span class="keyword">local</span> tmp = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(tbl) <span class="keyword">do</span></span><br><span class="line"><span class="keyword">local</span> typek = <span class="built_in">type</span>(k)</span><br><span class="line"><span class="keyword">local</span> typev = <span class="built_in">type</span>(v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = typek == <span class="string">"number"</span> <span class="keyword">and</span> <span class="string">"["</span> .. k ..<span class="string">"]"</span> <span class="keyword">or</span> k</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> typev == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> dotkey = parent .. (typek == <span class="string">"number"</span> <span class="keyword">and</span> key <span class="keyword">or</span> <span class="string">"."</span> .. key)</span><br><span class="line"><span class="keyword">if</span> mark[v] <span class="keyword">then</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(assign, dotkey .. <span class="string">"="</span> .. mark[v])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> typek == <span class="string">"number"</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tmp, serialize(v,dotkey))</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tmp, key .. <span class="string">"="</span> .. serialize(v, dotkey))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> typev == <span class="string">"string"</span> <span class="keyword">then</span></span><br><span class="line">v = <span class="built_in">string</span>.<span class="built_in">gsub</span>(v, <span class="string">"\n"</span>, <span class="string">"\\n"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">match</span>( <span class="built_in">string</span>.<span class="built_in">gsub</span>(v,<span class="string">"[^'\"]"</span>,<span class="string">""</span>), <span class="string">'^"+$'</span> ) <span class="keyword">then</span></span><br><span class="line">v = <span class="string">"'"</span> .. v .. <span class="string">"'"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">v = <span class="string">'"'</span> .. v .. <span class="string">'"'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">v = <span class="built_in">tostring</span>(v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> typek == <span class="string">"number"</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tmp, v)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tmp, key .. <span class="string">"="</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"&#123;"</span> .. <span class="built_in">table</span>.<span class="built_in">concat</span>(tmp, <span class="string">","</span>) .. <span class="string">"&#125;"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> serialize(t, <span class="string">"ret"</span>) .. <span class="built_in">table</span>.<span class="built_in">concat</span>(assign,<span class="string">" "</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table.loadstring</span><span class="params">(str)</span></span></span><br><span class="line"><span class="keyword">local</span> chunk = loadstring(<span class="string">"do local ret = "</span> .. str .. <span class="string">" return ret end"</span>)</span><br><span class="line"><span class="keyword">if</span> chunk <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> chunk()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>测试代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;a = <span class="number">1</span>, b = <span class="number">2</span>&#125;</span><br><span class="line">t.rt = &#123;c = <span class="number">3</span>, d = <span class="number">4</span>, t&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> s = <span class="built_in">table</span>.<span class="built_in">tostring</span>(t)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">-- 输出 &#123;b=2,a=1,rt=&#123;c=3,d=4&#125;&#125;ret.rt[1]=ret</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tl = <span class="built_in">table</span>.loadstring(s)</span><br><span class="line"><span class="built_in">assert</span>(tl.a == t.a)</span><br><span class="line"></span><br><span class="line"><span class="comment">----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t = &#123;[<span class="string">'foo'</span>]=<span class="string">'bar'</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="string">"ss\"aa\"bb\ncc"</span>, <span class="string">"hello"</span>, &#123;<span class="string">'a'</span>,<span class="string">'b'</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> s = <span class="built_in">table</span>.<span class="built_in">tostring</span>(t)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">-- 输出 &#123;11,22,33,'ss"aa"bb\ncc',"hello",&#123;"a","b"&#125;,foo="bar"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tl = <span class="built_in">table</span>.loadstring(s)</span><br><span class="line"><span class="built_in">assert</span>(tl.foo == t.foo)</span><br><span class="line"><span class="built_in">assert</span>(tl[<span class="number">4</span>] == <span class="string">'ss"aa"bb\ncc'</span>)</span><br></pre></td></tr></table></figure></p><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.codingnow.com/cloud/LuaSerializeTable" target="_blank" rel="noopener">云风的个人空间</a></li><li><a href="http://lua-users.org/wiki/TableUtils" target="_blank" rel="noopener">lua-users wiki</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天看了下同事写的关于 Lua 序列化的代码，觉得代码存在几个问题，其主要欠缺以下几点：&lt;/p&gt;
&lt;h3 id=&quot;1-支持循环引用的-table，反序列后，能正确恢复循环引用状态，如：&quot;&gt;&lt;a href=&quot;#1-支持循环引用的-table，反序列后，能正确恢复循环引用状态，如：&quot; class=&quot;headerlink&quot; title=&quot;1.支持循环引用的 table，反序列后，能正确恢复循环引用状态，如：&quot;&gt;&lt;/a&gt;1.支持循环引用的 table，反序列后，能正确恢复循环引用状态，如：&lt;/h3&gt;&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt; a = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.b = &amp;#123;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, a&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Lua" scheme="https://veinin.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="https://veinin.com/tags/Lua/"/>
    
      <category term="Lua Serialize Table" scheme="https://veinin.com/tags/Lua-Serialize-Table/"/>
    
  </entry>
  
  <entry>
    <title>《番茄工作法图解》读书笔记</title>
    <link href="https://veinin.com/2017/09/24/pomodoro-technique/"/>
    <id>https://veinin.com/2017/09/24/pomodoro-technique/</id>
    <published>2017-09-24T14:06:59.000Z</published>
    <updated>2017-12-04T16:00:40.860Z</updated>
    
    <content type="html"><![CDATA[<p>这本书以我采用番茄工作法的切身经历，向你传授这一工作法的实施全过程，你能看到它如何提高了我的工作效率。另外书中还加入了一些有关人脑思维的研究成果，用以揭示番茄工作法的原理；还包括采用该工作法的若干影响；以及如何根据需要，对该工作法进行调节和扩充。</p><p>番茄工作法能帮你与时间化敌为友，不会再因为还有一小时、一天、一周、一个月的时限而充满焦虑，你要做的就是定好25分钟番茄钟，然后全然专注于手头的任务。如果番茄钟响铃，25分钟结束，而任务还没完成，这并不代表失败。相反，这铃声在为你已连续地工作了一整段时间而喝彩。</p><a id="more"></a><p>什么是番茄工作法？简单说，就是列出你当天要做的事，设置25分钟闹钟，然后从第一件事开始。此外还要有每日回顾、做每日承诺、控制中断、预估要花的工夫等。这本书中我会以自己为例，向你展示如何使用番茄工作法，包括如何记录活动，以及如何挑出最重要的任务。</p><p>在番茄工作法中，1个番茄钟等于25分钟的努力。这是一个不可分割的抽象单位，是一段“一视同仁”的时间。你的基本承诺是，花上25分钟，尽可能地努力做好。在这段时间内，关键不在于当前活动是否能在当前番茄钟内完成，关键是在这一刻你尽了全力。</p><h2 id="番茄工作者的一天中的5个阶段"><a href="#番茄工作者的一天中的5个阶段" class="headerlink" title="番茄工作者的一天中的5个阶段"></a>番茄工作者的一天中的5个阶段</h2><ul><li><strong>计划</strong>：在一天的开始，从积压的工作（称为“活动清单”）中提取最重要的活动，填写到“今日待办”表格中。这就是你当天的自我承诺。</li><li><strong>跟踪</strong>：确定当天活动后，扭启25分钟的番茄钟，从当天活动的第一项开始进行。在每个25分钟的时间段（称为一个番茄钟）内，你要收集一些过程指标，比如计算遇到的中断次数。</li><li><strong>记录</strong>：在一天结束时，将当天收集的数据归档，写入“记录”表格。如果你跟踪了中断次数，就把中断次数写下来。</li><li><strong>处理</strong>：从所记录的原始数据中提取有用信息。例如，可以计算在每个25分钟的时间段，平均遇到几次中断。</li><li><strong>可视化</strong>：最终你要将信息以某种方式组织起来，从中找出改进流程的思路。如果你想获得最适合现实情况的工作习惯，在自我调整过程中，基本上每天都要做这样的回顾。</li></ul><h2 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h2><ul><li><strong>番茄钟一枚</strong></li><li><strong>铅笔一支</strong>（最好带橡皮）</li><li><strong>纸质表格三张</strong>（白纸即可，横格纸更好）　<ul><li>“今日待办”表格，列出打算在今天进行的活动。每天早上这张表要换新的。</li><li>“活动清单”表格，列出最近要进行的活动，随想随填，不用排序。同一张“活动清单”表格可以用很多天，增加新的活动，划掉已完成的。</li><li>记录表格，记录所采样的流程指标，以便对流程进行改进。同一张“记录”表格可以用很多天，以便比较每天的跟踪记录。</li></ul></li></ul><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p>将要完成的活动全部填入“活动清单”表格，每天早晨，从其中选出数项要在今天进行的活动，抄入“今日待办”表格。</p><p>开始工作</p><ul><li>在“今日待办”中选择一项最重要的活动</li><li>启动番茄钟，时间设定为25分钟</li><li>开始工作，直到番茄钟响铃•在“今日待办”表格该活动右侧标一个×</li><li>休息片刻（3～5分钟）</li><li>开始下一个番茄钟，继续工作，直到完成这项活动，在“今日待办”表格上划掉它</li><li>每四个番茄钟后，多休息一会儿（15～30分钟）</li></ul><h2 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h2><p>你将学习如何以合理、有效的方式处理番茄钟时间内的中断和干扰。</p><p>番茄钟期间的中断有以下两种形式</p><h3 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h3><p>具体地说，是直觉向心智发出信号，告诉自己去做当前专注活动以外的事情。<br>要对付内部中断，最佳策略是可视化、接受，然后纳入计划或删除。</p><h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><p>有人找你询问或请你帮忙，并且等你答复。接下来我们看，对于这两类中断，番茄工作法都有相应的处理策略。<br>外部中断具有互动性。有人正在等你答复。他们试图阻止你画×，而你需要一个策略来减少中断。所以必须“扭转”番茄钟和中断之间的依赖关系。<br>如电子邮件和电话很容易，你可以将其关闭。发电子邮件的人不会期待在25分钟内就收到回信。<br>假如有人找你面谈，在不影响结果的前提下，可以请求对方尽量推迟。对于你的同事来说，你今天答复还是周五答复，结果可能是一样的。在对方接受的范围内，建议他尽量往后安排。用稍后的番茄钟重新计划中断事件，而不要在当时直接处理，这样做好处多多。</p><h3 id="处理外部中断的策略"><a href="#处理外部中断的策略" class="headerlink" title="处理外部中断的策略"></a>处理外部中断的策略</h3><ul><li><strong>告知</strong>：“我手头有事，正忙。”</li><li><strong>协商</strong>：“周五再帮你做，行吗？”</li><li><strong>计划</strong>：写下活动名称，稍后为它计划未来的番茄钟。</li><li><strong>答复</strong>：按照承诺回电或答复，不然的话，下次别人就没法信任你了。</li></ul><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>番茄钟具有原子性。不可分割。它是这套流程方法中最小的货币单位。如果任务被放下了，无论是暂时的还是长期的，当前番茄钟都必须作废。它就不能算数了，也不应该画×。你得扭启一个新的25分钟番茄钟代替它。如果需要，可以先休息一下再开始。</p><h2 id="预估任务"><a href="#预估任务" class="headerlink" title="预估任务"></a>预估任务</h2><p>预估和测量在番茄工作法中必不可少。如果没有它们，每天要做计划是很困难的。番茄工作法要求花时间做回顾，这样才能不断改进，继往开来。设法将你“认为自己能做的”与“实际做到的”相对应。跟踪和记录是番茄工作法中的测量方法。<br>你无法预言会出现什么新情况、新问题。但可以通过训练和监控，积累做预估的经验和技巧。</p><p>计算预估的“货币”单位是番茄钟。因为番茄钟的原子性，不能使用小数，如1/2或2.2个番茄钟是不行的。</p><p>假如一项活动预估超过7个番茄钟，说明它太复杂了。需要拆分这项活动。拆开的每项小活动在“活动清单”表格中单独占一行，各自有预估值。活动越大，预估越不准。</p><p>如果一项活动预估不够1个番茄钟，则可以在它旁边标个0。并不是说它要花0个番茄钟来完成，只是表示时间花费小于1个番茄钟。这样的活动在“活动清单”表格中仍然各自占一行。</p><p>本来预估这项活动需要若干个番茄钟，但这些番茄钟用完了，这时要做二次预估。猜测要完成这项活动还需要多少个番茄钟。如果二次预估也不合要求，你可以做三次预估，也是最终预估。</p><p>如果三次预估的数目还不够完成活动，那真是有点失败了。你得分析一下，为什么一次又一次反复地低估这件事？也许应当将活动拆开，降低复杂度。按照常理，活动越复杂，预估越不准。</p><h2 id="应变"><a href="#应变" class="headerlink" title="应变"></a>应变</h2><p>番茄工作法是守则。它提供简单而具体的最佳实践，容易上手。这可能意味着它不适合所有的人或环境。但番茄工作法也内置了应变能力。</p><p>当你了解应用番茄工作法的常规方法之后，可能会有调整它的想法。很好。这就是收集跟踪数据、做每日回顾的目的。但是，请尝试坚持使用常规方法，至少两周内不要做任何改动。你需要亲身经历，以便确切知道哪里适合你、哪里不适合。</p><p>刚开始学习使用番茄工作法，简单朴实就是最好的。一段时间后，你可以根据个人情况进行一些优化。比如说，我在一天里要花大量时间来写电子邮件。为了避免每次收到新邮件都会中断我手头的活动，我可以每天分配两个番茄钟，也就是50分钟来写回信。</p><p>番茄工作法的默认时间表中，每隔三个短休息就要有一个长休息，但不是强制性的，而要根据你的角色和工作内容而定，包括工作场所和个人状态。</p><h2 id="番茄工作法流程示意图"><a href="#番茄工作法流程示意图" class="headerlink" title="番茄工作法流程示意图"></a>番茄工作法流程示意图</h2><p><img src="/images/01_pomodoro-technique_Illustrated.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《番茄工作法图解》，<a href="https://book.douban.com/subject/5916234/" target="_blank" rel="noopener">豆瓣读书</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书以我采用番茄工作法的切身经历，向你传授这一工作法的实施全过程，你能看到它如何提高了我的工作效率。另外书中还加入了一些有关人脑思维的研究成果，用以揭示番茄工作法的原理；还包括采用该工作法的若干影响；以及如何根据需要，对该工作法进行调节和扩充。&lt;/p&gt;
&lt;p&gt;番茄工作法能帮你与时间化敌为友，不会再因为还有一小时、一天、一周、一个月的时限而充满焦虑，你要做的就是定好25分钟番茄钟，然后全然专注于手头的任务。如果番茄钟响铃，25分钟结束，而任务还没完成，这并不代表失败。相反，这铃声在为你已连续地工作了一整段时间而喝彩。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://veinin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时间管理" scheme="https://veinin.com/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
      <category term="番茄工作法" scheme="https://veinin.com/tags/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/"/>
    
  </entry>
  
</feed>
