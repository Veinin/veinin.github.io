<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Veinin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://veinin.com/"/>
  <updated>2019-03-20T13:51:56.171Z</updated>
  <id>https://veinin.com/</id>
  
  <author>
    <name>Veinin Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快节奏多人游戏（4）：延迟补偿</title>
    <link href="https://veinin.com/2019/03/14/fast-paced-multiplayer-04/"/>
    <id>https://veinin.com/2019/03/14/fast-paced-multiplayer-04/</id>
    <published>2019-03-14T14:25:00.000Z</published>
    <updated>2019-03-20T13:51:56.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>前面 3 篇文章阐述了游戏客户端-服务器的架构，我们总结如下：</p><ul><li>服务器从所有客户端获取带有时间戳的输入</li><li>服务器处理输入后更新游戏世界状态</li><li>服务器将游戏世界的快照发送给所有客户端</li><li>客户端发送输入并在本地模拟其效果</li><li>客户端获得游戏世界更新，同步预测状态和权威状态，并插入其他实体已知的过去状态。</li></ul><p>从玩家的角度来看，这里有两个重要的结论：</p><ul><li>玩家可以看到现在的自己</li><li>玩家可以看到其他实体的过去</li></ul><p>这种情况通常表现会不错，但对于时间和空间都非常敏感的事件来说这就会产生问题，例如：爆头射击敌人。</p><a id="more"></a><h2 id="延迟补偿"><a href="#延迟补偿" class="headerlink" title="延迟补偿"></a>延迟补偿</h2><p>当你用你的狙击步枪完美的瞄准了敌人头部，并扣动了扳机，这将是你不能错过的时刻。</p><p>但是你并没有打到。</p><p>为什么会这样呢？</p><p>在之前的客户端-服务器架构解释中，这是因为你射击敌人的头部是在 100 毫秒之前的位置，而不是你射击时的实际位置。</p><p>在某种程度上，它就像在光速的宇宙中游玩，你瞄准了敌人过去的位置，但是当你扣动扳机时他已经消失了。</p><p>幸运的是，有一个相对简单的解决方案，大多数时候这对大多数玩家来说是都是会有一个不错的体验（下面内容讨论了一个例外）。</p><p>以下是它的工作原理：</p><ul><li>当你准备瞄准射击时，客户端会将此事件发送给服务器，服务器会提供完整信息：瞄准射击的确切时间戳以及武器的确切目标。</li><li>至关重要的一步，由于服务器获得带有时间戳的所有输入，因此它可以在过去的任何时刻以可信任的方式重构游戏世界。特别是它可以在任何时间点完全按照任何客户的样子重构游戏世界。</li><li>这意味着服务器可以在你瞄准射击的瞬间确切地知道武器瞄准的内容。虽然对客户端来说敌人头部是的过去位置，但服务器是知道敌人头部在你现在的瞄准位置。</li><li>服务器在射击的时间点处理镜头，并更新客户端。</li></ul><p>现在每个人都很开心！</p><p>服务器很高兴，因为他是服务器，他总是很开心。</p><p>你也很高兴，因为你瞄准了敌人的头部，进行射击，并得到一个爆头奖励！</p><p>敌人可能是唯一一个不完全开心的人。如果他在被击中时站着不动，这是他的错，对吧？如果他在动……哇，你是一个非常棒的狙击手。</p><p>但是，如果他处于空位，背后是一堵墙，然后在他认为自己安全的情况下，在几分之一秒后被枪杀了怎么办？</p><p>嗯，这可能发生。这是你做出的权衡。因为你过去向他射击，他在掩护后的几毫秒可能仍会被射杀。</p><p>这有点不公平，但对于每个参与者来说，这是最合适的解决方案。错过了一次不容错过的射击会更糟糕！</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这是我对于快节奏多人游戏的最后一篇文章。很显然很多事情很难做到正确，但是对于正在发生的事情有明确的概念性理解，这并不是很困难。</p><p>虽然这些文章的读者都是游戏开发者，但它也发现了另一群对这个感兴趣的读者：游戏玩家！从游戏玩家的角度来看，理解为什么有些事情以这种方式发生也是非常有趣的。</p><h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><p>尽管这些技术看起来很聪明，但我不能说对它们有任何功劳，这些文章只是我从其他渠道学到的一些概念所整理成的简单易懂的指南，其中包括文章、源代码以及一些实验。</p><p>关于这个主题相关的文章你可以参考：<a href="http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/" target="_blank" rel="noopener">What Every Programmer Needs To Know About Game Networking</a> 与 <a href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization" target="_blank" rel="noopener">Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization</a></p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/03/02/fast-paced-multiplayer-01/">快节奏多人游戏（1）：客户端与服务器架构</a></li><li><a href="/2019/03/06/fast-paced-multiplayer-02/">快节奏多人游戏（2）：客户端预测与服务器协调</a></li><li><a href="/2019/03/10/fast-paced-multiplayer-03/">快节奏多人游戏（3）：实体插值</a></li><li><a href="/2019/03/14/fast-paced-multiplayer-04/">快节奏多人游戏（4）：延迟补偿</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/lag-compensation.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;前面 3 篇文章阐述了游戏客户端-服务器的架构，我们总结如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器从所有客户端获取带有时间戳的输入&lt;/li&gt;
&lt;li&gt;服务器处理输入后更新游戏世界状态&lt;/li&gt;
&lt;li&gt;服务器将游戏世界的快照发送给所有客户端&lt;/li&gt;
&lt;li&gt;客户端发送输入并在本地模拟其效果&lt;/li&gt;
&lt;li&gt;客户端获得游戏世界更新，同步预测状态和权威状态，并插入其他实体已知的过去状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从玩家的角度来看，这里有两个重要的结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;玩家可以看到现在的自己&lt;/li&gt;
&lt;li&gt;玩家可以看到其他实体的过去&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种情况通常表现会不错，但对于时间和空间都非常敏感的事件来说这就会产生问题，例如：爆头射击敌人。&lt;/p&gt;
    
    </summary>
    
      <category term="多人游戏" scheme="https://veinin.com/categories/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="多人游戏" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
      <category term="多人游戏网络同步" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>快节奏多人游戏（3）：实体插值</title>
    <link href="https://veinin.com/2019/03/10/fast-paced-multiplayer-03/"/>
    <id>https://veinin.com/2019/03/10/fast-paced-multiplayer-03/</id>
    <published>2019-03-10T12:05:00.000Z</published>
    <updated>2019-03-20T13:50:04.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本系列的第一篇文章中，我们介绍了权威服务器的概念及其防止客户欺骗的用处。然而，天真地使用这种技术可能会导致关于可玩性和响应性的潜在问题。在第二篇文章中，我们提出了客户端预测作为克服这些限制的方法。</p><p>这两篇文章的最终结果传递的一组概念与技术是允许玩家通过互联网连接到权威的服务器，并在传输延迟的情况下，让玩家以一种完全像玩单机游戏的感觉方式控制游戏中的角色。</p><p>在本文中，我们将对连接到同一服务器的其他玩家进行探索。</p><a id="more"></a><h2 id="服务器时间步长"><a href="#服务器时间步长" class="headerlink" title="服务器时间步长"></a>服务器时间步长</h2><p>在上一篇文章中，我们描述服务器的行为非常简单：它读取客户的输入，更新游戏状态，并发送结果给客户端。但当多个客户端连接时，服务器的主循环将会有所不同。</p><p>在多个客户端同时连接同一个服务器的情况下，多个客户端可能同时发送输入信息，并且速度将非常快（玩家可以快速的发送诸如按箭头按键、移动鼠标或者点击屏幕的输入操作）。服务器接受每个客户端的输入操作然后马上广播更新后的游戏世界状态将是非常消耗CPU和网络带宽的。</p><p>一个更好的方式是对接受的每个客户端输入进行排队，而不需要接受一个就马上进行处理。相反，游戏世界以一个较低的频率周期性的更新。例如每秒更新 10 次，每次更新之间产生的延迟（这种情况下为 100 毫秒），我们称之为步长。在每次更新循环的迭代中，所有未处理的客户都输入指令都将应用到游戏世界中去（处理这些指令的时间增量可能比时间步长更小一些），并将新状态广播给客户端。</p><p>总之，服务器游戏世界里面的更新步长速率是根据客户端的输入而独立存在的，并且是可以被预测的。</p><h2 id="处理低频率更新"><a href="#处理低频率更新" class="headerlink" title="处理低频率更新"></a>处理低频率更新</h2><p>从客户的角度来看，上面提到的方案可以很容易的进程预测，客户都的预测工作因为与延迟无关，因此在相对不频繁的状态更新的中也是可以进行预测的。但是，由于客户端的低频率广播（继续使用100毫秒的示例），客户端得到的关于其他实体可能在游戏中移动的信息是非常少的。</p><p>在下面的第一个实现中，我们将在接受到服务器的状态更新后再更新角色的位置信息，但这回导致角色的运动非常不稳定，你可能看到的是每 100 毫秒玩家就瞬移一次，而不是很平滑的移动到目的地。</p><p><img src="/images/fpm/fpm3-01.png" alt="fpm"></p><p>根据你正在开发的游戏类型中，有很多方法可以解决这个问题。一般来说，你的游戏实体越可预测，那么就越容易做到正确。</p><h2 id="航位（Dead-reckoning）推算"><a href="#航位（Dead-reckoning）推算" class="headerlink" title="航位（Dead reckoning）推算"></a>航位（Dead reckoning）推算</h2><p>假设你正在制作一款赛车游戏，一辆正在快速行驶的汽车是非常容易预测的。例如，如果它以每秒100米的运行速度，一秒钟后它距离开始的地点大约是100米。</p><p>为什么只能是概略的计算呢？因为一秒钟内，汽车可能会加速或者减速，抑或是转向左侧或右侧一点，这里的关键字是“一点”。不管玩家实际在做什么，汽车的可操作性使得其在高速运行时的任何一个时间点的位置高度依赖于其之前的位置、速度和方向<br>。换句话说，赛车是不可能立即就旋转 180 度的。</p><p>这种情况下，我们应该如何在每 100 毫秒的步长情况下发送服务器的更新呢？客户端每收到一次其他车辆的速度和方向后，在接下来的 100 毫秒它将无法再接收到任何新的信息，但客户端却依旧需要显示车辆正在运行。最简单的解决方案是假设汽车的方向和加速度都会在 100 毫秒内保持不变，我们可以使用这个参数在本地运行汽车的物理模拟。然后，100 毫秒后，当服务器的更新到达时，再将汽车的位置进行校正。</p><p>在很多变动的因素下，这些校正的参数可能会很大，当然也可能相对较小。如果玩家确实把汽车保持在直线上并且不改变汽车的速度，那么预测的位置将和校正位置完全相同。另外，如果玩家遭受到了撞击，那么预测的位置可能会有非常大的错误。</p><p>需要注意的是航行位置推算可以应用于低速的情况，例如战舰。事实上，“航位推算”一词来源于海上航行。</p><h2 id="实体插值"><a href="#实体插值" class="headerlink" title="实体插值"></a>实体插值</h2><p>在某些情况下，根本无法运用航位推算，特别是在玩家的方向和速度可以可以立刻改变的情况下。例如，在 3D 射击游戏中，玩家通常会以非常高的速度进行跑动、停止和转向操作，这使得航位推算根本无法应用，因为根据玩家之前的位置和速度的数据根本无法预测接下来会发生什么。</p><p>当服务器发送权威数据时，你不能只更新玩家的位置，这样你只会让玩家每 100 毫秒只更新一次位置，这会让游戏无法继续玩下去。</p><p>你需要解决的是在你拥有的每 100 毫秒的权威位置数据里面，如何和向玩家展示中间发生了什么事情。解决这个问题的关键是展示其他玩家相对当前玩家来说的过去时间。</p><p>假设你在 t = 1000 时收到位置数据，并且你已经在 t = 900 时也收到了数据，因此你现在知道玩家在 t = 900 和 t = 1000 时的位置数据。你可以在 t = 1000 和 t = 1100 显示其他玩家从 t = 900 到 t = 1000 所做的事情。在“延迟”显示100毫秒的情况下，通过这种方式，你始终会显示用户的实际移动数据。</p><p><img src="/images/fpm/fpm3-02.png" alt="fpm"></p><p>用于从 t = 900 到 t = 1000 进行插值的位置数据取决于游戏。通常插值效果以及不错了，如果觉得还不够好，你可以让服务器在每次更新时发送更详细的移动数据。例如，玩家紧随一系列的直线段，或每隔 10 ms 采样一次的位置，这样的插值看起来会更好（在你发送一些增量的小规模移动数据时，你可以针对此特殊情况对线路上的数据格式进行大量优化，因此你不太需要为此发送10倍数量级的数据）。</p><p>请注意，使用这种技术，每个玩家看到游戏世界的渲染都会略有不同，因为每个玩家虽能看到现在的自己，但看到的其他实体却是过去的行为。然而，即使对于快节奏的游戏，看到具有 100 毫秒延迟的其他实体通常也是显而易见的。</p><p>这里有一些例外，当你需要很多空间和时间精度时，例如当玩家向其他玩家射击时，由于看的是过去的其他玩家，你的目标是延迟 100 毫秒的，也就是说，你的射击的是 100 毫秒前目标！我们将在下一篇文章中讨论这个问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在具有权威服务器的客户端-服务器环境中，因为不太频繁的更新与网络延迟，你仍然必须给予每个玩家显示连续性和平稳移动的假象。在本系列文章的第2部分中，我们探索了一种使用客户端预测和服务器协调来实时显示用户控制的玩家的移动方法，这可确保用户输入会立即对本地玩家产生影响，消除因为延迟而导致游戏无法继续下去的影响。</p><p>但是，游戏中的其他实体仍然是个问题。在本文中，我们探讨了两种处理它们的方法。</p><p>第一种方法，航位推算，适用于实体的位置可以从先前的实体数据（例如位置，速度和加速度）进行预估的游戏。当不满足这些条件时，此方法将不可行。</p><p>第二个方法，实体插值，当你根本无法预测实体未来的位置时，且它仅能使用服务器提供的真实实体数据时，你可以显示其他实体时在时间上稍微做一些延迟让步。实际效果是用户能看到玩家自己在当前的实际数据，但其他实体看到的却是过去。这通常会带来难以置信的无缝体验。</p><p>但是，如果不做其他事情，当需要高分辨率和时间精度时，例如对一个移动的目标进行瞄准射击，上面的做法将不可用：当客户端2渲染客户端1的位置与服务器端客户端1的位置不匹配时，这会让爆头射击变得不可用。由于没有了爆头射击功能，游戏也会变得不完整，我们将在下一篇文章中处理这个问题。</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/03/02/fast-paced-multiplayer-01/">快节奏多人游戏（1）：客户端与服务器架构</a></li><li><a href="/2019/03/06/fast-paced-multiplayer-02/">快节奏多人游戏（2）：客户端预测与服务器协调</a></li><li><a href="/2019/03/10/fast-paced-multiplayer-03/">快节奏多人游戏（3）：实体插值</a></li><li><a href="/2019/03/14/fast-paced-multiplayer-04/">快节奏多人游戏（4）：延迟补偿</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/entity-interpolation.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在本系列的第一篇文章中，我们介绍了权威服务器的概念及其防止客户欺骗的用处。然而，天真地使用这种技术可能会导致关于可玩性和响应性的潜在问题。在第二篇文章中，我们提出了客户端预测作为克服这些限制的方法。&lt;/p&gt;
&lt;p&gt;这两篇文章的最终结果传递的一组概念与技术是允许玩家通过互联网连接到权威的服务器，并在传输延迟的情况下，让玩家以一种完全像玩单机游戏的感觉方式控制游戏中的角色。&lt;/p&gt;
&lt;p&gt;在本文中，我们将对连接到同一服务器的其他玩家进行探索。&lt;/p&gt;
    
    </summary>
    
      <category term="多人游戏" scheme="https://veinin.com/categories/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="多人游戏" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
      <category term="多人游戏网络同步" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>快节奏多人游戏（2）：客户端预测与服务器协调</title>
    <link href="https://veinin.com/2019/03/06/fast-paced-multiplayer-02/"/>
    <id>https://veinin.com/2019/03/06/fast-paced-multiplayer-02/</id>
    <published>2019-03-06T14:10:00.000Z</published>
    <updated>2019-03-20T13:49:39.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本系列文章的第一篇文章中，我们探讨了一个客户端-服务器模型，它具有一个权威的服务器和愚蠢的客户端，客户端只是输入发送指令到服务器，然后服务器发送更新后的游戏状态给客户端进行展示。</p><p>该方案的简单实现会导致客户端输入指令和屏幕上的更新之间产生延迟。例如一个玩家按下了右键，角色开始移动前需要等待半秒钟，这是因为客户端的输入必须首先发送给服务器，服务器必须处理输入并计算出最新的游戏状态，并且把更新后的游戏状态再次发送给客户端。</p><p><img src="/images/fpm/fpm2-01.png" alt="fpm"></p><p>在因特网这类网络环境中，这里的延迟可能只是十分之几秒，游戏可能感觉最多时没有反应，或者最坏的情况下，游戏会无法继续玩下去。在本文中，我们将找到最小化延迟甚至消除该问题的方法。</p><a id="more"></a><h2 id="客户端预测"><a href="#客户端预测" class="headerlink" title="客户端预测"></a>客户端预测</h2><p>即使有一些作弊的玩家，大多数的时候服务器都可以处理有效的请求（来自非作弊客户端和欺骗那些在特定时间没有欺骗的客户）。这意味着收到的大部分输入都是有效的，并会按预期更新游戏状态。也就是说，如果你的角色位于坐标（10, 10）并按下右箭头键，它将结束于坐标（11,10）。</p><p>我们可以利用这个优势，如果游戏世界足够确定（即给定游戏状态和一组输入，结果是完全可预测的）。</p><p>假设我们有一个 100 毫秒的延迟，并且从一个方格移动到下一个方格的角色动画也需要 100 毫秒，使用上文提到的简单实现，这个操作加上延迟则需要花费 200 毫秒：</p><p><img src="/images/fpm/fpm2-02.png" alt="fpm"></p><p>由于世界是确定性的，我们可以先假设我们发送到服务器的输入将成功执行。在此假设下，客户端可以在处理输入后预测游戏世界的状态，并且大多数情况下这将是正确的。</p><p>我们可以发送输入并开始渲染输入的结果，就像它们已经成功一样，而不是发送输入并等待新游戏状态开始呈现它。通常情况下，我们等待服务器发送的“真实”游戏状态将匹配本地计算的状态：</p><p><img src="/images/fpm/fpm2-03.png" alt="fpm"></p><p>现在玩家的动作和屏幕上的结果之间绝对没有延迟，而服务器仍然具有权威性（如果被黑客攻击的客户端会发送无效输入，它可以在屏幕上呈现任何想要的内容，但它不会影响服务器状态）。</p><h2 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h2><p>在上面的例子中，我仔细选择了的延迟数字能游戏一切正常。但是，请考虑稍微修改的情况：假设我们对服务器有 250 毫秒的延迟，从正方形移动到下一个需要 100 毫秒。我们可以说玩家连续按下了右键2次，并试图向右移动2个方格。</p><p>使用上面的客户端预测技术，这将会发生以下事情：</p><p><img src="/images/fpm/fpm2-04.png" alt="fpm"></p><p>当新的游戏状态到来时，我们在 t = 250 毫秒遇到一个有趣的问题。客户端此时预测的状态是 x = 12，但服务器说新的游戏状态是 x = 11。由于服务器是权威的，因此客户端必须将角色移回 x = 11。但是，一个新的服务器状态会在 t = 350 到达，表示 x = 12，所以玩家角色将再次跳转到当前正确的游戏状态。</p><p>从玩家的角度来看，他按了两次右箭头键，角色向右移动了两个方格，在那里站了 50 毫秒，向左跳了一个方格，在那里站了 100 毫秒，又向右跳了一个方格。你可以想象，这种游戏体验是不可接受的。</p><h2 id="服务器对账"><a href="#服务器对账" class="headerlink" title="服务器对账"></a>服务器对账</h2><p>解决这个问题的关键是要意识到客户端在当前时间看到游戏世界，但由于滞后，它从服务器获得的更新实际上是过去的游戏状态。当服务器发送更新的游戏状态时，它还没有处理客户端发送的所有命令。</p><p>但是，要解决这个问题并不是非常困难。首先，客户端为每个请求添加序列号，在我们的例子中，第一次按键是请求 #1，第二次按键是请求 #2。然后，当服务器回复时，它包括它处理的最后一个输入的序列号：</p><p><img src="/images/fpm/fpm2-05.png" alt="fpm"></p><p>现在，在 t = 250 时，服务器会说 “基于我看到你的请求 #1，你的位置是 x = 11”。因为服务器是权威的，所以它将字符位置设置为 x = 11。现在让我们假设客户端保留了它发送给服务器的请求的副本。基于新的游戏状态，它知道服务器已经处理了请求 #1，因此它可以丢弃该副本。但它也知道服务器仍然必须发回处理请求 #2 的结果。因此，再次应用客户端预测，客户端可以基于服务器发送的最后权威状态以及服务器尚未处理的输入来计算游戏的“当前”游戏状态。</p><p>因此，在 t = 250 时，客户端收到了 “x = 11，最后处理的请求 = #1” 的消息。客户端会将其发送输入的 #1 副本丢弃掉，但它仍然保留了 #2 的副本，因为该副本尚未得到服务器的确认。它使用服务器发送的内容更新游戏内部状态：x = 11。此时应用服务器仍未看到的所有输入，在这种情况下，输入 #2 的结果是开始向右移动，最终结果是 x = 12，这将是正确的。</p><p>继续上面的例子，在 t = 350 时刻，一个新的游戏状态从服务器到达，这次它说 “x = 12，最后处理的请求 = #2”。此时，客户端丢弃所有到 #2 的输入，并更新状态 x = 12。你可以看到，这里没有处理任何重复的输入，处理结束后，结果也是正确的。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>上面讨论了一个简单的玩家移动的例子，但同样的原则可以应用于几乎所有的其他事物上面。例如，在回合制战斗中，当前玩家攻击另外一个角色，您可以显示攻击血液特效和表示扣血的数字，但没有在服务器返回角色的真正血量之前，你不应该直接更新角色真实的血量情况。</p><p>由于游戏状态的复杂性，并不是很容易把状态逆转回来。你可能希望避免直接预测角色的死亡状态，直到服务器告诉你角色死亡后才真正执行死亡逻辑，虽然有时候角色的血量在客户的游戏状态已经降为 0 以下了（如果另外一个角色在受到致命打击之前使用了急救箱，而此时服务器还没告诉你）。</p><p>这给我们带来了一个有趣的观点，即使游戏世界是完全确定并且没有任何作弊的客户端，客户端预测的状态和服务器发送的状态仍然可能在协调后不匹配。如上所诉，本文的描述不太可能使用在单个玩家身上，但当多个玩家连接到一个服务器上时这些问题很容易就遇到。我们将在下一篇文章继续讲解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用权威的服务器时，你需要等待服务器实际处理的输入时提供一些模拟响应的假象，因此，客户端需要模拟输入的结果，当服务器实际的状态到达时，预测的客户端将从更新的状态中以及客户端发送的输入指令重新计算。</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/03/02/fast-paced-multiplayer-01/">快节奏多人游戏（1）：客户端与服务器架构</a></li><li><a href="/2019/03/06/fast-paced-multiplayer-02/">快节奏多人游戏（2）：客户端预测与服务器协调</a></li><li><a href="/2019/03/10/fast-paced-multiplayer-03/">快节奏多人游戏（3）：实体插值</a></li><li><a href="/2019/03/14/fast-paced-multiplayer-04/">快节奏多人游戏（4）：延迟补偿</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在本系列文章的第一篇文章中，我们探讨了一个客户端-服务器模型，它具有一个权威的服务器和愚蠢的客户端，客户端只是输入发送指令到服务器，然后服务器发送更新后的游戏状态给客户端进行展示。&lt;/p&gt;
&lt;p&gt;该方案的简单实现会导致客户端输入指令和屏幕上的更新之间产生延迟。例如一个玩家按下了右键，角色开始移动前需要等待半秒钟，这是因为客户端的输入必须首先发送给服务器，服务器必须处理输入并计算出最新的游戏状态，并且把更新后的游戏状态再次发送给客户端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fpm/fpm2-01.png&quot; alt=&quot;fpm&quot;&gt;&lt;/p&gt;
&lt;p&gt;在因特网这类网络环境中，这里的延迟可能只是十分之几秒，游戏可能感觉最多时没有反应，或者最坏的情况下，游戏会无法继续玩下去。在本文中，我们将找到最小化延迟甚至消除该问题的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="多人游戏" scheme="https://veinin.com/categories/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="多人游戏" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
      <category term="多人游戏网络同步" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>快节奏多人游戏（1）：客户端与服务器架构</title>
    <link href="https://veinin.com/2019/03/02/fast-paced-multiplayer-01/"/>
    <id>https://veinin.com/2019/03/02/fast-paced-multiplayer-01/</id>
    <published>2019-03-02T13:13:37.000Z</published>
    <updated>2019-03-20T13:49:28.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是探索使快节奏多人游戏成为可能的技术和算法的系列文章中的第一篇。下面只是一个介绍性的入门讨论，如果你已经熟悉多人游戏设计背后的理念，你可以跳到下一篇文章。</p><p>开发任何类型的游戏本身都是具有非常大的挑战性的。然而，多人游戏却增加了很多需要我们处理的新问题。有趣的是，其核心问题却是人性和物理！</p><h2 id="作弊问题"><a href="#作弊问题" class="headerlink" title="作弊问题"></a>作弊问题</h2><p>多人游戏的一切都始于作弊。</p><p>作为一个游戏开发者，你通常并不关心一个玩家是否在一个买断制的单机游戏中作弊，你也不用关心他的行为是否会影响其他玩家。作弊的玩家可能无法完全按照你的计划去体验游戏，但是由于他们购买了游戏，所以他们有权以任何他们喜欢的方式玩游戏。</p><p>而多人游戏与单机游戏则恰恰相反。在任何有竞争性的游戏当中，玩家作弊的目的可能只是为了让自己更好，但往往这种作弊行为同时也会让其他玩家对游戏的体验变得更糟。作为开发人员，你必须避免这种情况的发生，因为只要有一个作弊玩家的存在往往会导致更多的其他玩家离去，最后你的游戏也会变得没有任何人玩。</p><p>有许许多多的防止游戏中作弊的方法，但其中最重要的一个（可能也是唯一有意义的一个）却很简单：不要相信玩家，总是假设最坏的情况–玩家会试图作弊。</p><a id="more"></a><h2 id="权威的服务器和愚蠢的客户端"><a href="#权威的服务器和愚蠢的客户端" class="headerlink" title="权威的服务器和愚蠢的客户端"></a>权威的服务器和愚蠢的客户端</h2><p>这里有一个看似很简单的解决方案：你可以让游戏中的所有内容都发生在你控制的中央服务器中，并使客户端成为游戏的特权观众。换句话说，你的游戏客户端将输入（按键、指令）发送到服务器，而服务器运行着游戏，并处理玩家的输入，把运行的结果发送回客户端。我们叫这种服务器为“权威性服务器”，因为服务器有权触发游戏时间中发生的任何事情。</p><p>当然，你的服务器可能会被某个漏洞利用，但这超出了本系列文章的范围。但是，使用权威的服务器可以防止各种各样的黑客攻击。例如，如果你不信任游戏中客户端的玩家HP的数值状态，当被客户端被黑客攻击并修改其本地的HP数值时，告诉服务器它的HP数值增加了10000%，但服务器其实是知道玩家血量只有1%，当受到其玩家攻击时，服务器就会判断其死亡，无论黑客对客户端做了任何修改都是徒劳无功的。</p><p>另外一个简单的例子中，对于玩家在游戏时间上的坐标位置。如果你让客户端告知服务器其所处的位置，那么如果受到黑客攻击，玩家上一秒在位置 (10, 10)，一秒钟后可能就变成 (20, 10) 坐标的情况，玩家可能会很轻易就穿越一堵墙，或者跑的比其他玩家更快。相反，在一个权威的服务器中，如果让服务器知道玩家所处的位置，客户端告诉服务器“我想向右移动一个方格”，服务器用 (11, 10) 更新玩家位置的变化，并回复客户端“你现在的位置在 (11, 10)”。</p><p><img src="/images/fpm/fpm1-01.png" alt="fpm"></p><p>总之，游戏状态仅由服务器来管理。客户端将操作发送给服务器。服务器定时更新游戏状态，然后将新游戏状态发送回客户端，客户端只是在屏幕上呈现更新后的状态。</p><h2 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h2><p>愚蠢的客户端方案在慢节奏的回合制游戏中会工作的很正常，例如战略游戏和扑克牌。它也适用于局域网，在所有实际应用中，通信都是即时的。但是，用游戏运用于互联网进行快节奏的游戏时，这一切都会被打破。</p><p>我们来谈谈网络中物理相关的知识。假设你在旧金山，连接到纽约的服务器，那是大约 4000 公里，没有什么东西能比光传输的更快，甚至互联网上的传输的字节（在较低级别是光脉冲，电缆中的电子或电磁波），光大约以 300000 km/s 的速度行进，因此传输 4000 公里大约需要 13 毫秒。</p><p>这可能听起来非常快，但它实际上是一个非常乐观的数据，它假设数据是以直线路径的光速传播的，但实际上很少有这种情况。在现实生活中，数据经历了路由器的一系列跳转，其中大多数都不是在光速中进行的，每个路由器自身也会引入一些延迟，因为数据包往往需要拷贝、校验以及重新路由等操作。</p><p>为了论证，我们假设从客户端到服务器的数据传输需要50毫秒，这可能是最佳的情况。但是如果你在纽约连接到东京的服务器会发生了什么呢？如果由于某种原因出现网络拥塞怎么办？延迟可能会是100毫秒、200毫秒，甚至高达500毫秒。</p><p>回到我们上一个例子，你的客户端向服务器发送了一个输入：我按下了右箭头，服务器在50毫秒后获得它，假设服务器处理请求并立即发回更新的状态。您的客户端在50毫秒后获得最新的游戏状态：你现在处于位置 (1, 0)。从你的角度来看，在你按下右箭头的 1/10 秒内没有发生任何事情，然后你的角色终于向右移动了一个方格，你的输入与输出的结果的显示延迟看起来并不多，但它们是显而易见的。当然，如果你的延迟在半秒以上，你的游戏甚至会因为出现卡顿而无法继续进行下去。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>联网的多人游戏非常有趣，但它也引入了一系列全新的挑战。权威的服务器架构非常擅长阻止大多数的作弊，但其实现可能会使游戏中的操作产生延迟，并使玩家感到反应迟钝。</p><p>在下面的文章中，我们将探讨如何构建一个权威服务器的系统，同时最大限度的减少玩家所经历的操作延迟，使其几乎与本地单人游戏无任何区别。</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/03/02/fast-paced-multiplayer-01/">快节奏多人游戏（1）：客户端与服务器架构</a></li><li><a href="/2019/03/06/fast-paced-multiplayer-02/">快节奏多人游戏（2）：客户端预测与服务器协调</a></li><li><a href="/2019/03/10/fast-paced-multiplayer-03/">快节奏多人游戏（3）：实体插值</a></li><li><a href="/2019/03/14/fast-paced-multiplayer-04/">快节奏多人游戏（4）：延迟补偿</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/client-server-game-architecture.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;这是探索使快节奏多人游戏成为可能的技术和算法的系列文章中的第一篇。下面只是一个介绍性的入门讨论，如果你已经熟悉多人游戏设计背后的理念，你可以跳到下一篇文章。&lt;/p&gt;
&lt;p&gt;开发任何类型的游戏本身都是具有非常大的挑战性的。然而，多人游戏却增加了很多需要我们处理的新问题。有趣的是，其核心问题却是人性和物理！&lt;/p&gt;
&lt;h2 id=&quot;作弊问题&quot;&gt;&lt;a href=&quot;#作弊问题&quot; class=&quot;headerlink&quot; title=&quot;作弊问题&quot;&gt;&lt;/a&gt;作弊问题&lt;/h2&gt;&lt;p&gt;多人游戏的一切都始于作弊。&lt;/p&gt;
&lt;p&gt;作为一个游戏开发者，你通常并不关心一个玩家是否在一个买断制的单机游戏中作弊，你也不用关心他的行为是否会影响其他玩家。作弊的玩家可能无法完全按照你的计划去体验游戏，但是由于他们购买了游戏，所以他们有权以任何他们喜欢的方式玩游戏。&lt;/p&gt;
&lt;p&gt;而多人游戏与单机游戏则恰恰相反。在任何有竞争性的游戏当中，玩家作弊的目的可能只是为了让自己更好，但往往这种作弊行为同时也会让其他玩家对游戏的体验变得更糟。作为开发人员，你必须避免这种情况的发生，因为只要有一个作弊玩家的存在往往会导致更多的其他玩家离去，最后你的游戏也会变得没有任何人玩。&lt;/p&gt;
&lt;p&gt;有许许多多的防止游戏中作弊的方法，但其中最重要的一个（可能也是唯一有意义的一个）却很简单：不要相信玩家，总是假设最坏的情况–玩家会试图作弊。&lt;/p&gt;
    
    </summary>
    
      <category term="多人游戏" scheme="https://veinin.com/categories/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="多人游戏" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
      <category term="多人游戏网络同步" scheme="https://veinin.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>寻路算法揭秘（4）：实用 A* 算法</title>
    <link href="https://veinin.com/2019/02/28/pathfinding-demystified-04/"/>
    <id>https://veinin.com/2019/02/28/pathfinding-demystified-04/</id>
    <published>2019-02-28T14:13:45.000Z</published>
    <updated>2019-03-25T16:00:50.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本系列的前三篇文章从寻路算法的基础知识开始，最后非常清晰明了地阐述了A *算法。这在理论上是很好的，但对于理解如何在实践中应用它却是一个不同的主题。</p><p>例如，如果你的世界不是网格怎么办？</p><p>如果你的角色不能瞬间旋转90度怎么办？</p><p>如果你的世界是无限的，你又该如何建立一个图表？</p><p>如果您不关心路径上的长度，但是您依赖太阳光并且需要尽可能地在阳光下呢？</p><p>如何找到两个目标节点中任何一个的最短路径？</p><a id="more"></a><h2 id="成本（Cost）函数"><a href="#成本（Cost）函数" class="headerlink" title="成本（Cost）函数"></a>成本（Cost）函数</h2><p>在最初的示例中，我们搜索了从开始节点到目标节点之间的最短路径。然而，我们没有将路径长度存储在一个变量 <code>length</code> 中，而是将其命名为 <code>cost</code>，为什么呢？</p><p>A* 搜索不仅仅能搜索到最短路径，还可以搜索到你定义的“最好”的路径，这对我们的目标是有好处的。当我们想要最短路径时，代价时路径的长度；但当我们想要最小化，比如说，燃料消耗，那就得把它当作消耗成本（cost）；如果你想最大化“阳光下的时间”，那么成本就是没有阳光的时间。诸如此类…</p><p>这通常意味着图中的每一条边都与一个特定的成本相关。在最初的例子中，因为我们在计算路径上的步长，路径的成本是隐式的，假设它总是为 1，但是你可以根据你想要的最小化的任何值来调整每条边的成本。</p><h2 id="目标（Goal）函数"><a href="#目标（Goal）函数" class="headerlink" title="目标（Goal）函数"></a>目标（Goal）函数</h2><p>假设你是一辆汽车，需要去加油站。任何加油站都可以。您想要到最短的路径的最近加油站。</p><p>一种天真的方法是依次计算到每个加油站的最短路径，然后选择最短的路径。这会奏效，但这会非常浪费。</p><p>你可以做的是用过一个方法来替换单一的目标节点（goal_node），这个方法根据给定的节点来判断是否是目标节点。这样你可以同时寻找多个目标，你还可以调整启发式算法，以返回所有可能目标的最小估计成本。</p><p>根据你的具体情况，你可能无法准确到达目标，或者这样做成本很高（如果你在一张巨大的地图中传送一个角色，你会在一哪怕一英寸的差距吗？），因此，方法 <code>is_goal_node</code> 可以在“足够接近”时返回 <code>true</code>。</p><h2 id="不需要很明确"><a href="#不需要很明确" class="headerlink" title="不需要很明确"></a>不需要很明确</h2><p>将世界表示为离散的网格对于许多游戏来说可能不够好。例如，考虑第一人称射击游戏或赛车游戏，世界是离散的，你不能用网格来表示它。</p><p>但这还有一个更大的难题，如果世界是无限大的呢？在这种情况下，即使你可以把它表示成为一个网格，你也不能建立与网格相对应的图形，因为它是一个无限大的图像。</p><p>然而，希望并没有丧失。我们确实需要一个图表来运行图形搜索算法，但是没人说图表必须是明确的。</p><p>如果仔细查看算法，你会注意到我们对图表整体没有做任何事情。相反，我们通过正在考虑的节点中获取可以到达的节点，正如 A* 算法演示中看到的，图中的一些节点根本没有被探索过。</p><p>那么，如果我们只是在搜索时才去构建图形该怎么办？</p><p>我们将起始节点设置为当前角色的位置。无论何时调用方法 <code>get_adjacent_nodes</code>，它都可以找出角色从给定节点移动的可能方向，并在运行中创建相邻节点。</p><h2 id="超越三重维度"><a href="#超越三重维度" class="headerlink" title="超越三重维度"></a>超越三重维度</h2><p>即使您的世界是 2D 网格，也需要考虑其他因素。例如，如果你的角色不能瞬间转90度或180度，这种情况该怎么办？</p><p>每个搜索节点所代表的状态步兵局限于某个位置，相反，它可以包括一组任意复杂的值。例如，如果旋转90度从一个方块走到另外一个方块所需的时间相同，那么角色的状态可以是： [坐标(position), 航向(heading)]。现在，每个节点不仅仅表示角色的位置，还表示角色的航向，图的每一条新边（隐式或显示）反应了这一点。</p><p>回到最初的 5x5 的网格，现在搜索的起始坐标可能是 [A, East]，相邻节点现在则是 [B, East] 和 [A, South]。如果你想到达 F 节点，首先你需要先修正你的航向，所以路径将是 [A, East] -&gt; [A, South] -&gt; [F, South]。</p><p>而第一人称射击游戏呢？你至少需要四个维度：[X, Y, Z, 航向]，设置可能是：[X, Y, Z, 航向, 血量, 弹药]。</p><p>请注意，状态越复杂，启发式函数也就会越复杂。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这几篇文章的目的是一劳永逸的消除 A* 算法是一种神秘的，难以理解的感觉。相反，我已经证明了它没有什么神秘之处。事实上，它可以用一种非常直接的方式从0开始推导出来。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>阿米特·帕特尔（Amit Patel）有一篇非常好的关于 <a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html" target="_blank" rel="noopener">A* 算法介绍</a>，当然他的其他主题文章也是非常棒的。</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/02/18/pathfinding-demystified-01/">寻路算法揭秘（1）：通用搜索</a></li><li><a href="/2019/02/20/pathfinding-demystified-02/">寻路算法揭秘（2）：搜索策略</a></li><li><a href="/2019/02/23/pathfinding-demystified-03/">寻路算法揭秘（2）：A* 解密</a></li><li><a href="/2019/02/28/pathfinding-demystified-04/">寻路算法揭秘（3）：实用 A* 算法</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/generic-search.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;本系列的前三篇文章从寻路算法的基础知识开始，最后非常清晰明了地阐述了A *算法。这在理论上是很好的，但对于理解如何在实践中应用它却是一个不同的主题。&lt;/p&gt;
&lt;p&gt;例如，如果你的世界不是网格怎么办？&lt;/p&gt;
&lt;p&gt;如果你的角色不能瞬间旋转90度怎么办？&lt;/p&gt;
&lt;p&gt;如果你的世界是无限的，你又该如何建立一个图表？&lt;/p&gt;
&lt;p&gt;如果您不关心路径上的长度，但是您依赖太阳光并且需要尽可能地在阳光下呢？&lt;/p&gt;
&lt;p&gt;如何找到两个目标节点中任何一个的最短路径？&lt;/p&gt;
    
    </summary>
    
      <category term="寻路算法" scheme="https://veinin.com/categories/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="寻路算法" scheme="https://veinin.com/tags/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*" scheme="https://veinin.com/tags/A/"/>
    
  </entry>
  
  <entry>
    <title>寻路算法揭秘（3）：A* 解密</title>
    <link href="https://veinin.com/2019/02/23/pathfinding-demystified-03/"/>
    <id>https://veinin.com/2019/02/23/pathfinding-demystified-03/</id>
    <published>2019-02-23T12:21:00.000Z</published>
    <updated>2019-03-25T16:00:36.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本系列文章中的第一篇介绍了通用的寻路算法，每种不同类型的寻路算法背后都是它的一个微小变化。</p><p>第二篇文章揭示了不同搜索算法背后的秘密：这一切都要归结于 <code>choose_node</code> 函数。它还提供了一个相当简单的 <code>choose_node</code> 函数来生成一个称为<strong>统一搜索成本</strong>的算法。</p><p>这个算法非常好：它将找到从开始节点到目标节点的最短路径。然而，它也有一点点浪费：它会前往人们可以很容易察觉到的错误路径节点，这往往会让目标偏移，我们能避免这种情况的发生吗？</p><h2 id="魔术算法"><a href="#魔术算法" class="headerlink" title="魔术算法"></a>魔术算法</h2><p>想象一下，我们在一台特殊的计算机上运行搜索算法，它拥有一个可以变魔术的芯片。有了这个很棒的芯片，我们就能用一种非常简单的方式来表达 <code>choose_node</code> 函数，它保证产生最短的路径，不会浪费时间去探索那些不会通向目标地方的道路:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function choose_node (reachable):</span><br><span class="line">    return magic(reachable, &quot;最短路径的下一个节点是什么&quot;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>虽然这很诱人，但是神奇的芯片仍然需要一些更低级别的代码，下面是一个类似的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function choose_node (reachable):</span><br><span class="line">    min_cost = infinity</span><br><span class="line">    best_node = None</span><br><span class="line"></span><br><span class="line">    for node in reachable:</span><br><span class="line">        cost_start_to_node = node.cost</span><br><span class="line">        cost_node_to_goal = magic(node, &quot;shortest path to the goal&quot;)</span><br><span class="line">        total_cost = cost_start_to_node + cost_node_to_goal</span><br><span class="line"></span><br><span class="line">        if min_cost &gt; total_cost:</span><br><span class="line">            min_cost = total_cost</span><br><span class="line">            best_node = node</span><br><span class="line"></span><br><span class="line">    return best_node</span><br></pre></td></tr></table></figure><p>这是选择下一个节点的好方式：我们选择从开始节点到目标节点的最短路径，而这正是我们想要的。</p><p>我们还最大幅度的减少了魔法的使用：我们确切的知道从起始节点到目标节点（即node.cost）所需成本，并且我们只是使用魔法来预测从当前节点前往目标节点的成本。</p><h2 id="不神奇但是非常棒的-A-算法"><a href="#不神奇但是非常棒的-A-算法" class="headerlink" title="不神奇但是非常棒的 A* 算法"></a>不神奇但是非常棒的 A* 算法</h2><p>不幸的是，魔术芯片很新，但我们希望其支持传统的硬件。上面大多数代码都没问题，除了这一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 抛出麻瓜处理器异常</span><br><span class="line">cost_node_to_goal = magic(node, &quot;shortest path to the goal&quot;)</span><br></pre></td></tr></table></figure><p>所以，我们并不能用魔法来知道我们尚未探索的道路的成本。很好，那让我们来猜猜看，我们很乐观，所以我们假设当前节点到目标节点之间没有任何东西，我们可以直接走：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cost_node_to_goal = distance(node, goal_node)</span><br></pre></td></tr></table></figure><p>注意，最短路径和最小距离是不同的：最小距离假定了当前节点和目标节点之间绝对没有障碍物。</p><p>这个假设当然非常简单。在我们基于网格的示例种，它是两个节点之间的曼哈顿距离，而所谓“曼哈顿距离”是指两点在在东西方向上的距离加上南北方向上的距离，即：abs(Ax - Bx) + abs(Ay - By)。如果你可以移动到对角线，则它的距离会是：sqrt( (Ax - Bx)^2 + (Ay - By)^2)。诸如此类，但最重要的是永远不要高估道路的成本。</p><p>所以，下面是一个没有魔法的 <code>choose_node</code> 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function choose_node (reachable):</span><br><span class="line">    min_cost = infinity</span><br><span class="line">    best_node = None</span><br><span class="line"></span><br><span class="line">    for node in reachable:</span><br><span class="line">        cost_start_to_node = node.cost</span><br><span class="line">        cost_node_to_goal = estimate_distance(node, goal_node)</span><br><span class="line">        total_cost = cost_start_to_node + cost_node_to_goal</span><br><span class="line"></span><br><span class="line">        if min_cost &gt; total_cost:</span><br><span class="line">            min_cost = total_cost</span><br><span class="line">            best_node = node</span><br><span class="line"></span><br><span class="line">    return best_node</span><br></pre></td></tr></table></figure><p>预估从节点到目标节点的距离的函数成为<strong>启发式算法</strong>，观众朋友们，我们称这种算法叫做 _A*_。</p><h2 id="在线演示"><a href="#在线演示" class="headerlink" title="在线演示"></a>在线演示</h2><p>当你从意识到神秘的 _A*_ 算法实际上那么简单的震惊中恢复过来时，这里有一个你可以试玩的演示。与前面的示例不同，你会注意到整个搜索在错误的方向上浪费的时间非常少。</p><script src="http://www.gabrielgambetta.com/js/path_helpers.js"></script><table><tr><td><canvas width="401" height="401" id="demo"></canvas></td><td><p id="reachable" style="color:green; font-family:courier;">reachable = []</p><p id="explored" style="color:red; font-family:courier;">explored = []</p><p id="path" style="font-family:courier;"></p><p><input type="button" value="Restart" onclick="stopRunSearch(); search.reset();"> <input type="button" value="Step" onclick="stopRunSearch(); search.step();"> <input type="button" value="Run" onclick="runSearch();"></p></td></tr></table><script>// Choose the node with the lowest path cost.Search.prototype.chooseNode = function() {    // return this.reachable[Math.floor(Math.random() * this.reachable.length)];    var min_cost = Infinity;    var best_node = undefined;    for (var i in this.reachable) {        var node = this.reachable[i];        // Compute Manhattan distance to goal.        var idx = getNodeIndex(node, this.graph.nodes);        var nr = Math.floor(idx / this.graph.cols);        var nc = idx % this.graph.cols;         idx = getNodeIndex(this.goal_node, this.graph.nodes);        var gr = Math.floor(idx / this.graph.cols);        var gc = idx % this.graph.cols;         var node_to_goal_distance_estimate = Math.abs(nr - gr) + Math.abs(nc - gc);        var total_cost = node.cost + node_to_goal_distance_estimate;        if (total_cost < min_cost) {            min_cost = total_cost;            best_node = node;        }    }    return best_node;}Search.prototype.addAdjacent = function(node, adjacent) {    if (findNode(adjacent, this.explored)) {        return;    }    if (!findNode(adjacent, this.reachable)) {        this.reachable.push(adjacent);    }    if (adjacent.cost > node.cost + 1) {        adjacent.cost = node.cost + 1;        adjacent.previous = node;    }}// Build the grid used in the example.// "*" represent a blocked square, " " an open one.var graph = new Graph(["          ",                       "          ",                       "          ",                       "          ",                       "          ",                       "          ",                       "        * ",                       "       ** ",                       "      **  ",                       "          "]);var stepDelay = 100;var search = new Search(graph, "BN", "CK");search.reset();render(search);</script><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们最终得到了 _A*_ 算法，它只不过是第一篇文章中描述的通用搜索算法，在第二篇文章的描述中加入了一些改进，使用 <code>choose_node</code> 函数选择我们预估的节点将使我们更加接近目标，仅此而已。</p><p>参照上面的结论，我们给出了主要方法的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function find_path(start_node, goal_node):</span><br><span class="line">    reachable = [start_node]</span><br><span class="line">    explored = []</span><br><span class="line"></span><br><span class="line">    while reachable is not empty:</span><br><span class="line">        # 选择一个我们知道如何到达的节点</span><br><span class="line">        node = choose_node(reachable)</span><br><span class="line"></span><br><span class="line">        # 如果我们刚好到达了目标节点，则构建并返回路径。</span><br><span class="line">        if node == goal_node:</span><br><span class="line">            return build_path(goal_node)</span><br><span class="line"></span><br><span class="line">        # 记录已经处理的节点，防止重复处理</span><br><span class="line">        reachable.remove(node)</span><br><span class="line">        explored.add(node)</span><br><span class="line"></span><br><span class="line">        # 我们能从这个节点得到我们以前没有探索过的新节点</span><br><span class="line">        new_reachable = get_adjacent_node(node) - explored</span><br><span class="line">        for adjacent in new_reachable:</span><br><span class="line">            # 是不是第一次抵达这个节点</span><br><span class="line">            if adjacent not in reachable:</span><br><span class="line">                reachable.add(adjacent)</span><br><span class="line"></span><br><span class="line">            # 如果这是一个新路径，或者比现有的路径更短，则保留它</span><br><span class="line">            if node.cost + 1 &lt; adjacent.cost:</span><br><span class="line">                adjacent.previous = node</span><br><span class="line">                adjacent.cost = node.cost + 1</span><br><span class="line"></span><br><span class="line">    # 如果我们到达了这里，则路径没有找到</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure><p><code>build_path</code> 方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function build_path(to_node):</span><br><span class="line">    path = []</span><br><span class="line">    while to_node != None:</span><br><span class="line">        path.add(to_node)</span><br><span class="line">        to_node = to_node.previous</span><br><span class="line">    return path</span><br></pre></td></tr></table></figure><p>使用 A* 算法实现的 <code>choose_node</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function choose_node(reachable):</span><br><span class="line">    min_cost = infinity</span><br><span class="line">    best_node = None</span><br><span class="line"></span><br><span class="line">    for node in reachable:</span><br><span class="line">        cost_start_to_node = node.cost</span><br><span class="line">        cost_node_to_goal = estimate_distance(node, goal_node)</span><br><span class="line">        total_cost = cost_start_to_node + cost_node_to_goal</span><br><span class="line"></span><br><span class="line">        if min_cost &gt; total_cost:</span><br><span class="line">            min_cost = total_cost</span><br><span class="line">            best_node = node</span><br><span class="line"></span><br><span class="line">    return best_node</span><br></pre></td></tr></table></figure><p>经此而已。</p><p>那么为什么本系列文章还有第四部分？</p><p>现在你已经了解了 _A*_ 算法的工作原理，我想探索一些令人难以置信的应用程序，而不仅仅是在一个正方形的网格中搜索路径。</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/02/18/pathfinding-demystified-01/">寻路算法揭秘（1）：通用搜索</a></li><li><a href="/2019/02/20/pathfinding-demystified-02/">寻路算法揭秘（2）：搜索策略</a></li><li><a href="/2019/02/23/pathfinding-demystified-03/">寻路算法揭秘（2）：A* 解密</a></li><li><a href="/2019/02/28/pathfinding-demystified-04/">寻路算法揭秘（3）：实用 A* 算法</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/generic-search.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;本系列文章中的第一篇介绍了通用的寻路算法，每种不同类型的寻路算法背后都是它的一个微小变化。&lt;/p&gt;
&lt;p&gt;第二篇文章揭示了不同搜索算法背后的秘密：这一切都要归结于 &lt;code&gt;choose_node&lt;/code&gt; 函数。它还提供了一个相当简单的 &lt;code&gt;choose_node&lt;/code&gt; 函数来生成一个称为&lt;strong&gt;统一搜索成本&lt;/strong&gt;的算法。&lt;/p&gt;
&lt;p&gt;这个算法非常好：它将找到从开始节点到目标节点的最短路径。然而，它也有一点点浪费：它会前往人们可以很容易察觉到的错误路径节点，这往往会让目标偏移，我们能避免这种情况的发生吗？&lt;/p&gt;
&lt;h2 id=&quot;魔术算法&quot;&gt;&lt;a href=&quot;#魔术算法&quot; class=&quot;headerlink&quot; title=&quot;魔术算法&quot;&gt;&lt;/a&gt;魔术算法&lt;/h2&gt;&lt;p&gt;想象一下，我们在一台特殊的计算机上运行搜索算法，它拥有一个可以变魔术的芯片。有了这个很棒的芯片，我们就能用一种非常简单的方式来表达 &lt;code&gt;choose_node&lt;/code&gt; 函数，它保证产生最短的路径，不会浪费时间去探索那些不会通向目标地方的道路:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function choose_node (reachable):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return magic(reachable, &amp;quot;最短路径的下一个节点是什么&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="寻路算法" scheme="https://veinin.com/categories/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="寻路算法" scheme="https://veinin.com/tags/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*" scheme="https://veinin.com/tags/A/"/>
    
  </entry>
  
  <entry>
    <title>寻路算法揭秘（2）：搜索策略</title>
    <link href="https://veinin.com/2019/02/20/pathfinding-demystified-02/"/>
    <id>https://veinin.com/2019/02/20/pathfinding-demystified-02/</id>
    <published>2019-02-20T10:20:00.000Z</published>
    <updated>2019-03-25T15:57:58.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本系列第一篇文章介绍了通用寻路算法。如果你没有完全理解它，请返回并重新阅读，因为其对你了解后面的内容至关重要，一旦你掌握了它，A* 算法将是世界上最自然的事情。</p><h2 id="秘制酱汁"><a href="#秘制酱汁" class="headerlink" title="秘制酱汁"></a>秘制酱汁</h2><p>我在上一章结尾处留下了两个悬而未决的问题：如果每一种寻路算法都使用相同的代码，是什么让 A<em> 的行为看起来像 A</em> 呢？而为什么上一章的演示实例会找出不同的路径呢？</p><p>这两个问题的答案是非常相关联的。尽管算法定义得很好，但有一个方面我故意含糊不清，事实证明，它是解释搜索算法行为的关键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node = choose_node(reachable)</span><br></pre></td></tr></table></figure><p>那些看起来很无辜的线使得每个搜索算法都与众不同。<code>choose_node</code> 所作的选择会让世界看起来不同。</p><p>那么为什么上一章的演示实例会找出不同的路径呢？答案是因为 <code>choose_node</code> 方法随机选择了一个节点。</p><a id="more"></a><h2 id="长度很重要"><a href="#长度很重要" class="headerlink" title="长度很重要"></a>长度很重要</h2><p>在深入研究 <code>choose_node</code> 函数的不同行为之前，根据前面的解释，我们需要对算法中存在的一点疏忽进行修正。</p><p>每当我们考虑与当前节点的相邻节点是，我们忽略了那些我们已经知道如何到达的节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if adjacent not in reachable:</span><br><span class="line">    adjacent.previous = node  # 记住我们是如何抵达这个节点的</span><br><span class="line">    reachable.add(adjacent)</span><br></pre></td></tr></table></figure><p>这里犯了一个错误：如果我们刚好发现一个更好的到达此节点的方式呢？在这种情况下，我们应该应该调整这个节点的前驱节点来使到达此节点的路径更短。</p><p>为此，我们需要知道从起始节点到任何可达的节点之间的路径长度，我们称这种长度为 <code>cost</code>。现在让我们假设从一个节点移动到一个相邻节点的固定花费（cost）为 1。</p><p>在开始搜索之前，我们先设置每个节点的 <code>cost</code> 为值 <code>infinity</code>，这使得任何路径都比这个值要短。我们还需要设置到达 <code>start_node</code> 节点的 <code>cost</code> 为 0。</p><p>所以现在代码看起来是这样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if adjacent not in reachable:</span><br><span class="line">    reachable.add(adjacent)</span><br><span class="line"></span><br><span class="line"># 如果这是一条新路径，或者比现有的路径更断，则保留它。</span><br><span class="line">if node.cost + 1 &lt; adjacent.cost:</span><br><span class="line">    adjacent.previous = node</span><br><span class="line">    adjacent.cost = node.cost + 1</span><br></pre></td></tr></table></figure><h2 id="统一的搜索成本"><a href="#统一的搜索成本" class="headerlink" title="统一的搜索成本"></a>统一的搜索成本</h2><p>现在让我们关注 <code>choose_node</code>(选择节点) 方法。如果我们想要得到尽可能短的路径，随机选择一个节点显然不是一个很好的主意。</p><p>一个更好的方法是选择从开始节点可以到达最短路径的节点。这通常会选择较短的路径，而不是较长的路径。当然，这并不意味着不考虑较长的路径，而是优先考虑较短的路径。因为一旦找到有效路径，算法就会停止，这应该就是我们的较短路径。</p><p>这里是一种可能的 <code>choose_node</code> 函数实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function choose_node (reachable):</span><br><span class="line">    best_node = None</span><br><span class="line"></span><br><span class="line">    for node in reachable:</span><br><span class="line">        if beat_node == None or best_node &gt; node.cost:</span><br><span class="line">            best_node = node</span><br><span class="line"></span><br><span class="line">    return best_node</span><br></pre></td></tr></table></figure><p>直观的说，该算法的搜索从开始节点“径向”展开，直到抵达结束节点。下面是这种搜索行为的Demo演示:</p><script src="http://www.gabrielgambetta.com/js/path_helpers.js"></script><table><tr><td><canvas width="401" height="401" id="demo"></canvas></td><td><p id="reachable" style="color:green; font-family:courier;">reachable = []</p><p id="explored" style="color:red; font-family:courier;">explored = []</p><p id="path" style="font-family:courier;"></p><p><input type="button" value="Restart" onclick="stopRunSearch(); search.reset();"> <input type="button" value="Step" onclick="stopRunSearch(); search.step();"> <input type="button" value="Run" onclick="runSearch();"></p></td></tr></table><script>// Choose the node with the lowest path cost.Search.prototype.chooseNode = function() {    // return this.reachable[Math.floor(Math.random() * this.reachable.length)];    var min_cost = Infinity;    var best_node = undefined;    for (var i in this.reachable) {        var node = this.reachable[i];        if (node.cost < min_cost) {            min_cost = node.cost;            best_node = node;        }    }    return best_node;}Search.prototype.addAdjacent = function(node, adjacent) {    if (findNode(adjacent, this.explored)) {        return;    }    if (!findNode(adjacent, this.reachable)) {        this.reachable.push(adjacent);    }    if (adjacent.cost > node.cost + 1) {        adjacent.cost = node.cost + 1;        adjacent.previous = node;    }}// Build the grid used in the example.// "*" represent a blocked square, " " an open one.var graph = new Graph(["          ",                       "          ",                       "          ",                       "          ",                       "          ",                       "          ",                       "        * ",                       "       ** ",                       "      **  ",                       "          "]);var stepDelay = 100;var search = new Search(graph, "BN", "CK");search.reset();render(search);</script><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在选择下一个要考虑的节点方式上做一个非常简单的改变，就可以得到一个非常好的搜索算法：找到从开始节点到目标节点的最短路径。</p><p>在某种程度上，这仍然是个愚蠢的做法。算法会一直漫无目的的寻找，直到它偶然发现了目标节点。在上面的例子中，当我们在朝着 A 节点方向搜索时却距离目标节点越来越远，这有什么意义呢？</p><p>我们能让 <code>choose_node</code> 方法更加智能吗？即使事先不知道正确的方向，也能让它朝着目标不断迈进。</p><p>事实证明我们是可以做到的，在下一篇文章中，我们最终会得到更加完善的 <code>choose_node</code> 方法，它会使常规的寻路算法变成 A*。</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/02/18/pathfinding-demystified-01/">寻路算法揭秘（1）：通用搜索</a></li><li><a href="/2019/02/20/pathfinding-demystified-02/">寻路算法揭秘（2）：搜索策略</a></li><li><a href="/2019/02/23/pathfinding-demystified-03/">寻路算法揭秘（2）：A* 解密</a></li><li><a href="/2019/02/28/pathfinding-demystified-04/">寻路算法揭秘（3）：实用 A* 算法</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/generic-search.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;本系列第一篇文章介绍了通用寻路算法。如果你没有完全理解它，请返回并重新阅读，因为其对你了解后面的内容至关重要，一旦你掌握了它，A* 算法将是世界上最自然的事情。&lt;/p&gt;
&lt;h2 id=&quot;秘制酱汁&quot;&gt;&lt;a href=&quot;#秘制酱汁&quot; class=&quot;headerlink&quot; title=&quot;秘制酱汁&quot;&gt;&lt;/a&gt;秘制酱汁&lt;/h2&gt;&lt;p&gt;我在上一章结尾处留下了两个悬而未决的问题：如果每一种寻路算法都使用相同的代码，是什么让 A&lt;em&gt; 的行为看起来像 A&lt;/em&gt; 呢？而为什么上一章的演示实例会找出不同的路径呢？&lt;/p&gt;
&lt;p&gt;这两个问题的答案是非常相关联的。尽管算法定义得很好，但有一个方面我故意含糊不清，事实证明，它是解释搜索算法行为的关键：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;node = choose_node(reachable)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那些看起来很无辜的线使得每个搜索算法都与众不同。&lt;code&gt;choose_node&lt;/code&gt; 所作的选择会让世界看起来不同。&lt;/p&gt;
&lt;p&gt;那么为什么上一章的演示实例会找出不同的路径呢？答案是因为 &lt;code&gt;choose_node&lt;/code&gt; 方法随机选择了一个节点。&lt;/p&gt;
    
    </summary>
    
      <category term="寻路算法" scheme="https://veinin.com/categories/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="寻路算法" scheme="https://veinin.com/tags/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*" scheme="https://veinin.com/tags/A/"/>
    
  </entry>
  
  <entry>
    <title>寻路算法揭秘（1）：通用搜索</title>
    <link href="https://veinin.com/2019/02/18/pathfinding-demystified-01/"/>
    <id>https://veinin.com/2019/02/18/pathfinding-demystified-01/</id>
    <published>2019-02-18T13:13:37.000Z</published>
    <updated>2019-03-25T15:55:36.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>寻路算法通常是游戏开发者一个比较困惑的主题。特别是 A* 算法常常令人费解，人们普遍会认为这是一种神秘的魔法。</p><p>本系列文章的目的是以一种非常清晰易懂的方式解释常规的寻路与 A* 算法，你不必误解这是一个非常困难的话题，如果解释的当，这将是非常简单明了的问题。</p><p>请注意，我们的重点将放在游戏领域的寻路，与学术化的方法不同，我们将跳过诸如深度优先（Depth-First）或广度优先（Breadth-First）搜索算法的介绍，并尽快进从0到1的介绍 A* 算法。</p><p>第一篇文章将要解释寻路的基本概念，一旦你掌握了这些基本概念，你会发现 A* 算法非常简单。</p><h2 id="简单的第一步"><a href="#简单的第一步" class="headerlink" title="简单的第一步"></a>简单的第一步</h2><p>虽然你能够将这些概念任意复杂的 3D 环境中去，但首先我们将从一个非常简单的设置开始：一个 5x5 的方格。为了方便起见，我们用大写字母标记了每一个方块。</p><p><img src="/images/pathfinding/path1-01.png" alt="pd"></p><a id="more"></a><p>我们要做的第一件事就是通过图形来表示环境。我不会详细介绍图表的内容，直观地说，它是由箭头连接的一组气泡。我们把气泡称为“节点”，箭头称为“边缘”。</p><p>每个节点代表一个角色可以的一种“状态”。在这种情况下，角色的状态就是它的位置，所以我们要为每个方块的网格创建一个节点：</p><p><img src="/images/pathfinding/path1-02.png" alt="pd"></p><p>现在让我们添加边缘，它代表了你可以从其他的给定状态“达到”哪些状态。在下面的例子中，除了被阻挡的方格外，你可以从任何方格走到其相邻的方格：</p><p><img src="/images/pathfinding/path1-03.png" alt="pd"></p><p>如果你你能从 A 节点到达 B 节点，我们可以说 B 是 A 的邻边。</p><p>注意，边缘是有方向的，我们需要一个从 A 到 B 的边，也需要一个从 B 到 A 的边。这看起来可能有点多余，但当你考虑复杂的“状态”时，就不会是这样了。例如，你可以从屋顶掉落到地面，但你不能从地面再跳到屋顶；你可以从“活着”变成“死亡”，但反过来则不行。</p><h2 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h2><p>当我们向从 A 节点到 T 节点时，在第一步中我们可以从两个方向进行选择：走到 B 节点或走到 F 节点。</p><p>假设我们先走到 B 节点，现在你又有了两个选择：回到 A 节点或去到 C 节点。我们记得我们已经去过了 A 节点，这是一个我们已经考虑过的选择，所以没必要再选择一次（否则我们可能整天都在走 A -&gt; B -&gt; A -&gt; B…），所以下一步我们将去到 C 节点。</p><p>现在我们到达了 C 节点，但是我们发现我们已经无路可走了，而再回到 B 节点是没有任何意义的。所以我们到了一个死胡同，当我们在 A 节点选择 B 节点时就不是一个好主意，也许我们应该尝试下 F 节点。</p><p>我们继续不断的重复这个过程，直到我们发现了 T 节点。我们只是通过回溯我们的步骤，重新构建了路径。当我们在 T 节点时，我们怎么来到这里的？那么终点的路径是 O -&gt; T 吗？那我们怎么走到 O 节点？</p><p>请记住，我们实际上根本没有移动，所有的这些都只是一次思考练习。我们仍然站在 A 节点，在我们弄清楚整个路径之前，我们根本不会移动。当我们说“移动到B节点”，我们实际上是在说“想象我们到达了B节点”。</p><h2 id="通用算法"><a href="#通用算法" class="headerlink" title="通用算法"></a>通用算法</h2><p><strong>本章节是本系列文章最重要的部分</strong>。这是你为了寻路必须理解的部分，其他（包括A*）只是一些细节而已。一旦你了解了这一部分你将得到启蒙。</p><p>这一章节当然也很简单。</p><p>让我们将上面的例子形式化成一些伪代码。</p><p>我们需要追踪我们知道的从起点可以到达的节点。开始时，我们只有一个起始节点，但是我们可以对网格进行“探索”，并搞清楚如何到达其他节点。我们把这个列表叫做 <code>reachable</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reachable = [start_node]</span><br></pre></td></tr></table></figure><p>另外，我们需要追踪我们已经到达过的节点，因为我们不想再次前往，我们把这部分节点列表叫做 <code>explored</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explored = []</span><br></pre></td></tr></table></figure><p>这里我们来到了<strong>算法的核心部分</strong>：在搜索的每一个步骤时，我们先选择一个我们已知可达但尚未探索过的节点，然后在此节点检索我们可以到达的新节点。一旦发现我们可以到达目标节点，我们就完成了！否则，继续寻找。</p><p>这听起来好像很简单？是的，但这还不是全部，让我们一步步的用伪代码写出来。</p><p>我们一直寻找，直到我们到达目标节点（在这种情况下，我们已经找到了从开始节点到目标节点的路径），或者直到没有其他节点可以继续探索（在这种情况下，没有从开始节点到达目标节点的路径）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while reachable is not empty:</span><br></pre></td></tr></table></figure><p>我们选择一个我们已知的但没有探索过的节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node = choose_node(reachable)</span><br></pre></td></tr></table></figure><p>如果我们已经直到如何到达目标节点，我们就完成了！然后只需要建立一条路径，根据当前节点的前驱(previous )节点回到开始节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if node == goal_node:</span><br><span class="line">    path = []</span><br><span class="line">    while node != None:</span><br><span class="line">        path.add(node)</span><br><span class="line">        node = node.previous</span><br><span class="line"></span><br><span class="line">    return path</span><br></pre></td></tr></table></figure><p>我们多次的去往同一个节点是没有意义的，所以我们需要追踪那些已经去过的节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reachable.remove(node)</span><br><span class="line">explored.add(node)</span><br></pre></td></tr></table></figure><p>我们可以算出从当前节点可以到达的新节点。我们继续从当前节点的相邻节点开始，并删除我们已经探索过的节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_reachable = get_adjacent_nodes(node) - explored</span><br></pre></td></tr></table></figure><p>然后取出可探索的每一个新节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for adjacent in new_reachable:</span><br></pre></td></tr></table></figure><p>如果我们已经探索过此节点，则忽略它。否则，把此节点加入到已经探索过的节点列表中，记录我们已经探索过它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if adjacent not in reachable:</span><br><span class="line">    adjacent.previous = node  # Remember how we got there.</span><br><span class="line">    reachable.add(adjacent)</span><br></pre></td></tr></table></figure><p>找到目标节点是退出循环的一种方式。另外一种则是当可探索(reachable)的节点为空时：如果我们已经没有可检查的节点，并且没有任何一个节点是我们的目标节点，这意味着没有从开始节点到达目标节点的路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return None</span><br></pre></td></tr></table></figure><p>然后…也就这样了。这已经是一个完整的流程了，我们把上面的代码提取到一个单独的方法中去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function find_path (start_node, end_node):</span><br><span class="line">    reachable = [start_node]</span><br><span class="line">    explored = []</span><br><span class="line"></span><br><span class="line">    while reachable is not empty:</span><br><span class="line">        # Choose some node we know how to reach.</span><br><span class="line">        node = choose_node(reachable)</span><br><span class="line"></span><br><span class="line">        # If we just got to the goal node, build and return the path.</span><br><span class="line">        if node == goal_node:</span><br><span class="line">            return build_path(goal_node)</span><br><span class="line"></span><br><span class="line">        # Don&apos;t repeat ourselves.</span><br><span class="line">        reachable.remove(node)</span><br><span class="line">        explored.add(node)</span><br><span class="line"></span><br><span class="line">        # Where can we get from here?</span><br><span class="line">        new_reachable = get_adjacent_nodes(node) - explored</span><br><span class="line">        for adjacent in new_reachable:</span><br><span class="line">            if adjacent not in reachable</span><br><span class="line">                adjacent.previous = node  # Remember how we got there.</span><br><span class="line">                reachable.add(adjacent)</span><br><span class="line"></span><br><span class="line">    # If we get here, no path was found :(</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure><p>下面这个函数通过前驱节点构建返回起始节点的路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function build_path (to_node):</span><br><span class="line">    path = []</span><br><span class="line">    while to_node != None:</span><br><span class="line">        path.add(to_node)</span><br><span class="line">        to_node = to_node.previous</span><br><span class="line">    return path</span><br></pre></td></tr></table></figure><p>就这样，这是每一个寻路算法的伪代码，包括 A*。</p><h2 id="在线演示"><a href="#在线演示" class="headerlink" title="在线演示"></a>在线演示</h2><p>下面是一个在线演示和上面算法的实现示例。<code>choose_node</code> 只是一个随机选择的节点。你可以一步步的运行它，并查看 <code>可达(reachable)</code> 和 <code>已探索(explored)</code> 节点的变化情况，以及 <code>前驱(previous)</code> 节点的连接情况。</p><script src="http://www.gabrielgambetta.com/js/path_helpers.js"></script><table><tr><td width="201" height="201"><canvas width="201" height="201" id="demo"></canvas></td><td><p id="reachable" style="color:green; font-family:courier;">reachable = []</p><p id="explored" style="color:red; font-family:courier;">explored = []</p><p id="path" style="font-family:courier;"></p><p><input type="button" value="Restart" onclick="stopRunSearch(); search.reset();"> &lt;input type=”button” value=”Step”onclick=”stopRunSearch(); search.step();”&gt; <input type="button" value="Run" onclick="runSearch();"></p></td></tr></table><script>// Choose a random node from the reachable list.Search.prototype.chooseNode = function() {    return this.reachable[Math.floor(Math.random() * this.reachable.length)];}Search.prototype.addAdjacent = function(node, adjacent) {    if (findNode(adjacent, this.explored) || findNode(adjacent, this.reachable)) {        return;    }    adjacent.previous = node;    this.reachable.push(adjacent);}// Build the grid used in the example.// "*" represent a blocked square, " " an open one.var graph = new Graph(["   * ",                       " *** ",                       "     ",                       "* ** ",                       "*    "]);var stepDelay = 200;var search = new Search(graph, "A", "T");search.reset();render(search);</script><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述算法是每一种寻路算法的通用算法。</p><p>那么，你知道是什么使得每一种寻路算法彼此都不相同吗？为什么 <code>A*</code> 叫做 <code>A*</code>。</p><p>这里有个小提示：如果你多次运行上面的演示搜索，你会发现算法每次找到的路径并不一定总是相同。它找到了一些其他路径，但其并不是最短路径，为什么？</p><hr><ul><li><p>系列文章目录：</p><ul><li><a href="/2019/02/18/pathfinding-demystified-01/">寻路算法揭秘（1）：通用搜索</a></li><li><a href="/2019/02/20/pathfinding-demystified-02/">寻路算法揭秘（2）：搜索策略</a></li><li><a href="/2019/02/23/pathfinding-demystified-03/">寻路算法揭秘（2）：A* 解密</a></li><li><a href="/2019/02/28/pathfinding-demystified-04/">寻路算法揭秘（3）：实用 A* 算法</a></li></ul></li><li><p><a href="http://www.gabrielgambetta.com/generic-search.html" target="_blank" rel="noopener">翻译原文</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;寻路算法通常是游戏开发者一个比较困惑的主题。特别是 A* 算法常常令人费解，人们普遍会认为这是一种神秘的魔法。&lt;/p&gt;
&lt;p&gt;本系列文章的目的是以一种非常清晰易懂的方式解释常规的寻路与 A* 算法，你不必误解这是一个非常困难的话题，如果解释的当，这将是非常简单明了的问题。&lt;/p&gt;
&lt;p&gt;请注意，我们的重点将放在游戏领域的寻路，与学术化的方法不同，我们将跳过诸如深度优先（Depth-First）或广度优先（Breadth-First）搜索算法的介绍，并尽快进从0到1的介绍 A* 算法。&lt;/p&gt;
&lt;p&gt;第一篇文章将要解释寻路的基本概念，一旦你掌握了这些基本概念，你会发现 A* 算法非常简单。&lt;/p&gt;
&lt;h2 id=&quot;简单的第一步&quot;&gt;&lt;a href=&quot;#简单的第一步&quot; class=&quot;headerlink&quot; title=&quot;简单的第一步&quot;&gt;&lt;/a&gt;简单的第一步&lt;/h2&gt;&lt;p&gt;虽然你能够将这些概念任意复杂的 3D 环境中去，但首先我们将从一个非常简单的设置开始：一个 5x5 的方格。为了方便起见，我们用大写字母标记了每一个方块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pathfinding/path1-01.png&quot; alt=&quot;pd&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="寻路算法" scheme="https://veinin.com/categories/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="寻路算法" scheme="https://veinin.com/tags/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*" scheme="https://veinin.com/tags/A/"/>
    
  </entry>
  
  <entry>
    <title>玩转终端软件 Hyper</title>
    <link href="https://veinin.com/2018/11/30/hyper-windows-tutorial/"/>
    <id>https://veinin.com/2018/11/30/hyper-windows-tutorial/</id>
    <published>2018-11-29T17:20:00.000Z</published>
    <updated>2018-11-29T17:21:40.171Z</updated>
    
    <content type="html"><![CDATA[<p>相信有很多人开发环境是我 Windows 上面，有时候又不得不面临在 Windows 上面开发 Linux 环境的程序。还好 Windows 10 系统为我们提供了一个叫 WSL（Windows Subsystem for Linux） 的子系统。但是，尽管微软已经很努力得在改善 Windows 开发环境了，但我们却始终得不到一个比较简单易用得终端软件，最起码你用 Window 自带得终端来操作 Linux 系统还是会觉得缺了点什么。</p><p>目前市面上很多终端软件都比 Windows 自带终端好太多，比如这篇文章就介绍了 20 个比较好用终端软件：</p><p><a href="https://www.slant.co/topics/1552/~best-terminal-emulators-for-windows" target="_blank" rel="noopener">THE BEST 1 OF 20 OPTIONS</a></p><p>之前用过一个不错得软件叫做 <a href="http://cmder.net/" target="_blank" rel="noopener">Cmder</a>，但它不是今天得主角，我们今天要介绍得是另一款更符合我口味得终端软件 Hyper。</p><h2 id="获取并安装-Hyper"><a href="#获取并安装-Hyper" class="headerlink" title="获取并安装 Hyper"></a>获取并安装 Hyper</h2><p>你可以在一下几个地方获取到 Hyper：</p><ul><li>官方网站：<a href="http://cmder.net/" target="_blank" rel="noopener">入口</a></li><li>Github：<a href="https://github.com/zeit/hyper" target="_blank" rel="noopener">入口</a></li></ul><p>下载到二进制安装包后，直接安装就可以运行，本文运行环境是 Windows。</p><h2 id="基础插件安装"><a href="#基础插件安装" class="headerlink" title="基础插件安装"></a>基础插件安装</h2><p>Hyper 本身是支持插件系统的，在安装扩展插件时，你需要先安装 Hyper 命令行程序，你可以点击菜单，选择 <code>Plugin</code> 选项，点击 <code>Install Hyper CLI command in PATH</code>。</p><p><img src="/images/hyper/insall-path.png" alt="install"></p><p>其官方在首页推荐了4个比较易用的插件，推荐直接全部安装。安装地址请点击 <a href="https://hyper.is/plugins" target="_blank" rel="noopener">链接</a>。其中4款插件分别为：</p><ul><li><a href="https://hyper.is/plugins/hypercwd" target="_blank" rel="noopener">hypercwd</a>，它可以让你的终端在新建标签页时，保持上一个终端的目录地址。安装命令： <code>hyper i hypercwd</code>。</li><li><a href="https://hyper.is/plugins/hyper-search" target="_blank" rel="noopener">hyper-search</a>，它可以让你搜索整个终端的所有文本内容。安装命令： <code>hyper i hyper-search</code>。</li><li><a href="https://hyper.is/plugins/hyper-pane" target="_blank" rel="noopener">hyper-pane</a>，增强窗口导航，对于支持多个页签的软件来说这是个利器。安装命令： <code>hyper i hyper-pane</code>。</li><li><a href="https://hyper.is/plugins/hyper-pane" target="_blank" rel="noopener">hyperpower</a>，这是一个让你的终端变得更加绚丽的插件，当然这么炫酷的效果是不是会影响你的工作呢，还是要视个人情而定。安装命令： <code>hyper i hyperpower</code>。</li></ul><p><img src="https://cloud.githubusercontent.com/assets/13041/16820268/13c9bfe6-4905-11e6-8fe4-baf8fc8d9293.gif" alt="hyperpower"></p><a id="more"></a><h2 id="主题插件安装"><a href="#主题插件安装" class="headerlink" title="主题插件安装"></a>主题插件安装</h2><p>Hyper 支持插件系统，自然就少不了主题了，官方首页推荐了4种同颜色的主题，你可以直接在<a href="https://hyper.is/themes" target="_blank" rel="noopener">主题地址</a>查看并安装。</p><p><img src="/images/hyper/themes.png" alt="install"></p><p>当然，上面的满足不了你，你也可以去在上面的主题地址中的页签 <code>NEWEST</code> 找到更多主题，或者你也可以直接去 GitHub 搜索，抑或是你自己写一个主题插件。总之，你最终会找到一款符合你的主题皮肤。</p><h2 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h2><p>GitHub 有一个项目叫做 <a href="https://github.com/bnb/awesome-hyper" target="_blank" rel="noopener">awesome-hyper</a>，其列出了 Hyper 社区中精选的软件包、主题和相关有趣的资源列表，比如下面这款当你输入 <code>git push</code> 成功执行后，终端会出现火箭动画：</p><p><img src="https://user-images.githubusercontent.com/6589909/28026422-9dc92218-655b-11e7-8852-3ee8d57c87d5.gif" alt="git-push"></p><h2 id="Hyper-集成-WSL"><a href="#Hyper-集成-WSL" class="headerlink" title="Hyper 集成 WSL"></a>Hyper 集成 WSL</h2><p>通常我们在使用 WSL 工作时，希望启动终端时就进入 WSL bash 内部，Windows 中有一个 base.exe 程序可以让我们在启动终端后输入 <code>bash</code> 后进入 WSL 终端。<br>但这一步实在太繁琐了，有了 Hyper，我们只需要改动一下配置文件，上面这步就可以直接省略。</p><p>现在，你只需打开 Hyper 设置页面文件，这一步需要从菜单 Edit -&gt; Preferences 进入，然后编辑 <code>shell</code> 和 <code>shellArgs</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell: 'C:\\Windows\\System32\\wsl.exe',</span><br><span class="line">shellArgs: [],</span><br></pre></td></tr></table></figure><p>再次从新打开 Hyper，你会发现默认已经进入了 base 终端页面。</p><h2 id="使用-zsh-代替-bash"><a href="#使用-zsh-代替-bash" class="headerlink" title="使用 zsh 代替 bash"></a>使用 zsh 代替 bash</h2><p>通常 Linux 服务器上面默认使用的命令模式是 <code>bash</code>，除了 <code>bash</code> 之外，还有很多其他诸如 <code>zsh</code>、<code>csh</code>、<code>fish</code>等，这其中，我认为 <code>zsh</code> 增强功能（标签完成和拼写错误修正）会很吸引人。</p><h3 id="安装-zsh-和-oh-my-zsh"><a href="#安装-zsh-和-oh-my-zsh" class="headerlink" title="安装 zsh 和 oh-my-zsh"></a>安装 zsh 和 oh-my-zsh</h3><p>虽然 <code>zsh</code> 配置很繁琐，但这一步已经有人帮你完成了，GitHub 上面有一个项目叫做 <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a> 就是专门用来管理配置 <code>zsh</code> 的一个框架。</p><p>在使用 <code>oh-my-zsh</code> 之前，你需要安装 <code>zsh</code>，各个平台安装的方式可能不一样，你可以通过这个 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH" target="_blank" rel="noopener">链接</a> 查看 <code>zsh</code> 安装方式。</p><p>有了 <code>zsh</code> 后，要安装 <code>oh-my-zsh</code>，你还需要用 <code>wget</code> 或者 <code>curl</code> 来辅助安装：</p><ul><li>通过 curl 安装，<code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></li><li>通过 wget 安装，<code>sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</code></li></ul><p>安装完成后，你可以通过命令 <code>chsh -s /bin/zsh</code> 设置 <code>zsh</code> 为默认的 shell。</p><h3 id="安装自动补全功能"><a href="#安装自动补全功能" class="headerlink" title="安装自动补全功能"></a>安装自动补全功能</h3><p>使用 <code>zsh</code> 我认为第一个吸引我的重要插件就是 <a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">zsh-autosuggestions</a>。它会自动为你的终端命令提供补全建议，让你能更加快速的完成命令输入，有了它，你再也不用一遍遍的按 <code>tab</code> 来加快你的命令输入了。</p><p><code>zsh-autosuggestions</code> 安装文档你可以点击这个<a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md" target="_blank" rel="noopener">链接</a> 进入查看，比如使用 Git 安装步骤如下：</p><p>使用 Git 把项目从仓库 Clone 下来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>将以下内容添加到 <code>.zshrc</code> 文件内：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br></pre></td></tr></table></figure><p>重新开启终端会话，你就可以享受 <code>zsh-autosuggestions</code> 给你带来的便利了。</p><p><img src="/images/hyper/auosuggestions.gif" alt="install"></p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p><code>Oh My Zsh</code> 附带了大量的插件和主题，你可以利用它们可以进一步增强和美化你的终端功能。要想配置主题和插件，你可以直接修改 <code>~/.zshrc</code> 文件。</p><p>对于插件启用，你可以编辑 <code>plugins</code> 输入你想要加载的插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins =（</span><br><span class="line">  git</span><br><span class="line">  bundler</span><br><span class="line">  dotenv</span><br><span class="line">  osx</span><br><span class="line">  rake</span><br><span class="line">  rbenv</span><br><span class="line">  ruby</span><br><span class="line">）</span><br></pre></td></tr></table></figure><p>对于主题，你也可以编辑文件 <code>~/.zshrc</code>，在 <code>ZSH_THEME</code> 修改主题名称即可，链接 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes" target="_blank" rel="noopener">External themes</a> 提供了大部分主题的样式，你可以直接修改参数后即可看到主题效果，比如 <code>agnoster</code> 主题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME="agnoster"</span><br></pre></td></tr></table></figure><p>修改完成后，你的终端会变成这个样子：</p><p><img src="/images/hyper/agnoster.png" alt="install"></p><p>请注意，很多主题如果你无法显示预期效果，那是因为响应的主题系统字体没有安装，你需要正确的安装了 <a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">Powerline字体</a> 字体才会显示出来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细阐述了如何安装 Hyper 终端软件，其中包括配置 Hyper 插件和主题设置，并讲述了如何使用 Hyper 完全代替 Windows 的默认终端软件 CMD。<br>最后，介绍了一种使用 zsh 来代替 bash 的方法，你可以让你的终端功能更加强大易用。<br>用一句时髦的话来总结：Hyper 长得很漂亮哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信有很多人开发环境是我 Windows 上面，有时候又不得不面临在 Windows 上面开发 Linux 环境的程序。还好 Windows 10 系统为我们提供了一个叫 WSL（Windows Subsystem for Linux） 的子系统。但是，尽管微软已经很努力得在改善 Windows 开发环境了，但我们却始终得不到一个比较简单易用得终端软件，最起码你用 Window 自带得终端来操作 Linux 系统还是会觉得缺了点什么。&lt;/p&gt;
&lt;p&gt;目前市面上很多终端软件都比 Windows 自带终端好太多，比如这篇文章就介绍了 20 个比较好用终端软件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.slant.co/topics/1552/~best-terminal-emulators-for-windows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;THE BEST 1 OF 20 OPTIONS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前用过一个不错得软件叫做 &lt;a href=&quot;http://cmder.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cmder&lt;/a&gt;，但它不是今天得主角，我们今天要介绍得是另一款更符合我口味得终端软件 Hyper。&lt;/p&gt;
&lt;h2 id=&quot;获取并安装-Hyper&quot;&gt;&lt;a href=&quot;#获取并安装-Hyper&quot; class=&quot;headerlink&quot; title=&quot;获取并安装 Hyper&quot;&gt;&lt;/a&gt;获取并安装 Hyper&lt;/h2&gt;&lt;p&gt;你可以在一下几个地方获取到 Hyper：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官方网站：&lt;a href=&quot;http://cmder.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;入口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github：&lt;a href=&quot;https://github.com/zeit/hyper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;入口&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下载到二进制安装包后，直接安装就可以运行，本文运行环境是 Windows。&lt;/p&gt;
&lt;h2 id=&quot;基础插件安装&quot;&gt;&lt;a href=&quot;#基础插件安装&quot; class=&quot;headerlink&quot; title=&quot;基础插件安装&quot;&gt;&lt;/a&gt;基础插件安装&lt;/h2&gt;&lt;p&gt;Hyper 本身是支持插件系统的，在安装扩展插件时，你需要先安装 Hyper 命令行程序，你可以点击菜单，选择 &lt;code&gt;Plugin&lt;/code&gt; 选项，点击 &lt;code&gt;Install Hyper CLI command in PATH&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/hyper/insall-path.png&quot; alt=&quot;install&quot;&gt;&lt;/p&gt;
&lt;p&gt;其官方在首页推荐了4个比较易用的插件，推荐直接全部安装。安装地址请点击 &lt;a href=&quot;https://hyper.is/plugins&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;。其中4款插件分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hyper.is/plugins/hypercwd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hypercwd&lt;/a&gt;，它可以让你的终端在新建标签页时，保持上一个终端的目录地址。安装命令： &lt;code&gt;hyper i hypercwd&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hyper.is/plugins/hyper-search&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hyper-search&lt;/a&gt;，它可以让你搜索整个终端的所有文本内容。安装命令： &lt;code&gt;hyper i hyper-search&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hyper.is/plugins/hyper-pane&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hyper-pane&lt;/a&gt;，增强窗口导航，对于支持多个页签的软件来说这是个利器。安装命令： &lt;code&gt;hyper i hyper-pane&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hyper.is/plugins/hyper-pane&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hyperpower&lt;/a&gt;，这是一个让你的终端变得更加绚丽的插件，当然这么炫酷的效果是不是会影响你的工作呢，还是要视个人情而定。安装命令： &lt;code&gt;hyper i hyperpower&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/13041/16820268/13c9bfe6-4905-11e6-8fe4-baf8fc8d9293.gif&quot; alt=&quot;hyperpower&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hyper" scheme="https://veinin.com/categories/Hyper/"/>
    
    
      <category term="Hyper" scheme="https://veinin.com/tags/Hyper/"/>
    
      <category term="Shell" scheme="https://veinin.com/tags/Shell/"/>
    
      <category term="Zsh" scheme="https://veinin.com/tags/Zsh/"/>
    
      <category term="CMD" scheme="https://veinin.com/tags/CMD/"/>
    
  </entry>
  
  <entry>
    <title>AI 行为树设计与实现-实现篇</title>
    <link href="https://veinin.com/2018/08/08/ai_behavior_tree_design_and_implementation_02/"/>
    <id>https://veinin.com/2018/08/08/ai_behavior_tree_design_and_implementation_02/</id>
    <published>2018-08-08T13:15:00.000Z</published>
    <updated>2018-08-11T14:34:14.682Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中，我们主要介绍了有限状态机和行为树的各自特点以及他们之间的优劣势，本文着重讲解如何实现一个可用的行为树，手动实现一个行为树的库，这个库代码不到200行，代码库采用面向对象方式实现，语言采用的是 Lua，当然你也可以翻译成其他任何你顺手的语言。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>行为树时一个树形结构，我们AI系统要做的是执行每个节点，所以我们最开始必须先抽象一个节点出来，该节点作为所有其他类型节点的父节点：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Node = class(<span class="string">'Node'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node:ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.blackboard = opts.blackboard</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node:doAction</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Node</span><br></pre></td></tr></table></figure><p>我们可以看到，节点拥有一个可选的成员变量 <code>blackboard</code>，我们称它为黑板，你可以搜索查看设计模式关于 <a href="https://www.google.com.hk/search?hl=zh-CN&amp;q=%E9%BB%91%E6%9D%BF%E6%A8%A1%E5%BC%8F&amp;gws_rd=ssl" target="_blank" rel="noopener">黑板模式</a> 的详细介绍。</p><p>引入黑板，是因为很多节点在处理AI逻辑时是需要对数据进行处理，黑板中包含了整个行为树可以操作的数据结构。比如上一节我们提到的关于一个NPC守夜巡逻的实现中，整个行为树要处理的对象其实是NPC，NPC打伞、NPC巡逻动作其实是NPC自身的一个行为，而行为树各个节点要处理的目标就是存放在黑板中的这个NPC。</p><p>我们实现的行为树节点对外部来说只有一个入口 <code>doAction</code> 函数，下面实现的所有其他类型的行为树节点都继承自 <code>Node</code> 节点。</p><a id="more"></a><h2 id="节点执行状态"><a href="#节点执行状态" class="headerlink" title="节点执行状态"></a>节点执行状态</h2><p>上一章我们解释了行为树包含两大类子节点：控制节点与行为节点。</p><ul><li>控制节点，这类节点没有任何游戏内的具体逻辑实现，只是为了控制行为节点的执行；</li><li>行为节点，这是涉及我们游戏内的具体游戏逻辑的节点，行为节点通常会在执行完成后，返回执行成功与否，拥有行为节点的父节点，也就是控制节点，会根据行为节点的返回值，做出相应的控制。</li></ul><p>为了更加明白的阐述，我们举个例子，例如上一节提到的NPC夜晚巡逻的AI，我们把“是否晚上”、“巡逻”这种节点称为行为节点，行为节点需要返回一些执行结果，如“是否晚上”节点返回为真，则控制节点再运行“巡逻”行为。</p><p>所以，在进入详细代码设计之前，所有节点的执行，都是需要定义一些返回状态常量值的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> BTConst = &#123;&#125;</span><br><span class="line"></span><br><span class="line">BTConst.SUCCESS = <span class="number">0</span></span><br><span class="line">BTConst.FAIL = <span class="number">1</span></span><br><span class="line">BTConst.WAIT = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BTConst</span><br></pre></td></tr></table></figure><p>行为树的节点，通常需要以上三种执行状态，执行节点成功、失败以及等待，对于等待状态，是因为一些节点单次执行并没有成功，需要等待下一次的执行时间到来以继续执行。</p><h2 id="控制节点实现"><a href="#控制节点实现" class="headerlink" title="控制节点实现"></a>控制节点实现</h2><p>对于一个行为树系统，其核心部分主要是其提供的控制节点，通过控制节点，我们可根据自己的游戏需求拓展出一套相对应的条件与行为节点。我们必须再度强调控制节点是与具体的游戏逻辑是无关的，它只负责整个行为树的逻辑控制。</p><p>本文的代码采用面向对象开发，实现语言采用 Lua。在实现控制节点前，我们先看看控制节点的类结构：</p><p><img src="/images/btree/behavior_node.png" alt="behavior_node"></p><p>从图中我们可以看到，控制节点核心包含选择节点（Selector）、序列节点（Sequence）和平行节点（Parallel），它们都继承自一个组合节点（Composite）。</p><h3 id="组合节点-Coposite"><a href="#组合节点-Coposite" class="headerlink" title="组合节点(Coposite)"></a>组合节点(Coposite)</h3><p>组合节点可以看作是一个节点的集合，可以组合多个子节点。行为树的控制节点都是组合各类行为节点的父节点，然后按一定的规则执行它们。我们先实现一个组合节点：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Composite = class(<span class="string">'Composite'</span>, Node)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Conposite:ctor</span><span class="params">()</span></span></span><br><span class="line">    self.children = &#123;&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Composite:addChild</span><span class="params">(node)</span></span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(self.children, node)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Composite</span><br></pre></td></tr></table></figure><p>组合节点成员只有一个，那就是一个孩子节点的集合，我们可以往组合节点上面添加任意数量的孩子节点。</p><h3 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h3><p>选择节点，顾名思义，就是需要从众多的子节点中选择一个可以执行成功的节点，如果子节点执行成功，则跳出执行，并且下次执行时继续从头开始。<br>选择在行为树中运用的频率比其他两个控制节点来说要更多，因为游戏AI系统中充斥着各种不同情况，我们的AI系统需要从中选择一个合理的路径执行。<br>比如下图某个NPC的AI是选择巡逻还是休息：</p><p><img src="/images/btree/selector.png" alt="selector"></p><p>选择节点代码来实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Selector = Class(<span class="string">'Selector'</span>, Composite)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Selector:ctor</span><span class="params">()</span></span></span><br><span class="line">    self.index = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">reset</span><span class="params">(self)</span></span></span><br><span class="line">    self.index = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Selector:doAction</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> size = #self.children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> BTConst.SUCCESS</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.index &gt; size <span class="keyword">then</span></span><br><span class="line">        reset(self)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = self.index, size <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> ret = self.children[i]:doAction()</span><br><span class="line">        self.index = self.index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret == BTConst.SUCCESS <span class="keyword">then</span></span><br><span class="line">            reset(self)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">elseif</span> ret == BTConst.WAIT <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    reset(self)</span><br><span class="line">    <span class="keyword">return</span> BTConst.FAIL</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Selector</span><br></pre></td></tr></table></figure><p>上面代码中，选择节点的策略是先从第一个子节点开始执行，如果遇到某个节点执行成功，则重置执行节点的位置，并直接返回，那么下次再进入该节点后，会直接从第一个子节点开始执行。<br>如果执行某个节点是等待状态，则直接返回，下次重新进入该节点执行时，会直接从等待的那个节点继续执行。<br>如果所有节点都未成功或没有等待，则返回失败，并重置执行位置，下次将会从头开始执行。</p><h3 id="序列节点"><a href="#序列节点" class="headerlink" title="序列节点"></a>序列节点</h3><p>序列节点执行是有序的，它会从从到尾依次执行其子节点，当碰到一个子节点失败是会被打断，并且立刻返回，剩下的节点将不会继续执行。<br>序列节点的特性适合于执行一系列连续的操作，如果某个操作执行失败，则后续的操作会被打断。<br>如NPC在选择巡逻还是休息的AI中，在判断巡逻时，需要判断是白天还是晚上，如果满足条件，则巡逻，否则休息：</p><p><img src="/images/btree/sequence.png" alt="sequence"></p><p>序列节点代码来实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Sequence = class(<span class="string">'Sequence'</span>, Composite)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sequence:ctor</span><span class="params">()</span></span></span><br><span class="line">    self.index = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">reset</span><span class="params">(self)</span></span></span><br><span class="line">    self.index = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sequence:doAction</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> size = #self.children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> BTConst.SUCCESS</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.index &gt; size <span class="keyword">then</span></span><br><span class="line">        reset(self)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = self.index size <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> ret = self.children[i]:doAction()</span><br><span class="line">        self.index = self.index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret == BTConst.WAIT <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">elseif</span> ret == BTConst.FAIL <span class="keyword">then</span></span><br><span class="line">            reset(self)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    reset(self)</span><br><span class="line">    <span class="keyword">return</span> BTConst.SUCCESS</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Sequence</span><br></pre></td></tr></table></figure><p>上面代码选择从头开始执行各个子节点，遇到某个节点等待，则跳出，下次继续执行剩余节点。<br>如果某个节点执行失败，则重置执行位置，并返回，下次执行时，会从头开始。<br>最后，在所有节点都执行成功后，重置执行位置，并返回执行成功，下次执行时，从头继续开始。</p><h3 id="平行节点"><a href="#平行节点" class="headerlink" title="平行节点"></a>平行节点</h3><p>平行节点与序列节点类似，但平行节点，每次执行时都会把所有子节点执行一边，然后统计其执行结果，根据平行节点执行策略，返回相应的结果。<br>平行节点影响执行结果返回会有好几种策略：</p><ul><li>FAIL_ON_ONE，只要有一个子节点执行返回失败，则执行结果就会返回失败状态。</li><li>FAIL_ON_ALL，所有子节点执行失败了，执行结果才会返回失败，否则算做成功。</li></ul><p>平行节点运用于执行一系列不被其他节点影响还的操作，如NPC巡逻AI中，在平行节点中有两个子节点，一个是选择天气，一个是选择守夜巡逻，天气系统中只会影响NPC是否需要打伞，而守夜巡逻分支影响NPC是否需要巡逻，着两个节点会独立的运行，它们之间不会相互影响的，</p><p><img src="/images/btree/parallel.png" alt="parallel"></p><p>平行节点代码来实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> FAIL_ON_ONE = <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> FAIL_ON_ALL = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> Parallel = class(<span class="string">'Parallel'</span>, Composite)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parallel:ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.policy = opts <span class="keyword">and</span> opts.policy <span class="keyword">or</span> FAIL_ON_ONE</span><br><span class="line">    self.waits = &#123;&#125;</span><br><span class="line">    self.succ = <span class="number">0</span></span><br><span class="line">    self.fail = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">reset</span><span class="params">(self)</span></span></span><br><span class="line">    self.waits = &#123;&#125;</span><br><span class="line">    self.succ = <span class="number">0</span></span><br><span class="line">    self.fail = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">checkPolicy</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="keyword">if</span> self.policy == FAIL_ON_ONE <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> self.fail &gt; <span class="number">0</span> <span class="keyword">and</span> BTConst.FAIL <span class="keyword">or</span> BTConst.SUCCESS</span><br><span class="line">    <span class="keyword">elseif</span> self.policy == FAIL_ON_ALL <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> self.succ &gt; <span class="number">0</span> <span class="keyword">and</span> BTConst.SUCCESS <span class="keyword">or</span> BTConst.FAIL</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parallel:doAction</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> size = #self.children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> BTConst.SUCCESS</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> ret</span><br><span class="line">    <span class="keyword">local</span> rest = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> origin = #self.waits &gt; <span class="number">0</span> <span class="keyword">and</span> self.waits <span class="keyword">or</span> self.children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #origin <span class="keyword">do</span></span><br><span class="line">        ret = origin[i]:doAction()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret == BTConst.SUCCESS <span class="keyword">then</span></span><br><span class="line">            self.succ = self.succ + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elseif</span> ret == BTConst.WAIT <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">table</span>.<span class="built_in">insert</span>(rest, origin[i])</span><br><span class="line">        <span class="keyword">elseif</span> ret == BTConst.FAIL <span class="keyword">then</span></span><br><span class="line">            self.fail = self.fail + <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> #rest &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        self.waits = rest</span><br><span class="line">        <span class="keyword">return</span> BTConst.WAIT</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    ret = checkPolicy(self)</span><br><span class="line">    reset(self)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面代码中，首先声明了平行节点执行策略 <code>FAIL_ON_ONE</code> 与 <code>FAIL_ON_ALL</code>。平行节点定义了3个类成员 <code>waits</code> 表示执行等待的节点，<code>succ</code> 表示执行成功的节点数量，<code>fail</code> 表示执行失败的节点数量。<br>节点开始执行前先获取执行起点，如果有等待执行的节点，有优先执行等待节点；如果没有等待的节点，则从头开始执行各个子节点。<br>子节点执行成功、失败，则记录，如果是带状态则记录到等待列表 <code>rest</code> 中，并在执行完成后，检查 <code>rest</code>，如果存在等待节点，则直接返回，下次继续执行等待节点。<br>如果所有节点执行都返回成功或失败，则根据记录从节点策略中获取返回状态码，并重置所有执行记录，等待下一次重新开始执行。</p><h3 id="装饰节点"><a href="#装饰节点" class="headerlink" title="装饰节点"></a>装饰节点</h3><p>装饰节点可以作为额外的附加条件，例如，时间间隔控制、频率控制、触发概率、结果取反、错误处理等待。<br>比如我一个怪物使用某个技能，我们实现了使用技能的行为节点，但我们需要对这个使用技能的行为节点增加节点触发概率，这种情况下，我们就可以使用装饰节点来扩充原有的行为节点。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Decorator = class(<span class="string">'Decorator'</span>, Node)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Decorator:ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.child = opts.child</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Decorator:setChild</span><span class="params">(node)</span></span></span><br><span class="line">    self.child = node</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Decorator</span><br></pre></td></tr></table></figure><p>上面装饰节点中，存储了一个装饰子节点，这个子节点将作为被装饰的对象。</p><h3 id="循环节点"><a href="#循环节点" class="headerlink" title="循环节点"></a>循环节点</h3><p>循环节点根据条件不停循环执行子节点，直到子节点返回成功，然后检查循环条件，判断自己是否继续循环。比如巡逻AI中，根节点就是一个循环节点，默认情况下，循环节点会移植运行下去，直到循环节点运行成功，比如我们需求在NPC进行巡逻后，就结束AI的运行等等。</p><p><img src="/images/btree/loop.png" alt="loop"></p><p>我们看下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Loop = Class(<span class="string">'Loop'</span>, Decorator)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Loop:ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.loopCond = data.loopCond</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Loop:doAction</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> ret = self.child:doAction()</span><br><span class="line">    <span class="keyword">if</span> ret ~= BTConst.SUCCESS <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.loopCond <span class="keyword">and</span> self.loopCond(self.blackboard) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> BTConst.WAIT</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BTConst.SUCCESS</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Loop</span><br></pre></td></tr></table></figure><p>循环节点也是一个装饰节点，其有一个循环检查条件节点用于在子节点执行成功后检查，</p><h2 id="行为节点实现"><a href="#行为节点实现" class="headerlink" title="行为节点实现"></a>行为节点实现</h2><p>有了控制节点后，我们剩下的就是实现行为节点了，行为节点可能每个游戏都会不一样，这主要是因为每个游戏AI可能都不同，具体需求到来时，才针对性的实现，所以行为节点通常依托于控制节点，其只会作为叶子节点使用。</p><h3 id="条件节点"><a href="#条件节点" class="headerlink" title="条件节点"></a>条件节点</h3><p>条件节点的作用是判定，如NPC巡逻AI中，天气判定、打伞判定、时间判定都是一个条件节点。先看条件节点实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Condition = class(<span class="string">'Condition'</span>, Node)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Condition:ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.umpire = opts.umpire</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Condition:doAction</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> self.umpire <span class="keyword">and</span> self.umpire(self.blackboard) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> BTConst.SUCCESS</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BTConst.FAIL</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Condition</span><br></pre></td></tr></table></figure><p>条件节点有一个成员变量 <code>umpire</code> ，我们把他视为一个“裁判员”，用来判定某个条件是否成立。这个变量在 Lua 中实现为一个函数，我们可以自定义一个函数，然后根据上面的接口创建一个条件，比如创建判定天气为晴天的条件节点：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> isSunny = <span class="function"><span class="keyword">function</span><span class="params">(blackboard)</span></span></span><br><span class="line">    <span class="keyword">return</span> blackboard.world.weather == <span class="string">"Sunny"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> isSunnyCondition = Condition.new(isSunny)</span><br><span class="line">isSunnyCondition.doAction()</span><br></pre></td></tr></table></figure><p>可以看到上面创建一个判定天晴的条件节点是分成简单的，判定条件参数传入的是一个“黑板”成员，里面保存着AI需要的数据对象，比如上面代码中，我们可以直接通过黑板获取到世界<code>world</code>对象，来获取当前天气。</p><h3 id="动作节点"><a href="#动作节点" class="headerlink" title="动作节点"></a>动作节点</h3><p>动作节点人如其名，只会执行相应的动作，具体执行什么动作，也是根据游戏 AI 需求去重新实现的，比如我们的巡逻AI中，NPC 执行打伞、收伞、巡逻等一系列的动作。动作节点只需要继承自 Node 节点，然后实现 <code>doAction</code> 内容即可，如一个 NPC 的巡逻动作：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> PatrolAction = class(<span class="string">'PatrolAction'</span>, Node)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PatrolAction:doAction</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> npc = self.blackboard.npc</span><br><span class="line">    npc:GoPatrol()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> PatrolAction</span><br></pre></td></tr></table></figure><p>上面巡逻动作节点实现很简单，只需要执行时，从黑板中获取到NPC对象，然后调用NPC巡逻函数 <code>GoPatrol</code>，NPC就开始进行巡逻了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章节，我们的行为树核心代码基本全部实现，对于AI不太复杂的游戏，这些代码基本可用了，当然我们也可以根据上面代码在项目需求满足不了的情况下，继续拓展不同类型、不同功能的节点，比如可以支持权值的选择节点等等。下一节，我们将根据这些代码来实现一个具体的 NPC 巡逻 AI。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中，我们主要介绍了有限状态机和行为树的各自特点以及他们之间的优劣势，本文着重讲解如何实现一个可用的行为树，手动实现一个行为树的库，这个库代码不到200行，代码库采用面向对象方式实现，语言采用的是 Lua，当然你也可以翻译成其他任何你顺手的语言。&lt;/p&gt;
&lt;h2 id=&quot;节点&quot;&gt;&lt;a href=&quot;#节点&quot; class=&quot;headerlink&quot; title=&quot;节点&quot;&gt;&lt;/a&gt;节点&lt;/h2&gt;&lt;p&gt;行为树时一个树形结构，我们AI系统要做的是执行每个节点，所以我们最开始必须先抽象一个节点出来，该节点作为所有其他类型节点的父节点：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt; Node = class(&lt;span class=&quot;string&quot;&gt;&#39;Node&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node:ctor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(opts)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.blackboard = opts.blackboard&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node:doAction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Node&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以看到，节点拥有一个可选的成员变量 &lt;code&gt;blackboard&lt;/code&gt;，我们称它为黑板，你可以搜索查看设计模式关于 &lt;a href=&quot;https://www.google.com.hk/search?hl=zh-CN&amp;amp;q=%E9%BB%91%E6%9D%BF%E6%A8%A1%E5%BC%8F&amp;amp;gws_rd=ssl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黑板模式&lt;/a&gt; 的详细介绍。&lt;/p&gt;
&lt;p&gt;引入黑板，是因为很多节点在处理AI逻辑时是需要对数据进行处理，黑板中包含了整个行为树可以操作的数据结构。比如上一节我们提到的关于一个NPC守夜巡逻的实现中，整个行为树要处理的对象其实是NPC，NPC打伞、NPC巡逻动作其实是NPC自身的一个行为，而行为树各个节点要处理的目标就是存放在黑板中的这个NPC。&lt;/p&gt;
&lt;p&gt;我们实现的行为树节点对外部来说只有一个入口 &lt;code&gt;doAction&lt;/code&gt; 函数，下面实现的所有其他类型的行为树节点都继承自 &lt;code&gt;Node&lt;/code&gt; 节点。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="https://veinin.com/categories/AI/"/>
    
    
      <category term="AI" scheme="https://veinin.com/tags/AI/"/>
    
      <category term="行为树" scheme="https://veinin.com/tags/%E8%A1%8C%E4%B8%BA%E6%A0%91/"/>
    
      <category term="状态机" scheme="https://veinin.com/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>AI 行为树设计与实现-理论篇</title>
    <link href="https://veinin.com/2018/08/07/ai_behavior_tree_design_and_implementation_01/"/>
    <id>https://veinin.com/2018/08/07/ai_behavior_tree_design_and_implementation_01/</id>
    <published>2018-08-07T10:36:00.000Z</published>
    <updated>2018-08-11T11:05:08.175Z</updated>
    
    <content type="html"><![CDATA[<p>一个典型的 AI 系统通常包含：感知、导航和决策三个子系统。对于游戏来说，感知系统是可以“作弊”的，不需要NPC真的去“感知”世界，系统可以告诉NPC世界是怎么的。所以，对于导航系统，不再属于本文的讨论范畴。而决策系统才是让NPC看起来可以有自己的意图和信念的，所以本文讨论的是决策系统。</p><p>一个 AI 决策系统模型看起来是这样的：</p><p><img src="/images/btree/decision.png" alt="decision"></p><p>最开始，游戏 AI 的决策系统往往会这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(自己)</span><br><span class="line">    case '血量充足':</span><br><span class="line">        攻击();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    case '快死了':</span><br><span class="line">        加血();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ‘死了’:</span><br><span class="line">        游戏结束();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>随机计算机硬件的不断提升，可以分配给 AI 运算的 CPU 时间越来越长，我们对游戏 AI 的要求也自然提高了，比如我们可以相处这样的策略：有多个敌人时，使用群体技能；只有单个敌人时，使用强力的单体攻击；魔法低于50时，吃药补魔法；血量低于100时，吃个大的血瓶回血。</p><p>于是，AI 程序员在上面的需求到来的时候，不得不继续扩充上的 swtich 条件，然后在 case 里面增加自己的逻辑。可以想象，如果一个 Moba 类游戏中，一个地狱难度的电脑的 AI 需要根据场上的情况使用各种策略。当策划的需求越来越多，很快，一个带有上万行的代码函数就横空出世啦。如果这时候遇到了一个 Bug ，不要说修复，仅仅是阅读这个函数的代码都恐怕让人觉得畏惧了。</p><p>毫无疑问，当一个函数遇到大量的状态转换判断的时候，很容易让整个程序崩溃，不过经过后辈们前赴后继的努力，目前市面上关于游戏的 AI 有了更加精简的代码手段。比如常见 的 AI 模型：FSM（有限状态机）和 Behavior Tree（行为树）。</p><h2 id="有限状态机（FMS）"><a href="#有限状态机（FMS）" class="headerlink" title="有限状态机（FMS）"></a>有限状态机（FMS）</h2><p>相对于 <code>switch - case</code> 来说， FSM 编程与人类的思维相似，更易于梳理，更加灵活。当每种状态封装后，就不在会有一个“中央”函数来控制所有的逻辑，每个状态只要管好自己的业务就行。这样，一个复杂的决策系统就被切割成了两子系统，不同的状态以及状态之间的转换。切割后的子系统与原有的系统被大大简化，从而使得代码变得可以维护。FSM 在相当多的游戏中已经被应用，甚至 Unreal Engine 的脚本语言是直接支持状态编程的。</p><p>当游戏中的NPC决策并不太复杂时候，FSM是非常有效的。比如 Half-Life 这款游戏，里面的AI被业界称赞了很久，而其中的AI就是通过FSM来实现的。</p><h3 id="有限状态机举例"><a href="#有限状态机举例" class="headerlink" title="有限状态机举例"></a>有限状态机举例</h3><p>我们接下来通过一个简单的例子来认识一下FSM。比如一个AI文字表述如下：</p><p>1.平时的状态是巡逻</p><ol start="2"><li>如果遇到敌人之后打量一下敌人</li><li>如果敌人比自己弱小，那就打攻击</li><li>如果敌人比自己强大，那就跑逃跑</li></ol><p>那么这个可以很自然的转换成 FSM，然后进行编程实现，我们可以看看整个 AI 流程图：</p><p><img src="/images/btree/fms.png" alt="fms"></p><h3 id="有限状态机缺点"><a href="#有限状态机缺点" class="headerlink" title="有限状态机缺点"></a>有限状态机缺点</h3><p>虽然FSM简洁，和人的直觉思维相近，但是FSM也是有缺点的：</p><ul><li>由于我们所能做的仅是编辑从一状态到另一状态的转换，而无法做出更高层次的模式功能，所以会导致我们发现自己总是在构建相似的行为，这会花费我们大部分时间。</li><li>使用 FSM 实现目标导向的行为需要做很多工作。这是一个大问题，因为大部分有针对性的AI 需要处理长远目标。</li><li>FSM 难以并发。当并行运行多个状态机，要么死锁，要么我们通过手工编辑来确保它们在某个程度上能够兼容。</li><li>大规模支持较差，即使是分层的有限状态机，也难以大规模扩展。它们往往是在其中夹杂一大块逻辑代码，而非行为编辑模块化。</li><li>用 FSM 实现任何设计都需要做大量工作，需要花费设计师的大量时间(并非编程时间)，甚至最终这还会成行为中的 bugs 的来源。</li></ul><h2 id="行为树（Behavior-Tree）"><a href="#行为树（Behavior-Tree）" class="headerlink" title="行为树（Behavior Tree）"></a>行为树（Behavior Tree）</h2><p>行为树是在Next-Gen AI中提出的模型，虽说是Next-Gen AI，但距其原型提出已有约10年时间。其中Spore(孢子)，Crysis(孤岛危机)2，Red Dead Redemption(荒野大镖客：救赎)等就是用行为树作为它们的AI模型。而越来越多的引擎也都开始直接支持行为树，比如 Cry Engine, Havok等。</p><p>对于用行为树定模型构造的AI系统来说，每次执行AI时 ，系统都会从根节点遍历整个树，父节点执行子节点，子节点执行完后将结果返回父节点，然后父节点根据子节点的结果来决定接下来怎么做。</p><p>所谓树，那么其就存在很多节点，而对于行为树来说，它把基本节点类型分为两大类：</p><h3 id="控制节点"><a href="#控制节点" class="headerlink" title="控制节点"></a>控制节点</h3><p>在行为树中我们所看到的所有父节点都被称为控制节点。控制节点是行为树的核心部分，它与具体的游戏是无关的，它只负责整个行为树的逻辑控制。其包含以下几种类型：</p><ul><li>选择节点(Selector)：属于组合节点，顺序执行子节点，只要碰到一个子节点返回true，则停止继续执行，并返回true，否则返回false，类似于程序中的逻辑或。</li><li>顺序节点(Sequence)：属于组合节点，顺序执行子节点，只要碰到一个子节点返回false，则停止继续执行，并返回false，否则返回true，类似于程序中的逻辑与。</li><li>平行节点(Parallel)：提供了平行的概念，无论子节点返回值是什么都会遍历所有子节点。所以不需要像 Selector/Sequence 那样预判哪个 Child Node 应摆前，哪个应摆后。Parallel Node增加方便性的同时，也增加实现和维护复杂度。</li><li>组合节点(Coposite)：可以组合多个子节点。</li><li>装饰节点(Decoraor)：可以作为某种节点的一种额外的附加条件，如允许次数限制，时间限制，错误处理等。</li><li>循环节点(Loop)：循环执行相应的动作，并返回结果。</li></ul><h3 id="行为节点"><a href="#行为节点" class="headerlink" title="行为节点"></a>行为节点</h3><p>行为树的行为定义都在行为节点中，也就是我们说的叶子节点。行为节点是与我们的具体需求相关的，不同的需求定义会有不同的行为节点。</p><ul><li>条件节点(Condition)：属于叶子节点，判断条件是否成立。</li><li>动作节点(Action)：属于叶子节点，执行动作，一般返回true。</li></ul><p>当然，如果有更多需求，也可以自己继续拓展，通过控制与行为节点的组合，最终，会产生一颗行为树，它看起来会是这样的：</p><p><img src="/images/btree/behavior_tree.png" alt="behavior_tree"></p><h3 id="行为树举例"><a href="#行为树举例" class="headerlink" title="行为树举例"></a>行为树举例</h3><p>我们可以来看一个行为树构造 AI 的例子，这个AI的逻辑文字表述为：</p><p>1.一个NPC在晚上需要执行守夜巡逻的任务。<br>2.如果到了白天，那么NPC需要休息。<br>3.如果天下雨的话，则需要打伞。<br>4.如果天气变晴，处在打伞状态下的人需要把伞收起。</p><p>通过以上条件，我们可以转换成一颗行为树：</p><p><img src="/images/btree/behavior_tree_npc.png" alt="behavior_tree_npc"></p><h3 id="行为树优缺点"><a href="#行为树优缺点" class="headerlink" title="行为树优缺点"></a>行为树优缺点</h3><p>行为树模型看似简单，但是以下几个优点让行为树目前变成了复杂AI的主流模型：</p><ul><li>静态性。越复杂的功能越需要简单的基础，否则最后连自己都玩不过来。即使系统需要某些”动态”性，也应该尽量使用静态的行为树来表示。静态性直接带来的好处就是整棵树的规划无需再运行时动态调整，大大方便设计人员和编程人员，并且大大减少诡异的bug，同时这也为很多优化和预编辑都带来方便。</li><li>直观性。行为树可以方便地把复杂的AI知识条目组织得非常直观。默认的组合节点处理子节点的迭代方式就像是处理一个预设优先策略队列，也非常符合人类的正常思考模式：先最优再次优。此外，行为树编辑器对优秀的程序员来说也是唾手可得。</li><li>复用性。各种节点，包括叶子节点，可复用性都极高。</li><li>扩展性。可以容易地为项目量身定做新的组合节点或修饰节点。还可以积累一个项目相关的节点库，长远来说非常有价值。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个典型的 AI 系统通常包含：感知、导航和决策三个子系统。对于游戏来说，感知系统是可以“作弊”的，不需要NPC真的去“感知”世界，系统可以告诉NPC世界是怎么的。所以，对于导航系统，不再属于本文的讨论范畴。而决策系统才是让NPC看起来可以有自己的意图和信念的，所以本文讨论的是决策系统。&lt;/p&gt;
&lt;p&gt;一个 AI 决策系统模型看起来是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/btree/decision.png&quot; alt=&quot;decision&quot;&gt;&lt;/p&gt;
&lt;p&gt;最开始，游戏 AI 的决策系统往往会这样写：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt;(自己)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &#39;血量充足&#39;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        攻击();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &#39;快死了&#39;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        加血();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ‘死了’:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        游戏结束();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="AI" scheme="https://veinin.com/categories/AI/"/>
    
    
      <category term="AI" scheme="https://veinin.com/tags/AI/"/>
    
      <category term="行为树" scheme="https://veinin.com/tags/%E8%A1%8C%E4%B8%BA%E6%A0%91/"/>
    
      <category term="状态机" scheme="https://veinin.com/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记：游戏 UI 半自动化开发流程</title>
    <link href="https://veinin.com/2018/07/31/dev_notes-game-UI-semi-automated-development/"/>
    <id>https://veinin.com/2018/07/31/dev_notes-game-UI-semi-automated-development/</id>
    <published>2018-07-31T12:10:00.000Z</published>
    <updated>2018-08-01T14:39:59.893Z</updated>
    
    <content type="html"><![CDATA[<p>最近着手试了下我们客户端 UI 开发，发现整个流程对于开发人员来说并不是很友好，我们游戏客户端代码基本使用 Lua 语言进行，引擎则采用 Unity。对于 UI 模块目前有一套基本的 MVC 模式的开发流程，但这个开发模式的边界并没有处理很好，导致开发过程中异常艰难。编写代码的人员有时也会很懵逼，因为实现的方式可以有多种多样。</p><p>在了解了整个旧有的开发流程后，我发现个问题，其中由UI编辑到代码编写，这个流程中，大部分过程都是重复行工作，而针对这一部分重复行工作通过一些小工具可以让UI开发流程实现半自动化。</p><p>所谓半自动化，无非就是，开发人员不需要编写基本的UI代码，基础UI代码可以自动生成，包括整个开发流程中使用的各个UI窗口的组件都可以自动生成代码。</p><p>另外，因为UI编写过程中进程资源修改、代码修改，我希望都可以在修改完后立刻可以看到效果，而不是重启游戏。</p><p>下面是我对于一个半自动化的UI开发流程整理笔记。</p><a id="more"></a><h2 id="UI-编辑流程"><a href="#UI-编辑流程" class="headerlink" title="UI 编辑流程"></a>UI 编辑流程</h2><p>我们的 UI 编辑是一个独立的项目工程，通常一个功能的 UI 编辑会由策划完成一部分工作，程序人员拿过来，按需求再整理 UI 资源、编写代码即可。</p><ol><li>编辑器项目结构</li></ol><p>在UI编辑器中，其文件结构看起来是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">UIProject</span><br><span class="line">    -&gt; Assert</span><br><span class="line">        -&gt; PublicPrefabs - 公共UI</span><br><span class="line">        -&gt; PulibcResources - 公共资源</span><br><span class="line">        -&gt; Texture - 纹理</span><br><span class="line">        -&gt; UI</span><br><span class="line">            -&gt; LoginWindow - 登陆窗口UI</span><br><span class="line">                -&gt; Prefabs</span><br><span class="line">            -&gt; EquipWinodw - 装备窗口UI</span><br><span class="line">                -&gt; Prefabs</span><br><span class="line">            -&gt; TeamWindow  - 组队窗口UI</span><br><span class="line">                -&gt; Prefabs</span><br><span class="line">                    -&gt; TeamCreateView - 队伍创建窗口</span><br><span class="line">                    -&gt; TeamMemberView - 队员窗口</span><br><span class="line">                    -&gt; TeamMemberItem - 队员窗口队伍信息</span><br><span class="line">                    -&gt; ...</span><br><span class="line">                -&gt;  UI资源1.png</span><br><span class="line">                -&gt;  UI资源2.png</span><br><span class="line">                -&gt;  ...</span><br><span class="line">            -&gt; ...</span><br></pre></td></tr></table></figure><p>比如在一个组队功能UI里面，其他包含一个文件夹（TeamWindow），该文件夹下包含了多个UI用到的私有美术资源图片、纹理等。Window 文件夹下，有一个 Prefabs 文件夹，用来保存该功能所用到的所有子UI。</p><p>比如上面队伍窗口（TeamWindow）在UI设计中看起来是这样的：</p><p><img src="/images/mvc/mvc_ui_design.png" alt="mvc"></p><p>其包含3个View文件，两个主要窗口，CreateView用来创建队伍窗口，MemberView用来显示队伍成员窗口，而MemberItem用来显示队伍成员窗口下的队员详细。</p><p>2.UI文件打包</p><p>编辑好的UI会统一打包成一个文件，方便使用代码做资源一次性加载。比如上面TeamWindow，打包后一个统一的资源包文件，包含了上面所示的队伍UI下面的所有子窗口。</p><h2 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h2><p>原有的UI开发流程是使用 MVC 设计模式的，采用这个模式，如果能处理好，开发起来也是会很顺畅的。</p><p>对于 MVC，我们先用一张图来展示：</p><p><img src="/images/mvc/mvc_pattern.png" alt="mvc"></p><p>在 Unity UI 开发中引入 MVC 设计模式，它看起来是这样的：</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><ul><li>其只是用来保存数据用的，其不能访问 View 或 Controller。</li><li>它可以被 Controller 和 View 直接访问。</li></ul><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><ul><li>其只是游戏中能用户看到的 UI 布局。</li><li>View 可以处理 UI 点击逻辑、处理外面传进来的数据，可以访问和修改 Model。</li><li>在 Unity 中，每个 UI 资源的 Prefab 文件都会生成一个与之对应的 View 源代码文件。</li></ul><h3 id="Conroller"><a href="#Conroller" class="headerlink" title="Conroller"></a>Conroller</h3><ul><li>负责控制单个模块内所有 View 资源的加载、显示、关闭、数据更新、分组、层级控制等。</li><li>其持有所有 View 和 Model 对象。</li><li>其销毁后，所有View 和 Model 都会自动销毁。</li></ul><h2 id="MVC-实现"><a href="#MVC-实现" class="headerlink" title="MVC 实现"></a>MVC 实现</h2><p>对于上面所示的MVC模式，我们结合相关MVC特性，用实际代码来展示，下面实例统一采用 Lua 语言，并使用面向对象概念来设计。</p><h3 id="实现一个-Controller-接口"><a href="#实现一个-Controller-接口" class="headerlink" title="实现一个 Controller 接口"></a>实现一个 Controller 接口</h3><p>Controller 是一个UI功能的控制中心，其控制当前Window下的所有UI的加载、显示、隐藏，以及数据保存、清理、传递工作。<br>默认情况下所有子UI（UIView子类）都是会自动被其销毁的，其资源、数据都会在最后一个窗口关闭后自动清理掉。</p><p>Controller 接口完整生命周期示例图如下：</p><p><img src="/images/mvc/mvc_controller_life_cycle.png" alt="mvc"></p><p>实现的 Controller 接口代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIController = Class(<span class="string">'UIController'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Ctor</span><span class="params">(opts)</span></span></span><br><span class="line">    self.isInit         = <span class="literal">false</span></span><br><span class="line">    self.isPersistent   = opts.isPersistent <span class="comment">-- 是否持久化 model 数据，如果为 true，不会销毁 model 数据</span></span><br><span class="line">    self.prefabsName    = opts.prefabsName  <span class="comment">-- UI 打包后的资源名称</span></span><br><span class="line">    self.assets         = &#123;&#125;                <span class="comment">-- 已经加载的资源</span></span><br><span class="line"></span><br><span class="line">    self.model          = &#123;&#125;                <span class="comment">-- model 数据</span></span><br><span class="line"></span><br><span class="line">    self.viewClasses    = &#123;&#125;                <span class="comment">-- view 资源对应的子类，未实例化</span></span><br><span class="line">    self.openViews      = &#123;&#125;                <span class="comment">-- 已经打开的 view</span></span><br><span class="line">    self.openViewCount  = &#123;&#125;                <span class="comment">-- 已经打开的 view 数量</span></span><br><span class="line">    self.lastOpenData   = <span class="literal">nil</span>               <span class="comment">-- 上次打开 view 时的数据（未初始化时需要先保存打开时数据，初始化完成后再打开）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:IsInit</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> self.isInit</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">OnLoad</span><span class="params">(self, assets)</span></span></span><br><span class="line">    <span class="keyword">for</span> _, asset <span class="keyword">in</span> <span class="built_in">ipairs</span>(assets) <span class="keyword">do</span></span><br><span class="line">        self.assets[asset.name] = asset</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self.isInit = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">next</span>(self.viewClasses) <span class="keyword">then</span></span><br><span class="line">        self:OnInitView()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.lastOpenData <span class="keyword">then</span></span><br><span class="line">        self.Open(<span class="built_in">unpack</span>(self.lastOpenData))</span><br><span class="line">        self.lastOpenData = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        self:OnDefaultOpen()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Init</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> self:IsInit() <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    LoadManager:LoadPrefab(self.prefabsName, <span class="function"><span class="keyword">function</span><span class="params">(assets)</span></span></span><br><span class="line">        OnLoad(self, assets)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:OnInitView</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:RegisterView</span><span class="params">(class)</span></span></span><br><span class="line">    <span class="built_in">assert</span>(self.viewClasses[class.name] == <span class="literal">nil</span>)</span><br><span class="line">    self.viewClasses[class.name] = class</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">CreateView</span><span class="params">(self, name)</span></span></span><br><span class="line">    <span class="keyword">local</span> class = self.viewClasses[name]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> class <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> view = class.New()</span><br><span class="line">    view.controller = self</span><br><span class="line">    view.model      = self.model</span><br><span class="line"></span><br><span class="line">    self.openViews[name] = view</span><br><span class="line">    self.openViewCount = self.openViewCount + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">GetView</span><span class="params">(self, name)</span></span></span><br><span class="line">    <span class="keyword">local</span> view = self.openViews[name]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> view <span class="keyword">then</span></span><br><span class="line">        view = CreateView(self, name)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> view <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> view:IsState(UIConst.LIFESTATE.NONE) <span class="keyword">then</span></span><br><span class="line">        UIHelper.InitView(self, view)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Open</span><span class="params">(name, ...)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self:IsInit() <span class="keyword">then</span></span><br><span class="line">        self.lastOpenData = &#123;name, ...&#125;</span><br><span class="line">        self:Init()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> view = GetView(self, name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> view <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> view:IsState(UIConst.LIFESTATE.SHOW) <span class="keyword">then</span></span><br><span class="line">        view:Update(...)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        view:Open(...)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Close</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> view <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    GameObject.Destroy(view.gameObject)</span><br><span class="line"></span><br><span class="line">    self.openViews[name] = <span class="literal">nil</span></span><br><span class="line">    self.openViewCount = self.openViewCount - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.openViewCount == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        self:Dispose()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Dispose</span><span class="params">()</span></span></span><br><span class="line">    self.isInit = <span class="literal">false</span></span><br><span class="line">    self.assets = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    LoadManager:RemovePrefab(self.prefabsName)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.isPersistent <span class="keyword">then</span></span><br><span class="line">        self.model = &#123;&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self:OnDispose()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:OnDispose</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIController</span><br></pre></td></tr></table></figure><p>根据上面生命周期实例图和代码实现，我们可以看到 Contoller 入口有两个，一个是外部打开指定 View，一个是外部关闭指定 View。</p><p>当外部需要打开指定 View 时，我们先检查当前 Controller 是否初始化完成，如果未初始化，则先临时保存打开时的数据，然后再走初始化 Controller 逻辑，加载 UI 资源。</p><p>当加载 UI 资源完成后，我们通过 View 的名称，调用 <code>GetView()</code> 函数获取一个 View 对象，如果 View 对象未创建，则走创建对象逻辑 <code>CreateView()</code>，并调用 View 初始化逻辑（下一节详解）。</p><p>获取到 View 对象后，如果 View 是打开状态则调用 <code>UIView.Update(...)</code> 函数更新，关闭状态则调用 <code>UIView:Open(...)</code> 函数打开。</p><p>UIController 对外暴露一个公共接口：</p><ul><li><code>UIController.Open(name, ...)</code>，用于外部打开指定 View 。</li><li><code>UIController.RegisterView(class)</code>，用于注册一个 View 子类，通过其来实例化相应的 UI 窗口。</li><li><code>UIController.Close(view)</code>，用于关闭一个 View，这个接口用于 View 为了关闭自己而调用。</li></ul><p>UIController 作为一个父类，需要子类重写以下接口：</p><ul><li><code>UIController.OnInitView()</code>，初始化所有View，调用 <code>RegisterView</code> 注册指定 View。</li><li><code>UIController.OnDispose()</code>，销毁整个 Controller 的后续处理。</li></ul><h3 id="实现一个-View-接口"><a href="#实现一个-View-接口" class="headerlink" title="实现一个 View 接口"></a>实现一个 View 接口</h3><p>View 接口是所有UI资源窗口的父类，子类通过继承方式实现一个UI子窗口显示。<br>View 子类可以直接访问和修改 model 数据，另外，我希望在 View 中能间接调用 Controller 打开其他窗口。</p><p>View 接口完整生命周期示例图如下：</p><p><img src="/images/mvc/mvc_view_life_cycle.png" alt="mvc"></p><p>根据上面生命周期实例图，我们可以看出整个 View 对象从初始化到关闭的完整生命周期流程。我们把 View 生命周期状态分为3部分：</p><ul><li>NONE，未初始化状态</li><li>HIDE，隐藏状态</li><li>SHOW，打开状态</li></ul><p>根据上面的状态图，我们先实现 View 接口代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIView = Class(<span class="string">'UIView'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Ctor</span><span class="params">()</span></span></span><br><span class="line">    self.controller    = <span class="literal">nil</span> <span class="comment">-- 持有 View 的 UIController 对象</span></span><br><span class="line">    self.model         = <span class="literal">nil</span> <span class="comment">-- View 持有的 Model 数据，与 UIController 共享</span></span><br><span class="line"></span><br><span class="line">    self.gameObject    = <span class="literal">nil</span>   <span class="comment">-- 引擎对象，该对象保存着UI资源</span></span><br><span class="line">    self.isAutoDestroy = <span class="literal">false</span> <span class="comment">-- 是否自动销毁，默认关闭时直接销毁对象，如果不自动销毁，关闭动作时隐藏</span></span><br><span class="line">    self.layer         = UIConst.LAYER.MIDDLE   <span class="comment">-- UI 层级（高、中、低）</span></span><br><span class="line">    self.lifeState     = UIConst.LIFESTATE.NONE <span class="comment">-- UI 生命周期状态</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:IsState</span><span class="params">(state)</span></span></span><br><span class="line">    <span class="keyword">return</span> self.lifeState == state</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Init</span><span class="params">()</span></span></span><br><span class="line">    self.gameObject:SetActive(<span class="literal">false</span>)</span><br><span class="line">    self.lifeState = UIConst.LIFESTATE.HIDE</span><br><span class="line">    self:OnInit()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OpenView</span><span class="params">(name, ...)</span></span></span><br><span class="line">    self.controller:Open(name, ...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Open</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self:IsState(UIConst.LIFESTATE.HIDE) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self.lifeState = UIConst.LIFESTATE.SHOW</span><br><span class="line">    self.gameObject:SetActive(<span class="literal">true</span>)</span><br><span class="line">    self:OnShow(...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Update</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self:IsState(UIConst.LIFESTATE.SHOW) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self:OnUpdate(...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:Close</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self:IsState(UIConst.LIFESTATE.SHOW) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    self:OnHide()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.isAutoDestroy <span class="keyword">then</span></span><br><span class="line">        self.controller:Close(self)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        self.gameObject:SetActive(<span class="literal">false</span>)</span><br><span class="line">        self.lifeState = UIConst.LIFE_STATE.HIDE</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OnInit</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OnShow</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OnUpdate</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIView:OnHide</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIView</span><br></pre></td></tr></table></figure><p>View 初始化时，会从引擎底层加载 UI 编辑器指定的 UI 组件到 View 对象，这一步是 Contoller 在创建 View 时执行的，我们可以看到 <code>UIContoller.GetView()</code> 函数调用时，判断当前 View 对象如果是未初始化状态则调用帮助函数 <code>UIHelper.InitView()</code> 加载所有 UI 组件对象，其加载代码看起来时这样的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIHelper = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Lua 封装的 UI 组件对象</span></span><br><span class="line"><span class="keyword">local</span> UI_TYPES = &#123;</span><br><span class="line">    [<span class="string">'UIButton'</span>]        = <span class="built_in">require</span>(<span class="string">"game.ui.component.UIButton"</span>),</span><br><span class="line">    [<span class="string">'UILabel'</span>]         = <span class="built_in">require</span>(<span class="string">"game.ui.component.UILabel"</span>),</span><br><span class="line">    [<span class="string">'UIInputField'</span>]    = <span class="built_in">require</span>(<span class="string">"game.ui.component.UIInputField"</span>),</span><br><span class="line">    <span class="comment">-- 其他 UI 组件...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建引擎 UI 对象</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">CreateCSObject</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- TODO 创建引擎UI对象，设置其层级关系</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化所以 UI 组件Lua对象</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">InitComponents</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="keyword">local</span> components = view.gameObject.components</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, component <span class="keyword">in</span> <span class="built_in">ipairs</span>(components) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> uiLuaClass = UI_TYPES[component.typeName]</span><br><span class="line">        <span class="keyword">if</span> uiLuaClass <span class="keyword">then</span></span><br><span class="line">            view[component.key] = uiLuaClass.New(component.value)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化 UIView 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIHelper.InitView</span><span class="params">(view)</span></span></span><br><span class="line">    view.gameObject = CreateCSObject(view)</span><br><span class="line"></span><br><span class="line">    InitComponents(view)</span><br><span class="line"></span><br><span class="line">    view:Init()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIHelper</span><br></pre></td></tr></table></figure><p>在我们可以看到所有 UI 组件都在 Lua 层有一个简单的封装对象，我们在 UI 编辑器指定 UI 组件名称和类型后，在加载完 View 对象后，其 UI 组件就被赋予给了 View 对象。下面给出了一个按钮组件的简单封装实例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIButton = Class(<span class="string">'UIButton'</span>, UIBehaviour)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIButton:SetText</span><span class="params">(name)</span></span></span><br><span class="line">    self.core.text = name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIButton:SetEnable</span><span class="params">(isEnable)</span></span></span><br><span class="line">    self.core:SetEnable(isEnable)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIButton:AddListener</span><span class="params">(callback, delayTime)</span></span></span><br><span class="line">    delayTime = delayTime <span class="keyword">or</span> <span class="number">0.3</span></span><br><span class="line">    self.event.onClickLua = callback</span><br><span class="line">    self.event.clickDelayTime = delayTime</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIButton</span><br></pre></td></tr></table></figure><p>View 初始化完成后，每次打开时，都会传入打开时需要的数据，我们根据状态，把数据传给不同的处理函数。当前 UI 处于打开状态时调用 <code>UIView.Open()</code>；处于显示状态，则调用 <code>UIView.Update()</code>。最后可以使用 <code>UIView.Close()</code> 关闭 View。</p><p>UIView 对外暴露一个公共接口：</p><ul><li><code>UIView.Init()</code>，初始化 View，初始化完成后调用一次 <code>UIView.OnInit()</code>。</li><li><code>UIView.Open(...)</code>，当 View 处于隐藏状态时，打开 View，最终会调用 <code>UIView.OnShow()</code> 处理。</li><li><code>UIView.Update(...)</code>，当 View 处于打开状态时，更新 View 数据，最终会调用 <code>UIView.OnUpdate()</code> 处理。</li><li><code>UIView.Close(...)</code>，用于关闭当前 UI，并调用 <code>UIView.OnHide()</code> 处理 View 隐藏后逻辑，其资源清理逻辑最终会交给 Controller 执行。</li><li><code>UIView.OpenView(name)</code>，用于打开其他 View，其打开逻辑会交给 Controller 执行。</li></ul><p>UIView 作为一个父类，需要子类重写以下接口：</p><ul><li><code>UIView.OnInit()</code>，初始化View，我们需要做一些 UI 组件事件注册逻辑处理，如果某个按钮点击后的逻辑，因为这些逻辑固定不变的，整个 View 生命周期只会调用过一次。</li><li><code>UIView.OnShow()</code>，如果 View 隐藏状态，在打开 View 时，会调用此函数，并传入打开 UI 时需要处理的数据。</li><li><code>UIView.OnUpdate()</code>，如果 View 打开状态，在打开 View 时，会调用此函数，并传入打开 UI 时需要处理的数据。</li><li><code>UIView.OnHide()</code>，当 View 被调用 UIView.Close(…) 时，在销毁前，会被调用，需要在此函数内处理关闭 View 时的逻辑。</li></ul><h2 id="View-分组"><a href="#View-分组" class="headerlink" title="View 分组"></a>View 分组</h2><p>在复杂的游戏 UI 功能开发时，常常遇到这些的问题：</p><ul><li>同一个 UI 窗口内，我们希望某一组 UI 是互斥的，即同一时间内，Controller 只能打开该组内的某一个 View，如果同组有其他 View 打开则先关闭一打开的 View。</li><li>有一些 UI 分组，在某个指定 UI 关闭后，其分组内的任何 UI 只要打开都会自动关闭。</li></ul><p>看到这些需求后，我们很快想到使用一颗树来管理这些 UI View 分组。其分组示例图如下：</p><p><img src="/images/mvc/mvc_view_group.png" alt="mvc"></p><p>从图中我们可以看到，这是一个树形结构的 UI 分组，有一个根节点，子节点之间是分层的，每一层节点之间可以设置未互斥状态，即同一时间内，只能被打开一个。<br>有了这个树形结构，当某个节点被关闭后，我们可以很快获取到这个节点的所有子节点，并关闭它们。</p><p>于是可以设计一个 UI 分组代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Tree = <span class="built_in">require</span> <span class="string">"game.foundation.Tree"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> UIGroupTree = Class(<span class="string">'UIGroupTree'</span>, Tree)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIGroupTree:Ctor</span><span class="params">()</span></span></span><br><span class="line">    self.isExclusion = <span class="literal">true</span> <span class="comment">-- 子节点是否互斥，默认未互斥</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIGroupTree:SetExclusion</span><span class="params">(isExclusion)</span></span></span><br><span class="line">    self.isExclusion = isExclusion</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIGroupTree:IsExclusion</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> self.isExclusion</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIGroupTree:AddChildUI</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="keyword">return</span> self.NewChild(view.name)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIGroupTree</span><br></pre></td></tr></table></figure><p>代码中树形结构 <code>Tree</code> 实现请参考外部 <a href="https://gist.github.com/Veinin/a9fbf71f6a82938100dff7fbff501495" target="_blank" rel="noopener">链接</a>。</p><p>然后我们拓展 Contoller 接口实现：</p><ul><li>加入新的成员变量 group (UIGroupTree类型)</li><li>加入创建 UI 分组对象函数，<code>UIController.NewGroup(view)</code>，用于创建一个分组。</li><li>加入新的抽象函数 <code>UIController.OnInitGroup()</code>，子类如需要UI分组，则重写该函数，该函数在 Controller 初始化时被调用。</li><li>打开某个 UI 时检查 View 对象是否分组、分组是否互斥、是否有互斥 View 已打开，如果打开则关闭互斥 View。</li><li>关闭某个 UI 时检查 View 对象是否分组，当前节点是否存在子节点，子节点是否有打开情况，如果打开则关闭 View。</li></ul><p>扩展 Controller 的代码实现如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIGroupTree = <span class="built_in">require</span> <span class="string">"game.ui.group.UIGroupTree"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> UIController:Ctor()</span><br><span class="line">    <span class="comment">-- 上面已实现代码省略...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">OnLoad</span><span class="params">(self, assets)</span></span></span><br><span class="line">    <span class="comment">-- 上面已实现代码省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">next</span>(self.viewClasses) <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- ...</span></span><br><span class="line">        self:OnInitGroup()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:OnInitGroup</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- 子类实现</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个UI分组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:NewGroup</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="built_in">assert</span>(self.group == <span class="literal">nil</span>, <span class="string">"不允许创建多个分组"</span>)</span><br><span class="line">    self.group = UIGroupTree.New(view.name)</span><br><span class="line">    <span class="keyword">return</span> self.group</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查互斥</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">CheckExclusion</span><span class="params">(self, view)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.group <span class="keyword">or</span> self.openViewCount == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> name = view.name</span><br><span class="line">    <span class="keyword">local</span> node = self.group:FindChild(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> parent = node:GetParent()</span><br><span class="line">    <span class="keyword">if</span> #parent == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> parent:IsExclusion() <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> childName</span><br><span class="line">    <span class="keyword">local</span> childView</span><br><span class="line">    <span class="keyword">for</span> _, child <span class="keyword">in</span> <span class="built_in">ipairs</span>(parent) <span class="keyword">do</span></span><br><span class="line">        childName = child.name</span><br><span class="line">        childView = self.openViews[childName]</span><br><span class="line">        <span class="keyword">if</span> childName ~= name <span class="keyword">and</span> childView <span class="keyword">then</span> <span class="comment">-- 如果打开则关闭</span></span><br><span class="line">            self:Close(childView)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Open</span><span class="params">(name, ...)</span></span></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 打开前检查分组互斥</span></span><br><span class="line">    CheckExclusion(self, view)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> view:IsState(UIConst.LIFESTATE.SHOW) <span class="keyword">then</span></span><br><span class="line">        view:Update(...)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        view:Open(...)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查子节点关闭</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">CheckCloseChild</span><span class="params">(self, view)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.group <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> name = view.name</span><br><span class="line">    <span class="keyword">local</span> node = self.group:FindChild(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> childView</span><br><span class="line">    node:IterativeChildren(<span class="function"><span class="keyword">function</span><span class="params">(child)</span></span></span><br><span class="line">        childView = self.openViews[child.value]</span><br><span class="line">        <span class="keyword">if</span> childView <span class="keyword">then</span>  <span class="comment">-- 如果子节点打开则关闭</span></span><br><span class="line">            self:Close(childView)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIController:Close</span><span class="params">(view)</span></span></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.openViewCount == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        self:Dispose()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">-- 还有打开的 View，检查是否其子节点，并关闭</span></span><br><span class="line">        CheckCloseChild(self, view)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UIController</span><br></pre></td></tr></table></figure><p>有了上面扩展实现的代码，我们就实现分组示例图中展示的分组结构：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyTestController:OnInitGroup</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> root = self:NewGroup(UIView1)</span><br><span class="line">    root:AddChild(UIView2)</span><br><span class="line">    root:AddChild(UIView3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> child = root:AddChild(UIView4)</span><br><span class="line">    child:AddChild(UIView5)</span><br><span class="line">    child:AddChild(UIView6)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="UI-开发半自动化"><a href="#UI-开发半自动化" class="headerlink" title="UI 开发半自动化"></a>UI 开发半自动化</h2><p>我们知道，游戏 UI 开发，很多固定的流程其实是可以省略的：</p><ul><li>UI 编辑完成后，开始写业务代码时，可以将所有基础代码全部生成，比如上面的 Controller 子类和每个窗口的 View 子类。</li><li>每个 View 类型，我们设计时其会对应 UI 编辑器的一个界面，且 UI 编辑器里面的所有组件，都是可以读取到的，在 Unity 中，我们保存为 Prefab 文件，而这个文件可以帮助我们设计一个自动生成代码的工具。</li><li>每次修改 UI 增加了新的组件后，我们希望原有的已经编辑的代码可以保留，在编辑器中刷新一下代码，能将新增加的控件基础代码直接加入到相应的代码文件里面。</li><li>每次修改完 UI 资源后，然后对应改完代码后，不希望在游戏中重启客户端才能看到效果，所以，我们加入了热更机制，任何代码都是可以热更新的，那么 UI 开发人员编码阶段将会非常方便。</li></ul><p>综上考虑，因为我们项目很多人使用 <strong>IntelliJ IDEA</strong> 配合一个不错的 Lua 插件 <strong>EmmyLua</strong>， 相对来说使用 Lua 开发还是比较顺畅的。所以决定在 <strong>IntelliJ IDEA</strong> 平台上开发一个为项目定制的 UI 开发插件（当然现在一些主流的代码编辑器都支持插件编写，你可以很容易在其他编辑器中实现这些内容）。</p><p>在UI编辑完成后，开发人员，建立 UI 功能开发文件夹后，右键菜单点击生成代码，插件自动生成 UIController 和 UIView 对应子类。</p><p>比如一个组队功能包含以下 UI 文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> TeamWindow</span><br><span class="line">    -&gt; Prefabs</span><br><span class="line">        -&gt; CreateView.prefab</span><br><span class="line">        -&gt; MemberView.prefab</span><br><span class="line">        -&gt; MemberItem.prefab</span><br></pre></td></tr></table></figure><p>生成的代码文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> team</span><br><span class="line">    -&gt; contoller</span><br><span class="line">        -&gt; TeamController.lua</span><br><span class="line">    -&gt; views</span><br><span class="line">        -&gt; CreateView.lua</span><br><span class="line">        -&gt; MemberView.lua</span><br><span class="line">    -&gt; protocol</span><br><span class="line">        -&gt; TeamProtocol.lua -- 协议文件，项目定制</span><br></pre></td></tr></table></figure><p>下面是 Contoller 实例 <code>TeamController.lua</code> 文件内容，该文件自动生成了很多基础的代码，需要填写的地方只剩下分组（如需要）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIController = <span class="built_in">require</span> <span class="string">"game.ui.core.UIController"</span></span><br><span class="line"><span class="keyword">local</span> CreateView = <span class="built_in">require</span> <span class="string">"game.ui.team.views.CreateView"</span></span><br><span class="line"><span class="keyword">local</span> MemberView = <span class="built_in">require</span> <span class="string">"game.ui.team.views.MemberView"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> TeamController = Class(<span class="string">'TeamController'</span>, UIController)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TeamController:OnInitView</span><span class="params">()</span></span></span><br><span class="line">    self:RegisterView(CreateView)</span><br><span class="line">    self:RegisterView(MemberView)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">funciton TeamController:OnInitGroup()</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TeamController</span><br></pre></td></tr></table></figure><p>下面是一个 View 实例 CreateView.lua 文件内容，其基本的组件代码全部通过编辑器UI文件自动生成，开发人员只需要在对应的 UI 组件填入相对于的业务逻辑即可：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UIView = <span class="built_in">require</span> <span class="string">"game.ui.core.UIView"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> CreateView = Class(<span class="string">'CreateView'</span>, UIView)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:Ctor</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:OnInit</span><span class="params">()</span></span></span><br><span class="line">    self.closeButton:AddListener(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        self:Close()</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    self.cofirmButton:AddListener(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="comment">-- 开发人员实现创建队伍逻辑</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:OnShow</span><span class="params">(...)</span></span></span><br><span class="line">    self.nameInputField:SetText()</span><br><span class="line">    self.fightINputField:SetText()</span><br><span class="line">    self.levelInputField:SetText()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:OnUpdate</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateView:OnHide</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CreateView</span><br></pre></td></tr></table></figure><p>为了对比，下面展示以下 <code>CreateView.lua</code> 对应 <code>CreateView.prefab</code> 文件结构：</p><p><img src="/images/mvc/create_view.png" alt="mvc"></p><p>可以看出这个 UI 有5个需要处理的组件，两个按钮（关闭、确定），3个输入文本框（队伍名称、队伍战力、最低等级）。我们可以很容易从编辑的 prefab 文件中提取到里面的 UI 组件，然后通过插件直接生成代码文件。</p><p>有了上面的这些自动生成的代码，剩下的工作，其实就是填写一些基础的业务逻辑，那些重复性的工作工具已经可以帮你很好的完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文阐述了一个半自动化工作的游戏 UI 编写流程，并给出了实现步骤。<br>游戏 UI 开发流程存在大部分重复工作，我们稍微花点时间，其实是可以把这些重复工作自动化的，剩下的工作，无非就是填写下业务逻辑代码。<br>可以预见的是，开发这么一套半自动化的工具其实不到一周时间，其实是可以很容易搞定的，并且后续的 UI 开发效率其实是提升了一个档次。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近着手试了下我们客户端 UI 开发，发现整个流程对于开发人员来说并不是很友好，我们游戏客户端代码基本使用 Lua 语言进行，引擎则采用 Unity。对于 UI 模块目前有一套基本的 MVC 模式的开发流程，但这个开发模式的边界并没有处理很好，导致开发过程中异常艰难。编写代码的人员有时也会很懵逼，因为实现的方式可以有多种多样。&lt;/p&gt;
&lt;p&gt;在了解了整个旧有的开发流程后，我发现个问题，其中由UI编辑到代码编写，这个流程中，大部分过程都是重复行工作，而针对这一部分重复行工作通过一些小工具可以让UI开发流程实现半自动化。&lt;/p&gt;
&lt;p&gt;所谓半自动化，无非就是，开发人员不需要编写基本的UI代码，基础UI代码可以自动生成，包括整个开发流程中使用的各个UI窗口的组件都可以自动生成代码。&lt;/p&gt;
&lt;p&gt;另外，因为UI编写过程中进程资源修改、代码修改，我希望都可以在修改完后立刻可以看到效果，而不是重启游戏。&lt;/p&gt;
&lt;p&gt;下面是我对于一个半自动化的UI开发流程整理笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://veinin.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="半自动化，游戏UI开发，Unity" scheme="https://veinin.com/tags/%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%8C%E6%B8%B8%E6%88%8FUI%E5%BC%80%E5%8F%91%EF%BC%8CUnity/"/>
    
      <category term="MVC" scheme="https://veinin.com/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-线程同步精要</title>
    <link href="https://veinin.com/2018/06/25/programming_with_posix_pthreads_08/"/>
    <id>https://veinin.com/2018/06/25/programming_with_posix_pthreads_08/</id>
    <published>2018-06-25T06:11:13.000Z</published>
    <updated>2018-07-12T14:44:50.554Z</updated>
    
    <content type="html"><![CDATA[<p>本章节摘录自陈硕 《Linux多线程服务端编程:使用muduoC++网络库》 第二章关于线程同步笔记。</p><h2 id="线程同步四项原则"><a href="#线程同步四项原则" class="headerlink" title="线程同步四项原则"></a>线程同步四项原则</h2><p>线程同步的四项原则，按重要性排列：</p><ul><li>首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑 <code>immutable</code> 对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。</li><li>其次是使用高级的并发编程构件，如 <code>TaskQueue</code>、<code>Producer-ConsumerQueue</code>、<code>CountDownLatch</code> 等等。</li><li>最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。</li><li>除了使用 <code>atomic</code> 整数之外，不自己编写 <code>lock-free</code> 代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如<code>spin lock</code> vs <code>mutex</code>。</li></ul><a id="more"></a><h2 id="互斥器（mutex）"><a href="#互斥器（mutex）" class="headerlink" title="互斥器（mutex）"></a>互斥器（mutex）</h2><p>互斥器（mutex）是使用得最多的同步原语，粗略地说，它保护了临界区，任何一个时刻最多只能有一个线程在此 mutex 划出的临界区内活动。单独使用 mutex 时，我们主要为了保护共享数据。</p><p>主要原则：</p><ul><li>在C++中，应该使用用<code>RAII</code>手法封装<code>mutex</code>的创建、销毁、加锁、解锁这四个操作。Java里的 <code>synchronized</code> 语句和C#的 <code>using</code> 语句也有类似的效果，即保证锁的生效期间等于一个作用域（scope），不会因异常而忘记解锁。</li><li>只用非递归的 <code>mutex</code>（即不可重入的mutex）。</li><li>不手工调用 <code>lock()</code> 和 <code>unlock()</code> 函数，</li><li>在每次构造 <code>Guard</code> 对象的时候，思考一路上（调用栈上）已经持有的锁，防止因加锁顺序不同而导致死锁（deadlock）。</li></ul><p>次要原则：</p><ul><li>不使用跨进程的 <code>mutex</code>，进程间通信只用 TCPsockets。</li><li>加锁、解锁在同一个线程，线程a不能去 <code>unlock</code> 线程b已经锁住的 <code>mutex</code>（RAII自动保证）。 别忘了解锁（RAII自动保证）。</li><li>不重复解锁（RAII自动保证）。</li><li>必要的时候可以考虑用 <code>PTHREAD_MUTEX_ERRORCHECK</code> 来排错。</li></ul><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>互斥器（mutex）是加锁原语，用来排他性地访问共享数据，它不是等待原语。在使用 mutex 的时候，我们一般都会期望加锁不要阻塞，总是能立刻拿到锁。然后尽快访问数据，用完之后尽快解锁，这样才能不影响并发性和性能。</p><p>如果需要等待某个条件成立，我们应该使用条件变量（conditionvariable）。条件变量顾名思义是一个或多个线程等待某个布尔表达式为真，即等待别的线程“唤醒”它。条件变量只有一种正确使用的方式，几乎不可能用错。</p><p>对于wait端：</p><ul><li>必须与 <code>mutex</code> 一起使用，该布尔表达式的读写需受此mutex保护。</li><li>在 <code>mutex</code> 已上锁的时候才能调用 <code>wait()</code>。</li><li>把判断布尔条件和 <code>wait()</code> 放到 <code>while</code> 循环中。</li></ul><p>对于 signal/broadcast 端：</p><ul><li>不一定要在 <code>mutex</code> 已上锁的情况下调用 <code>signal</code>（理论上）。</li><li>在 <code>signal</code> 之前一般要修改布尔表达式。</li><li>修改布尔表达式通常要用 <code>mutex</code> 保护（至少用作fullmemorybarrier）。</li><li>注意区分 <code>signal</code> 与 <code>broadcast</code>： <code>broadcast</code> 通常用于表明状态变化，<code>signal</code> 通常用于表示资源。</li></ul><p>条件变量是非常底层的同步原语，很少直接使用，一般都是用它来实现高层的同步措施，如 <code>BlockingQueue&lt;T&gt;</code> 或 <code>CountDownLatch</code>。</p><p>倒计时（CountDownLatch）是一种常用且易用的同步手段。它主要有两种用途：</p><ul><li>主线程发起多个子线程，等这些子线程各自都完成一定的任务之后，主线程才继续执行。通常用于主线程等待多个子线程完成初始化。</li><li>主线程发起多个子线程，子线程都等待主线程，主线程完成其他一些任务之后通知所有子线程开始执行。通常用于多个子线程等待主线程发出“起跑”命令。</li></ul><h2 id="不要使用读写锁和信号量"><a href="#不要使用读写锁和信号量" class="headerlink" title="不要使用读写锁和信号量"></a>不要使用读写锁和信号量</h2><p>读写锁（Readers-Writerlock，简写为rwlock）是个看上去很美的抽象，它明确区分了 read 和 write 两种行为。</p><p>初学者常干的一件事情是，一见到某个共享数据结构频繁读而很少写，就把 mutex 替换为 rwlock。甚至首选 rwlock 来保护共享状态，这不见得是正确的。</p><ul><li>从正确性方面来说，一种典型的易犯错误是在持有 readlock 的时候修改了共享数据。这通常发生在程序的维护阶段，为了新增功能，程序员不小心在原来 readlock 保护的函数中调用了会修改状态的函数。这种错误的后果跟无保护并发读写共享数据是一样的。</li><li>从性能方面来说，读写锁不见得比普通 mutex 更高效。无论如何 readerlock 加锁的开销不会比 mutexlock 小，因为它要更新当前 reader 的数目。如果临界区很小，锁竞争不激烈，那么 mutex 往往会更快。</li><li>readerlock 可能允许提升为 writerlock，也可能不允许提升。如果处理不好容易导致程序崩溃和死锁。</li><li>通常 readerlock 是可重入的，writerlock 是不可重入的。但是为了防止 writer 饥饿，writerlock通常会阻塞后来的readerlock，因此 readerlock 在重入的时候可能死锁。另外，在追求低延迟读取的场合也不适用读写锁。</li></ul><p>对于信号量（Semaphore），陈硕认为信号量不是必备的同步原语，因为条件变量配合互斥器可以完全替代其功能，而且更不易用错。<br>信号量的另一个问题在于它有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能。</p><h2 id="归纳与总结"><a href="#归纳与总结" class="headerlink" title="归纳与总结"></a>归纳与总结</h2><p>作者认为，应该先把程序写正确（并尽量保持清晰和简单），然后再考虑性能优化，如果确实还有必要优化的话。这在多线程下仍然成立。让一个正确的程序变快，远比“让一个快的程序变正确”容易得多。</p><p>“效率”并不是我的主要考虑点，我提倡正确加锁而不是自己编写 <code>lock-free</code>算法（使用原子整数除外），更不要想当然地自己发明同步设施。在没有实测数据支持的情况下，妄谈哪种做法效率更高是靠不住的，不能听信传言或凭感觉“优化”。很多人误认为用锁会让程序变慢，其实真正影响性能的不是锁，而是锁争用（lockcontention）。</p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章节摘录自陈硕 《Linux多线程服务端编程:使用muduoC++网络库》 第二章关于线程同步笔记。&lt;/p&gt;
&lt;h2 id=&quot;线程同步四项原则&quot;&gt;&lt;a href=&quot;#线程同步四项原则&quot; class=&quot;headerlink&quot; title=&quot;线程同步四项原则&quot;&gt;&lt;/a&gt;线程同步四项原则&lt;/h2&gt;&lt;p&gt;线程同步的四项原则，按重要性排列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑 &lt;code&gt;immutable&lt;/code&gt; 对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。&lt;/li&gt;
&lt;li&gt;其次是使用高级的并发编程构件，如 &lt;code&gt;TaskQueue&lt;/code&gt;、&lt;code&gt;Producer-ConsumerQueue&lt;/code&gt;、&lt;code&gt;CountDownLatch&lt;/code&gt; 等等。&lt;/li&gt;
&lt;li&gt;最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。&lt;/li&gt;
&lt;li&gt;除了使用 &lt;code&gt;atomic&lt;/code&gt; 整数之外，不自己编写 &lt;code&gt;lock-free&lt;/code&gt; 代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如&lt;code&gt;spin lock&lt;/code&gt; vs &lt;code&gt;mutex&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-线程扩展</title>
    <link href="https://veinin.com/2018/06/20/programming_with_posix_pthreads_07/"/>
    <id>https://veinin.com/2018/06/20/programming_with_posix_pthreads_07/</id>
    <published>2018-06-20T14:12:24.000Z</published>
    <updated>2018-07-12T14:44:39.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栅栏（Barriers）"><a href="#栅栏（Barriers）" class="headerlink" title="栅栏（Barriers）"></a>栅栏（Barriers）</h2><p>barrier 字面意思时栅栏，barrier 是将一组成员保持在一起的一种方式，它可以实现让一组线程等待至某个状之后再全部同时执行。一个 barrier 通常被用来确保某些井行算法中的所有合作线程在任何线程可以继续运行之前到达算法中的一个特定点。</p><p>barrier 的核心是一个计数器，我们可以称之为“阈值”，即在一个 barrier 上必须等待的线程数。计时器计算着当前线程的返回数量，如果数量未达到指定点，那么之前返回的线程都必须继续等待，直到最后一个线程返回，才能开始下一步。</p><a id="more"></a><p>你可以查看源文件 <code>barrier.h</code> 、<code>barrier.c</code>、<code>barrier_main.c</code>，这是一个比较容易理解的实现。</p><p>另外 Pthreads 在 POSIX.14 草案标准（一个 “POSIX 标准子集”）中新增加了 Barriers 变量，其 API 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(<span class="keyword">pthread_barrier_t</span> * <span class="keyword">restrict</span> barrier, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br></pre></td></tr></table></figure><p>源文件 <code>pthread_barrier.c</code> 是一个 Pthreads barrier 的简单实例。</p><h2 id="读-写锁（Read-Write-Lock）"><a href="#读-写锁（Read-Write-Lock）" class="headerlink" title="读/写锁（Read-Write Lock）"></a>读/写锁（Read-Write Lock）</h2><p>读/写锁很像一个互斥量，它是阻止多个线程同时修改共享数据的另外一种方。但是不同于互斥量的是它区分读数据和写数据。一个互斥量排除所有的其他线程，而一个读/写锁如果线程不需要改变数据，则允许多个线程同时读数据。当一个线程需要更新缓存数据是，则必须以独占的方式进行，其他只读线程都不能继续占有锁。</p><p>读/写锁被用来保护经常需要读但是通常不需要修改的信息（读多写少）。当写锁被释放时，如果读数据者和写数据者同时正在等待存取，则读数据者被优先给予访问权。因为潜在地允许许多线程同时完成工作，读访问优先有利于并发。</p><p>文件 <code>rwlock.h</code> 、<code>rwlock.c</code>、<code>rwlock_main.c</code> 演示了如何使用标准的 Pthreads 互斥量和状况变量实现读写锁， 这是相对容易理解的可移植的实现。</p><p>另外，在最新版本的 <code>X/Open XSH5 [UNIX98]</code> 标准中，Pthreads 增加了读写锁的支持，读写锁的数据类型为 <code>pthread_rwlock_t</code>，如果需要静态分配该类型数据，那么可通过<code>PTHREAD_RWLOCK_INITIALIZER</code> 宏来初始化它。Pthreads 读写锁 API 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> lock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * <span class="keyword">restrict</span> lock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> * <span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * <span class="keyword">restrict</span> lock, <span class="keyword">const</span> struct timespec * <span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * <span class="keyword">restrict</span> lock, <span class="keyword">const</span> struct timespec * <span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *lock)</span></span>;</span><br></pre></td></tr></table></figure><p>你可以查看源文件 <code>pthread_rwlock.c</code>，这是简单的 Pthread 读写锁的使用实例。</p><h2 id="自旋锁（Spin-Locks）"><a href="#自旋锁（Spin-Locks）" class="headerlink" title="自旋锁（Spin Locks）"></a>自旋锁（Spin Locks）</h2><p>自旋锁（Spinlock）也是一种锁，自旋锁在线程尝试获取它时，会在一个循环中不停等待（旋转），同时反复检查锁是否可用。由于线程始终保持活动状态且并没有执行有用的任务，因此使用这种锁时将产生一种忙碌的等待情况。</p><p>因为在一些多线程场景中我们需要避免操作系统进程的重新调度或者上下文的切换开销，所以如果线程仅仅只是短时间内被阻塞，那么使用自旋锁将是一种非常有效的方式。但是，如果你的程序需要比较长的时间保持锁的使用，那么自旋锁将会变的浪费，因为它会阻止其他线程运行。线程持有锁的时间越长，操作系统调度程序在保持锁定时中断线程的风险就越大。在这种情况下，其他线程将会不停“旋转”（反复尝试获取锁定），而持有锁的线程没有进行释放。结果将是无限期推迟，直到持有锁的线程完成并释放它。</p><p>下面是一个自旋锁的实现方式，该实现中使用了 GCC 提供的原子操作的相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> lock;</span><br><span class="line">&#125; <span class="keyword">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spinlock_init</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sl-&gt;lock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spinlock_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;sl-&gt;lock, <span class="number">1</span>)) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">spinlock_trylock</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __sync_lock_test_and_set(&amp;sl-&gt;lock, <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spinlock_unlock</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __sync_lock_release(&amp;sl-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spinlock_destroy</span><span class="params">(<span class="keyword">spinlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) sl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以查看源文件 <code>spinlock.h</code> 和 <code>spinlock_main.c</code>，这是一个自旋锁的简单使用实例，演示了10个线程并发使用自旋锁修改单一数据流程。</p><p>另外，Pthreads 也提供了自旋锁的实现，其 API 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock, <span class="keyword">int</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br></pre></td></tr></table></figure><p>你可以在源文件 <code>pthread_spinlock.c</code> 中查看对自旋锁的使用实例。</p><h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><p>信号量是由 EW Dijkstra 在20世纪60年代后期设计的编程结构。Dijkstra 的模型是铁路运营。考虑一段铁路，其中存在单个轨道，在该轨道上一次只允许一列火车。</p><p>信号量同步此轨道上的行程。火车必须在进入单轨之前等待，直到信号量处于允许旅行的状态。当火车进入轨道时，信号量改变状态以防止其他列车进入轨道。离开这段赛道的火车必须再次改变信号量的状态，以允许另一列火车进入。</p><p>在计算机版本中，信号量似乎是一个简单的整数。线程等待许可继续，然后通过对信号量执行<code>P操作</code>来发出线程已经继续的信号。</p><p>线程必须等到信号量的值为正，然后通过从值中减去1来更改信号量的值。完成此操作后，线程执行<code>V操作</code>，通过向该值加1来更改信号量的值。这些操作必须以原子方式进行。在<code>P操作</code>中，信号量的值必须在值递减之前为正，从而产生一个值，该值保证为非负值，并且比递减之前的值小1。</p><h3 id="信号量-API"><a href="#信号量-API" class="headerlink" title="信号量 API"></a>信号量 API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure><p>信号量初始化函数中，pshared的值为零，则不能在进程之间共享信号量。如果pshared的值非零，则可以在进程之间共享信号量。值 value 之名，<br>其中，<code>sem_post</code> 以原子方式递增sem指向的信号量。调用后，当信号量上的任何线程被阻塞时，其中一个线程被解除阻塞。<br>使用 <code>sem_wait</code> 来阻塞调用线程，直到sem指向的信号量计数变为大于零，然后原子地减少计数。</p><h3 id="信号量解决生产者与消费者问题"><a href="#信号量解决生产者与消费者问题" class="headerlink" title="信号量解决生产者与消费者问题"></a>信号量解决生产者与消费者问题</h3><p>生产者和消费者问题是并发编程中标准的，众所周知的一个小问题。在一个缓冲区中，分为将项目放入缓冲区生产者，从缓冲区中取出项目的消费者。</p><p>在缓冲区有可用空间之前，生产者不能在缓冲区中放置东西。在生产者写入缓冲区之前，消费者不能从缓冲区中取出东西。</p><p>你可以查看源文件 <code>pthread-semaphore.c</code>，这是一个使用信号量解决生产者、消费者问题的实例。</p><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p>工作队列是一组线程间分派工作的方法，创建工作队列时，可以指定需要的最大并发级别（最大线程数量）。</p><p>依据工作量的要求，线程将被开始或停止。没有发现任何请求的一个线程将等待一段时间后终止。最优的时间段取决于在你的系统上创建一个新线程的开销、维护一个不做任何工作的线程的系统资源的开销，以及你将再次需要线程的可能性。</p><p>源文件 <code>workq.h</code> 、<code>workq.c</code> 和 <code>workq_main.c</code> 显示了一个工作队列管理器的实现。</p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栅栏（Barriers）&quot;&gt;&lt;a href=&quot;#栅栏（Barriers）&quot; class=&quot;headerlink&quot; title=&quot;栅栏（Barriers）&quot;&gt;&lt;/a&gt;栅栏（Barriers）&lt;/h2&gt;&lt;p&gt;barrier 字面意思时栅栏，barrier 是将一组成员保持在一起的一种方式，它可以实现让一组线程等待至某个状之后再全部同时执行。一个 barrier 通常被用来确保某些井行算法中的所有合作线程在任何线程可以继续运行之前到达算法中的一个特定点。&lt;/p&gt;
&lt;p&gt;barrier 的核心是一个计数器，我们可以称之为“阈值”，即在一个 barrier 上必须等待的线程数。计时器计算着当前线程的返回数量，如果数量未达到指定点，那么之前返回的线程都必须继续等待，直到最后一个线程返回，才能开始下一步。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-POSIX 针对线程的调整</title>
    <link href="https://veinin.com/2018/06/17/programming_with_posix_pthreads_06/"/>
    <id>https://veinin.com/2018/06/17/programming_with_posix_pthreads_06/</id>
    <published>2018-06-17T11:38:12.000Z</published>
    <updated>2018-07-12T14:44:36.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程与fork"><a href="#多线程与fork" class="headerlink" title="多线程与fork"></a>多线程与fork</h2><p>多线程进程调用 <code>fork</code> 创造的子进程，只有调用 <code>fork</code> 的线程在子进程内存在，除了当前调用的线程，其他线程在子进程中都会消失，但消失的线程状态仍然保留为调用 <code>fork</code> 时的相同状态，线程会拥有与在父进程内当前调用线程的相同状态，拥有相同的互斥量，同样的线程私有数据键值等。</p><p>在 <code>forked</code> 的进程中只有一个线程，消失的其他线程并不会调用诸如 <code>pthread_exit</code> 退出，线程也不会再运用线程私有数据 <code>destructors</code> 或清除处理函数。<br>这里就存在一个很危险的局面，其他线程可能正好位于临界区之内，持有了某个锁，而它突然死亡，也就再也没有机会去解锁了。而如果子进程试图去对某个 <code>mutex</code> 加锁，那么马上就会造成死锁的局面。</p><p>综上所述，除非你打算很快地在子进程中调用 <code>exec</code> 执行一个新程序， 否则应避免在一个多线程的程序中使用 <code>fork</code>。</p><a id="more"></a><p>如果你不能避免，那么你应该注意在子进程中不能调用以下这些函数（参考《Linux多线程服务端编程》）：</p><ul><li><code>malloc</code>,会访问全局状态，肯定会加锁。</li><li>任何分配和释放内存的函数，诸如<code>new</code>、<code>delete</code>……</li><li>任何 Pthreads 函数。</li><li><code>printf</code> 系列函数。其他线程可能持有了stdout/stderr的锁。</li><li><code>sigle</code> 中除了“sigle安全”之外的任何函数，应避免在信号处理函数内使用 <code>fork</code>。</li></ul><p>另外，Pthreads 增加了 <code>pthread_atfork</code> “fork 处理器” 机制以允许你的代码越过 <code>fork</code> 调用保护数据和不变量。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));</span><br></pre></td></tr></table></figure><p>该函数中，<code>prepare fork</code> 处理器以正确的顺序锁住所有的由相关代码使用的互斥量以阻止死锁的发生。<code>parent fork</code> 处理器只需要开锁所有互斥量即可，以允许父进程和所有线程继续正常工作。<code>child fork</code> 处理器经常可以与 parent fork 处评器一样； 但是有时需要重置程序或库的状态。</p><p>在程序 <code>atfork.c</code> 中展示了如何使用 <code>fork</code> 处理器。</p><h2 id="多线程与exec"><a href="#多线程与exec" class="headerlink" title="多线程与exec"></a>多线程与exec</h2><p><code>exec</code> 函数功能是消除当前程序的环境并且用一个新程序代替它，所以并没有受线程的影响。</p><h2 id="多线程与signal"><a href="#多线程与signal" class="headerlink" title="多线程与signal"></a>多线程与signal</h2><p>在多线程程序中，使用 signal 的第一原则就是 <strong>不要使用 signal</strong>。</p><p>尽管修改进程信号行为本身是线程安全的，但是不能防止其他线程随后很快地设置一个新的信号行为。任何印象线程的信号同样也会影响整个进程，这意味着向进程或进程内的任何线程传送一个 <code>SIGKILL</code> 信号，将终止进程。传送一个 <code>SIGSTOP</code> 停止命令时，将导致所有的线程停止直到收到 <code>SIGCOUNT</code> 信号。</p><h2 id="多线程与stdio"><a href="#多线程与stdio" class="headerlink" title="多线程与stdio"></a>多线程与stdio</h2><p>Pthreads 要求 ANSI C 标准 I/O (stdio) 函数是线程安全的。因为 stdio 包需要为输出缓冲区和文件状态指定静态存储区，stdio 实现将使用互斥量或信号灯等同步机制。</p><h3 id="flockfile-和-funlockfile"><a href="#flockfile-和-funlockfile" class="headerlink" title="flockfile 和 funlockfile"></a>flockfile 和 funlockfile</h3><p>在一些情况里，一系列 stdio 操作以不被中断的顺序执行是重要的。例如，一个提示符后面跟着一个从终端的读操作。为了不让其他线程在两个操作之间读 stdin 或者写<br>stdout，你应该在两个调用前后锁住 stdin 和 stdou。你可以使用使用 <code>flockfile</code> 和 <code>funlockfile</code> 以及 <code>ftrylockfile</code> 函数来确保一系列写操作不会被从其他线程的文件存取打断。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> flock <span class="title">file</span><span class="params">(FILE *file)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">ftrylockfile</span><span class="params">(FILE *file)</span></span></span><br><span class="line">void funlockfile(FILE *file)；</span><br></pre></td></tr></table></figure><p>你可以参考程序 <code>flock.c</code> 实例。</p><h3 id="getchar-unlocked-和-putchar-unlocked"><a href="#getchar-unlocked-和-putchar-unlocked" class="headerlink" title="getchar_unlocked 和 putchar_unlocked"></a>getchar_unlocked 和 putchar_unlocked</h3><p>函数 <code>getchar</code> 和 <code>putchar</code> 分别操作 stdin 和 stdout，而 <code>getc</code> 和 <code>putc</code> 能在任何stdio 文件流上被使用。Pthreads 要求这些函数锁住 stdio 流数据来防止代码对 stdio 缓冲区的偶然破坏。</p><p>Phtread 提供了函数 <code>getc_unlocked</code>、<code>putc_unlocked</code>、 <code>getchar_unlocked</code> 和 <code>putchar_unlocked</code>，但它们不执行任何锁操作，因此你必须在这些操作附近使用 <code>flockfile</code> 和 <code>fimlockfili</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar_unlocked</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc_unlocked</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar_unlocked</span> <span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>程序 <code>putchar.c</code> 显示了使用 <code>putchar</code> 和在一个文件锁内调用一系列 <code>putchar_unlocked</code>之间的差异。</p><h2 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h2><p>在一个多线程程序中，主函数是”进程主线程的启动函数”，从主函数返回将终止整个进程。与进程相关的所有内存（和线程）将消失。线程也不会执行清除处理器或线程私有数据 <code>destructors</code> 函数。调用 <code>exit</code> 具有同样的效果，你可以调用 <code>exit</code> 来很快地停止所有的线程。</p><p>当你不想使用起始线程或让它等待其他线程结束时，可以通过调用 <code>pthread_exit</code> 而非返回或调用 <code>exit</code> 退出主函数。从主函数中调用 <code>pthread_exit</code> 将在不影响进程内其他线程的前提下终止起始线程，允许其他线程继续运作，直到正常完成。</p><h2 id="线程安全函数"><a href="#线程安全函数" class="headerlink" title="线程安全函数"></a>线程安全函数</h2><p>Pthreads 定义了现存函数的线程安全的变体，它们在相应函数名结尾处添加后缀 <code>_r</code>：</p><ul><li>用户和终端ID，<code>getlogin_r</code>、<code>ctermid</code>、<code>ttyname_r</code>。</li><li>目录搜索，<code>readdir_r</code>。</li><li>字符串 token，<code>strtok_r</code>。</li><li>时间表示，<code>asctime_r</code>、<code>ctime_r</code>、<code>gmtime_r</code>、<code>localtime_r</code>。</li><li>随机数产生，<code>read_r</code>。</li><li>组和用户数据库，<code>getgrgid_r</code>、<code>getgrnam_r</code>、<code>getpwuid_r</code>、<code>getpwnam_r</code>。</li></ul><p>程序 <code>getlogin.c</code> 是一个如何调用获取用户和终端ID的实例。</p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多线程与fork&quot;&gt;&lt;a href=&quot;#多线程与fork&quot; class=&quot;headerlink&quot; title=&quot;多线程与fork&quot;&gt;&lt;/a&gt;多线程与fork&lt;/h2&gt;&lt;p&gt;多线程进程调用 &lt;code&gt;fork&lt;/code&gt; 创造的子进程，只有调用 &lt;code&gt;fork&lt;/code&gt; 的线程在子进程内存在，除了当前调用的线程，其他线程在子进程中都会消失，但消失的线程状态仍然保留为调用 &lt;code&gt;fork&lt;/code&gt; 时的相同状态，线程会拥有与在父进程内当前调用线程的相同状态，拥有相同的互斥量，同样的线程私有数据键值等。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;forked&lt;/code&gt; 的进程中只有一个线程，消失的其他线程并不会调用诸如 &lt;code&gt;pthread_exit&lt;/code&gt; 退出，线程也不会再运用线程私有数据 &lt;code&gt;destructors&lt;/code&gt; 或清除处理函数。&lt;br&gt;这里就存在一个很危险的局面，其他线程可能正好位于临界区之内，持有了某个锁，而它突然死亡，也就再也没有机会去解锁了。而如果子进程试图去对某个 &lt;code&gt;mutex&lt;/code&gt; 加锁，那么马上就会造成死锁的局面。&lt;/p&gt;
&lt;p&gt;综上所述，除非你打算很快地在子进程中调用 &lt;code&gt;exec&lt;/code&gt; 执行一个新程序， 否则应避免在一个多线程的程序中使用 &lt;code&gt;fork&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-线程高级编程</title>
    <link href="https://veinin.com/2018/06/12/programming_with_posix_pthreads_05/"/>
    <id>https://veinin.com/2018/06/12/programming_with_posix_pthreads_05/</id>
    <published>2018-06-12T15:12:32.000Z</published>
    <updated>2018-07-12T14:44:32.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一次性初始化"><a href="#一次性初始化" class="headerlink" title="一次性初始化"></a>一次性初始化</h2><p>一些事情仅仅需要做一次，不管是什么。在主函数中并且在调用任何其他依赖于初始化的事物之前，这时初始化应用最容易，特别是在创造任何线程之前初始化它需要的数据，如互斥量、线程特定数据键等。</p><p>在传统的顺序编程中，一次性初始化经常通过使用布尔变量来管理。控制变量被静态地初始化为 0,而任何依赖于初始化的代码都能测试该变量。如果变量值仍然为 0, 则它能实行初始化，然后将变量置为 1，以后检查的代码将跳过初始化。如下面代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialized)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    initialized = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>但在使用多线程时，上述操作就不是那么容易了。如果多个线程并发地执行初始化序列代码， 2 个线程可能都发现 <code>initialized</code> 为0，并且都执行初始化，而且该过程本该仅仅执行一次，那么上面代码就会立马发生不可预估的错误。</p><p>对于多线程环境下初始化的状态有两种方式：</p><ul><li>使用一个静态初始化的互斥量来编写一次性初始化代码。</li><li>无法静态初始化一个互斥量时，使用 <code>pthread_once</code>。</li></ul><p>对于 <code>pthread_once</code> 初始化，需要声明类型为 <code>pthread_once_t</code> 的一个控制变量，且该控制变量必须使用 <code>PTHREAD_ONCE_INIT</code> 宏进行静态初始化。<code>pthread_once</code> 首先检查控制变量，以判断是否已经完成初始化，如果完成，则什么都不做并立刻返回；否则，<code>pthread_once</code> 会调用初始化函数，并且记录初始化完成。如果在一个线程初始化时，另外一个线程也调用了<code>pthread_once</code>，则调用线程会阻塞等待，直到正在初始化的线程返回，这样就确保了所以状态一定会正确初始化完成。</p><p>下面是一个使用 <code>pthread_once</code> 来初始化的实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_once_t</span> once_block = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">once_init_routine</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_once(&amp;once_block, once_init_routine);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Once init"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread_toutine has locked the mutex.\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Destroy mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_once(&amp;once_block, once_init_routine);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Once init"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Main has locked the mutex.\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Destroy mutex"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序，唯一的临界共享数据实际是 <code>once_block</code>，主线程和线程 <code>thread_routine</code> 都会调用 <code>pthread_once</code> 进行初始化，但只会有一个线程会执行初始化函数。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>当我们创建线程或动态初始化互斥量和条件变量时，通常使用空指针作为第二个参数，这个参数实际上是指向一个属性对象的指针。空指针表明，Pthreads 应该为所有属性假定默认值，就像静态初始化互斥量或条件变量时一样。</p><p>一个属性对象是当初始化一个对象时提供的一个扩展参数表，可以提供更加高级的功能。类型 <code>pthread_attr_t</code> 代表一个属性对象，线程、 互斥置和条件变量都有自己特殊的属性对象类型， 分别是 <code>pthread_attr_t</code>、 <code>pthread_mutexattr_t</code> 和 <code>pthread_condattr_t</code>。</p><h3 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h3><p>Pthreads 为互斥量创建定义下列属性：<code>pshared</code>、<code>pratocol</code> 和 <code>prioceiling</code>。通过调用 <code>pthread_mutexattr_init</code> 初始化互斥量属性，指定一个指向类型 <code>pthread_mutexattr_t</code> 变量的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutexattr_t</span> mutex_attr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> *pshared)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure><p>下面程序显示了如何设置属性对象来创建使用 <code>pshared</code> 属性的互斥量，并且获取 <code>pshared</code> 值，打印输出 1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> pshared;</span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> mutex_attr;</span><br><span class="line"></span><br><span class="line">    status = pthread_mutexattr_init(&amp;mutex_attr);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex attr"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutexattr_setpshared(&amp;mutex_attr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Set pshared"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_init(&amp;mutex, &amp;mutex_attr);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutexattr_getpshared(&amp;mutex_attr, &amp;pshared);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Get pshared"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pshared: %d\n"</span>, pshared);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h3><p>Pthreads 为条件变量的创建仅定义了一个属性 <code>pshared</code>。使用 <code>pthread_condattr_init</code> 初始化条件变量属性对象，设置一个指向类型 <code>pthread_condattr_t</code> 变量的指针。可以通过调用 <code>pthread_condattr_setpshared</code> 设置 <code>pshared</code>。</p><p>该属性默认值时 <code>PTHREAD_PROCESS_PRIVATE</code>，如果条件变量属性需要被多个线程使用，可以设置值为 <code>PTHREAD_PROCESS_SHAREAD</code>。</p><p>下面程序演示了如何使用条件变量的 <code>pshared</code> 属性来创建设置一个条件变量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pthread_condattr_t</span> cond_attr;</span><br><span class="line"></span><br><span class="line">    status = pthread_condattr_init(&amp;cond_attr);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create attr"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_condattr_setpshared(&amp;cond_attr, PTHREAD_PROCESS_PRIVATE);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Set pshared"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cond_init(&amp;cond, &amp;cond_attr);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init cond"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>POSIX 为线程创建定义下列属性：detachstate、stacksize、stackaddr、scope、inheritsched、schedpolicy 和 schedparam。并不是所有系统都支持以上所有的属性，因此需要在使用前检查系统文档。</p><p>所有的 Pthreads 系统都支持 <code>detachstate</code> 属性 ，该属性的值可以是 <code>PTHREAD_CREATE_JOINABLE</code> 或 <code>PTHREAD_CREATE_DETACHED</code>。<br>默认的线程被创建为可连接的(joinable)，即意味着由 <code>pthread_create</code> 创建的该线程ID 能被用来与线程连接并获得它的返回值，或取消它。<br>如果设置为 <code>PTHREAD_CREATE_DETACHED</code>，则该属性对象创建的线程 ID 不能被使用，线程终止时，线程的所有资源都会被系统立刻回收。所以，在创建已经知道不需要取消或连接的线程时，应该以可分离的方式创建它们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br></pre></td></tr></table></figure><p>如果系统定义了标志 <code>_POSIX_THREAD_ATTR_STACKSIZE</code>，就可以设置 <code>stacksize</code> 属性，指定使用属性对象创建的线程栈的最小值。但栈大小不是可移植的，你应该小心使用它。<br>如果系统定义了标志 <code>_POSIX_THREAD_ATTR_STACKADDR</code>，就可以设置 <code>stackaddr</code> 属性，为指定线程指定一个存储器区域来作为堆栈使用。</p><p>下面程序演示了实际中的某些属性对象的使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The thread is here\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> thread_attr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">thread_param</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> stack_size;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_attr_init(&amp;thread_attr);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create attr"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_attr_setdetachstate(&amp;thread_attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Set detach"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _POSIX_THREAD_ATTR_STACKSIZE</span></span><br><span class="line">    status = pthread_attr_getstacksize(&amp;thread_attr, &amp;stack_size);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Get stack size"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Default stack size is %d; minimum is %d\n"</span>, stack_size, PTHREAD_STACK_MIN);</span><br><span class="line"></span><br><span class="line">    status = pthread_attr_setstacksize(&amp;thread_attr, PTHREAD_STACK_MIN*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Set stack size"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, &amp;thread_attr, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Main exiting\n"</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h2><p>大部分时间每个线程独立地运行着，完成一个特定的工作，并且自己退出。但是有时一个线程被创建并不需要一定完成某件事情。例如用户可以单击按钮取消停止长时间的搜索操作。取消一个线程就像告诉一个人停止他正在做的工作一样。Pthreads 允许每个线程控制自己的结束，它能恢复程序不变量并解锁互斥量。当线程完成一些重要的操作时它甚至能推迟取消。</p><p>以下是常用的线程取消函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">void pthread_cleanup_push(void (*routine)(void *), void *arg);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br></pre></td></tr></table></figure><p>Pthread 支持三种取消模式，模式为两位二进制编码，称为“取消状态”和“取消类型”。每种模式实质上包括开、关两种状态。取消状态可以是“启用”（ enable)或“禁用”（disable)，取消类型可以是被“推迟” 或 “异步。如果取消状态被禁用，那么其他取消模式都会失效，相反则可以执行“推迟”或“异步”模式。</p><table><thead><tr><th>模式</th><th>状态</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>Off（关）</td><td>禁用</td><td>二者之一</td><td>取消被推迟，直到启动取消模式</td></tr><tr><td>Deferred（推迟）</td><td>启用</td><td>推迟</td><td>在下一个取消点执行取消</td></tr><tr><td>Asynchronous（异步）</td><td>启用</td><td>异步</td><td>可以随时执行取消</td></tr></tbody></table><p>为取消一个线程， 你需要线程的标识符 ID， 即由 <code>pthread_create</code> 返回给创建者或由 <code>pthread_self</code> 返回给线程自己的 <code>pthread_t</code> 值。如果没有一个线程的标识符 TD， 就不能取消线程。</p><p>取消一个线程是异步的， 当 <code>pthread_cancel</code> 调用返回时， 线程未必已经被取消，可能仅仅被通知有一个针对它的未解决的取消请求。如果需要知道线程在何时实际终止，就必须在取消它之后调用 <code>pthread_join</code> 与它连接。</p><p>也有被称为 <code>pthread_testcancel</code> 的特殊函数， 该函数仅仅是一个推迟的取消点。如果线程没被要求终止，它将很快返回，这允许你将任何函数转变为取消点。</p><p>下面是一个在循环内调用 <code>pthread_testcancel</code> 来对一个延迟取消反应的线程实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread_routine starting\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (counter == <span class="number">0</span>; ; counter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((counter % <span class="number">1000</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"calling testcancel\n"</span>);</span><br><span class="line">            pthread_testcancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"callling cancel\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cancel(thread_id);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Cancel thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling join\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread_id, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == PTHREAD_CANCELED)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread canceled at iteration %d\n"</span>, counter);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread was not canceled\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推迟取消"><a href="#推迟取消" class="headerlink" title="推迟取消"></a>推迟取消</h3><p>“推迟取消”意味着线程的取消类型被设置为 <code>PTHREAD_DEFERRED</code>，线程的取消使能属性被设置为 <code>PTHREAD_CANCEL_ENABLE</code>，线程将仅仅在到达取消点时才响应取消请求。</p><p>大多数取消点包含可以“无限”时间阻塞线程的 I/O 操作，它们是可取消的，以便等待能被打断，比如 <code>wait</code>、<code>read</code> 这样的函数函数。<br>你可以在下面这个链接中查找到所有可能的取消点：<br><a href="http://man7.org/linux/man-pages/man7/pthreads.7.html" target="_blank" rel="noopener">Pthreads-Cancellation-points</a></p><p>如果需要保证取消不能在一个特别的取消点或取消点的一些顺序期间发生，可以暂时在代码的那个区域停用取消。下面程序是一个实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread_routine starting\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (counter == <span class="number">0</span>;; counter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((counter % <span class="number">755</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            status = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &amp;state);</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Disable cancel"</span>);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            status = pthread_setcancelstate(state, &amp;state);</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Restore cancel"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((counter % <span class="number">1000</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"calling testcancel\n"</span>);</span><br><span class="line">            pthread_testcancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"callling cancel\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cancel(thread_id);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Cancel thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling join\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread_id, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == PTHREAD_CANCELED)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread canceled at iteration %d\n"</span>, counter);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread was not canceled\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步取消"><a href="#异步取消" class="headerlink" title="异步取消"></a>异步取消</h3><p>如果目标线程不需要使用取消点来査询取消请求。对于运行一个紧密计算循环的线程（例如，在找一个素数因素）而言是非常珍贵的，因为那种情况下调用 <code>pthread_testcancel</code> 的开销在可能是严重的。</p><p>异步取消线程很难确保目标线程安全的执行取消，例如当你调用 <code>malloc</code> 时，系统为你分配一些堆内存，但 <code>malloc</code> 可能在很多地方被异步取消打断，可能在分配内存前，或可能在分配内存后、也可能在保存地址返回前被打断。无论哪种情况，你的代码保存的内存地址变量将是未初始化的，这就很可能造成内存泄漏。</p><p>所以，在你的任何代码里面应该 <strong>避免异步的取消</strong> ！我们很难正确使用异步取消，并且很少有用。</p><p>除非当函数被记录为“异步取消安全”的，否则当异步取消被启用时你不该调用任何函数。Pthreads 建议所有的库函数应该记录它们是否是异步取消安全的。如果函数的描述没有具体的说明，则你应该总是假定它不是异步取消安全的。</p><p>下面是一个计算密集的循环中异步取消的使用实例，但是如果在循环内有任何函数调用，程序将变得不可靠，而推迟取消的版本将能继续正确工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> matrixa[SIZE][SIZE];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> matrixb[SIZE][SIZE];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> matrixc[SIZE][SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cancel_type, status;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; SIZE; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrixa[i][j] = i;</span><br><span class="line">            matrixb[i][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        status = pthread_setcancelstate(PTHREAD_CANCEL_ASYNCHRONOUS, &amp;cancel_type);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Set cancel type"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; SIZE; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrixc[i][j]= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; SIZE; k++)</span><br><span class="line">                    matrixc[i][j] += matrixa[i][k] * matrixb[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        status = pthread_setcancelstate(cancel_type, &amp;cancel_type);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Set cancel type"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; SIZE; j++)</span><br><span class="line">                matrixa[i][j] = matrixc[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"callling cancel\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cancel(thread_id);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Cancel thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling join\n"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread_id, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == PTHREAD_CANCELED)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread canceled\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread was not canceled\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h3><p>当一个代码段被取消时，需要恢复一些状态，必须使用清除处理器。例如当线程在等待一个条件变量时被取消，它将被唤醒，并保持互斥量加锁状态。在线程终止前，通常需要恢复不变量，且它总是需要释放互斥量。</p><p>可以把每个线程考虑为有一个活动的清除处理函数的栈。 调用 <code>pthread_cleanup_push</code> 将清除处理函数加到栈中， 调用 <code>pthread_cleanup_pop</code> 删除最近增加的处理函数。当线程被取消时或当它调用 <code>pthread_exit</code> 退出时，Pthreads 从最近增加的清除处理函数幵始，依次调用各个活动的清除处理函数，当所有活动的清除处理函数返回时，线程被终止。</p><p>下面程序演示了当一个条件变量等待被取消时，使用清除处理函数来释放互斥量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADS 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">control_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> counter, bysy;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cv;</span><br><span class="line">&#125; <span class="keyword">control_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">control_t</span> control = &#123;<span class="number">0</span>, <span class="number">1</span>, PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">control_t</span> *st = (<span class="keyword">control_t</span> *)arg;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    st-&gt;counter--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cleaup_handler: counter == %d\n"</span>, st-&gt;counter);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_unlock(&amp;st-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Unlock in cleanup handler"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_push(cleanup_handler, (<span class="keyword">void</span> *)&amp;control);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_lock(&amp;control.mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Mutex lock"</span>);</span><br><span class="line"></span><br><span class="line">    control.counter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (control.bysy)</span><br><span class="line">    &#123;</span><br><span class="line">        status = pthread_cond_wait(&amp;control.cv, &amp;control.mutex);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Wait on condition"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id[THREADS];</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; THREADS; count++)</span><br><span class="line">    &#123;</span><br><span class="line">        status = pthread_create(&amp;thread_id[count], <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; THREADS; count++)</span><br><span class="line">    &#123;</span><br><span class="line">        status = pthread_cancel(thread_id[count]);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Cancel thread"</span>);</span><br><span class="line"></span><br><span class="line">        status = pthread_join(thread_id[count], &amp;result);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Join thread"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == PTHREAD_CANCELED)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Thread %d canceled\n"</span>, count);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Thread %d was not canceled\n"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的一个线程创建了一套线程来“转包”一些功能（如并行算术运算），并且当分包线程在进行中时“承包线程”被取消，你可能不希望留着分包线程继续运行。相反，可以把取消操作“传递”到每个“分包线程”，让它们独立地处理自己的终止过程。当“承包线程”取消它们时，不应该连接分包线程来推迟取消，相反，可以取消每个线程并且使用 <code>pthread_detach</code> 很快地分离它。当它们完成时，分包线程的资源就能够很快被重用， 而“承包线程” 同时能独立地完成一些事情。</p><p>以下程序演示了同时独立取消“分包线程”的一个方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADS 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">team_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>         join_i;</span><br><span class="line">    <span class="keyword">pthread_t</span>   workers[THREADS];</span><br><span class="line">&#125; <span class="keyword">team_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">worker_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(counter = <span class="number">0</span>; ; counter++)</span><br><span class="line">        <span class="keyword">if</span> ((counter % <span class="number">1000</span>) == <span class="number">0</span>)</span><br><span class="line">            pthread_testcancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">team_t</span> *team = (<span class="keyword">team_t</span> *)arg;</span><br><span class="line">    <span class="keyword">int</span> count, status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (count = team-&gt;join_i; count &lt; THREADS; count++) &#123;</span><br><span class="line">        status = pthread_cancel(team-&gt;workers[count]);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Cancel worker"</span>);</span><br><span class="line"></span><br><span class="line">        status = pthread_detach(team-&gt;workers[count]);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Detach worker"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cleanup: canceled %d\n"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">team_t</span> team;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; THREADS; count++) &#123;</span><br><span class="line">        status = pthread_create(&amp;team.workers[count], <span class="literal">NULL</span>, worker_routine, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Create worker"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_push(cleanup, (<span class="keyword">void</span> *)&amp;team);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (team.join_i = <span class="number">0</span>; team.join_i &lt; THREADS; team.join_i++) &#123;</span><br><span class="line">        status = pthread_join(team.workers[team.join_i], &amp;result);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Join worker"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create team"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cancel(thread_id);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Cancel team"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join team"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程私有数据"><a href="#线程私有数据" class="headerlink" title="线程私有数据"></a>线程私有数据</h2><p>在进程内的所有线程共享相同的地址空间，即意味着任何声明为静态或外部的变量，或在进程堆声明的变量，都可以被进<br>程内所有的线程读写。</p><p>当线程需要一个私有变量时，必须首先决定所有的线程是否共享相同的值，或者线程是否应该有它自己的值。如果它们共享变量，则可以使用静态或外部数据，就像你能在一个单线程程序做的那样；然而，必须同步跨越多线程对共享数据的存取， 运通常通过增加一个或多个互斤量来完成。</p><p>如果每个线程都需要一个私有变量值，则必须在某处存储所有的值。线程私有数据允许每个线程保有一份变量的拷贝，好像每个线程有一连串通过公共的“键”值索引的私有数据值。</p><h3 id="建立和使用线程私有数据"><a href="#建立和使用线程私有数据" class="headerlink" title="建立和使用线程私有数据"></a>建立和使用线程私有数据</h3><p>线程私有数据键在程序中是由类型 <code>pthread_key_t</code> 来表示的。</p><p>在任何线程试图使用键以前，创建线程私有数据键最容易的方法是调用 <code>pthread_key_create</code>，但必须保证 <code>pthread_key_create</code> 对于每个 <code>pthread_key_t</code> 变童仅仅调用一次。如果将一个键创建两次，其实是在创建两个不同的键。第二个键将覆盖第一个，第一个键与任何线程为其设置的值一起将永远地丢失。所以，最容易一次性创建一个键的方法是使用 <code>pthread_once</code>。</p><p>当程序不再需要时，你可以调用 <code>pthread_key_delete</code> 释放一个线程私有数据键。</p><p>在私有数据创建后，你可以使用 <code>pthread_getspecific</code> 函数来获得线程当前的键值，或调用 <code>pthread_setspecific</code> 来改变当前的键值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_key_t</span> key;</span><br><span class="line">int pthread_key_create(pthread_key_t *key, void (*destructor)(void *));</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>下面是一个建立和使用线程私有数据的实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tsd_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span>   thread_id;</span><br><span class="line">    <span class="keyword">char</span>        *<span class="built_in">string</span>;</span><br><span class="line">&#125; <span class="keyword">tsd_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> tsd_key;</span><br><span class="line"><span class="keyword">pthread_once_t</span> key_one = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">once_routine</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"initializing key\n"</span>);</span><br><span class="line">    status = pthread_key_create(&amp;tsd_key, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create key"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">tsd_t</span> *value;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_once(&amp;key_one, once_routine);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Once init"</span>);</span><br><span class="line"></span><br><span class="line">    value = (<span class="keyword">tsd_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">tsd_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>)</span><br><span class="line">        errno_abort(<span class="string">"Allocate key value"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_setspecific(tsd_key, value);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Set tsd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s set tsd value %p\n"</span>, (<span class="keyword">char</span>*)arg, value);</span><br><span class="line"></span><br><span class="line">    value-&gt;thread_id = pthread_self();</span><br><span class="line">    value-&gt;<span class="built_in">string</span> = (<span class="keyword">char</span>*)arg;</span><br><span class="line"></span><br><span class="line">    value = (<span class="keyword">tsd_t</span>*)pthread_getspecific(tsd_key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s starting...\n"</span>, value-&gt;<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    value = (<span class="keyword">tsd_t</span>*)pthread_getspecific(tsd_key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s done...\n"</span>, value-&gt;<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread1, <span class="literal">NULL</span>, thread_routine, <span class="string">"thread 1"</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread 1"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread2, <span class="literal">NULL</span>, thread_routine, <span class="string">"thread 2"</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread 2"</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-destructor-函数"><a href="#使用-destructor-函数" class="headerlink" title="使用 destructor 函数"></a>使用 destructor 函数</h3><p>当一个线程退出时，它有一些为线程私有数据键定义的值，通常需要处理它们。当你创建一个线程私有数据键时，Pthreads 允许你定义 <code>destructor</code> 函数。当具有非空的私有数据键值的一个线程终止时，键的 <code>destructor</code> (如果存在） 将以键的当前值为参数被调用。</p><p>下列程序表明了当一个线程终止时使用线程私有数据的 <code>destructors</code> 释放存储器。 它还跟踪有多少线程正在使用线程私有数据， 并且当最后线程的 <code>destructor</code> 被调用时， 删除线程私有数据键。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">private_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span>   thread_id;</span><br><span class="line">    <span class="keyword">char</span>        *<span class="built_in">string</span>;</span><br><span class="line">&#125; <span class="keyword">private_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> identity_key;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> identity_key_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">long</span> identity_key_counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">identity_key_destructor</span><span class="params">(<span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">private_t</span> *<span class="keyword">private</span> = (<span class="keyword">private_t</span>*)value;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread \"%s\" exiting...\n"</span>, <span class="keyword">private</span>-&gt;<span class="built_in">string</span>);</span><br><span class="line">    <span class="built_in">free</span>(value);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_lock(&amp;identity_key_mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Lock key mutex"</span>);</span><br><span class="line"></span><br><span class="line">    identity_key_counter--;</span><br><span class="line">    <span class="keyword">if</span> (identity_key_counter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        status = pthread_key_delete(identity_key);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Delete key"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"key delete...\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_unlock(&amp;identity_key_mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Unlock key mutex"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">identity_key_get</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    value = pthread_getspecific(identity_key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">private_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">NULL</span>)</span><br><span class="line">            errno_abort(<span class="string">"Allocate key value"</span>);</span><br><span class="line"></span><br><span class="line">        status = pthread_setspecific(identity_key, value);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Set TSD"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">private_t</span> *value;</span><br><span class="line"></span><br><span class="line">    value = (<span class="keyword">private_t</span>*) identity_key_get();</span><br><span class="line">    value-&gt;thread_id = pthread_self();</span><br><span class="line">    value-&gt;<span class="built_in">string</span> = (<span class="keyword">char</span>*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread \"%s\" starting...\n"</span>, value-&gt;<span class="built_in">string</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_1, thread_2;</span><br><span class="line">    <span class="keyword">private_t</span> *value;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_key_create(&amp;identity_key, identity_key_destructor);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Create key"</span>);</span><br><span class="line"></span><br><span class="line">    identity_key_counter = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    value = (<span class="keyword">private_t</span>*)identity_key_get();</span><br><span class="line">    value-&gt;thread_id = pthread_self();</span><br><span class="line">    value-&gt;<span class="built_in">string</span> = <span class="string">"Main thread"</span>;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_1, <span class="literal">NULL</span>, thread_routine, <span class="string">"thread 1"</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread 1"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_2, <span class="literal">NULL</span>, thread_routine, <span class="string">"thread 2"</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread 2"</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程实时调度"><a href="#线程实时调度" class="headerlink" title="线程实时调度"></a>线程实时调度</h2><p>“受限制”的响应时间不一定是“快”的反应，而是确实意味着“可预知”的响应速度。必须有一些方法来定义一个时间跨度，在该时间段内一系列操作保证被完成。例如控制一个核反应堆的系统比你将写的大多数程序有更严格的响应要求，并且没能满足反应堆要求的后果是更严重的。</p><p>很多代码将需要在“确定的反应时间”内提供一些“达到要求水平的服务”，我们称为实时编程。</p><p>实时编程分为“硬实时”和“软实时”。“硬实时”是不可原谅的，如燃料干的调整被推迟几微妙，你的核反应堆将会很危险；“软实时”意味着你大部分时间需要满足调度要求，但是如果不能能满足，后果也不是很严重。</p><h3 id="POSIX-实时选项"><a href="#POSIX-实时选项" class="headerlink" title="POSIX 实时选项"></a>POSIX 实时选项</h3><p>优先级调度允许程序员给系统提供了任何两个线程间相。无论何时当多个线程准备好执行时，系统将选择最高优先级的线程。</p><h4 id="调度策略和优先级。"><a href="#调度策略和优先级。" class="headerlink" title="调度策略和优先级。"></a>调度策略和优先级。</h4><p>调度策略允许设置各个调度策略的最小和最大优先级。POXIS 标准提供两种调度策略（<code>SCHED_FIFO</code> 和 <code>SCHED_RR</code>)。</p><ul><li><code>SCHED_FIFO</code>(先入先出）策略允许一个线程运行直到有更高优先级的线程准备好，或者直到它自愿阻塞自己。</li><li><code>SCHED_RR</code>(轮循），和先入先出策略是基本相同的，不同之处在于：如果有一个 <code>SCHED_RR</code>策略的线程执行了超过一个固定的时期（时间片间隔）没有阻塞，而另外的<code>SCHED_RR</code> 或 <code>SCHED_FIFO</code> 策略的相同优先级的线程准备好时，运行的线程将被抢占以使准备好的线程可以执行。</li></ul><p>程序 <code>sched_attr.c</code> 显示了如何使用属性对象来创建一个具有显式的调度策略和优先级的线程。<br>程序 <code>sched_thread.c</code> 显示了如何为一个正在运行的线程修改实时调度策略和参数。</p><h4 id="竞争范围和分配域。"><a href="#竞争范围和分配域。" class="headerlink" title="竞争范围和分配域。"></a>竞争范围和分配域。</h4><p>如果你正在写一个实时的应用程序，应该知道系统对这些控制量设置的支持，否则它们可能没有什么关系。</p><ul><li><strong>竞争范围</strong>，它描述了线程为处理器资源而竞争的方式。系统竞争范围意味着线程与进程之外的线程竞争处理器资源。一个进程内的髙优先级系统竞争范围线程能阻止其他进程内的系统竞争范围线程运行。进程竞争范围指线程仅仅在同一进程内相互竞争。可以使用 <code>pthread_attr_setscope</code> 设置竞争范围。</li><li><strong>分配域</strong>，分配域是系统内线程可以为其竞争的处理器的集合。一个系统叫以有一个以上的分配领域，每个包含一个以上的处理器。在一个单处理机系统内，分配域将只包含一个处理器，但是你仍然可以有多个分配域。在一台多处理机上，各个分配领域可以包含从一个处理器到系统中所有的处理器。</li></ul><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一次性初始化&quot;&gt;&lt;a href=&quot;#一次性初始化&quot; class=&quot;headerlink&quot; title=&quot;一次性初始化&quot;&gt;&lt;/a&gt;一次性初始化&lt;/h2&gt;&lt;p&gt;一些事情仅仅需要做一次，不管是什么。在主函数中并且在调用任何其他依赖于初始化的事物之前，这时初始化应用最容易，特别是在创造任何线程之前初始化它需要的数据，如互斥量、线程特定数据键等。&lt;/p&gt;
&lt;p&gt;在传统的顺序编程中，一次性初始化经常通过使用布尔变量来管理。控制变量被静态地初始化为 0,而任何依赖于初始化的代码都能测试该变量。如果变量值仍然为 0, 则它能实行初始化，然后将变量置为 1，以后检查的代码将跳过初始化。如下面代码示例：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; initialized = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (initialized)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// TODO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initialized = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-使用线程方式</title>
    <link href="https://veinin.com/2018/06/09/programming_with_posix_pthreads_04/"/>
    <id>https://veinin.com/2018/06/09/programming_with_posix_pthreads_04/</id>
    <published>2018-06-09T13:15:44.000Z</published>
    <updated>2018-07-12T14:44:26.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程编程模型"><a href="#线程编程模型" class="headerlink" title="线程编程模型"></a>线程编程模型</h2><p>线程变成模型主要有以下3种：</p><ul><li>流水线。每个线程反复地在数据系列集上执行冋一种操作，并把操作结果传递给下一步驟的其他线程。</li><li>工作组。每个线程在自己的数据上执行操作，工作组中的线程可能执行同样的操作，也可能执行不同的操作，但是它们一定独立地执行。</li><li>客户端/服务器。一个客户为每一件工作与一个独立的服务器“订契约”。通常“订契约”是匿名的，即一个请求通过某种接提交。</li></ul><a id="more"></a><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>在流水线（pipeline) 方式中，“数据元素”流串行地被一组线程顺序处理。每个线程依次在每个元素上执行一个特定的操作，并将结果传递给流<br>水线中的下一个线程。</p><p><img src="/images/pthreads/pipeline.png" alt="pipeline"></p><p>例如， 数据可能是扫描的图像，线程 A 可能处理一个图像数组，线程 B 可能在处理的数据中搜索某个特定的属性集，而线程 C 可能控制从线程 B 中收集连续的搜索结果流井做出报告。或者每个线程可能执行某个数据修改序列中的一步。</p><h2 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h2><p>在工作组模式中，数据由一组线程分别独立地处理。循环的“并行分解” 通常就是属于这种模式。</p><p><img src="/images/pthreads/working_group.png" alt="working_group"></p><p>例如，可能建立一组线程，每个线程负责处理数组的某些行或列。单一数据集合在线程间分离成不同部分，且结果是一个数据集。<br>由于所有的工作线程在不同的数据部分上执行相同的操作，这种模式通常被称为 SIMD (single instruction, multiple data, 单指令多数据流）并行处理。</p><h2 id="客户-服务器"><a href="#客户-服务器" class="headerlink" title="客户/服务器"></a>客户/服务器</h2><p>在客户服务器系统中，客户请求服务器对一组数据执行某个操作。服务器独立地执行操作——客户端或者等待服务器执行，或者并行地执行并在后面需要时査找结果。尽管让客户等待是最简单的，但这种方式很少有用，因为它不会为客户带来性能上的提高。另一方面，这又是一种对某些公共资源同步管理的简单方式。</p><p><img src="/images/pthreads/clinet_server.png" alt="clinet_server"></p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程编程模型&quot;&gt;&lt;a href=&quot;#线程编程模型&quot; class=&quot;headerlink&quot; title=&quot;线程编程模型&quot;&gt;&lt;/a&gt;线程编程模型&lt;/h2&gt;&lt;p&gt;线程变成模型主要有以下3种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流水线。每个线程反复地在数据系列集上执行冋一种操作，并把操作结果传递给下一步驟的其他线程。&lt;/li&gt;
&lt;li&gt;工作组。每个线程在自己的数据上执行操作，工作组中的线程可能执行同样的操作，也可能执行不同的操作，但是它们一定独立地执行。&lt;/li&gt;
&lt;li&gt;客户端/服务器。一个客户为每一件工作与一个独立的服务器“订契约”。通常“订契约”是匿名的，即一个请求通过某种接提交。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-同步</title>
    <link href="https://veinin.com/2018/06/07/programming_with_posix_pthreads_03/"/>
    <id>https://veinin.com/2018/06/07/programming_with_posix_pthreads_03/</id>
    <published>2018-06-07T12:16:55.000Z</published>
    <updated>2018-07-12T14:44:21.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不变量、临界区和谓词"><a href="#不变量、临界区和谓词" class="headerlink" title="不变量、临界区和谓词"></a>不变量、临界区和谓词</h2><p>不变量（invariant) 是由程序作出的假设， 特别是有关变量组间关系的假设。不变量可能会被破坏， 而且会经常被独立的代码段破坏。<br>临界区（critical section）有时称为“串行区域”，是指影响共享数据的代码段，临界区总能够对应到一个数据不变量。例如，你从队列中删除数据时， 你可以将删除数据的代码视为临界区。<br>谓词（Predicate) 是描述代码所需不变量的状态的语句。在英语中，谓词可以是如“队列为空”、 “资源可用” 之类的陈述。</p><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>大部分多线程程序需要在线程间共享数据。如果两个线程同时访问共享数据就可能会有问，因为一个线程可能在另一个线程修改共享数据的过程中使用该数据，并认为共享数据保持末变。<br>使线程同步最通用和常用的方法就是确保对相同数据的内存访问“互斥地”进行，即一次只能允许一个线程写数据，其他线程必须等待。<br>同步不仅仅在修改数据时重要， 当线程需要读取其他线程写入的数据时，而且数据写入的顺序也有影响时，同样需要同步。</p><a id="more"></a><h3 id="创建和销毁互斥量"><a href="#创建和销毁互斥量" class="headerlink" title="创建和销毁互斥量"></a>创建和销毁互斥量</h3><p>Pthreads 的互斥量用 <code>pthread_mutex_t</code> 类型的变量来表示。不能拷贝互斥量，拷贝的互斥量是不确定的，但可以拷贝指向互斥量的指针。</p><p>大部分时间互斥量在函数体外，如果有其他文件使用互斥量，声明为外部类型，如果仅在本文将内使用，则将其声明为静态类型。可以使用宏 <code>PTHREAD_WTEX_INZTIALIZER</code> 来声明具有默认属性的静态互斥量，静态初始化的互斥量不需要主动释放。</p><p>下面程序演示了一个静态创建互斥量的程序，该程序 <code>main</code> 函数为空，不会产生任何结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_struct_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">int</span>             value;</span><br><span class="line">&#125; <span class="keyword">my_struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my_struct_t</span> data = &#123;PTHREAD_MUTEX_INITIALIZER, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要初始化一个非缺省属性的互斥量， 必须使用动态初始化。如当使用 <code>malloc</code> 动态分配一个包含互斥量的数据结构时，应该使用 <code>pthread_nutex_init</code> 调用来动态的初始化互斥量。当不需要互斥量时，应该调用 <code>pthread_mutex_destory</code> 来释放它。另外，如果想保证每个互斥量在使用前被初始化，而且只被初始化一次。可以在创建任何线程之前初始化它，如通过调用 <code>pthread_once</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>下面程序演示了动态地初始化一个互斥量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_struct_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">int</span>             value;</span><br><span class="line">&#125; <span class="keyword">my_struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">my_struct_t</span> *data;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">my_struct_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>)</span><br><span class="line">        errno_abort(<span class="string">"Allocate structure"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_init(&amp;data-&gt;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_destroy(&amp;data-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Destroy mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加锁和解锁互斥量"><a href="#加锁和解锁互斥量" class="headerlink" title="加锁和解锁互斥量"></a>加锁和解锁互斥量</h3><p>最简单的情况下使用互斥量通过调用 <code>pthread_mutex_lock</code> 或 <code>pthread_mutex_trylock</code> 锁住互斥量，处理共享数据，然后调用 <code>pthread_mutex_unlock</code> 解锁互斥量。为确保线程能够读取一组变量的一致的值，需要在任何读写这些变量的代码段周围锁住互斥量。<br>当调用线程己经锁住互斥量之后，就不能再加锁一个线程己经锁住互斥量之后，试图这样做的结果可能是返回错误(EDEADLK)，或者可能陷入“自死锁”，使线程永远等待下去。同样，你也不能解锁一个已经解锁的互斥量，不能解锁一个由其他线程锁住的互斥量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>下面程序 alarm_mutex.c 是 alarm_thread.c 的一个改进版本，该程序效果如下：</p><ul><li>所有的闹钟按时间顺序存储在一个链表结构 <code>alarm_list</code> 中。</li><li>互斥量 <code>alarm_mutex</code> 负责协调对闹铃请求列表 <code>alarm_list</code> 的头节点的访问。</li><li>主线程，获取闹钟请求，将去按时间顺序插入到 <code>alarm_list</code> 中。</li><li>子线程，检查最新的闹铃列表，如果列表为空，则并阻塞住一段时间（1秒），解锁互斥量，以便主线程添加新的闹铃请求。否则获取下一个请求的差值，阻塞指定时间后，产生闹铃。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">alarm_tag</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alarm_tag</span>    *<span class="title">link</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                 seconds;</span><br><span class="line">    <span class="keyword">time_t</span>              time;</span><br><span class="line">    <span class="keyword">char</span>                message[<span class="number">64</span>];</span><br><span class="line">&#125; <span class="keyword">alarm_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> alarm_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">alarm_t</span> *alarm_list = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">alarm_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">alarm_t</span> *alarm;</span><br><span class="line">    <span class="keyword">int</span> sleep_time;</span><br><span class="line">    <span class="keyword">time_t</span> now;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        status = pthread_mutex_lock(&amp;alarm_mutex);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line"></span><br><span class="line">        alarm = alarm_list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alarm == <span class="literal">NULL</span>)</span><br><span class="line">            sleep_time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            alarm_list = alarm_list-&gt;link;</span><br><span class="line">            now = time(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (alarm-&gt;time &lt;= now)</span><br><span class="line">                sleep_time = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sleep_time = alarm-&gt;time - now;</span><br><span class="line"></span><br><span class="line">        status = pthread_mutex_unlock(&amp;alarm_mutex);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Unlock mutex"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sleep_time &gt; <span class="number">0</span>)</span><br><span class="line">            sleep(sleep_time);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sched_yield();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alarm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(%d) %s\n"</span>, alarm-&gt;seconds, alarm-&gt;message);</span><br><span class="line">            <span class="built_in">free</span>(alarm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">alarm_t</span> *alarm, **last, *next;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread, <span class="literal">NULL</span>, alarm_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create alarm thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Alarm&gt; "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fgets(line, <span class="keyword">sizeof</span>(line), <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(line) &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        alarm = (<span class="keyword">alarm_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">alarm_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (alarm == <span class="literal">NULL</span>)</span><br><span class="line">            errno_abort(<span class="string">"Allocate alarm"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">"%d %64[^\n]"</span>, &amp;alarm-&gt;seconds, alarm-&gt;message) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Bad command\n"</span>);</span><br><span class="line">            <span class="built_in">free</span>(alarm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status = pthread_mutex_lock(&amp;alarm_mutex);</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line"></span><br><span class="line">            alarm-&gt;time = time(<span class="literal">NULL</span>) + alarm-&gt;seconds;</span><br><span class="line"></span><br><span class="line">            last = &amp;alarm_list;</span><br><span class="line">            next = *last;</span><br><span class="line">            <span class="keyword">while</span> (next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next-&gt;time &gt;= alarm-&gt;time) &#123;</span><br><span class="line">                    alarm-&gt;link = next;</span><br><span class="line">                    *last = alarm;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = &amp;next-&gt;link;</span><br><span class="line">                next = next-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                *last = alarm;</span><br><span class="line">                alarm-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            status = pthread_mutex_unlock(&amp;alarm_mutex);</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Unlock mutex"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实例具有占用更少资源的优势，但它的响应性能不够。一旦 <code>alarm_thread</code> 线程从列表中接收了一个闹铃请求，它就进入睡眠直到闹铃到期。当它发现列表中没有闹铃请求时，也会睡眠 1 秒，以允许主线程接收新的用户请求。 当 <code>alarm_thread</code> 线程睡眠时，直到它从睡眠中返回，它都不能注意到由主线程添加到请求列表中的任何闹铃请求。这种情况下最好的办法是使用条件变量来通知共享数据的状态变化（后面章节内容）。</p><h3 id="非阻塞式互斥量锁"><a href="#非阻塞式互斥量锁" class="headerlink" title="非阻塞式互斥量锁"></a>非阻塞式互斥量锁</h3><p>当调用 <code>pthread_mutex_lock</code> 加锁互斥量时，如果此时互斥量己经被锁住，则调用线程将被阻塞。通常这是你希望的结果，但有时你可能希望如果互斥量己被锁住，则执行另外的代码路线，你的程序可能做其他一些有益的工作而不仅仅是等待。为此，Pthreads 提供了 <code>pthread_mutex_trylock</code> 函数，当调用互斥量己被锁住时调用该函数将返回错误代码 <code>EBUSY</code>。</p><p>下列实例程序 <code>trylock.c</code> 使用 <code>pthread_mutex_trylock</code> 函数来间歇性地报告计数器的值， 不过仅当它对计数器的访问与计数线程没有发生冲突时才报告：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPIN 10000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">long</span> counter;</span><br><span class="line"><span class="keyword">time_t</span> end_time;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">counter_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> spin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (time(<span class="literal">NULL</span>) &lt; end_time) </span><br><span class="line">    &#123;</span><br><span class="line">        status = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (spin = <span class="number">0</span>; spin &lt; SPIN; spin++)</span><br><span class="line">            counter++;</span><br><span class="line"></span><br><span class="line">        status = pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Unlock mutex"</span>);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Counter is %ld\n"</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">monitor_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> misses = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (time(<span class="literal">NULL</span>) &lt; end_time)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        status = pthread_mutex_trylock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (status != EBUSY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Trylock mutex"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Counter is %ld\n"</span>, counter/SPIN);</span><br><span class="line"></span><br><span class="line">            status = pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Unlock mutex"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            misses++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Monitor thread missed update %d times.\n"</span>, misses);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pthread_t</span> counter_thread_id;</span><br><span class="line">    <span class="keyword">pthread_t</span> monitor_thread_id;</span><br><span class="line"></span><br><span class="line">    end_time = time(<span class="literal">NULL</span>) + <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;counter_thread_id, <span class="literal">NULL</span>, counter_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create counter thread"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;monitor_thread_id, <span class="literal">NULL</span>, monitor_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create monitor thread"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(counter_thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join counter thread"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(monitor_thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join monitor thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个互斥量与死锁"><a href="#多个互斥量与死锁" class="headerlink" title="多个互斥量与死锁"></a>多个互斥量与死锁</h3><p>有时，一个互斥量是不够的，特别是当你的代码需要跨越软件体系内部的界限时。例如，当多个线程同时访问一个队列结构时，你需要两个互斥量，一个用来保护队列头，一个用来保护队列元素内的数据。当为多线程建立一个树型结构时，你可能需要为每个节点设置一个互斥量。</p><p>使用多个互斥量会导致复杂度的增加。最坏的情况就是死锁的发生，即两个线程分别锁住了一个互斥量而等待对方的互斥量。一个线程锁住了互斥量 A 后，加锁互斥量 B；同时另一个线程锁住了 B 而等待互斥量 A，则你的代码就产生了经典的死锁现象。</p><table><thead><tr><th>第一个线程</th><th>第二个线程</th></tr></thead><tbody><tr><td>pthread_mutex_lock(&amp;mutex_a)</td><td>pthread_mutex_lock(&amp;mutex_b)</td></tr><tr><td>pthread_mutex_lock(&amp;mutex_b)</td><td>pthread_mutex_lock(&amp;mutex_a)</td></tr></tbody></table><p>针对死锁，考虑以下两种通用的解决方法：</p><ul><li>固定加锁顺序。所有需要同时加锁互斥量A和互斥量B的代码，必须首先加锁互斥量A，然后锁互斥量B。</li><li>试加锁和回退。在锁住某个集合中的第一个互斥量后，使用以 <code>pthread_mutex_trylock</code> 来加锁集合中的其他互斥量，如果失败则将集合中所有己加锁互斥量释放，并重新锁。</li><li>如果代码不变量允许先释放互斥量 1,然后再加锁互斥量 2,就可以避免同时拥有两个互斥量的需要。但是，如果存在被破坏的不变置需要锁住不变量 1，则互斥量 1 就不能被释放，直到不变量被恢复为止。在这种情况下， 你应该考虑使用回退（或者试锁-回退 ）算法。</li></ul><p>以下程序 <code>backoff.c</code> 演示了如何使用回退算法避免互斥量死锁。程序建立了两个线程线程，一个运行函数 <code>lock_forward</code>,一个个运行函数 <code>lock_backward</code>。程序每次循环都会试图锁住三个互斥量，<code>lock_forward</code> 依次锁住互斥量1、2、3，<code>lock_backward</code>则按相反顺序加锁互斥量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITERATIONS 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex[<span class="number">3</span>] = &#123;</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> backoff = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> yield_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">lock_forward</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, iterate, backoffs;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (iterate = <span class="number">0</span>; iterate &lt; ITERATIONS; iterate++)</span><br><span class="line">    &#123;</span><br><span class="line">        backoffs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                status = pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">                <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                    err_abort(status, <span class="string">"First lock"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"forward lock got %d\n"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (backoff)</span><br><span class="line">                    status = pthread_mutex_trylock(&amp;mutex[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    status = pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (status == EBUSY)</span><br><span class="line">                &#123;</span><br><span class="line">                    backoffs++;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"forward locker backing of at %d\n"</span>, i);</span><br><span class="line">                    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                    &#123;</span><br><span class="line">                        status = pthread_mutex_unlock(&amp;mutex[i]);</span><br><span class="line">                        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                            err_abort(status, <span class="string">"Backoff"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                        err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"forward locker got %d\n"</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (yield_flag)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (yield_flag &gt; <span class="number">0</span>)</span><br><span class="line">                    sched_yield();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lock forward got all locks, %d backoffs\n"</span>, backoffs);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[<span class="number">1</span>]);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[<span class="number">2</span>]);</span><br><span class="line">        sched_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">lock_backward</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, iterate, backoffs;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (iterate = <span class="number">0</span>; iterate &lt; ITERATIONS; iterate++)</span><br><span class="line">    &#123;</span><br><span class="line">        backoffs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                status = pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">                <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                    err_abort(status, <span class="string">"First lock"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"backward lock got %d\n"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (backoff)</span><br><span class="line">                    status = pthread_mutex_trylock(&amp;mutex[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    status = pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (status == EBUSY)</span><br><span class="line">                &#123;</span><br><span class="line">                    backoffs++;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"backward locker backing of at %d\n"</span>, i);</span><br><span class="line">                    <span class="keyword">for</span> (; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        status = pthread_mutex_unlock(&amp;mutex[i]);</span><br><span class="line">                        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                            err_abort(status, <span class="string">"Backoff"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                        err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"backward locker got %d\n"</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (yield_flag)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (yield_flag &gt; <span class="number">0</span>)</span><br><span class="line">                    sched_yield();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lock backward got all locks, %d backoffs\n"</span>, backoffs);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[<span class="number">2</span>]);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[<span class="number">1</span>]);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">        sched_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> forward, backward;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        backoff = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>)</span><br><span class="line">        yield_flag = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;forward, <span class="literal">NULL</span>, lock_forward, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create forward"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;backward, <span class="literal">NULL</span>, lock_backward, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create backward"</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有特殊防范机制，这个程序很快就会死锁，如果上面程序运行 <code>backoff 0</code>，就会看到死锁现象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/backoff 0</span></span><br><span class="line">backward lock got 2</span><br><span class="line">backward locker got 1</span><br><span class="line">forward lock got 0</span><br></pre></td></tr></table></figure><p>上面两个线程都调用 <code>pthread_mutex_lock</code> 来加锁每个互斥量，由于线程从不同的端开始，所以它们在中间遇到时就会死锁。<br>而使用回退算法的程序，不管运行多少次循环，上面的程序都会正常执行，而不会发生死锁现象。</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量是用来通知共享数据状态信息的。可以使用条件变量来通知队列已空、或队列非空、或任何其他需要由线程处理的共享数据状态。</p><p>当一个线程互斥地访问其享状态时，它可能发现在其他线程改变状态之前它什么也做不了。即没有破坏不变量，但是线程就是对当前状态不感兴趣。例如，一个处理队列的线程发现队列为空时，它只能等恃，直到有一个节点被添加进队列中。</p><p>条件变置不提供互斥，需要一个互斥量来同步对共享数据的访问。</p><p>一个条件变量应该与一个谓词相关，如果试图将一个条件变量与多个谓词相关，或者将多个条件变量与一个谓词相关，就有陷入死锁或者竞争问题的危险。</p><h3 id="创建和释放条件变量"><a href="#创建和释放条件变量" class="headerlink" title="创建和释放条件变量"></a>创建和释放条件变量</h3><p>程序中由 <code>pthread_cond_t</code> 类型的变量来表示条件变量。如果声明了一个使用默认属性值的静态条件变量，则需要要使用 <code>PTHREAD_COND_TNTTIALIZER</code> 宏初始化，这样初始化的条件变量不必主动释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_tcond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure><p>下面时一个静态初始化条件变量的实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_struct_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  cond;</span><br><span class="line">    <span class="keyword">int</span>             value;</span><br><span class="line">&#125; <span class="keyword">my_struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my_struct_t</span> data = &#123;PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时无法静态地初始化一个条件变量，例如，当使用 <code>malloc</code> 分配一个包含条件变量的结构时，这时，你需要调用 <code>pthread_cond_init</code> 来动态地初始化条件变量。当动态初始化条件变量时，应该在不需要它时调用 <code>pthread_cond_destory</code> 来释放它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *condattr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p>下面是一个动态初始化条件变量的实例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_struct_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  cond;</span><br><span class="line">    <span class="keyword">int</span>             value;</span><br><span class="line">&#125; <span class="keyword">my_struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">my_struct_t</span> *data;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"> </span><br><span class="line">    data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">my_struct_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>)</span><br><span class="line">        errno_abort(<span class="string">"Allocate structure"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_init(&amp;data-&gt;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init mutex"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cond_init(&amp;data-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Init condition"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_cond_destroy(&amp;data-&gt;cond);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Destroy condition"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_destroy(&amp;data-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Destroy mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等待条件变量和唤醒等待线程"><a href="#等待条件变量和唤醒等待线程" class="headerlink" title="等待条件变量和唤醒等待线程"></a>等待条件变量和唤醒等待线程</h3><p>每个条件变量必须与一个特定的互斥量、一个谓词条件相关联。当线程等待条件变量时，它必须轉相关互斥量锁住。记住，在阻寒线程之前，条件变量等待操作将解锁互斥量；而在重新返回线程之前，会再次锁住互斥量。</p><p>所有并发地（同时）等待同一个条件变量的线程心须指定同一个相关互斥量。例如，Pthreads不允许线程1使用互斥量 A 等待条件变量 A，而线程2使用互斥量 B 等待条件变量 A。不过，以下情况是十分合理的：线程1使用互斥量 A 等待条件变量 A，而线程2使用互斥量 A 等待条件变量 B。即，任何条件变量在特定时刻只能与一个互斥量相关联，而互斥量则可以同时与多个条件变过关联。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(pthread_cond *cond, <span class="keyword">pthread_mutex_t</span> *mutex, struct timespec *expiration)</span></span>;</span><br></pre></td></tr></table></figure><p>一旦有线程为某个谓词在等待一个条件变量，你可能需要唤醒它。Pthreads 提供了两种方式唤醒等待的线程：一个是“发信号”，一个是“广播”。发信号只唤醒一个等待该条件变量的线程，而广播将唤醒所有等待该条件变量的线程。</p><p>广播与发信号真正的区别是效率：广播将唤醒额外的等待线程，而这些线程会检测自己的谓词然后继续等待，通常，不能用发信号代替广播。“当有什么疑惑的时候，就使用广播”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p>下面实例展示了如何等待条件变量，唤醒正在睡眠的等待线程。<br>线程 <code>wait_thread</code> 等待指定时间后，设置 <code>value</code> 值后，发送信号给条件变量。<br>主线程调用 <code>pthread_cond_timedwait</code> 函数等待最多2秒，如果 <code>hibernation</code> 大于2秒则条件变量等待将会超时，返回 <code>ETIMEOUT</code>;<br>如果 <code>hibernation</code> 设置为2秒，则主线程与 <code>wait_thread</code> 线程发生竞争，每次运行结果可能不同；<br>如果 <code>hibertnation</code> 设置少于2秒，则条件变量等待永远不会超时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_struct_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  cond;</span><br><span class="line">    <span class="keyword">int</span>             value;</span><br><span class="line">&#125; <span class="keyword">my_struct_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my_struct_t</span> data = &#123;PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hibernation = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">wait_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    sleep(hibernation);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_lock(&amp;data.mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line"></span><br><span class="line">    data.value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    status = pthread_cond_signal(&amp;data.cond);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Signal condition"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_unlock(&amp;data.mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Unlock mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pthread_t</span> wait_thread_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        hibernation = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;wait_thread_id, <span class="literal">NULL</span>, wait_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create wait thread"</span>);</span><br><span class="line"></span><br><span class="line">    timeout.tv_sec = time(<span class="literal">NULL</span>) + <span class="number">2</span>;</span><br><span class="line">    timeout.tv_nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_lock(&amp;data.mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Lock mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (data.value == <span class="number">0</span>) &#123;</span><br><span class="line">        status = pthread_cond_timedwait(&amp;data.cond, &amp;data.mutex, &amp;timeout);</span><br><span class="line">        <span class="keyword">if</span> (status == ETIMEDOUT) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Condition wait time out.\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">            err_abort(status, <span class="string">"Wait on condition"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = pthread_mutex_unlock(&amp;data.mutex);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Unlock mutex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闹钟实例最终版本"><a href="#闹钟实例最终版本" class="headerlink" title="闹钟实例最终版本"></a>闹钟实例最终版本</h3><p>之前采用 <code>mutex</code> 实现的闹钟版本并不完美，它必须在处理完当前闹铃后，才能检测其他闹铃请求是否已经被加入了列表，即使新的请求<br>的到期时间比当前请求早。例如， 首先输入命令行 <code>10 message1</code>， 然后输入 <code>5 message2</code>，那么程序是无法预知后面5秒的闹钟加入到列表中来了，只能先处理完10秒的闹钟，才能继续处理后面的内容。</p><p>我们可以增加条件变量的使用来解决这个问题，新的版本使用一个超时条件变量操作代替睡眠操作，以等待闹钟到时。<br>当主线程在列表中添加了一个新的请求时，将发信号给条件变量，立刻唤醒 <code>alarm_thread</code> 线程。<code>alarm_thread</code> 线程可以重排等待的闹铃请求，然后重新等待。</p><p>你可以在 <code>alarm_cond.c</code> 获取源代码实现。</p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不变量、临界区和谓词&quot;&gt;&lt;a href=&quot;#不变量、临界区和谓词&quot; class=&quot;headerlink&quot; title=&quot;不变量、临界区和谓词&quot;&gt;&lt;/a&gt;不变量、临界区和谓词&lt;/h2&gt;&lt;p&gt;不变量（invariant) 是由程序作出的假设， 特别是有关变量组间关系的假设。不变量可能会被破坏， 而且会经常被独立的代码段破坏。&lt;br&gt;临界区（critical section）有时称为“串行区域”，是指影响共享数据的代码段，临界区总能够对应到一个数据不变量。例如，你从队列中删除数据时， 你可以将删除数据的代码视为临界区。&lt;br&gt;谓词（Predicate) 是描述代码所需不变量的状态的语句。在英语中，谓词可以是如“队列为空”、 “资源可用” 之类的陈述。&lt;/p&gt;
&lt;h2 id=&quot;互斥量&quot;&gt;&lt;a href=&quot;#互斥量&quot; class=&quot;headerlink&quot; title=&quot;互斥量&quot;&gt;&lt;/a&gt;互斥量&lt;/h2&gt;&lt;p&gt;大部分多线程程序需要在线程间共享数据。如果两个线程同时访问共享数据就可能会有问，因为一个线程可能在另一个线程修改共享数据的过程中使用该数据，并认为共享数据保持末变。&lt;br&gt;使线程同步最通用和常用的方法就是确保对相同数据的内存访问“互斥地”进行，即一次只能允许一个线程写数据，其他线程必须等待。&lt;br&gt;同步不仅仅在修改数据时重要， 当线程需要读取其他线程写入的数据时，而且数据写入的顺序也有影响时，同样需要同步。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-线程</title>
    <link href="https://veinin.com/2018/06/05/programming_with_posix_pthreads_02/"/>
    <id>https://veinin.com/2018/06/05/programming_with_posix_pthreads_02/</id>
    <published>2018-06-05T14:22:01.000Z</published>
    <updated>2018-07-12T14:44:14.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立和使用线程"><a href="#建立和使用线程" class="headerlink" title="建立和使用线程"></a>建立和使用线程</h2><h3 id="线程标识符"><a href="#线程标识符" class="headerlink" title="线程标识符"></a>线程标识符</h3><p>程序中使用线程标识符 ID 来表示线程。线程 ID 属于封装的 pthreadLt 类型。<br>为建立线程，你需要在程序中声明一个 <code>pthread_t</code> 类型的变量。 如果只需在某个函数中使用线程 ID，或者函数直到线程终止时才返回，则可以将线程 ID 声明为自动存储变量，不过大部分时间内， 线程 ID 保存在共享变量中（静态或外部）， 或者保存在堆空间的结构体中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> thread;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>通过向 <code>pthread_create</code> 函数传送线程函数地址和线程函数调用的参数来创建线程。线程函数应该只有一个 <code>void *</code> 类型参数，并返回相同的类型值。<br>当创建线程时，<code>pthread_create</code> 函数返回一个 <code>pthread_t</code> 类型的线程 ID, 并保存在 thread 参数中。 通过这个线程 ID， 程序可以引用该线程。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread, const pthreae_attr_t *attr, void *(*start)(void *), void *arg);</span><br></pre></td></tr></table></figure><h3 id="获得自己的线程ID"><a href="#获得自己的线程ID" class="headerlink" title="获得自己的线程ID"></a>获得自己的线程ID</h3><p>线程可以通过调用 <code>pthread_self</code> 来获得自身的 ID。除非线程的创建者或者线程本身将线程 ID 保存于某处，否则不可能获得一个线程的 ID。要对线程进行任何操作都必须通过线程 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><h3 id="比较线程"><a href="#比较线程" class="headerlink" title="比较线程"></a>比较线程</h3><p>可以使用 <code>pthread_equal</code> 函数来比较两个线程 ID,只能比较二者是否相同。比较两个线程 ID 谁大谁小是没有任何意义的，因为线程 ID 之间不存在顺序。如果两个线程 ID 表示同一个线程，则 <code>pthread_equal</code> 函数返回非零值，否则返回零值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tl, <span class="keyword">pthread_t</span> t2)</span></span>;  <span class="comment">// 相等返回非0值</span></span><br></pre></td></tr></table></figure><h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>如果要创建一个从不需要控制的线程，可以是用属性（attribute）来建立线程以使它可分离的。如果不想等待创建的某个线程，而且知道不再需要控制它，可以使用 <code>pthread_detach</code> 函数来分离它。<br>分离一个正在运行的线程不会对线程带来任何影响，仅仅是通知系统当该线程结束时，其所属资源可以被回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h3><p>当 C 程序运行时，首先运行 <code>main</code> 函数。在线程代码中， 这个特殊的执行流被称为 “<strong>初始线程</strong>” 或 “<strong>主线程</strong>”。 你可以在初始线程中做任何你能在普通线程中做的事情。也可以调用 <code>pthread_exit</code> 来终止自己。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *value_ptr)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="取消线程"><a href="#取消线程" class="headerlink" title="取消线程"></a>取消线程</h3><p>外部发送终止信号给指定线程，如果成功则返回0，否则返回非0。发送成功并不意味着线程会终止。<br>另外，如果一个线程被回收，终止线程的 ID 可能被分配给其他新的线程，使用该 ID 调用 <code>pthread_cancel</code> 可能就会取消一个不同的线程， 而不是返回 ESRCH 错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h3><p>如果需要获取线程的返回值，或者需要获知其何时结束，应该调用 <code>pthread_join</code> 函数。 <code>pthread_join</code> 函数将阻塞其调用者直到指定线程终止。然后，可以选择地保存线程的返回值。调<br>用 <code>pthread_join</code> 函数将自动分离指定的线程。线程会在返回时被回收，回收将释放所有在线程终止时未释放的系统和进程资源，包栝保存线程返回值的内存空间、堆栈、保存寄存器状态的内存空间等。所以，在线程终止后上述资源就不该被访问了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **value_ptr)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程有四种基本状态：</p><ul><li>就绪（Ready）状态。线程能够运行，但在等待可用的处理器，可能刚刚启动，或刚刚从阻塞中恢复，或者被其他线程抢占。</li><li>运行（Running）状态。线程正在运行，在多处器系统中，可能有多个线程处于运行态线程由于等待处理器外的其他条件无法运行，如条件变量的改变、加锁互斥量或 I/O 操作结束。</li><li>阻塞（Blocked）状态。线程由于等待处理器外的其他条件无法运行，如条件变量的改变、加锁互斥量或 I/O 操作结束。</li><li>终止（Terminated）状态。线程从起始函数中返回，或调用 pthread_exit，或者被取消，终止自己并完成所有资源清理。不是被分离，也不是被连接，一且线程被分离或者连接，它就可以被收回。</li></ul><p>下面是线程的状态转换图：</p><p><img src="/images/pthreads/lifecycle.png" alt="pipeline"></p><p>下面程序展示了一个线程使用的完整生命周期实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">void</span> *thread_result;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_routine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Create thread"</span>);</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread_id, &amp;thread_result);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Join thread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread_result == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序中 <code>pthread_create</code> 创建线程后，线程处于就绪状态。受调度机制的限制，新线程可能在就绪状态下停留一段时间才被执行。<br>当处理器选中一个就绪线程执行它时，该线程进入运行态。通常这意味着某个其他线程被阻塞或者被时间片机制抢占，处理器会保存被阻塞（或抢占）线程的环境并恢复下二个就绪线程的环境。<br>主线程在调用 <code>pthread_join</code> 进入阻塞状态，等待它创建的线程运行结束。<br>当调用 <code>pthread_exit</code> 退出线程或调用 <code>pthread_cancel</code> 取消线程时， 线程在调用完清理过程后也将进入终止态。而主线程等到创建的线程终止后重新运行直到结束。</p><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;建立和使用线程&quot;&gt;&lt;a href=&quot;#建立和使用线程&quot; class=&quot;headerlink&quot; title=&quot;建立和使用线程&quot;&gt;&lt;/a&gt;建立和使用线程&lt;/h2&gt;&lt;h3 id=&quot;线程标识符&quot;&gt;&lt;a href=&quot;#线程标识符&quot; class=&quot;headerlink&quot; title=&quot;线程标识符&quot;&gt;&lt;/a&gt;线程标识符&lt;/h3&gt;&lt;p&gt;程序中使用线程标识符 ID 来表示线程。线程 ID 属于封装的 pthreadLt 类型。&lt;br&gt;为建立线程，你需要在程序中声明一个 &lt;code&gt;pthread_t&lt;/code&gt; 类型的变量。 如果只需在某个函数中使用线程 ID，或者函数直到线程终止时才返回，则可以将线程 ID 声明为自动存储变量，不过大部分时间内， 线程 ID 保存在共享变量中（静态或外部）， 或者保存在堆空间的结构体中。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pthread_t&lt;/span&gt; thread;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>POSIX 多线程程序设计-概述</title>
    <link href="https://veinin.com/2018/06/01/programming_with_posix_pthreads_01/"/>
    <id>https://veinin.com/2018/06/01/programming_with_posix_pthreads_01/</id>
    <published>2018-06-01T11:32:05.000Z</published>
    <updated>2018-07-12T14:43:46.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步（synchronous）意味着同时在一起工作。例如聊天室和在线会议就是同步的好例子，在聊天室中，人们对彼此的对话会立即得到反应。<br>同步相对来说比较简单，但开销相对较大。</p><p>异步（asynchronous) 表明事情相互独立地发生， 异步双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送。例如论坛和电子邮件就是采用异步通信的一个好例子，这样沟通的双方都会有足够的时间去思考。<br>异步增加了复杂性以及更加麻烦的调试过程。如果你没有同时执行多个活动， 那么异步就没有什么优势。 如果你开始了一个异步活动， 然后什么也不做等待它结束， 则你并没有从异步那儿获得太多好处。</p><a id="more"></a><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发（concurrency ) 的意思是指事情同时发生。 也是指让实际上可能串行发生的事情好像同时发生一样。 并发描述了单处理器系统中线程或进程的行为特点。在 POSIX 中，并发的定义要求“延迟调用线程的函数不应<br>该导致其他线程的无限期延迟。</p><p>并行（parallelism) 指并发序列同时执行， 换言之，软件中的“并行”语言中的“并发”是相同的意思， 而区別于软件中的“并发”。指事情在相同的方向上独立进行（没有交错）。</p><p>真正的并行只能在多处理器系统中存在， 但是并发可以在单处理器系统和多处理器系统中都存在。<br>并发能够在单处理器系统中存在是因为并发实际上是并行的假象。 并行要求程序能够同时执行多个操作，而并发只要求程序能够假装同时执行多个操作。</p><h3 id="单处理器和多处理器"><a href="#单处理器和多处理器" class="headerlink" title="单处理器和多处理器"></a>单处理器和多处理器</h3><p>单处理器是指一台计算机只有一个编程人员可见的执行单元（处理器）。对于拥有超标量体系结构、向量或者其他数学或 I/O 协处理器的单一通用处理器，我们仍然把它当成单处理器。</p><p>多处理器是指一台计算机拥有多个处理器，它们共享同一个指令集和相同的物理内存。虽然处理器不必同等地访问所有物理内存，但是每一个应该都能访问大部分内存。</p><h3 id="线程安全和可重入"><a href="#线程安全和可重入" class="headerlink" title="线程安全和可重入"></a>线程安全和可重入</h3><p>线程安全是指代码能够被多个线程调用而不会产生灾难性的结果。它补要求代码在多个线程中高效的运行，只要求能够安全的运行。人部分现行函数可以利用 Pthreads 提供的互斥量、 条件变量和线程私有数据来实现线程的安全。比如，在进入函数时加锁，在退出函数时解锁。这样的函数可以被多个线程调用，但一次只能有一个线程调用它。</p><p>“可重入”有时用来表示”有效的线程安全”。意味着函数不在连续的调用中保存静态数据，也不返回指向静态数据的指针。所有的数据都是由函数的调用程序提供的。重入函数不得调用非重入函数。</p><h2 id="线程的好处"><a href="#线程的好处" class="headerlink" title="线程的好处"></a>线程的好处</h2><p>多线程编程模型具有以下优点：</p><ul><li>在多处理器系统中开发程序的并行性，除了并行性这一优点是需要特殊硬件支持外， 其他优点对硬件不做要求。</li><li>在等待慢速外设 I/O 操作结束的同时， 程序可以执行其他计算， 为程序的并发提供更有效、 更自然的开发方式。</li><li>一种模块化编程模型， 能清晰地表达程序中独立事件间的相互关系。</li></ul><h2 id="线程的代价"><a href="#线程的代价" class="headerlink" title="线程的代价"></a>线程的代价</h2><p>任何事情都有代价，线程也不例外。在很多情形下好处超过了代价，在其他情形下则相反。</p><ul><li>计算负荷。比如线程间同步会直接影响运行时间，对于两个总是同时使用的变量分别加以保护，这意味着你在同步上花费太多的时间而损失了并发。</li><li>编程规则。尽管线程编程模型的基本思想简单，但是编写实际的代码不是件容易的事。编写能够在多个线程中良好工作的代码需要认真的思考和计划。你需要明白同步协议和程序中的不变量（invariant), 你不得不避免死锁、竞争和优先级倒置。</li><li>更难以调试。调试不可避免地要改变事件的时序。在调试串行代码时不会有什么大问题，但是在调试异步代码时却是致命的。如果一个线程因调试陷阱而运行得稍微慢了，则你要跟踪的问题就可能不会出现。每个程序员都会遇到此类在调试时无法再现的错误，这在线程编程中会更加普遍。</li></ul><h2 id="选择线程还是不用线程"><a href="#选择线程还是不用线程" class="headerlink" title="选择线程还是不用线程"></a>选择线程还是不用线程</h2><p>线程并非总是容易使用，而且并非总是可达到最好的性能。一些问题本身就是非并发的，添加线程线程只能降低程序的性能并使程序复杂。如果程序中的每一步都需要上一步的结果，则使用线程不会有任何帮助。每个线程不得不等待其他线程的结束。</p><p>最适合使用线程的应用包括以下这些：</p><ul><li>计算密集型应用，为了能在多处理器系统上运行，将这些计算分解到多个线程中实现。</li><li>I/O 密集型应用，为提高性能，将 I/O 操作重叠。很多线程可以同时等待不同的 I/O 操作。分布式服务器应用就是很好的实例，它们必须响应多个客户的请求，必须为通过慢速网络的连接主动提供 I/O 准备。</li></ul><h2 id="POSIX线程概念"><a href="#POSIX线程概念" class="headerlink" title="POSIX线程概念"></a>POSIX线程概念</h2><p>POSIX 线程线程 API 遵循国际正式标准 POSIX 1003.1c-1995, 我们将使用非正式的术语 “Pthreads” 代表 “POSIX 1003.1c-1995”。</p><p>线程系统包含三个基本要素：</p><ul><li>执行环境，是并发实体的状态。 并发系统必须提供建立、 删除执行环境和独立维护它们状态的方式。</li><li>调度，决定在某个给定时刻该执行哪个环境（或环境组）， 并在不同的环境中切换。</li><li>同步，为并发执行的环境提供了协调访问共享资源的一种机制。</li></ul><p>下表列出了上述三方面的几个不同的实例：</p><table><thead><tr><th>环境</th><th>执行环境</th><th>调度</th><th>同步</th></tr></thead><tbody><tr><td>交通</td><td>汽车</td><td>红绿灯</td><td>转变信号和刹车灯</td></tr><tr><td>UNIX ( 无线程 )</td><td>进程</td><td>优先级</td><td>等待和管道</td></tr><tr><td>Pthreads</td><td>线程</td><td>策略、 优先级</td><td>条件变量和互斥量</td></tr></tbody></table><h3 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h3><p>使用 Pthreads, 通过调用 <code>pthread_create</code> 来创建执行环境（线程）。 创建一个线程同样也调度了该线程的执行，这将通过调用指定的 “<strong>线程启动</strong>” 函数开始。Pthreads 允许在创建线程时指定调度参数，或者在线程运行时设定。<br>当线程调用 <code>pthread_exit</code> 时退出，或者也可以从线程启动函数中返回时退出。</p><p>基本的 Pthreads 同步模型使用 <strong>互斥量</strong> 来保护共享数据，使用 <strong>条件变量</strong> 来通信，还可以使用其他的同步机制，如 <strong>信号量</strong>、<strong>管道</strong> 和 <strong>消息队列</strong>。<br>互斥量允许线程在访问共享数据时锁定它，以避免其他线程的干扰。条件变量允许线程等待共享数据到达某个期望的状态（例如队列非空或者资源可用）。</p><h3 id="类型和接口"><a href="#类型和接口" class="headerlink" title="类型和接口"></a>类型和接口</h3><p>POSIX 线程数据类型：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>pthread_t</td><td>线程标识符</td></tr><tr><td>pthreae_mutex_t</td><td>互斥量</td></tr><tr><td>pthread_code_t</td><td>条件变量</td></tr><tr><td>pthread_key_t</td><td>线程私有权握访问键</td></tr><tr><td>pthread_attr_t</td><td>线程属性对象</td></tr><tr><td>pthread_mutexattr_t</td><td>互斥量属性对</td></tr><tr><td>pthread_condattr_t</td><td>条件变属性对象</td></tr><tr><td>pthread_once_t</td><td>“一次性初始化”控制变量</td></tr></tbody></table><h3 id="错误检查"><a href="#错误检查" class="headerlink" title="错误检查"></a>错误检查</h3><p>在传统的UNIX系统和原来的标准中．errno 是一个外部整型变量。由于该变量一次只能有一个值，所以只能支持进程中的单一执行流程。<br>传统的报错机制有许多问题，包括很难创建在报错的同时返回一个有用的 -1 值的函数。当引入多线程时会有更严重的问题。<br>Pthreads 修订版是 POSIX 中第一个与传统的 UNIX 和 C 语言报错机制相分离的部分。<br>Pthreads 中的新函数通过返回值来表示错误状态，而不是用变量。当成功时，Pthreads 函数返回 0, 并包含一个额外的输出参数来指向存有“有用结果”<br>的地址。当发生错误时，函数返回一个包含在 <code>errno</code> 变量以支持其他使用 <code>&lt;errao.h&gt;</code> 文件中的错误代码。</p><p>下面程序是一个典型的线程错误检查代码，因为 <code>pthread_t</code> 变量拥有一个无效的值，所以在使用 <code>pthread_join</code> 在遇到无效线程ID时会返回错误代码 <code>ESRCH</code>。<br>运行下面程序将显示错误消息：<code>error 3: No such process</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error %d: %s\n"</span>, status, strerror(status));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免在实例代码的每个函数调用中都增加报错和退出的代码段，我们需要写两个报错宏使用 err_abort 检测标准的 Pthreads 错误， 使用 errno_abort 检测传统的 errno 错误变量方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> err_abort(code, text) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;\</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s at \"%s\":%d: %s\n"</span>,\</span><br><span class="line">            text, __FILE__, __LINE__, strerror(code));\</span><br><span class="line">        <span class="built_in">abort</span>();\</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> errno_abort(text) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;\</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s at \"%s\":%d: %s\n"</span>,\</span><br><span class="line">            text, __FILE__, __LINE__, strerror(errno));\</span><br><span class="line">        <span class="built_in">abort</span>();\</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="异步编程举例"><a href="#异步编程举例" class="headerlink" title="异步编程举例"></a>异步编程举例</h2><p>下面使用一个简单的闹钟实例程序来演示基本的异歩编程方法。该程序循环接受用户输入信息，直到出错或者输入完毕，用户输入的每行信息中，第一部分是闹钟等待的时间（ 以秒为单位），第二部分是闹钟时间到迖时显示的文本消息。</p><h3 id="同步版本"><a href="#同步版本" class="headerlink" title="同步版本"></a>同步版本</h3><p>一直同步等待 <code>fgets</code> 产生输入，然后根据输入的秒数进行等待指定时间，最后输出闹钟响起的消息。该程序的问题是一次只能处理一个闹钟请求，如果你的程序设置了一个10分钟闹钟，就不能再继续让它在5分钟时响起另外一个闹钟。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seconds;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Alarm&gt; "</span>);</span><br><span class="line">        <span class="keyword">if</span> (fgets(line, <span class="keyword">sizeof</span>(line), <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(line) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">"%d %64[^\n]"</span>, &amp;seconds, message) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Bad command\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sleep(seconds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(%d) %s\n"</span>, seconds, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多进程版本"><a href="#多进程版本" class="headerlink" title="多进程版本"></a>多进程版本</h3><p>为每个命令使用 <code>fork</code> 调用生成一个独立的子进程来处理闹钟。<code>fork</code> 版本是异步方式的的一种实现，该程序可以随时输入命令行，它们被彼此独立地执行。 新版本并不比同步版本复杂多少。<br>该版本的主要难点在于对所有己终止子进程的 <code>reap</code>。如果程序不做这个工作，则要等到程序退出的时候由系统回收，通常回收子进程的方法是调用某个 <code>wait</code> 系列函数。在本例中，我们调用 waitpid 函数，并设置 WNOHANG（父进程不必挂等待子进程的结束）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> seconds;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Alarm&gt; "</span>);</span><br><span class="line">        <span class="keyword">if</span> (fgets(line, <span class="keyword">sizeof</span>(line), <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(line) &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">"%d %64[^\n]"</span>, &amp;seconds, message) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Bad command\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">                errno_abort(<span class="string">"Fork"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pid == (<span class="keyword">pid_t</span>)<span class="number">0</span>) &#123;</span><br><span class="line">                sleep(seconds);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"(%d) %s\n"</span>, seconds, message);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    pid = waitpid((<span class="keyword">pid_t</span>)<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">                    <span class="keyword">if</span> (pid == (<span class="keyword">pid_t</span>) <span class="number">-1</span>)</span><br><span class="line">                        errno_abort(<span class="string">"Wait for child"</span>);</span><br><span class="line">                &#125; <span class="keyword">while</span>(pid != (<span class="keyword">pid_t</span>)<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程版本"><a href="#多线程版本" class="headerlink" title="多线程版本"></a>多线程版本</h3><p>多线程版本与多进程十分相似，只是使用线程而非子进程来实现异步闹钟。本例中用到了以下三个Pthread函数：</p><ul><li><code>pthread_create</code> 函数建立一个线程， 运行由第三个参数 <code>alarm_thread</code> 指定的例程，并返回线程标识符 ID (保存在 <code>thread</code> 引用的变量中）</li><li><code>pthread_self</code> 获取当前线程标识符 ID。</li><li><code>pthread_detach</code> 函数允许在当线程终止时立刻回收线程资源。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errors.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">alarm_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  seconds;</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">64</span>];</span><br><span class="line">&#125; <span class="keyword">alarm_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">alarm_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">alarm_t</span> *alarm = (<span class="keyword">alarm_t</span>*)arg;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        err_abort(status, <span class="string">"Detach thread"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(alarm-&gt;seconds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%d) %s\n"</span>, alarm-&gt;seconds, alarm-&gt;message);</span><br><span class="line">    <span class="built_in">free</span>(alarm);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> seconds;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">alarm_t</span> *alarm;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Alarm&gt; "</span>);</span><br><span class="line">        <span class="keyword">if</span> (fgets(line, <span class="keyword">sizeof</span>(line), <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(line) &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        alarm = (<span class="keyword">alarm_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">alarm_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (alarm == <span class="literal">NULL</span>)</span><br><span class="line">            errno_abort(<span class="string">"Allocate alarm"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">"%d %64[^\n]"</span>, &amp;alarm-&gt;seconds, alarm-&gt;message) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Bad command\n"</span>);</span><br><span class="line">            <span class="built_in">free</span>(alarm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status = pthread_create(&amp;thread, <span class="literal">NULL</span>, alarm_thread, alarm);</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">                err_abort(status, <span class="string">"Create alarm thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>系列文章目录：<ul><li><a href="/2018/06/01/programming_with_posix_pthreads_01/">概述</a></li><li><a href="/2018/06/05/programming_with_posix_pthreads_02/">线程</a></li><li><a href="/2018/06/07/programming_with_posix_pthreads_03/">同步</a></li><li><a href="/2018/06/09/programming_with_posix_pthreads_04/">使用线程方式</a></li><li><a href="/2018/06/12/programming_with_posix_pthreads_05/">线程高级编程</a></li><li><a href="/2018/06/17/programming_with_posix_pthreads_06/">POSIX 针对线程的调整</a></li><li><a href="/2018/06/20/programming_with_posix_pthreads_07/">线程扩展</a></li><li><a href="/2018/06/25/programming_with_posix_pthreads_08/">线程同步精要</a></li></ul></li></ul><ul><li><a href="https://github.com/Veinin/programming-with-POSIX-threads-tutorials" target="_blank" rel="noopener">Github 示例源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;术语定义&quot;&gt;&lt;a href=&quot;#术语定义&quot; class=&quot;headerlink&quot; title=&quot;术语定义&quot;&gt;&lt;/a&gt;术语定义&lt;/h2&gt;&lt;h3 id=&quot;同步与异步&quot;&gt;&lt;a href=&quot;#同步与异步&quot; class=&quot;headerlink&quot; title=&quot;同步与异步&quot;&gt;&lt;/a&gt;同步与异步&lt;/h3&gt;&lt;p&gt;同步（synchronous）意味着同时在一起工作。例如聊天室和在线会议就是同步的好例子，在聊天室中，人们对彼此的对话会立即得到反应。&lt;br&gt;同步相对来说比较简单，但开销相对较大。&lt;/p&gt;
&lt;p&gt;异步（asynchronous) 表明事情相互独立地发生， 异步双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送。例如论坛和电子邮件就是采用异步通信的一个好例子，这样沟通的双方都会有足够的时间去思考。&lt;br&gt;异步增加了复杂性以及更加麻烦的调试过程。如果你没有同时执行多个活动， 那么异步就没有什么优势。 如果你开始了一个异步活动， 然后什么也不做等待它结束， 则你并没有从异步那儿获得太多好处。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://veinin.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phtreads" scheme="https://veinin.com/tags/Phtreads/"/>
    
      <category term="POSIX Pthreads" scheme="https://veinin.com/tags/POSIX-Pthreads/"/>
    
  </entry>
  
</feed>
