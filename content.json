{"meta":{"title":"Veinin","subtitle":null,"description":null,"author":"Veinin Guo","url":"http://veinin.com"},"pages":[{"title":"","date":"2018-03-04T14:36:10.150Z","updated":"2018-03-04T14:36:10.150Z","comments":false,"path":"booklist/index.html","permalink":"http://veinin.com/booklist/index.html","excerpt":"","text":"编程语言C C和指针 C专家编程 C陷阱与缺陷 C++ C++ 沉思录 C++ Primer Effective C++ More Effective C++ C++ templates C++标准库 C++并发编程实战 Lua Lua设计与实现 Lua程序设计 Java Effective java Java并发编程实战 Head First 设计模式 软件开发 大教堂与集市 人月神话 程序设计实践 重构+改善既有代码设计 代码大全 编码整洁之道 修改代码的艺术 微服务设计 算法 算法：C语言实现 : (第1～4部分) 垃圾回收的算法与实现 工具 Vim实用技巧 UML精粹 Docker 第一本Docker书 Docker生产环境实践指南 Linux POSIX 多线程程序设计 UNIX 环境高级编程 Linux 系统编程 深入理解 LINUX 络技术内幕 网络 Linux多线程服务端编程 : 使用muduo C++网络库 UNIX 络编程 卷1：套接字联 API UNIX 络编程 卷2：进程间通信 TCP/IP详解 卷1：协议 TCP/IP详解 卷2：实现 TCP/IP详解 卷3：TCP事务协议、HTTP、NNTP和UNIX域协议 游戏开发 体验引擎 : 游戏设计全景探秘 大型多人在线游戏开发(2006) Massively Multiplayer Game Development 2 (2015) 理财 富爸爸，穷爸爸 小狗钱钱 解读基金+我的投资观与实践 心理学 拖延心理学 : 向与生俱来的行为顽症宣战 自控力 : 斯坦福大学最受欢迎心理学课程 效率 如何阅读一本书 时间管理 : 如何充分利用你的24小时 番茄工作法图解 : 简单易行的时间管理方法 单核工作法图解 : 事多到事少,拖延变高效 历史 人类简史 : 从动物到上帝"},{"title":"","date":"2017-02-17T07:41:01.000Z","updated":"2017-02-17T07:45:21.172Z","comments":false,"path":"about/index.html","permalink":"http://veinin.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-17T07:34:12.000Z","updated":"2017-02-17T07:37:36.227Z","comments":false,"path":"categories/index.html","permalink":"http://veinin.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-17T07:38:13.000Z","updated":"2017-02-17T07:39:32.187Z","comments":false,"path":"tags/index.html","permalink":"http://veinin.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"开发笔记：游戏中属性定义、策划公式处理方案","slug":"dev-notes-designer-formula-processing-solution-in-game","date":"2018-03-24T13:28:00.000Z","updated":"2018-03-24T13:50:02.180Z","comments":true,"path":"2018/03/24/dev-notes-designer-formula-processing-solution-in-game/","link":"","permalink":"http://veinin.com/2018/03/24/dev-notes-designer-formula-processing-solution-in-game/","excerpt":"在游戏设计中，策划喜欢通过表格来制定自己的数值方案，通常一个游戏制作会有几十上百张不同功能的表格，这些表格通常采用Excel制定。大部分时候，策划更想要的是自己来操作所有数值，而不需要程序为其各种需求去正对性的通过代码来实现。 这样做有几个好处： 1.策划可以独立拓展自己的业务，而不依赖于程序。 2.程序可以更加专心于自己的逻辑功能，而不用去特意维护策划的数值变动需求。 3.工作内容分离，减少沟通成本，更加提升工作效率，让各部门更加专注于自己所处的领域。 在游戏日常开发中，有两个典型的应用场景，一个是角色的属性，一个是计算这些属性的公式，最后还需要通过这些属性在战斗中通过公式生成伤害数值。如果涉及复杂的战斗系统，通常一个角色的战斗属性可能会有上百种，而计算这些属性的公式，也可能成百上千。这里就会产生几个问题：属性、公式由程序去定义，还是策划自己去主导？属性、公式通过某种方式定义出来了，程序如何去使用？","text":"在游戏设计中，策划喜欢通过表格来制定自己的数值方案，通常一个游戏制作会有几十上百张不同功能的表格，这些表格通常采用Excel制定。大部分时候，策划更想要的是自己来操作所有数值，而不需要程序为其各种需求去正对性的通过代码来实现。 这样做有几个好处： 1.策划可以独立拓展自己的业务，而不依赖于程序。 2.程序可以更加专心于自己的逻辑功能，而不用去特意维护策划的数值变动需求。 3.工作内容分离，减少沟通成本，更加提升工作效率，让各部门更加专注于自己所处的领域。 在游戏日常开发中，有两个典型的应用场景，一个是角色的属性，一个是计算这些属性的公式，最后还需要通过这些属性在战斗中通过公式生成伤害数值。如果涉及复杂的战斗系统，通常一个角色的战斗属性可能会有上百种，而计算这些属性的公式，也可能成百上千。这里就会产生几个问题：属性、公式由程序去定义，还是策划自己去主导？属性、公式通过某种方式定义出来了，程序如何去使用？ 最近和策划一起讨论了下，最终给出了解决方案，属性、公式都有策划去配置，但公式需要简化，于是我们先给出了两张表格。 属性表一个属性字典，对于程序来说，特别设计属性服务器、客户端传输的过程，我们可以通过一个唯一ID、类型进行，只要客户端、服务器都拥有这么一张属性字典，那么将很容易对属性进行传输： 属性ID 名称 类型 初值 描述 成长公式 1 strength int 5 力量 2 pdCorrect float 1.2 物理伤害修正系数 3 physicalDamage int 20 物理基础伤害 公式1 4 physicalCritical int 15 物理暴击率 5 physicalCriticalDec int 10 物理暴击抵抗率 公式表一张公式表，由策划去配置，但程序得把策划的公式翻译成程序能读懂的代码。 公式ID 公式名称 公式内容 1 physicalDamage 40 (level pdCorrect + 1) * rand(1, 1.5) 1 physicalCriticalRate max(min(a.physicalCritical / 10 - t.physicalCriticalDec), 20), 0) 函数支持另外，对于策划来说，要通过公式来操作属性数据，特别是战斗中产生的伤害数据，就要求我们有一些简单函数支持，比如在Lua中，一些数学公式：math.min、math.ceil、math.random 等等。而对策划来说，大部分其实是不懂编程的，因此我们需要更加简化函数名称的设计。最终，我们得出需要以下函数的支持： min(…) ，返回参数中的最小值，如 min(1, 5, 2) ，会得到数值 1 max(…)，返回参数中的最大值，如 max(4, 10, 3)，会得到数值 10 rand(m, n)，当不带参数时，返回 [0,1] 区间内的浮点伪随机数，当以两个整数 m 与 n 调用时，返回一个 [m, n] 区间内的一致分布的伪随机数。如 rand(1, 10)，产生1-10区间内的一个随机数。 ceil(x)，返回不等于 x 的最小整数。如 ceil(1.55)，会得到数值 2 float(x)，返回不大于 x 的最大整数值，如 flooat(1.55)，会得到数值 1 实现有了上面这些，程序就可以编写工具，把策划配置的公式，导出成程序能够识别的公式函数了，比如：怪物的随等级增长物理伤害公式：40 (等级 物理伤害修正系数 + 1) * rand(1, 1.5)怪物的物理暴击计算：max(min(怪物暴击率 / 10 - 目标暴击抵抗率 / 10, 25), 0) 那么其最终需要转换成代码公式函数： 12345678910111213141516171819202122local formula = &#123;&#125;-- 怪物物理伤害公式function formula.physicalDamage(a) return 40 * (a.level * a.pdCorrect + 1) * math.random(1, 1.5)end-- 怪物暴击几率公式function formula.physicalCriticalRate(a, t) return math.max(math.min(a.physicalCritical / 10 - t.physicalCriticalDec), 20), 0)endlocal formulas = &#123; [1] = formula.physicalDamage, [2] = formula.physicalCriticalRate,&#125;function formula.exec(id, ...) return formula[id](...)endreturn formula 有了上面的表格，外加生成的公式，我们很容易计算出一个怪物的基础属性或战斗中产生的伤害数值：12345678910111213141516171819202122232425local formula = require \"formula\"local monster = &#123; level = 3, strength = 5, pdCorrect = 1.3, physicalDamage = 15, physicalCritical = 35, physicalCriticalDec = 10,&#125;local target = &#123; level = 2, strength = 5, pdCorrect = 1.3, physicalDamage = 20, physicalCritical = 35, physicalCriticalDec = 10,&#125;-- 得出怪物物理伤害local damage = formula.exec(1, monster)-- 得出怪物物理暴击率local criticalRate = formula.exec(2, monster, target) 最终，通过这套方案的实现，程序不用再去代码里维护各种各样的公式，策划也不在需要程序来帮忙维护公式，如果需求变动，只需要更改下表格，然后重新生成一份新公式就行；如果有新属性增加，只需要在表格中创建以个新的属性值，然后不管是角色，还是战斗中都能应用到新增加的变化。","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"http://veinin.com/categories/开发笔记/"}],"tags":[{"name":"游戏角色属性设计","slug":"游戏角色属性设计","permalink":"http://veinin.com/tags/游戏角色属性设计/"},{"name":"游戏策划公式设计","slug":"游戏策划公式设计","permalink":"http://veinin.com/tags/游戏策划公式设计/"}]},{"title":"开发笔记：MMORPG场景同步AOI解决方案","slug":"dev-notes-mmorpg-aoi-algorithm","date":"2018-03-23T11:20:00.000Z","updated":"2018-03-24T13:33:33.049Z","comments":true,"path":"2018/03/23/dev-notes-mmorpg-aoi-algorithm/","link":"","permalink":"http://veinin.com/2018/03/23/dev-notes-mmorpg-aoi-algorithm/","excerpt":"MMO 游戏，需要解决的最重要的问题之一，就是如何把游戏世界中各种状态的改变通知给需要知道这条信息的玩家。为此，需要为每个玩家设定一个AOI（Area Of Interest），当一个对象状态发生改变时，需要将信息广播出去，那些AOI覆盖到这条消息的玩家都会收到这条广播消息。 AOI 主要作用有两：第一，服务器上的玩家或 NPC 状态发生改变时，将消息广播到附近的玩家。第二，当玩家接近NPC时，进入NPC警戒区域，AOI 模块将消息发送给NPC，NPC再做出相应的AI反应。 目前游戏中 AOI 实现主要有3种：第一种，最容易也是最笨的一种，玩家定期同步自己状态给服务器，服务器定期比较所有对象间的关系，发现可以触发 AOI 事件就发送消息。写法简单，不容易出错，但如果处理不好，效率往往是最低的。","text":"MMO 游戏，需要解决的最重要的问题之一，就是如何把游戏世界中各种状态的改变通知给需要知道这条信息的玩家。为此，需要为每个玩家设定一个AOI（Area Of Interest），当一个对象状态发生改变时，需要将信息广播出去，那些AOI覆盖到这条消息的玩家都会收到这条广播消息。 AOI 主要作用有两：第一，服务器上的玩家或 NPC 状态发生改变时，将消息广播到附近的玩家。第二，当玩家接近NPC时，进入NPC警戒区域，AOI 模块将消息发送给NPC，NPC再做出相应的AI反应。 目前游戏中 AOI 实现主要有3种：第一种，最容易也是最笨的一种，玩家定期同步自己状态给服务器，服务器定期比较所有对象间的关系，发现可以触发 AOI 事件就发送消息。写法简单，不容易出错，但如果处理不好，效率往往是最低的。 空间切割网格算法把整个场景用等分大的格子划分成一个个小区域，对象进入、退出、移动时都需要更新相应的格子对象列表。这种算法插入、删除对象都非常快，时间复杂度为O（1）。缺点是当对象在格子直接移动时，需要消耗大量计算时间。目前《幻想西游》采用的是这种算法。 场景划分场景大小：200 200格子大小：50 50场景中需要划分等分大小的格子数： 200 / 50 200 50 = 16 个 效果如下图所示： 世界坐标与格子坐标每个格子有对于的格子坐标，每个世界坐标可以轻易的转换成格子坐标。世界坐标 (x, y) 转换成格子坐标公式为：(math.floor(x/gridWeidth), math.floor(y/gridHeight))如世界坐标为 (80, 50)，转换后对应格子坐标为 (2, 1)。 划分九宫格每个格子都需要维护该格子内的对象信息，同时也需要维护关心该格子的观察者信息。当对象处于场景某个格子时，该对象会有 9 个自己所关心的格子，对象可以观察并收到自己关心区域的 AOI 事件。当然，对象所处的格子也会被其他格子的对象所关心。也就是说一个格子里面的对象可以作为观察者，观察周围格子内对象；同时也是被观察者，被其他格子内的对象所观察。如图所示，当对象所进入格子 (2, 2) 时（红色区域），那么其关心的周围 9 个格子（浅蓝色区域）中任何一个发生 AOI 事件时，它都会收到相应的 AOI 事件消息。 对象进入场景通知对象所处周围9个格子的其他对象 进入 AOI 事件。 对象离开场景与进入相反，通知对象所处九宫格的其他对象 离开 AOI 事件。 对象移动如果对象格子变更时，如图所示，对象纵向移动由(2, 2) 移动到 (3, 2)，45度角移动由 (2, 2) 移动到 (3, 3）：会产生3种格子： 对象离开视野的格子（灰色格子），通知对象离开 AOI 事件。 对象进入视野的格子（橙色格子），通知对象进入 AOI 事件。 取所有需要操作的格子的交集（浅蓝色格子），通知对象移动 AOI 事件。 十字链表算法场景维护着两个双向链表（如果3D空间，则增加第3条），分别对应着 X 轴 和 Y 轴。每个链表对象的坐标按从小到大排列，也就是 X 坐标值越小，排在越前面，Y轴同理。此算法对象短距离移动时，很节省计算量，但涉及长距离移动时，计算量会非常大。 对象进入场景遍历 X 轴 和 Y 轴两个链表，找出新增对象在两个轴中所处的位置，将新对象加入到指定位置，并根据新对象的通知范围（可动态设定）获得需要通知对象集合，发送 进入 AOI 事件。 对象离开场景对象进入场景后，在 X 轴 和 Y 轴各保存了两个节点位置，可以通过这个位置，获取指定范围的的对象集合，发送 离开 AOI 事件。 ###对象移动与格字算法类似，对象移动后也会会产生3种对象集合： 更新位置前的集合，通知 离开 AOI 事件。 更新位置后的集合，通知 进入 AOI 事件。 取上面两个集合的交集，通知对象 移动 AOI 事件。 处理上面产生事件顺序与格字算法相同。 分层 AOI有了AOI算法，并不意味着能有满意的效果，假设场景里面放入10000人，那么按分布情况来说，即使有AOI算法，也会很糟糕，你会看到满屏幕的人，密密麻麻，卡的要死。这种情况下，玩家体验会很糟糕，所以可能需要进一步优化。目前市面上见得比较多的解决方案有几种，一种是对单个场景分线，复制多个相同的场景副本，玩家随机进入某个场景的副本，以此来达到分流的目的。另外一种方案，是从梦幻西游手游服务器AOI设计方案中看到的，设计一个分层AOI概念，也就是单个场景创建多个AOI对象。把玩家分通过某个规则，分在不同的层次。当人数增多时，可以动态进行分层，人数少的时候可以把层数合并回来，然后就是让玩家在人少的时候也能看到几个人，人多的时候还是看到几个人。这种优化放过来后，这是同一台服务器，效果大概是这样的，你在同一层里看到的都是你关心的人。这个感受就很好了。","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"http://veinin.com/categories/开发笔记/"}],"tags":[{"name":"MMORPG","slug":"MMORPG","permalink":"http://veinin.com/tags/MMORPG/"},{"name":"AOI","slug":"AOI","permalink":"http://veinin.com/tags/AOI/"}]},{"title":"Python 快速上手 - 字符串","slug":"python-practice-strings","date":"2018-03-18T08:46:00.000Z","updated":"2018-03-24T15:00:56.181Z","comments":true,"path":"2018/03/18/python-practice-strings/","link":"","permalink":"http://veinin.com/2018/03/18/python-practice-strings/","excerpt":"文本是程序需要处理的最常见的数据形式。涉及字符串的操作不仅仅是使用+操作符连接两个字符串，你还可以从字符串中提取部分字符串， 添加或删除空白字符， 将字母转换成小写或大写， 检查字符串的格式是否正确。你甚至可以编写 Python 代码访问剪贴板， 复制或粘贴文本。 处理字符串双引号在Python中构建一个字符串相当简单：以单引号开始和结束。如果字符串里面也使用单引号的话，则需要使用双引号开始和结束来表示一个字符串。 1&gt;&gt;&gt; s = \"I found hi's very selfish.\"","text":"文本是程序需要处理的最常见的数据形式。涉及字符串的操作不仅仅是使用+操作符连接两个字符串，你还可以从字符串中提取部分字符串， 添加或删除空白字符， 将字母转换成小写或大写， 检查字符串的格式是否正确。你甚至可以编写 Python 代码访问剪贴板， 复制或粘贴文本。 处理字符串双引号在Python中构建一个字符串相当简单：以单引号开始和结束。如果字符串里面也使用单引号的话，则需要使用双引号开始和结束来表示一个字符串。 1&gt;&gt;&gt; s = \"I found hi's very selfish.\" 转义字符“转义字符” 让你输入一些字符，它们用其他方式是不可能放在字符串里的。转义字符包含一个倒斜杠（\\）， 紧跟着是想要添加到字符串中的字符。常用的转移字符包括:\\’(单引号)、 \\”(双引号)、 \\t(制表符)、 \\(倒斜杠) 123&gt;&gt;&gt; s = 'I found hi\\'s very selfish.'&gt;&gt;&gt; s\"I found hi's very selfish.\" 原始字符串在字符串开始的引号之前加上 r， 那么它就成为了一个原始字符串。“原始字符串” 会完全忽略所有的转义字符， 打印出字符串中所有的倒斜杠。 1print(r'That is Carol\\'s cat.') 用三重引号的多行字符串虽然可以用\\n转义字符将换行放入一个字符串，但使用多行字符串通常更容易。在 Python 中，多行字符串的起止是 3 个单引号或 3 个双引号。“三重引号” 之间的所有引号、 制表符或换行， 都被认为是字符串的一部分。 Python 的代码块缩进规则不适用于多行字符串。 123456print('''Dear Alice,Eve's cat has been arrested for catnapping.Sincerely,Bob''') 多行注释虽然井号字符（#） 表示这一行是注释， 但多行字符串常常用作多行注释。 12345678910\"\"\"This is a test Python program.Written by Al Sweigart al@inventwithpython.comThis program was designed for Python 3, not Python 2.\"\"\"def spam(): \"\"\"This is a multiline comment to help explain what the spam() function does.\"\"\" print('Hello!') 字符串下标和切片字符串像列表一样，可以使用下标和切片。字符串切片并不能修改原来的字符串。但可以从一个变量中获取切片，记录在另一个变量中。 12345678910111213&gt;&gt;&gt; text = 'Hello world!'&gt;&gt;&gt; text[1]'e'&gt;&gt;&gt; text[-2]'d'&gt;&gt;&gt; text[0:4]'Hell'&gt;&gt;&gt; text[:5]'Hello'&gt;&gt;&gt; text[4:]'o world!'&gt;&gt;&gt; text2 = text[0:5]'Hello' 字符串使用 in 和 not in 操作符像列表一样， in 和 not in 操作符也可以用于字符串。用 in 或 not in 连接两个字符串得到的表达式， 将求值为布尔值 True 或 False。 123456&gt;&gt;&gt; 'Veinin' in 'Veinin Guo'True&gt;&gt;&gt; 'Veinin' not in 'Veinin Guo'False&gt;&gt;&gt; '' in 'Veinin Guo'True 字符串操作方法某些字符串需要转换、分析然后产生新的字符串，字符串内置了一些常用的方法。注意：Python 中所有字符串操作方法并不会改变字符串本身的属性，而是返回一个操作后的新字符串。 upper()、 lower()、 isupper()和 islower()upper()和 lower() 方法会返回一个新字符串，所有字母都被相应地转换为大写或小写。 12345&gt;&gt;&gt; text = &apos;Hello World!&apos;&gt;&gt;&gt; print(text.upper())HELLO WORLD!&gt;&gt;&gt; print(text.lower())hello world! isupper()和islower()方法用来判断字符串是否至少有要给字母，并且所有字母都是大写或小写，相应地如果成立就会返回布尔值 True，否则返回 False。 12345678&gt;&gt;&gt; 'Hello world'.isupper()False&gt;&gt;&gt; 'HELLO WORLD'.isupper()True&gt;&gt;&gt; 'Hello'.islower()False&gt;&gt;&gt; 'hello'.islower()True isX 方法为了能判断字符串的特点，提供了一些常用的以 is 开头的方法。 isalpha() 如果字符串非空，且只包含字母，则返回 True isalnum() 如果字符串非空，且只包含字母和数字，则返回 True isdecimal() 如果字符串非空，且只包含数字，则返回 True isspace() 如果字符串非空，且只包含空格、换行和制表符，则返回 True istitle() 如果字符串包含以大写字母开头且后面字母都是小写字母的单词，则返回 True 1234567891011121314151617181920&gt;&gt;&gt; 'abc'.isalpha()True&gt;&gt;&gt; 'abc123'.isalpha()False&gt;&gt;&gt;&gt;&gt;&gt; 'abc123'.isalnum()True&gt;&gt;&gt;&gt;&gt;&gt; 'abc123'.isdecimal()False&gt;&gt;&gt; '10088'.isdecimal()True&gt;&gt;&gt;&gt;&gt;&gt; ' '.isspace()True&gt;&gt;&gt;&gt;&gt;&gt; 'I Am From China'.istitle()True&gt;&gt;&gt; 'I am from China'.istitle()False startswith() 和 endswith()startswith() 和 endswith() 用来判断某个字符串以某个字符串开始或结束，成立则返回 True。 123456&gt;&gt;&gt; 'Hello World'.startswith('Hello')True&gt;&gt;&gt; 'Hello World'.startswith('nihao')False&gt;&gt;&gt; 'Hello World'.endswith('World')True join() 和 split()join() 方法用来将一个字符串列表中的每个字符串连接成一个新的字符串。而 split() 方法与 join() 方法刚好相反，它会将一个字符串按制定分隔符进行分割，返回一个分割后的列表。 12345678&gt;&gt;&gt; ', '.join(['java', 'python', 'golang'])'java, python, golang'&gt;&gt;&gt;&gt;&gt;&gt; 'I am from China'.split()['I', 'am', 'from', 'China']&gt;&gt;&gt;&gt;&gt;&gt; 'ABCDEFGEFGEFG'.split('E')['ABCD', 'FG', 'FG', 'FG'] 使用 rjust()、 ljust() 和 center() 方法对齐文本rjust() 和 ljust() 方法使用向左或向右插入空格的方式返回一个字符串的填充版本。而 center() 方法则是让字符串文本居中。上面三个方法都接受两个参数，第一个参数指定填充数量。第二个参数，指定填充的字符，默认是填充空格。 12345678&gt;&gt;&gt; 'Veinin'.ljust(20, '-')'Veinin--------------'&gt;&gt;&gt; 'Veinin'.rjust(20, '-')'--------------Veinin'&gt;&gt;&gt; 'Veinin'.center(20)' Veinin '&gt;&gt;&gt; 'Veinin'.center(20, '#')'#######Veinin#######' 使用 strip()、 rstrip() 和 lstrip() 方法删除空白字符strip()、 rstrip() 和 lstrip() 三个方法分别对一个字符串的两边、右边和左边的空白字符进行删除操作。 1234567&gt;&gt;&gt; name = ' Veinin Guo '&gt;&gt;&gt; name.strip()'Veinin Guo'&gt;&gt;&gt; name.rstrip()' Veinin Guo'&gt;&gt;&gt; name.lstrip()'Veinin Guo '","categories":[{"name":"Python","slug":"Python","permalink":"http://veinin.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://veinin.com/tags/Python/"},{"name":"编程","slug":"编程","permalink":"http://veinin.com/tags/编程/"}]},{"title":"Python 快速上手 - 字典","slug":"python-practice-dictionaries","date":"2018-03-18T08:10:00.000Z","updated":"2018-03-24T14:09:51.148Z","comments":true,"path":"2018/03/18/python-practice-dictionaries/","link":"","permalink":"http://veinin.com/2018/03/18/python-practice-dictionaries/","excerpt":"字典数据类型提供了一种灵活的访问和组织数据的方式。像列表一样，“字典”是许多值的集合。但不像列表的下标， 字典的索引可以使用许多不同数据类型， 不只是整数。 字典的索引被称为“键”，键及其关联的值称为“键-值”对。字典仍然可以用整数值作为键， 就像列表使用整数值作为下标一样， 但它们不必从 0 开始， 可以是任何数字。 1234567891011&gt;&gt;&gt; myCat = &#123;'size': 'fat', 'color': 'gray', 'disposition': 'loud'&#125;&gt;&gt;&gt; myCat['size']'fat'&gt;&gt;&gt; 'My cat has ' + myCat['color'] + ' fur.''My cat has gray fur.'&gt;&gt;&gt;&gt;&gt;&gt; ticket = &#123;12306: 'websites', 123456: 'phone number'&#125;&gt;&gt;&gt; ticket[12306]'websites'&gt;&gt;&gt; ticket[123456]'phone number'","text":"字典数据类型提供了一种灵活的访问和组织数据的方式。像列表一样，“字典”是许多值的集合。但不像列表的下标， 字典的索引可以使用许多不同数据类型， 不只是整数。 字典的索引被称为“键”，键及其关联的值称为“键-值”对。字典仍然可以用整数值作为键， 就像列表使用整数值作为下标一样， 但它们不必从 0 开始， 可以是任何数字。 1234567891011&gt;&gt;&gt; myCat = &#123;'size': 'fat', 'color': 'gray', 'disposition': 'loud'&#125;&gt;&gt;&gt; myCat['size']'fat'&gt;&gt;&gt; 'My cat has ' + myCat['color'] + ' fur.''My cat has gray fur.'&gt;&gt;&gt;&gt;&gt;&gt; ticket = &#123;12306: 'websites', 123456: 'phone number'&#125;&gt;&gt;&gt; ticket[12306]'websites'&gt;&gt;&gt; ticket[123456]'phone number' 字典与列表确定两个列表是否相同时， 表项的顺序很重要。字典不像列表，字典中的表项是不排序的，键-值对输入的顺序并不重要。因为字典是不排序的， 所以不能像列表那样切片。尽管字典是不排序的，但可以用任意值作为键，这一点让你能够用强大的方式来组织数据。尝试访问字典中不存在的键， 将导致 KeyError 出错信息。 1234567891011121314&gt;&gt;&gt; a = ['cats', 'dogs']&gt;&gt;&gt; b = ['dogs', 'cats']&gt;&gt;&gt; a == bFalse&gt;&gt;&gt;&gt;&gt;&gt; c = &#123;'firstName': 'Veinin', 'age': 25&#125;&gt;&gt;&gt; d = &#123;'age': 25, 'firstName': 'Veinin'&#125;&gt;&gt;&gt; c == dTrue&gt;&gt;&gt;&gt;&gt;&gt; d['lastName']Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;KeyError: 'lastName' keys()、 values()和 items()方法有 3 个字典方法，它们将返回类似列表的值，分别对应于字典的键、值和键-值对：keys()、 values()和 items()。这些方法返回的值不是真正的列表，它们不能被修改，没有append()方法。但这些数据类型（分别是 dict_keys、 dict_values 和 dict_items）可以用于for 循环。 123456789101112131415161718192021&gt;&gt;&gt; person = &#123;'firstName': 'Veinin', 'lastName': 'Guo', 'age': 18&#125;&gt;&gt;&gt; for k in person.keys(): print(k)firstNamelastNameage&gt;&gt;&gt;&gt;&gt;&gt; for v in person.values(): print(v)VeininGuo18&gt;&gt;&gt;&gt;&gt;&gt; for k, v in person.items(): print(k, v)firstName VeininlastName Guoage 18 检查字典中是否存在键或值in 和 not in 操作符可以检查值是否存在于列表中。也可以利用这些操作符，检查某个键或值是否存在于字典中。 12345&gt;&gt;&gt; person = &#123;'firstName': 'Veinin', 'lastName': 'Guo', 'age': 18&#125;&gt;&gt;&gt; 'name' in personFalse&gt;&gt;&gt; 'sex' not in personTrue get()方法在访问一个键的值之前，检查该键是否存在于字典中，这很麻烦。好在，字典有一个 get()方法，它有两个参数：要取得其值的键，以及如果该键不存在时，返回的备用值。 123456&gt;&gt;&gt; person = &#123;'firstName': 'Veinin', 'lastName': 'Guo', 'age': 18&#125;&gt;&gt;&gt; \"I'm \" + str(person.get('age', 0)) + '.'\"I'm 18.\"&gt;&gt;&gt;&gt;&gt;&gt; 'His height is ' + str(person.get('height', 188)) + 'cm.''His height is 188cm.' setdefault()方法你常常需要为字典中某个键设置一个默认值，当该键没有任何值时使用它。setdefault()方法的第一个参数，是要检查的键。第二个参数，是如果该键不存在时要设置的值。 12345&gt;&gt;&gt; person = &#123;'firstName': 'Veinin', 'lastName': 'Guo', 'age': 18&#125;&gt;&gt;&gt; person.setdefault('height', 180)180&gt;&gt;&gt; print('His height is ' + str(person.get('height', 188)) + 'cm.')His height is 180cm.","categories":[{"name":"Python","slug":"Python","permalink":"http://veinin.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://veinin.com/tags/Python/"},{"name":"编程","slug":"编程","permalink":"http://veinin.com/tags/编程/"}]},{"title":"Python 快速上手 - 列表","slug":"python-practice-list","date":"2018-03-18T07:50:00.000Z","updated":"2018-03-24T14:10:00.527Z","comments":true,"path":"2018/03/18/python-practice-list/","link":"","permalink":"http://veinin.com/2018/03/18/python-practice-list/","excerpt":"列表和元组可以包含多个值，这样编写程序来处理大量数据就变得更容易。而且，由于列表本身又可以包含其他列表，所以可以用它们将数据安排成层次结构。 列表数据类型“列表” 是一个值， 它包含多个字构成的序列。列表用左方括号开始， 右方括号结束，即[]。12colors = ['red', 'green', 'blue']nums = [1, 2, 3]","text":"列表和元组可以包含多个值，这样编写程序来处理大量数据就变得更容易。而且，由于列表本身又可以包含其他列表，所以可以用它们将数据安排成层次结构。 列表数据类型“列表” 是一个值， 它包含多个字构成的序列。列表用左方括号开始， 右方括号结束，即[]。12colors = ['red', 'green', 'blue']nums = [1, 2, 3] 用下标取得列表中的单个值列表后面方括号内的整数被称为“下标”。列表中第一个值的下标是 0，第二个值的下标是 1，第三个值的下标是 2，依此类推。如果使用的下标超出了列表中值的个数， Python 将给出 IndexError 出错信息。列表也可以包含其他列表值。这些列表的列表中的值， 可以通过多重下标来访问。123456789101112131415&gt;&gt;&gt; colors = ['red', 'green', 'blue', ['red and blue', 'red and green']]&gt;&gt;&gt; colors[0]red&gt;&gt;&gt; colors[1]green&gt;&gt;&gt; colors[2]blue&gt;&gt;&gt; colors[1] + colors[2]greenblue&gt;&gt;&gt;&gt;&gt;&gt; pcolors[4][1]red and green&gt;&gt;&gt;&gt;&gt;&gt; colors[5]IndexError: list index out of range 负数下标虽然下标从 0 开始并向上增长，但也可以用负整数作为下标。整数值−1 指的是列表中的最后一个下标， −2 指的是列表中倒数第二个下标，以此类推。1234567&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; colors[-1]blue&gt;&gt;&gt; colors[-3]red&gt;&gt;&gt; colors[-1] + colors[-3]bluered 用 len()取得列表的长度len()函数将返回传递给它的列表中值的个数， 就像它能计算字符串中字符的个数一样。123&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; len(colors)3 用下标改变列表中的值可以使用列表的下标来改变下标处的值。例如， spam[1] = &#39;aardvark&#39; 意味着“将列表 spam 下标 1 处的值赋值为字符串’aardvark’。12345678&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; colors[1] = 'red and blue'&gt;&gt;&gt; colors[1]'red and blue'&gt;&gt;&gt;&gt;&gt;&gt; colors[-1] = 'blue and red'&gt;&gt;&gt; print(colors[-1])blue and red 列表连接和列表复制操作符可以连接两个列表， 得到一个新列表， 就像它将两个字符串合并成一个新字符串一样。 *操作符可以用于一个列表和一个整数，实现列表的复制。 1234567&gt;&gt;&gt; a = [1, 2, 3] + ['a', 'b', 'c']&gt;&gt;&gt; a[1, 2, 3, 'a', 'b', 'c']&gt;&gt;&gt;&gt;&gt;&gt; a = a * 2&gt;&gt;&gt; a[1, 2, 3, 'a', 'b', 'c', 1, 2, 3, 'a', 'b', 'c'] 用 del 语句从列表中删除值del 语句将删除列表中下标处的值， 表中被删除值后面的所有值， 都将向前移动一个下标。12345678&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; del colors[2]&gt;&gt;&gt; colors['red', 'green']&gt;&gt;&gt;&gt;&gt;&gt; del colors[1]&gt;&gt;&gt; colors['red'] 列表用于循环在 for 循环中可以使用 range(len(someList))， 来迭代列表的每一个下标。1234567&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; for i in range(len(colors)): print('Index : ' + str(i) + \" in color is: \" + colors[i])Index : 0 in color is: redIndex : 1 in color is: greenIndex : 2 in color is: blue in 和 not in 操作符利用 in 和 not in 操作符， 可以确定一个值否在列表中。 像其他操作符一样， in和 not in 用在表达式中， 连接两个值： 一个要在列表中查找的值， 以及待查找的列表。这些表达式将求值为布尔值。12345&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; 'red' in colorsTrue&gt;&gt;&gt; 'black' not in colorsTrue 多重赋值技巧多重赋值技巧是一种快捷方式， 让你在一行代码中， 用列表中的值为多个变量赋值。所以不必像这样：1234colors = ['red', 'green', 'blue']red = colors[0]green = colors[1]blue = colors[2] 可有使用如下技巧：12colors = ['red', 'green', 'blue']red, green, blue = colors 最后要注意变量的数目和列表的长度必须严格相等， 否则 Python 将给出 ValueError。 增强赋值针对+、 -、 *、 /和%操作符， 都有增强的赋值操作符。123456789a = 10a += 1a -= 2a *= 2a /= 2a %= 5print(a) # 9.0 方法方法和函数是一回事，只是它是调用在一个值上。方法部分跟在这个值后面，以一个句点分隔。每种数据类型都有它自己的一组方法。例如， 列表数据类型有一些有用的方法，用来查找、 添加、 删除或操作列表中的值。 用 index()方法在列表中查找值列表值有一个 index()方法， 可以传入一个值， 如果该值存在于列表中， 就返回它的下标。如果该值不在列表中， Python 就报 ValueError。1234567&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; colors.index('red')0&gt;&gt;&gt; colors.index('black')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ValueError: 'black' is not in list 用 append()和 insert()方法在列表中添加值使用append()方法调用， 可以将参数添加到列表末尾。insert()方法可以在列表任意下标处插入一个值。 insert()方法的第一个参数是新值的下标， 第二个参数是要插入的新值。1234567&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; colors.append('black')&gt;&gt;&gt; colors['red', 'green', 'blue', 'black']&gt;&gt;&gt; colors.insert(1, 'orange')&gt;&gt;&gt; colors['red', 'orange', 'green', 'blue', 'black'] 用 remove()方法从列表中删除值给 remove()方法传入一个值，它将从被调用的列表中删除。12345&gt;&gt;&gt; colors = ['red', 'orange', 'green', 'blue', 'black']&gt;&gt;&gt; colors.remove('black')&gt;&gt;&gt; colors.remove('orange')&gt;&gt;&gt; colors['red', 'green', 'blue'] 用 sort()方法将列表中的值排序数值的列表或字符串的列表， 能用 sort()方法排序。123456789&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; colors.sort()&gt;&gt;&gt; colors['blue', 'green', 'red']&gt;&gt;&gt;&gt;&gt;&gt; a = [5, 3, 2, 1]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1, 2, 3, 5] 也可以指定 reverse 关键字参数为 True， 让 sort()按逆序排序。123&gt;&gt;&gt; a.sort(reverse=True)&gt;&gt;&gt; a[5, 3, 2, 1] 排序注意事项： 首先， sort()方法当场对列表排序。不要写出 colors = colors.sort()这样的代码。 其次， 不能对既有数字又有字符串值的列表排序，因为 Python 不知道如何比较它们。 第三， sort()方法对字符串排序时， 使用“ASCII 字符顺序”， 而不是实际的字典顺序。这意味着大写字母排在小写字母之前。因此在排序时， 小写的 a 在大写的 Z 之后。 类似列表的类型：字符串和元组列表并不是唯一表示序列值的数据类型。例如， 字符串和列表实际上很相似，只要你认为字符串是单个文本字符的列表。对列表的许多操作， 也可以作用于字符串：按下标取值、 切片、 用于 for 循环、 用于 len()， 以及用于 in 和 not in 操作符。需要注意的是：字符串是“不可变的”， 它不能被更改。尝试对字符串中的一个字符重新赋值， 将导致 TypeError 错误。12345678910111213&gt;&gt;&gt; name = 'Veinin' &gt;&gt;&gt; name[0] 'V' &gt;&gt;&gt; name[-1] 'n' &gt;&gt;&gt; 'in' in name True &gt;&gt;&gt; 'p' not in name True&gt;&gt;&gt; name[0] = 'A'Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'str' object does not support item assignment 字符串是“不可变的”， 它不能被更改。“改变” 一个字符串的正确方式， 是使用切片和连接。构造一个“新的” 字符串， 从老的字符串那里复制一些部分。1234567&gt;&gt;&gt; name = 'Veinin'&gt;&gt;&gt; newName = 'Jali' + name[4:6]&gt;&gt;&gt; name'Veinin'&gt;&gt;&gt; newName'Jaliin'&gt;&gt;&gt; 元组数据类型除了两个方面，“元组” 数据类型几乎与列表数据类型一样。首先， 元组输入时用圆括号()， 而不是用方括号[]。其次，元组像字符串一样， 是不可变的。 元组不能让它们的值被修改、 添加或删除。1234567891011&gt;&gt;&gt; colors = ('red', 'green', 'blue')&gt;&gt;&gt; colors[0]'red'&gt;&gt;&gt; colors[-2]'green'&gt;&gt;&gt; colors[1:3]('green', 'blue')&gt;&gt;&gt; colors[2] = 'black'Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment 如果需要元组值的一个可变版本， 使用函数函数 list() 将元组转换成列表就很方便。 相反也可以使用 tuple() 函数将列表转换成元组。 引用对于字符串和整数值赋值操作，将执行拷贝操作，赋值后二者是不同的变量，保存了不同的值。但列表不是这样的。 当你将列表赋给一个变量时，实际上是将列表的“引用”赋给了该变量。引用是一个值，指向某些数据。列表引用是指向一个列表的值。12345678910111213141516&gt;&gt;&gt; a = 40&gt;&gt;&gt; b = a&gt;&gt;&gt; a = 50&gt;&gt;&gt; a50&gt;&gt;&gt; b40&gt;&gt;&gt;&gt;&gt;&gt; foo = [1, 2, 3]&gt;&gt;&gt; bar = foo&gt;&gt;&gt; foo[0] = 120&gt;&gt;&gt; foo[120, 2, 3]&gt;&gt;&gt; bar[120, 2, 3]&gt;&gt;&gt; 传递引用当函数被调用时， 参数的值被复制给变元。对于列表以及字典， 这意味着变元得到的是引用的拷贝。1234567&gt;&gt;&gt; def something(arr):... arr.append(4)...&gt;&gt;&gt; arr = [1, 2, 3]&gt;&gt;&gt; something(arr)&gt;&gt;&gt; arr[1, 2, 3, 4] copy()和 deepcopy() 函数在处理列表和字典时，尽管传递引用常常是最方便的方法， 但如果函数修改了传入的列表或字典， 你可能不希望这些变动影响原来的列表或字典。要做到这一点，Python 提供了名为 copy 的模块， 其中包含 copy()和 deepcopy()函数。第一个函数copy.copy()， 可以用来复制列表或字典这样的可变值， 而不只是复制引用。如果要复制的列表中包含了列表， 那就使用 copy.deepcopy()函数来代替。deepcopy()函数将同时复制它们内部的列表。1234567891011121314import copya = [1, 2, 3, [4, 5, 6]]b = copy.copy(a)a[0] = 110a[3][0] = 120print(a) # [110, 2, 3, [120, 5, 6]]print(b) # [1, 2, 3, [120, 5, 6]]c = copy.deepcopy(a)c[3][0] = 4print(a) # [110, 2, 3, [120, 5, 6]]print(c) # [110, 2, 3, [4, 5, 6]]","categories":[{"name":"Python","slug":"Python","permalink":"http://veinin.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://veinin.com/tags/Python/"},{"name":"编程","slug":"编程","permalink":"http://veinin.com/tags/编程/"}]},{"title":"Python 快速上手 - 函数","slug":"python-practice-functions","date":"2018-03-18T07:29:00.000Z","updated":"2018-03-24T14:09:57.972Z","comments":true,"path":"2018/03/18/python-practice-functions/","link":"","permalink":"http://veinin.com/2018/03/18/python-practice-functions/","excerpt":"Python 提供了这样一些内建函数，但你也可以编写自己的函数。“函数”就像一个程序内的小程序。 使用 def 语句定义一个函数12345678def hello(): print('Veinin') print('Veinin Guo') print('Hello trere.')for i in range(3): hello() print('')","text":"Python 提供了这样一些内建函数，但你也可以编写自己的函数。“函数”就像一个程序内的小程序。 使用 def 语句定义一个函数12345678def hello(): print('Veinin') print('Veinin Guo') print('Hello trere.')for i in range(3): hello() print('') 函数参数定义一个函数时可以自己定义接收参数，传入的参数值，放在函数的括号之间。12345def hello(name): print('Hello ' + name)hello('Veinin')hello('Jalin') 返回值和 return 语句函数调用求值的结果， 称为函数的“返回值”。用 def 语句创建函数时， 可以用 return 语句指定应该返回什么值。 return 语句包含以下部分： return 关键字； 函数应该返回的值或表达式。12345678910111213141516import randomdef getAnswer(answerNumber): if answerNumber == 1: return 'It is certain' elif answerNumber == 2: return 'It is decidedly so' elif answerNumber == 3: return 'Yes' else: return 'No'r = random.randint(1, 4)fortune = getAnswer(r)print(fortune) None 值在 Python 中有一个值称为 None，它表示没有值。 None 是 NoneType 数据类型的唯一值。像布尔值 True和 False 一样， None 必须大写首字母 N。12345spam = Noneprint(None == spam)spam = 'Hello'print(None == spam) 关键字参数和 print()print()函数有可选的变元 end 和 sep， 分别指定在参数末尾打印什么，以及在参数之间打印什么来隔开它们。默认情况下，print()函数自动在传入的字符串末尾添加了换行符。可以设置 end 关键字参数，将它变成另一个字符串。例如，如果程序像这样：12print('Hello', end='')print('World') print()传入多个字符串值时，该函数就会自动用一个空格分隔它们。可以传入 sep 关键字参数， 替换掉默认的分隔字符串。1234567&gt;&gt;&gt; print('cats', 'dogs', 'mice')cats dogs mice&gt;&gt;&gt; print('Red', 'Green', 'Blue')Red Green Blue&gt;&gt;&gt; print('Red', 'Green', 'Blue', sep=',')Red,Green,Blue 局部和全局作用域在被调用函数内赋值的变元和变量，处于该函数的“局部作用域”。在所有函数之外赋值的变量，属于“全局作用域”。处于局部作用域的变量，被称为“局部变量”。处于全局作用域的变量，被称为“全局变量”。 作用域很重要， 理由如下： 全局作用域中的代码不能使用任何局部变量 12345def spam(): eggs = 31337spam()print(eggs) # NameError: name 'eggs' is not defined 局部作用域可以访问全局变量 12345name = 'Veinin'def hello(): print('Hello, ' + name)hello() 一个函数的局部作用域中的代码，不能使用其他局部作用域中的变量 12345678910def spam(): eggs = 99 bacon() print(eggs)def bacon(): ham = 101 print(eggs) # NameError: name 'eggs' is not definedspam() 如果在不同的作用域中，你可以用相同的名字命名不同的变量。也就是说，可以有一个名为 spam 的局部变量，和一个名为 spam 的全局变量。 1234567def spam(): eggs = 'spam local' print(eggs) # prints 'spam local'eggs = 'global'spam()print(eggs) # prints 'global' global 语句如果需要在一个函数内修改全局变量， 就使用 global 语句。它就告诉 Python，在这个函数中， 某个值指的是全局变量， 所以不要用这个名字创建一个局部变量。1234567def spam(): global eggs eggs = 'spam'eggs = 'global'spam()print(eggs) 有 4 条法则， 来区分一个变量是处于局部作用域还是全局作用域： 1．如果变量在全局作用域中使用（即在所有函数之外），它就总是全局变量。 2．如果在一个函数中，有针对该变量的 global 语句，它就是全局变量。 3．否则，如果该变量用于函数中的赋值语句，它就是局部变量。 4．但是，如果该变量没有用在赋值语句中，它就是全局变量。12345678910111213def spam(): global eggs eggs = 'spam' # this is the global def bacon(): eggs = 'bacon' # this is the local def ham(): print(eggs) # this is the globaleggs = 42 # this is the globalspam()print(eggs) 异常处理在 Python 程序中遇到错误， 或“异常”， 如果不处理，意味着整个程序崩溃。而我们希望程序能检测错误， 处理它们，然后继续运行。 以下代码，当试图用一个数除以零时，就会发生 ZeroDivisionError: division by zero 错误提示。从而导致后面代码中断运行。123456def devide(divideBy): return 42 / divideByprint(devide(2))print(devide(0))print(devide(22)) 我们可以使用 try 和 except 语句来处理错误。那些可能出错的语句被放在 try 子句中。如果错误发生，程序执行就转到接下来的 except 子句开始处。123456789def devide(divideBy): try: return 42 / divideBy except ZeroDivisionError: print('Error: Invalid argument.')print(devide(2))print(devide(0))print(devide(22))","categories":[{"name":"Python","slug":"Python","permalink":"http://veinin.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://veinin.com/tags/Python/"},{"name":"编程","slug":"编程","permalink":"http://veinin.com/tags/编程/"}]},{"title":"Python 快速上手 - 控制流","slug":"python-practice-flow-control","date":"2018-03-18T07:22:00.000Z","updated":"2018-03-24T14:09:55.493Z","comments":true,"path":"2018/03/18/python-practice-flow-control/","link":"","permalink":"http://veinin.com/2018/03/18/python-practice-flow-control/","excerpt":"程序就是一系列指令。但编程真正的力量不仅在于运行（或“执行”） 一条接一条的指令， 就像周末的任务清单那样。根据表达式求值的结果，程序可以决定跳过指令， 重复指令， 或从几条指令中选择一条运行。实际上， 你几乎永远不希望程序从第一行代码开始， 简单地执行每行代码， 直到最后一行。“控制流语句” 可以决定在什么条件下执行哪些 Python 语句。 布尔值“布尔” 数据类型只有两种值： True 和 False。 Boolean（布尔） 的首字母大写， 因为这个数据类型是根据数学家 George Boole 命名的。12345678910&gt;&gt;&gt; spam = True&gt;&gt;&gt; spamTrue&gt;&gt;&gt; trueTraceback (most recent call last):File \"&lt;pyshell#2&gt;\", line 1, in &lt;module&gt;trueNameError: name 'true' is not defined&gt;&gt;&gt; True = 2 + 2SyntaxError: assignment to keyword","text":"程序就是一系列指令。但编程真正的力量不仅在于运行（或“执行”） 一条接一条的指令， 就像周末的任务清单那样。根据表达式求值的结果，程序可以决定跳过指令， 重复指令， 或从几条指令中选择一条运行。实际上， 你几乎永远不希望程序从第一行代码开始， 简单地执行每行代码， 直到最后一行。“控制流语句” 可以决定在什么条件下执行哪些 Python 语句。 布尔值“布尔” 数据类型只有两种值： True 和 False。 Boolean（布尔） 的首字母大写， 因为这个数据类型是根据数学家 George Boole 命名的。12345678910&gt;&gt;&gt; spam = True&gt;&gt;&gt; spamTrue&gt;&gt;&gt; trueTraceback (most recent call last):File \"&lt;pyshell#2&gt;\", line 1, in &lt;module&gt;trueNameError: name 'true' is not defined&gt;&gt;&gt; True = 2 + 2SyntaxError: assignment to keyword 比较操作符“比较操作符” 比较两个值，求值为一个布尔值。12345678&gt;&gt;&gt; 42 == 42True&gt;&gt;&gt; 42 == 99False&gt;&gt;&gt; 2 != 3True&gt;&gt;&gt; 2 != 2False 布尔操作符3 个布尔操作符（and、 or 和 not） 用于比较布尔值。12345678&gt;&gt;&gt; True and TrueTrueFalse or TrueTrue&gt;&gt;&gt; not TrueFalse(4 &lt; 5) and (5 &lt; 6)True 控制流语句if 语句if 语句的子句（也就是紧跟 if 语句的语句块），将在语句的条件为 True 时执行。如果条件为 False，子句将跳过。if 语句包含以下部分： if 关键字； 条件（即求值为 True 或 False 的表达式）； 冒号； 在下一行开始，缩进的代码块（称为 if 子句）。12if name == 'Alice': print('Hi, Alice.') else 语句if 子句后面有时候也可以跟着 else 语句。只有 if 语句的条件为 False 时， else子句才会执行。lse 语句中包含下面部分： else 关键字； 冒号； 在下一行开始，缩进的代码块（称为 else 子句）。1234if name == 'Alice': print('Hi, Alice.')else: print('Hello, stranger.') elif 语句有时候可能你希望，“许多” 可能的子句中有一个被执行。 elif 语句是“否则如果”，总是跟在 if 或另一条 elif 语句后面。在代码中， elif 语句总是包含以下部分： elif 关键字； 条件（即求值为 True 或 False 的表达式）； 冒号； 在下一行开始，缩进的代码块（称为 elif 子句）。 while 循环语句while 语句总是包含下面几部分： 关键字； 条件（求值为 True 或 False 的表达式）； 冒号； 从新行开始，缩进的代码块（称为 while 子句）。1234spam = 0while spam &lt; 5: print('Hello, world.') spam = spam + 1 break 语句如果执行遇到 break 语句，就会马上退出 while 循环子句。在代码中， break 语句仅包含 break 关键字。123456while True: print('Please type your name.') name = input() if name == 'Veinin': breakprint('Thank you!') continue 语句像 break 语句一样， continue 语句用于循环内部。如果程序执行遇到 continue语句，就会马上跳回到循环开始处，重新对循环条件求值12345678910while True: print('Who are your?') name = input() if name != 'Veinin': continue print('Hello, Veinin. What is the password?') password = input() if password == '123': breakprint('Access granted.') for 循环和 range()函数通过 for 循环语句和 range()函数来实现一个代码块执行固定次数。for 语句看起来像 for i in range(5):这样， 总是包含以下部分： for 关键字； 一个变量名； in 关键字； 调用 range()方法，最多传入 3 个参数； 冒号； 从下一行开始，缩退的代码块（称为 for 子句）。12345678print('My name is')for i in range(5): print('Jimmy Five Time (' + str(i) + ')') total = 0for num in range(100): total = total + numprint(total) range()的开始、 停止和步长参数下列代码 range 函数中，第一个参数是 for 循环变量开始的值， 第二个参数是上限， 但不包含它， 也就是循环停止的数字。第三个参数是“步长”。 步长是每次迭代后循环变量增加的值。12for i in range(0, 10, 2): print(i) 导入模块Python 程序可以调用一组基本的函数， 这称为“内建函数”， 包括你见到过的print()、 input()和 len()函数。 Python 也包括一组模块，称为“标准库”。每个模块都是一个 Python 程序， 包含一组相关的函数， 可以嵌入你的程序之中。例如， math模块有数学运算相关的函数， random 模块有随机数相关的函数， 等等。在代码中， import 语句包含以下部分： import 关键字； 模块的名称； 可选的更多模块名称，之间用逗号隔开。123import randomfor i in range(5): print(random.randint(1, 10)) 使用逗号分隔符来导入多个模块1import random, sys, os, math from import 语句import 语句的另一种形式包括 from 关键字，之后是模块名称， import 关键字和一个星号， 例如 from random import * 。使用这种形式的 import 语句，调用 random模块中的函数时不需要 random.前缀。但是， 使用完整的名称会让代码更可读， 所以最好是使用普通形式的 import 语句。 用 sys.exit()提前结束程序通过调用 sys.exit()函数， 可以让程序终止或退出。因为这个函数在 sys 模块中，所以必须先导入 sys， 才能使用它。12345678import syswhile True: print('Type exit to exit.') response = input() if response == 'exit': sys.exit() print('You typed ' + response + '.')","categories":[{"name":"Python","slug":"Python","permalink":"http://veinin.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://veinin.com/tags/Python/"},{"name":"编程","slug":"编程","permalink":"http://veinin.com/tags/编程/"}]},{"title":"《小狗钱钱》读书笔记","slug":"reading-notes-money-oder-das","date":"2018-03-04T12:12:00.000Z","updated":"2018-03-04T12:21:15.600Z","comments":true,"path":"2018/03/04/reading-notes-money-oder-das/","link":"","permalink":"http://veinin.com/2018/03/04/reading-notes-money-oder-das/","excerpt":"《小狗钱钱》讲述的是一个童话故事，一个普通小女孩吉娅发现一只受伤的拉布拉多犬，并把它带回了家，取名叫钱钱。可是，有谁会想到，这只普通的四脚动物却是一个真正的理财天才呢？吉娅和小狗成为了朋友，通过小狗钱钱的指导，最后吉娅成功实现了自己的梦想，它彻底改变了吉娅一家人的财富命运。这是一本老少皆宜的理财入门书籍。作者是被誉为欧洲首席金钱教练博多·舍费尔。这本书会教你如何从小学会支配金钱，而不是受金钱的支配；如何像富人那样思考，正确地认识和使用金钱；如何进行理财投资，找到积累资产的方法，早日实现财务自由！","text":"《小狗钱钱》讲述的是一个童话故事，一个普通小女孩吉娅发现一只受伤的拉布拉多犬，并把它带回了家，取名叫钱钱。可是，有谁会想到，这只普通的四脚动物却是一个真正的理财天才呢？吉娅和小狗成为了朋友，通过小狗钱钱的指导，最后吉娅成功实现了自己的梦想，它彻底改变了吉娅一家人的财富命运。这是一本老少皆宜的理财入门书籍。作者是被誉为欧洲首席金钱教练博多·舍费尔。这本书会教你如何从小学会支配金钱，而不是受金钱的支配；如何像富人那样思考，正确地认识和使用金钱；如何进行理财投资，找到积累资产的方法，早日实现财务自由！ 梳理理财目标中国的智者老子说过：“天下难事，必作于易；天下大事，必作于细”。你自己必须真的有“想要变得富有”这个愿望，所以你必须找到10个“想要变得富有”的梦想。然后找出3项你觉得最重要的梦想出来，并作为目标，然后拿一本相册作为你的梦想相册。收集一些与自己的愿望有关的照片，把它们贴在相册里。我们要通过图片来思考。最后为自己的每一个梦想各准备一个储蓄罐，比如银行卡子账户。一旦储蓄罐准备好，你就应当把省下的每一分钱放进去。 撰写成功日记你是否能挣到钱，最关键的并不是你有没有好点子，也不是你有多聪明，而是你的自信程度。你的自信程度决定了你是否相信自己的能力，是否相信你自己。假如你根本不相信你能做到的话，那么你就根本不会动手去做，而假如你不开始去做，那么你就什么也得不到。自信是很容易梳理的，你只需要准备一个本子，给它取名叫‘成功日记’，然后每天都把当天所有做成功的事情记录进去。每次都写至少5条你的个人成果，任何小事都可以。 坚持你的梦想不论在什么情况下，每天都坚持自己所做所想。不间断地设想我的未来。当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。 快速摆脱负债毁掉所有的信用卡。在许可范围内按最低的分期付款数目标准支付。应当尽可能少地偿还贷款。分期付款额越高，每个月剩下的生活费就越少。许多人和银行约定的分期付款数额刚好在他们承受能力的上限，因此他们手里的钱一直很紧张。将扣除生活费后剩下的钱的一半存起来，剩下的一半用于支付消费贷款。最好根本不申请消费贷款。债务人都应该在自己的钱包里贴一张纸条，上面写着“这真的有必要吗”。这样的话，当他站在收银台前的时候，就会想到不应该花太多的钱。 合理分配你挣到的钱如果你想变得富有，你同时还要存钱，这笔钱是你绝不会再花的，只用利息进行消费，让你能依靠本金来生活。拥有一只自己的“鹅”。鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。把50％的收入变的“鹅”，用来让鹅长大；40％放入梦想储蓄罐，用来帮助实现自己的目标；剩下的10％用来零花。 进行明确的投资应该把钱投资在安全的地方。我的钱应该下很多“金蛋”。我们要足够了解你的投资对象，投资应该简单明了，而且易于操作。用72除以通货膨胀率，得出的数字就是你的钱在多少年后只值现在的一半。聪明的商人可不会让自己的钱只躺在银行里睡大觉，这样做根本没有什么利息。即使有，通货膨胀也会完全吞掉你的利息。用72除以年收益率的百分比，得出的数字就是这笔钱翻一番的年数。如果你们投资的收益率是15％，差不多5年以后，钱就会翻一倍。 如何挑选基金基金应该至少有10年历史。假如它在这么长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。 语录 不是试试看，而是去切实行动！如果你只是抱着试试看的心态，那么你只会以失败告终，你会一事无成。“尝试”纯粹是一种借口，你还没有做，就已经给自己想好了退路。不能试验，你只有两个选择——做或者不做。 学习就是认识新观念和新想法的过程。假如人们始终以同一种思维方式来考虑问题的话，那么始终只会得到同样的结果。因为我对你讲述的许多内容是你以前从未接触过的，所以我建议你，在你还没有做之前，不要轻易下结论。没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。 必须学会量入为出，否则有了更多的钱只会给他们带来更大的麻烦，因为支出往往会和收入一同增长，除非我们学会合理分配我们的财产。 要想过更幸福、更满意的生活，人就得改变自身。这和钱无关，金钱本身既不会使人幸福，也不会带来不幸。金钱是中性的，既不好，也不坏。只有当钱属于某一个人的时候，它才会对这个人产生好的影响或者坏的影响。钱可以被用于好的用途，也可以被用于坏的用途。一个幸福的人有了钱会更幸福；而一个悲观忧虑的人，钱越多，烦恼就越多。” 没有人能强迫你做你不愿意做的事情。只有你自己才能强迫自己去做。 最珍贵的礼物是我们自己争取来的。克服了丢面子的恐惧，世界就会向你敞开大门！ 成功会使人骄傲。如果你骄傲自大，你就会停止学习。不学习，人就不会再进步。 对股票，每个人都知道一点点，可是很少有人清楚它到底是什么东西。 金融家有时候还真是一群奇怪的人。也许当他们随意地说出一串除了他们自己谁也听不懂的名词时，他们会觉得自己比较重要。但遗憾的是，许多人因此感到自己不懂投资。不懂的东西，人们是不相信的。而其实这些东西就是这么简单。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://veinin.com/categories/读书笔记/"}],"tags":[{"name":"投资","slug":"投资","permalink":"http://veinin.com/tags/投资/"},{"name":"理财","slug":"理财","permalink":"http://veinin.com/tags/理财/"}]},{"title":"《富爸爸，穷爸爸》读书笔记","slug":"reading-notes-rich-dad-poor-dad","date":"2018-02-25T14:42:00.000Z","updated":"2018-03-04T12:13:53.003Z","comments":true,"path":"2018/02/25/reading-notes-rich-dad-poor-dad/","link":"","permalink":"http://veinin.com/2018/02/25/reading-notes-rich-dad-poor-dad/","excerpt":"我们从小就听父母说，好好读书，好好上课，毕业了找一份好的工作。那好好上学真的可以找到好的工作吗？找到好的工作肯定会变富有吗？我想这些问题的答案都是否定的，谁能够一直坐在教室里听着那些枯燥乏味的教学内容，那些内容让我们只会运用于考试中，在生活中往往被我们给忽略了。我们如何才能让我们的生活不在为了金钱而忙碌，我们为什么不能让金钱为我们而工作呢！ 因此，要学会管理风险，要学会投资，不要让我们的生活只留下房贷、车贷。不要生活在一种虚假的忙碌中，那样的生活没有意义，只会让我们在往后的生活中教育自己的后代：好好上学，好好读书，找个好工作。这样的生活在当今社会已经不实用了，没有谁会认为只有读书才有出路。 《富爸爸，穷爸爸》是一个真实的故事，作者罗伯特·清崎从人的个体出发分析富人之所以成为富人，穷人之所以成为穷人的自身因素，提出了一个全新的“财商”的概念。并向传统的学校教育提出挑战。","text":"我们从小就听父母说，好好读书，好好上课，毕业了找一份好的工作。那好好上学真的可以找到好的工作吗？找到好的工作肯定会变富有吗？我想这些问题的答案都是否定的，谁能够一直坐在教室里听着那些枯燥乏味的教学内容，那些内容让我们只会运用于考试中，在生活中往往被我们给忽略了。我们如何才能让我们的生活不在为了金钱而忙碌，我们为什么不能让金钱为我们而工作呢！ 因此，要学会管理风险，要学会投资，不要让我们的生活只留下房贷、车贷。不要生活在一种虚假的忙碌中，那样的生活没有意义，只会让我们在往后的生活中教育自己的后代：好好上学，好好读书，找个好工作。这样的生活在当今社会已经不实用了，没有谁会认为只有读书才有出路。 《富爸爸，穷爸爸》是一个真实的故事，作者罗伯特·清崎从人的个体出发分析富人之所以成为富人，穷人之所以成为穷人的自身因素，提出了一个全新的“财商”的概念。并向传统的学校教育提出挑战。 清崎有两个爸爸，其中一个有博士学位的是他的亲生爸爸，也是本书中的穷爸爸；另外一个初中都没有读完是他好友的爸爸，即本书中的富爸爸。两位爸爸都有非常高的收入，但是穷爸爸却常常为钱而烦恼，而富爸爸最后成为了夏威夷最富有的人。 富爸爸过世后给家里留下了很多的财产，而穷爸爸则为家人留下了很多没有还清的债务。之所以会出现这样的情况，是因为穷爸爸缺乏基本的财务知识。 而关于财务教育最大的问题是学校没有教过这门学科，所以我们对于财务的教育都来自家庭，而问题就在于除非你的父母是属于收入很高的1%的那一部分人，不然我们普通的家庭并不知道如何教自己的孩子财务方面的知识。而且他们也不会阅读像《富爸爸穷爸爸》这类的书籍。如果我们没有出身在那1%的家庭，那么我们可以向清崎来学习，学习“富爸爸”的观念，即不要做金钱的奴隶，要让金钱为我们工作。 第一课：富人不为钱工作穷人和中产阶级为钱而工作。起床，上班，付账，再起床，再上班，再付账……他们的生活从此被这两种感觉所控制：恐惧和贪婪。给他们更多的钱，他们就会以更高的开支重复这种循环。这就是所谓的的‘老鼠赛跑’。人们自身的恐惧和无知使他们困在陷阱里，正是出于恐惧的心理，人们才想找一份安稳的工作。这些恐惧有：害怕付不起账单，害怕被解雇，害怕没有足够的钱，害怕重新开始。为了寻求保障，他们会学习某种专业，或是做生意，拼命为钱而工作。大多数人成了钱的奴隶，然后就把怒气发泄在他们老板身上。他们不明白自己为什么老缺钱，于是以为多挣点钱就能解决问题，但几乎没有人意识到缺乏财商教育才是问题的关键。 第二课：为什么要教授财务知识一个受过高等教育且事业有成的人，同时也可能是财务上的文盲。这种人往往太过努力地工作，因为他们只知道努力工作，却不知道如何让钱为他们工作。如果人们认为钱能解决一切问题，恐怕他们的日子就不会太好过。只有知识才能解决问题并创造财富，那些不是靠财务知识挣来的钱也不会长久。你必须明白资产和负债的区别，并且购买资产。如果你想致富，这一点你必须知道。富人获得资产，而穷人和中产阶级获得负债，只不过他们以为那些负债就是资产。资产是能把钱放进你口袋里的东西。负债是把钱从你口袋里取走的东西。富人：增加收入，减少支出和负债，买入更多资产。穷人：增加收入，增加支出和负债。中产阶级：购买自以为是资产的负债。 第三课：关注自己的事业职业不等于你的事业。大多数人工作其实是为其他人，而非他们自己。首先他们要为公司的老板工作，其次是通过纳税为政府工作，最后是为向他们提供住房按揭贷款的银行工作。多关注自己的事业。存在财务问题的人经常耗费一生为别人工作，其中许多人在他们不能工作时就变得一无所有。富人与穷人一个重要的区别就是：富人最后才买奢侈品，而穷人和中产阶级会先买下诸如大房子、珠宝、皮衣、宝石、游艇等奢侈品，因为他们想让自己看上去很富有。他们看上去的确很富有，但实际上他们已深陷贷款的陷阱之中。那些能给子孙留下遗产的人和那些能长期富有的人，就是先构筑资产项，然后才用资产所产生的收入购买奢侈品的，而穷人和中产阶级则用他们的血汗钱和本应该留给子孙的遗产来购买奢侈品。 真正的资产可以分为以下几类： 1．不需我到场就可以正常运作的业务。我拥有它们，但由别人经营和管理。如果我必须在那儿工作，那它就不是我的事业而是我的职业了； 2．股票； 3．债券； 4．共同基金； 5．能够产生收入的房地产； 6．票据（借据）； 7．版税，如音乐、手稿、专利； 8．其他任何有价值、可产生收入或有增值潜力并且有很好销路的东西。 第四课：税收的历史和公司的力量公司的避税优势： 1.公司的某些收入可以用于税前收入支出 2.企业所得税率低于个人所得税率 知识就是力量，而且钱越多，就越需要知识管理它，使它继续增加。没有这种知识，世界就会牵着你走。 财商是由4个方面的专门知识构成的： 第一是会计，也就是我说的财务知识。 第二是投资，我把它称为钱生钱的科学。投资涉及策略和方案，这要右脑来做，是属于创造的部分。 第三是了解市场，它是供给与需求的科学。这要求了解受感情驱动的市场的“技术面”。 第四是法律。利用一个具有会计、投资和市场运营的企业会使你的财富实现爆炸性地增长。了解减税优惠政策和公司法的人会比雇员和小业主更快致富。拥有公司的富人：挣钱、支出、缴税为公司工作的人：挣钱、缴税、支出 第五课：富人的投资我们都拥有巨大的潜能，然而，我们都拥有或多或少的自我怀疑的心理。过分的害怕和自我怀疑是毁掉我们才能的最大因素。成为财务上的天才既需要专业知识，又需要足够的勇气。投资者分为两类：第一类也是最普遍的一类，即进行一揽子投资的人。他们联系一家从事经营个人投资业务的中介机构，例如房地产公司、股票经纪人或财务规划师等，然后买下某些产品。这些产品可能是共同基金、房地产投资信托、股票或债券等。 第二类是自己创造投资机会的投资者。这种投资者通常会自行组织一项交易，好比一个人买来电脑零部件，然后自己组装，这有点像量身定做。这类投资者，除了提高财商的4项基本技能，还必须具备3种主要技能， 1．如何寻找其他人都忽视的机会。 2．如何增加资金。 3．怎样把精明的人组织起来。聪明的人往往会雇用比自己更聪明的人或与他们一起工作。当你需要建议的时候，你一定要确定你选择的是明智的顾问。 第六课：学会不为钱工作大部分人需要学习和掌握不止一项技能，只有这样他们的收入才能获得显著增长。财商是会计、投资、市场和法律等各方面知识和能力的综合。将上述4种技能结合起来，以钱生钱就会容易得多。当涉及钱的时候，只有一项技能的人不得不努力工作。找一份稳定的工作。大部分人是为短期的工资和福利工作的，但从长期来看这种做法常常是具有灾难性的。劝告年轻人在找工作时要看能从中学到什么，而不是只看能挣多少钱。在选择某种职业或陷入“老鼠赛跑”的陷阱之前，要仔细看看脚下的路，弄清楚自己到底想获得什么技能。是建议他们要有长远的眼光。我承认为了金钱和生活安稳而工作是很重要，但我仍主张要再找一份工作，以便从中学到另一种技能。我受过良好教育的爸爸工作越努力，就越具有竞争力，但同时他也更深地陷入专业特长的陷阱之中。虽然他的工资增长了，可他的选择机会却少了。直到失去了在政府中的工作，他才发现自己在职业选择上是多么被动。这就好比职业运动员因为突然受伤或是年龄太大而无法继续参加比赛一样，他们会失去曾经拥有的高收入工作，而有限的技能又使他们无法另辟蹊径。我想， 克服困难掌握财务知识的人有时候还是不能积累丰厚的资产项，其主要原因有5个： 1．恐惧心理。 2．愤世嫉俗。 3．懒惰。 4．不良习惯。 5．自负。 开始行动 1．我需要一个超现实的理由——精神的力量。 2．每天作出自己的选择——选择的力量。从理财的角度来说，我们每挣到一美元，就得到了一次选择自己是成为富人、穷人还是中产阶级的机会。我们花钱的习惯反映了我们是什么样的人，穷人之所以贫穷是因为他们有着不良的消费习惯。 3．慎重地选择朋友——关系的力量。首先，我不会把理财状况作为挑选朋友的标准。 4．掌握一种模式，然后再学习一种新的模式——快速学习的力量。面包师要按照一定的配方做面包，即使配方只是记在脑子里。挣钱也是一样的道理，这也是金钱有时被称做“面包圈”的原因。 5．首先支付自己——自律的力量。如果你控制不了自己，就别想着致富。不要背上数额过大的债务包袱。要保持低支出。首先增加自己的资产，然后，再用资产项产生的现金流来买大房子或好车子。陷在“老鼠赛跑”中不是明智的选择。当你资金短缺时，让压力去发挥作用，而不要动用你的储蓄或资本。利用这种压力来激发你的理财天赋，想出新办法挣到更多的钱，然后再支付账单。这样做，不但能让你赚到钱，还能提高你的财商。 6．给你的经纪人以优厚的报酬——好建议的力量。 7．做一个“印第安给予者”——无私的力量。 8．用资产来购买奢侈品——专注的力量。 9．对英雄的崇拜——神话的力量。 10．先予后取——给予的力量。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://veinin.com/categories/读书笔记/"}],"tags":[{"name":"理财","slug":"理财","permalink":"http://veinin.com/tags/理财/"},{"name":"富爸爸","slug":"富爸爸","permalink":"http://veinin.com/tags/富爸爸/"},{"name":"穷爸爸","slug":"穷爸爸","permalink":"http://veinin.com/tags/穷爸爸/"}]},{"title":"《人类简史》读书笔记","slug":"reading-notes-a-brief-history-of-humankind","date":"2017-12-31T11:59:10.000Z","updated":"2017-12-31T03:03:03.098Z","comments":true,"path":"2017/12/31/reading-notes-a-brief-history-of-humankind/","link":"","permalink":"http://veinin.com/2017/12/31/reading-notes-a-brief-history-of-humankind/","excerpt":"十万年前，地球上至少有六种不同的人。但今日，世界舞台为什么只剩下了我们自己？从只能啃食虎狼吃剩的残骨的猿人，到跃居食物链顶端的智人，从雪维洞穴壁上的原始人手印，到阿姆斯壮踩上月球的脚印，从认知革命、农业革命，到科学革命、生物科技革命，我们如何登上世界舞台成为万物之灵的？ 这是以色列历史学家尤瓦尔·赫拉利成名作，这本书以不到500页的篇幅，从10万年前一直讲到了21世纪，为我们理清人类的发展脉络提供了一个充满哲思的全局视角。","text":"十万年前，地球上至少有六种不同的人。但今日，世界舞台为什么只剩下了我们自己？从只能啃食虎狼吃剩的残骨的猿人，到跃居食物链顶端的智人，从雪维洞穴壁上的原始人手印，到阿姆斯壮踩上月球的脚印，从认知革命、农业革命，到科学革命、生物科技革命，我们如何登上世界舞台成为万物之灵的？ 这是以色列历史学家尤瓦尔·赫拉利成名作，这本书以不到500页的篇幅，从10万年前一直讲到了21世纪，为我们理清人类的发展脉络提供了一个充满哲思的全局视角。 在历史的路上，有三大重要革命：大约7万年前，“认知革命”（CognitiveRevolution）让历史正式启动。大约12000年前，“农业革命”（AgriculturalRevolution）让历史加速发展。而到了大约不过是500年前，“科学革命”（ScientificRevolution）可以说是让历史画下句点而另创新局。这本书的内容，讲述的就是这三大革命如何改变了人类和其他生物。 认知革命人类是怎么从一种平凡无奇的动物走到食物链顶端的，认知革命带给了我们答案。 大约在240万年前的东非最早的人类开始演化，祖先是一种更早的猿属“Australopithecus”（南方古猿）。大约200万年前，这些远古人类有一部分离开了家园而踏上旅程，足迹遍及北非、欧洲和亚洲的广大地带。北欧的森林白雪皑皑，印度尼西亚的热带丛林湿气蒸腾，想活命显然需要不同的特征，因此人类也开始朝着不同方向进化。于是人类发展出几个不同的物种，除了“智人”以外，还有比如在欧洲和西亚的“尼安德特人”，住在在东方亚洲的“直立人”等等。 如果不出意外，可能在今天我们可以看到多个不同的人种，多种人种共存其实会是常态。但是，意外出现了，大约7万年前，智人从东非扩张到阿拉伯半岛，并且很快席卷整个欧亚大陆，由于不同的人种之间的水火不容，互有反感，于是发生种族灭杀，当地的原生人种很快就会灭绝。大约3万年前尼安德特人退出了世界舞台，而到了12000年前，像小矮人般的人类也从弗洛里斯岛上永远消失，这种残酷的种族屠杀一直持续到了大约1万年前，终于，地球上的人种只剩下了智人一种。 因为智人迁移到其他地区，而造成其他人类物种的灭绝。那么为什么是智人，而不是其他人种呢？那是因为在大约7万年前，智人仿佛脱胎换骨，某次偶然的基因突变，改变了智人的大脑内部连接方式，让他们以前所未有的方式来思考，用完全新式的语言来沟通。他们的认知能力（学习、记忆、沟通）得到了革命性的发展，这时的智人已经和你我同样聪明、有创意、反应灵敏，他们产生了新的思维和沟通方式，这也是所谓的认知革命。 认知革命给智人带来了新的语言，这种新语言带来了最独特的功能–“讨论虚构的事物”。智人的语言并不是世界上的第一种语言。因为许多动物（包括所有的猿类和猴类）都会使用有声语言。例如，青猴（greenmonkey）就有各种不同的喊叫方式，传达不同的信息。不论是人类还是许多动物，都能大喊：“小心！有狮子！”。但在认知革命之后，智人就能够说出：“狮子是我们部落的守护神”。智人能够谈论并不真正存在的事物，相信一些不太可能的事情。于是传说、神话、神以及宗教也应运而生。 “虚构”这件事的重点不只在于让人类能够拥有想象，更重要的是可以“一起”想象，编织出种种共同的虚构故事，不管是《圣经》的《创世记》、澳大利亚原住民的“梦世记”（Dreamtime），甚至连现代所谓的国家其实也是种想象。这样的虚构故事赋予智人前所未有的能力，让我们得以集结大批人力、灵活合作。虽然一群蚂蚁和蜜蜂也会合作，但方式死板，而且其实只限近亲。至于狼或黑猩猩的合作方式，虽然已经比蚂蚁灵活许多，但仍然只能和少数其他十分熟悉的个体合作。智人的合作则是不仅灵活，而且能和无数陌生人合作。正因如此，才会是智人统治世界，蚂蚁只能吃我们的剩饭，而黑猩猩则被关在动物园和实验室里。 于人类共同的想象之外，这个宇宙中根本没有神、没有国家、没有钱、没有人权、没有法律，也没有正义。通过虚构的故事，就算是大批互不相识的人，只要同样相信相信某个故事，就能共同合作。无论是现代国家、中世纪的教堂、古老的城市，或者古老的部落，任何大规模人类合作的根基，都在于某种只存在于集体想象中的虚构故事。而这也使智人最后打破了团体的人数限制，创造出了有数万居民的城市、有上亿人口的帝国，这也是智人成功的关键。 农业革命人类曾有长达250万年的时间靠采集及狩猎维生，并不会特别干预动植物的生长情形。直立人、匠人或是尼安德特人都会采集野无花果、猎捕野绵羊，但不会去管究竟无花果树该长在哪，羊该在哪片草地吃草，又或是哪只公羊该跟母羊交配。 这一切在大约1万年前全然改观，人类开始投入几乎全部的心力，操纵着几种动植物的生命。从日升到日落，人类忙着播种、浇水、除草、牧羊，一心以为这样就能得到更多的水果、谷物和肉类。这是一场关于人类生活方式的革命：农业革命。 农业革命让人类的食物总量增加，但量的增加并不代表吃得更好、过得更悠闲，反而只是造成人口爆炸，而且产生一群养尊处优、娇生惯养的精英分子。普遍来说，农民的工作要比采集者更辛苦，而且到头来的饮食还要更糟。农业革命可说是史上最大的一桩骗局。 正是这些征收来的多余食粮，养活了政治、战争、艺术和哲学，建起了宫殿、堡垒、纪念碑和庙宇。在现代晚期之前，总人口有九成以上都是农民，日出而作、胼手胝足。他们生产出来的多余食粮养活了一小撮的精英分子：国王、官员、战士、牧师、艺术家和思想家，但历史写的几乎全是这些人的故事。于是，历史只告诉了我们极少数的人在做些什么，而其他绝大多数人的生活就是不停挑水耕田。 农业革命后几千年的历史，可以总结为一个问题：如果人类的基因里并没有大规模合作的生物本能，所有的合作网络究竟如何维系？简单的讲法，是人类创造出了由想象建构的秩序、发明了文字，以这两者补足我们基因中的不足。但对许多人来说，这些合作网络究竟是好是坏实在难说。网络背后那些想象的秩序既不中立也不公平，总把人分成一些其实并不存在的分类，并且排出上下等级。上等人享有各种权力和特权，而下等人有的只有歧视和压迫。 人类统一融合农业革命之后，人类社会规模变得更大、更复杂，而维系社会秩序的虚构故事也更为细致完整。人类几乎从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照着这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化”。 每种文化都自成一格、和谐共存，而且都有独特的不变本质。每一群人都会有自己的世界观，和社会、法律及政治系统，而且各自运作顺畅，就像是行星绕着太阳一样。 从实际观点看，全球融合最关键的阶段就是过去这几个世纪。各大帝国成长，全球贸易强化，亚洲、非洲、美洲和大洋洲的人类形成紧密连接，于是印度菜里出现了墨西哥的辣椒，阿根廷的草原上漫步着来自西班牙的牛。 在过去的3000年间，人类有越来越多雄心勃勃的计划，想要实现这种世界一家的概念。他们发明货币、建筑帝国和传播宗教。 商业、帝国和全球性的宗教，最后终于将几乎每个智人都纳入了我们今天的全球世界。这个扩张和统一的过程并不是完全直线发展、一帆风顺。但纵观大局，可以看到从许多小文化到少数大文化再到最后的全球单一文化，应该是人类历史无法避免的结果。 科学革命历史就这样从一个岔路走到下一个岔路，选择走某条道路而非另一条的原因总是神秘而不得而知。大约在公元1500年，历史做出了最重大的选择，改变的不只是人类的命运，而是地球上所有生命的命运。我们将它称为“科学革命”。 将人类带到阿拉莫戈多、带上月球的这段历史进程，称为“科学革命”。在这场革命中，人类因为将资源投入科学研究，取得了巨大的新力量。之所以说这是一场革命，是因为一直到大约公元1500年前，全球人类还不相信自己能在医疗、军事和经济方面再有什么突破。政府和富有的赞助者虽然也会将资金投入教育和作为奖学金，但一般来说只是为了维持现有能力，而不是取得新的能力。典型的前现代统治者会赞助牧师、哲学家和诗人，目的是请他们让他的统治合法化，并且维护社会秩序，而不是要他们发明新的药物、武器，或是刺激经济成长。 但在过去的500年中，人类越来越相信可以靠着投资科学研究提升人类的能力。而且这不只是盲目的信仰，而是经过了反复的证明。随着证据越来越多，手中握有资源的富人和政府也就越来越愿意投入科学。如果没有这些投资，人类永远不可能在月球上漫步，不可能操纵微生物，更不可能分裂原子。 后记历史有太多的可能性，而许多的可能性最后都未成真。我们不难想象，历史其实很有可能就这样一代又一代地过去，而从未发生科学革命，就算没有基督教，没有古罗马帝国，没有金币，历史还是会继续发展下去。 在7万年前，智人还不过是一种微不足道的动物，在非洲的角落自顾自地生活。但就在接下来的几千年间，智人就成了整个地球的主人、生态系统的梦魇。时至今日，智人似乎只要再跨一步就能进入神的境界，不仅有望获得永恒的青春，更拥有创造和毁灭一切的神力。 但遗憾的是，智人在地球上的所作所为，实在没有太多令人自豪。虽然我们主宰了环境、增加了粮食产量、盖起城市、建立帝国，还创造了无远弗届的贸易网络，但全球的痛苦减少了吗？一次又一次，虽然整体人类的能力大幅提升，但却不一定能改善个别人类的福祉，而且常常还让其他动物深受其害。 拥有神的能力，但是不负责任、贪得无厌，而且连想要什么都不知道。天下危险，恐怕莫此为甚。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://veinin.com/categories/读书笔记/"}],"tags":[{"name":"人类简史","slug":"人类简史","permalink":"http://veinin.com/tags/人类简史/"},{"name":"历史","slug":"历史","permalink":"http://veinin.com/tags/历史/"},{"name":"人类学","slug":"人类学","permalink":"http://veinin.com/tags/人类学/"}]},{"title":"《拖延心理学》读书笔记","slug":"reading-notes-procrastination","date":"2017-12-02T08:15:00.000Z","updated":"2017-12-02T08:22:19.080Z","comments":true,"path":"2017/12/02/reading-notes-procrastination/","link":"","permalink":"http://veinin.com/2017/12/02/reading-notes-procrastination/","excerpt":"拖延从根本上来说并不是一个时间管理方面或懒惰的问题，也不是一个道德问题，而是一个复杂的心理问题。根本而言，拖延的问题是一个人跟自身如何相处的问题，它反映的是一个人在自尊上的问题。 本书的第一部分中，我们对产生拖延的形形色色的根源进行了追溯，告诉我们为何会拖延。在第二部分中，给出了一些帮助你采取行动的建议，教导我们如何去应对拖延症。我们的目标并不是消除拖延。很多时候对一些事情弃之不理反而对你最为有利；相反，这本书希望能够让你更加接受自己，由你自己来掌握取舍和得失。","text":"拖延从根本上来说并不是一个时间管理方面或懒惰的问题，也不是一个道德问题，而是一个复杂的心理问题。根本而言，拖延的问题是一个人跟自身如何相处的问题，它反映的是一个人在自尊上的问题。 本书的第一部分中，我们对产生拖延的形形色色的根源进行了追溯，告诉我们为何会拖延。在第二部分中，给出了一些帮助你采取行动的建议，教导我们如何去应对拖延症。我们的目标并不是消除拖延。很多时候对一些事情弃之不理反而对你最为有利；相反，这本书希望能够让你更加接受自己，由你自己来掌握取舍和得失。 我们为何拖延表面上看来，拖延症是因为懒，或者是对时间管理能力不足而造成的。而本书告诉了我们一个真正的原因，拖延症的成因主要是源于内心的恐惧。 由于家庭、性格、以及自己的各种经历，会导致人们产生各种各样的恐惧。很多拖延者并不能识别所有这些活跃于表面现象之下的情绪波动，因为他们利用拖延来逃避不舒服的感受。为了对付这些恐惧，我们产生了一种防卫机制来对抗恐惧，而拖延就是用来避免恐惧的。这样的反应模式一次次循环，让我们一次次的陷入了“拖延怪圈”中。 对于“拖延怪圈”，每个人都有自己不同的体验。你或许在几个星期、几个月，甚至几年时间内都挣扎在这个怪圈当中，或者，你也可能从头到尾只需要几个小时就经历了一个怪圈。 “这次我想早点开始。” “我得马上开始。” “我不开始又怎么样呢？” a.“我应该早点开始。” b.“我可以做任何事，除了这件……” c.“我无法享受任何事情。” d.“我希望没人发现。” “还有时间。” “我这个人有毛病。” 最后的抉择：做还是不做。 道路之一：不做 a.“我无法忍受了！” b.“何必庸人自扰呢？” 道路之二：背水一战 a.“我不能再坐等了。” b.“事情还没有这么糟，为什么当初我不早一点开始做呢？” c.“把它做完就行了！” “我永远不会再拖延！” 人们之所以产生拖延的不良习性，是因为他们害怕。他们害怕如果他们行动了，他们的行为会让他们陷入麻烦。他们担心如果展示了自己真实的一面，会有危险的结果等着他们。在所有无序和拖拉的背后，他们其实在害怕他们不被接受，以至于他们不仅躲开这个世界，甚至还躲开他们自己。虽然要忍受自责、自轻和对自己的反感是相当痛苦的，但是比起去看清真实的自我所带来的脆弱和无地自容，这样的感受或许更能够被承受得起，拖延是保护他们的盾牌。 如何改变拖延做出改变和学会一种新的行为模式是一个渐进的过程，这是一个可以预知的改变顺序，称为为“改变的阶段”。 第一阶段，“前关注”，没有准备做出改变，甚至都没有想过要做改变。 第二阶段，“关注”，通过阅读这本书，你知道了拖延是因为恐惧，你开始思考是否准备采取行动。 第三阶段，“准备”，做了一点尝试，虽然没有完全投入其中。“好吧，我终于要开始锻炼身体了”。 第四阶段，“行动”，“我今天去健身房，感觉还不错”。 当你迟迟不肯记账的时候，你可能是不想面对花费过大而收入过少的事实。当你一直不回短信的时候，你可能在恐惧跟陌生人打交道。当你迟迟不想写论文的时候，你可能是担心论文会占用所有的娱乐时间。 无论你的任何拖延是出于什么奇奇怪怪的原因，我们都应该坦然接受。慢慢来，不管你多么渴望改善自己，也不管你怎样努力，你不可能在第二天，或者下个星期，或者下个月，就一下子停止拖延了。 当我们再一次面对一件难事，大脑依然会收到恐惧信号，焦虑会立刻袭来，此时请提醒自己，不要重蹈覆辙，而是要改变心态，跳出拖延。 当你知道自己花钱太多，收入太少时，你可以提醒你自己，年轻人收入低，没关系，能进步就好。当你害怕和陌生人打交道是，你可以告诉自己，很多人都在做这样的事情。 观察你内心的抵抗情绪，虽然你在处理拖延问题上开始有所进步，但是你可能还是会因为自己努力不够、进步不大或者没有完成自己设定的所有目标而对自己感到失望或者生气。或者，你也可能会觉得我们对你要求太多了。不管抵抗情绪采取什么样的形式表现出来，它会让你停留在原地停滞不前。 通过树立新的行为模式和思维方法，我们就可以舒缓恐惧所带来的焦虑和压力，而不是靠拖延来逃避恐惧。 除此之外，涉及一些具体的改变拖延方法方面，书中还给出了很多实用性的建议，比如： 明确自己的目标与可行性的计划，启动一周试验。 学会更好的判断时间，提升你定是能力的技巧，让自己的时间观念通常跟“钟表时间”同步。 学会接受有益于你的人和事，学会结局那些没有意义的追求。 通过运动来启动你的状态，从拖延的麻痹状态中解救出来。 总结本书指出了人们之所以拖延的很多原因，认为拖延是心理问题。就像书中说的那样，光是认清楚拖延的根源还是不够的，你还必须做一些事情以防止拖延来主导你的生活，采用一些书中的建议，并行动起来。最后去尝试一种新的行为模式，感受自己的拖延，如实的去接受它，不再躲避，打破自己的拖延循环。 参考 《拖延心理学》，豆瓣读书 速读《拖延心理学》，bilibili","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://veinin.com/categories/读书笔记/"}],"tags":[{"name":"拖延症","slug":"拖延症","permalink":"http://veinin.com/tags/拖延症/"},{"name":"心理学","slug":"心理学","permalink":"http://veinin.com/tags/心理学/"}]},{"title":"《Linux 命令行与shell脚本编程大全》读书笔记（命令行部分）","slug":"reading-notes-linux-command-lime","date":"2017-11-24T15:30:00.000Z","updated":"2017-11-26T15:36:17.768Z","comments":true,"path":"2017/11/24/reading-notes-linux-command-lime/","link":"","permalink":"http://veinin.com/2017/11/24/reading-notes-linux-command-lime/","excerpt":"什么是 LinuxLinux可划分为以下四部分： Linux内核 系统内存管理 软件程序管理 硬件设备管理 文件系统管理 GNU工具GNU组织（GNU是GNU’s Not Unix的缩写），模仿Unix操作系统开发一系列标准的计算机系统工具，但没有可以运行它们的内核系统。","text":"什么是 LinuxLinux可划分为以下四部分： Linux内核 系统内存管理 软件程序管理 硬件设备管理 文件系统管理 GNU工具GNU组织（GNU是GNU’s Not Unix的缩写），模仿Unix操作系统开发一系列标准的计算机系统工具，但没有可以运行它们的内核系统。 核心GNU工具该项目移植了很多常见的Unix系统命令行工具。供Linux系统使用的这组核心工具被称为coreutils（coreutilities）软件包。由三部分构成：用以处理文件的工具、用以操作文本的工具、用以管理进程的工具 shellGNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。 shell的核心是命令行提示符。命令行提示符是shell负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中执行。所有Linux发行版默认的shell都是bash shell。 图形化桌面环境 X Window系统 KDE桌面（K Desktop Environment， K桌面环境） GNOME桌面（the GNU Network Object Model Environment， GNU网络对象模型环境） Unity桌面…… 应用软件Linux 发行版不同的Linux发行版通常归类为3种： 完整的核心Linux发行版核心Linux发行版含有内核、一个或多个图形化桌面环境以及预编译好的几乎所有能见到的Linux应用。它提供了一站式的完整Linux安装。 特定用途的发行版它们通常基于某个主流发行版，但仅包含主流发行版中一小部分用于某种特定用途的应用程序。如许多特定用途的Linux发行版都是基于Debian Linux，但仅打包了完整Debian系统中的一小部分。 LiveCD测试发行版它无需安装就可以看到Linux系统是什么样的。多数现代PC都能从CD启动，而不是必须从标准硬盘启动。基于这点，一些Linux发行版创建了含有Linux样本系统（称为Linux LiveCD）的可引导CD。 bash 手册man命令用来访问存储在Linux系统上的手册页面。在想要查找的工具的名称前面输入man命令，就可以找到那个工具相应的手册条目。手册每个内容区域都分配了一个数字，从1开始，一直到9：1：可执行程序或shell命令2：系统调用3：库调用4：特殊文件5：文件格式与约定6：游戏7：概览、约定及杂项8：超级用户和系统管理员命令9：内核例程 过滤输出列表ls命令能够识别标准通配符，并在过滤器中用它们进行模式匹配： 问号（?）代表一个字符； 星号（*）代表零个或多个字符。 在特定位置上可能出现的两种字符，a或i: 1ls -l my_scr[ai]pt 指定字符范围，例如字母范围[a – i]: 1ls -l f[a-i]ll 使用感叹号（!）将不需要的内容排除在外: 1ls -l f[!a]ll 管理文件目录处理文件 创建文件：touch 复制文件：cp 重命名文件：mv 删除文件：rm 链接文件：ln在系统上维护同一文件的两份或多份副本，除了保存多份单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法。这种虚拟的副本就称为链接。 文件链接在Linux中有两种不同类型的文件链接： 符号链接符号链接就是一个实实在在的文件，它指向存放在虚拟目录结构中某个地方的另一个文件。这两个通过符号链接在一起的文件，彼此的内容并不相同。使用ln命令以及-s选项来创建符号链接：1ln -s data_file sl_data_file 硬链接硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件。引用硬链接文件等同于引用了源文件。使用ln命令时不再需要加入额外的参数创建硬链接：1ln code_file hl_code_file 查看文件 显示文本文件中所有数据；cat 显示文本文件的内容，但会在显示每页数据之后停下来：more more命令的升级版：less 显示文件最后几行的内容：tail 显示文件开头那些行的内容：head 处理目录 创建目录：mkdir New_Dir 创建多个目录和子目录，需要加入-p参数：mkdir -p New_Dir/Sub_Dir/Under_Dir 删除目录，只删除空目录：rmdir New_Dir 删除目录及其所有内容：rm -rf Small_Dir 查看文件类型：file my_file 处理数据文件排序、搜索 排序数据：sort [options] [file] 搜索数据：grep [options] pattern [file] 压缩数据Linux上的文件压缩工具： bzip2，采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码，文件扩展名：.bz2 compress，最初的Unix文件压缩工具，已经快没人用了，文件扩展名：.Z gzip，GNU压缩工具，用Lempel-Ziv编码，文件扩展名：.gz zip，Windows上PKZIP工具的Unix实现，文件扩展名：.zip gzip 软件包是GNU项目的产物，意在编写一个能够替代原先Unix中compress工具的免费版本。这个软件包含有下面的工具： gzip：用来压缩文件。 gzcat：用来查看压缩过的文本文件的内容。 gunzip：用来解压文件。 归档数据虽然zip命令能够很好地将数据压缩和归档进单个文件，但它不是Unix和Linux中的标准归档工具。目前，Unix和Linux上最广泛使用的归档工具是tar命令。 tar命令的格式：1tar function [options] object1 object2 ... function参数定义了tar命令应该做什么： -A –concatenate 将一个已有tar归档文件追加到另一个已有tar归档文件 -c –create 创建一个新的tar归档文件 -d –diff 检查归档文件和文件系统的不同之处 –delete 从已有tar归档文件中删除 -r –append 追加文件到已有tar归档文件末尾 -t –list 列出已有tar归档文件的内容 -u –update 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中 -x –extract 从已有tar归档文件中提取文件 每个功能可用选项来针对tar归档文件定义一个特定行为： -C dir 切换到指定目录 -f file 输出结果到文件或设备file -j 将输出重定向给bzip2命令来压缩内容 -p 保留所有文件权限 -v 在处理文件时显示文件 -z 将输出重定向给gzip命令来压缩内容 列出归档内容：tar -tf test.tar提取归档内容：tar -xvf test.tar创建归档文件：tar -cvf test.tar test/ test2 管理进程探查进程当程序运行在系统上时，我们称之为进程（process）。想监测这些进程，需要熟悉ps命令的用法。使用ps命令的关键不在于记住所有可用的参数，而在于记住最有用的那些参数。 123456$ ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 Aug21 ? 00:07:16 /usr/lib/systemd/systemd --system --deserialize 26root 2 0 0 Aug21 ? 00:00:04 [kthreadd]root 3 2 0 Aug21 ? 00:00:28 [ksoftirqd/0]root 7 2 0 Aug21 ? 00:00:00 [migration/0] 常用参数： -e参数指定显示所有运行在系统上的进程； -f参数则扩展了输出，这些扩展的列包含了有用的信息。 -l参数，它会产生一个长格式输出。 这些扩展的列包含了有用的信息： UID：启动这些进程的用户。 PID：进程的进程ID。 PPID：父进程的进程号（如果该进程是由另一个进程启动的）。 C：进程生命周期中的CPU利用率。 STIME：进程启动时的系统时间。 TTY：进程启动时的终端设备。 TIME：运行进程需要的累计CPU时间。 CMD：启动的程序名称。 实时监测进程想观察那些频繁换进换出的内存的进程趋势，top命令刚好适用这种情况。 12345678910111213top - 15:54:00 up 95 days, 10:46, 1 user, load average: 0.14, 0.07, 0.06Tasks: 176 total, 1 running, 175 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 602816 total, 65452 free, 248696 used, 288668 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 177264 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 170 root 20 0 0 0 0 S 0.3 0.0 20:03.70 xfsaild/sda114270 root 20 0 828800 24620 2880 S 0.3 4.1 19:15.48 dockerd16454 systemd+ 20 0 888224 33020 0 S 0.3 5.5 7:18.88 mysqld31990 veining+ 20 0 155620 2216 1500 R 0.3 0.4 0:00.04 top 1 root 20 0 193496 4944 2392 S 0.0 0.8 7:25.59 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:04.07 kthreadd 输出的第一部分显示的是系统的概况： 第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载。 第二行显示了进程概要信息——top命令的输出中将进程叫作任务（task）：有多少进程处在运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）。 第三行显示了CPU的概要信息。 top根据进程的属主（用户还是系统）和进程的状态（运行、空闲还是等待）将CPU利用率分成几类输出。 最后两行说明了系统内存的状态。第一行说的是系统的物理内存：总共有多少内存，当前用了多少，还有多少空闲。后一行说的是同样的信息，不过是针对系统交换空间（如果分配了的话）的状态而言的。 最后一部分显示了当前运行中的进程的详细列表，有些列跟ps命令的输出类似： PID：进程的ID。 USER：进程属主的名字。 PR：进程的优先级。 NI：进程的谦让度值。 VIRT：进程占用的虚拟内存总量。 RES：进程占用的物理内存总量。 SHR：进程和其他进程共享的内存总量。 S：进程的状态（D代表可中断的休眠状态， R代表在运行状态， S代表休眠状态， T代表跟踪状态或停止状态， Z代表僵化状态）。 %CPU：进程使用的CPU时间比例。 %MEM：进程使用的内存占可用内存的比例。 TIME+：自进程启动到目前为止的CPU时间总量。 COMMAND：进程所对应的命令行名称，也就是启动的程序名。 结束进程在Linux中，进程之间通过信号来通信。进程的信号就是预定义好的一个消息，进程能识别它并决定忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。 在Linux上有两个命令可以向运行中的进程发出进程信号。 kill命令：kill 3940kill命令可通过进程ID（PID）给进程发信号。默认情况下，kill命令会向命令行中列出的全部PID发送一个TERM信号。遗憾的是，你只能用进程的PID而不能用命令名，所以kill命令有时并不好用。 killall命令：killall http*killall命令非常强大，它支持通过进程名而不是PID来结束进程。 killall命令也支持通配符，这在系统因负载过大而变得很慢时很有用。 管理磁盘Linux文件系统将所有的磁盘都并入一个虚拟目录下。在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作称为挂载（mounting）。如果用的Linux发行版不支持自动挂载和卸载可移动存储媒体，就必须手动完成。 mount命令Linux上用来挂载媒体的命令叫作mount。默认情况下， mount命令会输出当前系统上挂载的设备列表。12345$ mountsysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=294632k,nr_inodes=73658,mode=755)securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime) mount命令提供如下四部分信息： 媒体的设备文件名 媒体挂载到虚拟目录的挂载点 文件系统类型 已挂载媒体的访问状态 手动挂载媒体设备的基本命令：1mount -t type device directory umount命令从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。umount命令的格式非常简单：1umount [directory | device ] df 命令有时你需要知道在某个设备上还有多少磁盘空间。df命令可以让你很方便地查看所有已挂载磁盘的使用情况常用参数是-h，它会把输出中的磁盘空间按照用户易读的形式显示，通常用M来替代兆字节，用G替代吉字节。12345$ dfFilesystem 1K-blocks Used Available Use% Mounted on/dev/sda1 10474496 8675760 1798736 83% /devtmpfs 294632 0 294632 0% /devtmpfs 301408 0 301408 0% /dev/shm df命令会显示每个有数据的已挂载文件系统。命令输出如下： 设备的设备文件位置； 能容纳多少个1024字节大小的块； 已用了多少个1024字节大小的块； 还有多少个1024字节大小的块可用； 已用空间所占的比例； 设备挂载到了哪个挂载点上。 du 命令du命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这一方法可用来快速判断系统上某个目录下是不是有超大文件。 能让du命令用起来更方便的几个命令行参数： -c：显示所有已列出文件总的大小。 -h：按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节。 -s：显示每个输出参数的总计。 理解Shellshell 的类型系统启动什么样的shell程序取决于你个人的用户ID配置，在/etc/passwd文件中。默认的交互shell会在用户登录某个虚拟控制台终端或在GUI中运行终端仿真器时启动。不过还有另外一个默认shell是/bin/sh，它作为默认的系统shell，用于那些需要在启动时使用的系统shell脚本。 shell 的父子关系用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell，是一个父shell。在CLI提示符后输入/bin/bash命令或其他等效的bash命令时， 会创建一个新的shell程序。这个shell程序被称为子shell（child shell） 。 bash shell程序可使用命令行参数修改shell启动方式： -c string 从string中读取命令并进行处理 -i 启动一个能够接收用户输入的交互shell -l 以登录shell的形式启动 -r 启动一个受限shell，用户会被限制在默认目录中 -s 从标准输入中读取命令 依次运行的一系列命令。这可以通过命令列表来实现，只需要在命令之间加入分号（;）即可：pwd ; ls ; cd /etc ; pwd ; 要想将命令置入后台模式，可以在命令末尾加上字符&amp;：sleep 3000&amp; 协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。使用coproc命令进行协程处理：coproc sleep 10 理解 shell 的内建命令外部命令外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、 /usr/bin、 /sbin或/usr/sbin中。ps就是一个外部命令。你可以使用which和type命令找到它。当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。外部命令ps很方便显示出它的父进程以及自己所对应的衍生子进程。 内建命令内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。cd和exit命令都内建于bash shell。可以利用type命令来了解某个命令是否是内建的：123456$ type psps is hashed (/usr/bin/ps)$$ type -a echoecho is a shell builtinecho is /bin/echo 查看最近用过的命令列表：history 为常用的命令（及其参数）创建另一个名称：alias 要查看当前可用的别名，使用alias命令以及选项-p：alias -p 环境变量Linux环境变量能帮你提升Linux shell体验。很多程序和脚本都通过环境变量来获取系统信息、存储临时数据和配置信息。在Linux系统上有很多地方可以设置环境变量，了解去哪里设置相应的环境变量很重要。在涉及环境变量名时，如果要用到变量，使用$；如果要操作变量，不使用$。 在bash shell中，环境变量分为两类： 全局变量全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的shell可见。这让全局环境变量对那些所创建的子shell需要获取父shell信息的程序来说非常有用。要查看全局变量，可以使用 env 或 printenv 命令。 要显示个别环境变量的值，可以使用 printenv 命令：12$ printenv HOME/home/veininguo 也可以使用 echo 显示变量的值。在变量前面加上一个美元符（$）:12echo $HOME/home/veininguo 局部变量局部环境变量只能在定义它们的进程中可见。在Linux系统并没有一个只显示局部环境变量的命令。 set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。 设置用户定义变量可以在bash shell中直接设置自己的变量。 设置局部用户定义变量创建在shell进程内可见的局部变量，但在子shell中无法使用用户定义变量。可以通过等号给环境变量赋值，值可以是数值或字符串。所有的环境变量名均使用大写字母，如果是你自己创建的局部变量或是shell脚本，请使用小写字母。变量名、等号和值之间没有空格，这一点非常重要。123$ my_variable=&quot;Veinin Guo&quot;$ echo $my_variableVeinin Guo 设置全局环境变量在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。通过export命令来完成，变量名前面不需要加$。子shell无法使用export命令改变父shell中全局环境变量的值。1234567891011121314$ my_variable=&quot;I am Global now&quot;$ export my_variable$$ echo $my_variableI am Global now$$ bash$ echo $my_variableI am Global now$$ exitexit$ echo $my_variableI am Global now 删除环境变量可以用 unset 命令完成这个操作。在命令中引用环境变量时不要使用$。1234$ echo $my_variableI am Global now$ unset my_variable$ echo $my_variable 设置 PATH 环境变量在 shell 命令行界面中输入一个外部命令时， shell 必须搜索系统来找到对应的程序。PATH 环境变量定义了用于进行命令和程序查找的目录。PATH中的目录使用冒号分隔。 12$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/veininguo/.local/bin:/home/veininguo/bin 把新的搜索目录添加到现有的PATH环境变量中，无需从头定义。PATH中各个目录之间是用冒号分隔的。你只需引用原来的PATH值，然后再给这个字符串添加新目录就行了。也将单点符也加入PATH环境变量，单点符代表当前目录。 123456789$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/veininguo/.local/bin:/home/veininguo/bin$$ PATH=$PATH:/usr/games:/usr/local/games$$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/veininguo/.local/bin:/home/veininguo/bin:/usr/games:/usr/local/games$$ PATH=$PATH:. 定位系统环境变量在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作启动文件或环境文件。在大多数发行版中，存储个人用户永久性bash shell变量的地方是$HOME/.bashrc文件。 启动bash shell有3种方式： 登录时作为默认登录shell，登录shell会从5个不同的启动文件里读取命令： /etc/profile，是bash shell默认的的主启动文件。只要你登录了Linux系统， bash就会执行/etc/profile启动文件中的命令。 $HOME目录下的启动文件，剩下的启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环境变量。大多数Linux发行版只用这四个启动文件中的一到两个：$HOME/.bash_profile$HOME/.bashrc$HOME/.bash_login$HOME/.profile 作为非登录shell的交互式shell如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入bash时启动），那么你启动的shell叫作交互式shell。交互式shell启动时，只会检查用户HOME目录中的.bashrc文件。 作为运行脚本的非交互shell系统执行shell脚本时用的就是这种shell。不同的地方在于它没有命令行提示符。但是当你在系统上运行脚本时，也许希望能够运行一些特定启动的命令，为了处理这种情况， bash shell提供了BASH_ENV环境变量。 数组变量要给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔。1$ mytest=(one two three four five) 引用一个单独的数组元素，就必须用代表它在数组中位置的数值索引值。索引值要用方括号括起来。12$ echo $&#123;mytest[2]&#125;three 文件权限缺乏安全性的系统不是完整的系统。系统中必须有一套能够保护文件免遭非授权用户浏览或修改的机制。 Linux沿用了Unix文件权限的办法，即允许用户和组根据每个文件和目录的安全性设置来访问文件。 Linux 的安全性Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。用户对系统中各种对象的访问权限取决于他们登录系统时用的账户。用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是登录名。 /etc/passwd 文件这个文件将用户的登录名匹配到对应的UID值，它包含了一些与用户有关的信息。 1234567$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologin...veininguo:x:1000:1001::/home/veininguo:/bin/bashdockerroot:x:996:993:Docker User:/var/lib/docker:/sbin/nologin /etc/passwd文件的字段包含了如下信息： 登录用户名 用户密码 用户账户的UID（数字形式） 用户账户的组ID（GID）（数字形式） 用户账户的文本描述（称为备注字段） 用户HOME目录的位置 用户的默认shell /etc/shadow 文件/etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow文件，这让它比起/etc/passwd安全许多。etc/shadow文件为系统上的每个用户账户都保存了一条记录。记录就像下面这样：1veininguo:*:17399:0:99999:7::: 每条记录中都有9个字段： 与/etc/passwd文件中的登录名字段对应的登录名 加密后的密码 自上次修改密码后过去的天数密码（自1970年1月1日开始计算） 多少天后才能更改密码 多少天后必须更改密码 密码过期前提前多少天提醒用户更改密码 密码过期后多少天禁用用户账户 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示） 预留字段给将来使用 添加新用户用来向Linux系统添加新用户的主要工具是useradd。系统默认值被设置在/etc/default/useradd文件中。 在创建新用户时，如果你不在命令行中指定具体的值， useradd命令就会使用-D选项所显示的那些默认值。这个例子列出的默认值如下： 新用户会被添加到GID为100的公共组； 新用户的HOME目录将会位于/home/loginname； 新用户账户密码在过期后不会被禁用； 新用户账户未被设置过期日期； 新用户账户将bash shell作为默认shell； 系统会将/etc/skel目录下的内容复制到用户的HOME目录下； 系统为该用户账户在mail目录下创建一个用于接收邮件的文件。 默认情况下，useradd命令不会创建HOME目录，但是-m命令行选项会使其创建HOME目录。 12345678$ sudo useradd -m test$ sudo ls -al /home/test/total 12drwx------. 2 test test 62 Nov 26 13:18 .drwxr-xr-x. 4 root root 35 Nov 26 13:18 ..-rw-r--r--. 1 test test 18 Sep 6 16:25 .bash_logout-rw-r--r--. 1 test test 193 Sep 6 16:25 .bash_profile-rw-r--r--. 1 test test 231 Sep 6 16:25 .bashrc 删除用户userdel可以从系统中删除用户， 加上-r参数， userdel会删除用户的HOME目录以及邮件目录。 1234$sudo userdel -r test$$ sudo ls -al /home/test/ls: cannot access /home/test/: No such file or directory 修改用户Linux提供了一些不同的工具来修改已有用户账户的信息： usermod，修改用户账户的字段，还可以指定主要组以及附加组的所属关系。常用参数如下：-c修改备注字段。-e修改过期日期。-g修改默认的登录组。-l修改用户账户的登录名。-L锁定账户，使用户无法登录。-p修改账户的密码。-U解除锁定，使用户能够登录。 passwd和chpasswd改变用户密码的一个简便方法就是用passwd命令。如果需要为系统中的大量用户修改密码， chpasswd命令可以事半功倍。 chsh、 chfn和chagechsh、 chfn和chage工具专门用来修改特定的账户信息。chsh命令用来快速修改默认的用户登录shell。chfn命令提供了在/etc/passwd文件的备注字段中存储信息的标准方法。chage命令用来帮助管理用户账户的有效期。 Linux 组组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。每个组都有唯一的GID——跟UID类似，在系统上这是个唯一的数值。 /etc/group 文件/etc/group文件包含系统上用到的每个组的信息。 12345$ cat /etc/grouproot:x:0:bin:x:1:daemon:x:2:... /etc/group文件有4个字段： 组名 组密码 ID 属于该组的用户列表 创建新组groupadd命令可在系统上创建新组。1234$ sudo groupadd shared$ tail /etc/groupdocker:x:992:shared:x:1002: usermod命令将用户被分配到该组。12345$ sudo usermod -G shared test$$ tail /etc/groupshared:x:1002:testtest:x:1003: 修改组groupmod命令可以修改已有组的GID（加-g选项）或组名（加-n选项）。12345$ sudo groupmod -n sharering shared$ tail /etc/groupgoogle-sudoers:x:1000:veininguotest:x:1003:sharering:x:1002:test 文件权限文件权限符ls命令可以用来查看Linux系统上的文件、目录和设备的权限。123$ ls -ltotal 1693436drwxrwxr-x. 2 veininguo veininguo 6 Nov 21 16:08 data_file 输出结果的第一个字段就是描述文件和目录权限的编码。第一个字符代表了对象的类型： -代表文件 d代表目录 l代表链接 c代表字符型设备 b代表块设备 n代表网络设备 之后有3组三字符的编码。每一组定义了3种访问权限： r代表对象是可读的 w代表对象是可写的 x代表对象是可执行的 若没有某种权限，在该权限位会出现单破折线。这3组权限分别对应对象的3个安全级别： 对象的属主 对象的属组 系统其他用户 改变权限chmod命令用来改变文件和目录的安全性设置：chmod options mode file chmod命令采用了另一种方法。下面是在符号模式下指定权限的格式：[ugoa…][[+-=][rwxXstugo…]第一组字符定义了权限作用的对象： u代表用户 g代表组 o代表其他 a代表上述所有 现有权限基础上增加权限（+），还是在现有权限基础上移除权限（-），或是将权限设置成后面的值（=）1234567$ chmod o+r newfile$ ls -lF newfile-rwxrw-r-- 1 rich rich 0 Sep 20 19:16 newfile$$ chmod u-x newfile$ ls -lF newfile-rw-rw-r-- 1 rich rich 0 Sep 20 19:16 newfile 改变所属关系chown命令用来改变文件的属主。1234567$ chown dan newfile$ ls -l newfile-rw-rw-r-- 1 dan rich 0 Sep 20 19:16 newfile$$ chown dan.shared newfile$ ls -l newfile-rw-rw-r-- 1 dan shared 0 Sep 20 19:16 newfile chgrp命令可以更改文件或目录的默认属组。123$ chgrp shared newfile$ ls -l newfile-rw-rw-r-- 1 rich shared 0 Sep 20 19:16 newfile 文件系统使用Linux系统时，需要作出的决策之一就是为存储设备选用什么文件系统。大多数Linux发行版在安装时会非常贴心地提供默认的文件系统，了解一下可用的选择有时也会有所帮助。 Linux 文件系统 ext文件系统，最早的文件系统，叫作扩展文件系统 （extended filesystem，简记为ext）。 ext2文件系统，ext文件系统有不少限制，比如文件大小不得超过2 GB。ext文件系统就升级到了第二代扩展文件系统，叫作ext2。 日志文件系统日志文件系统为Linux系统增加了一层安全性。它不再使用之前先将数据直接写入存储设备再更新索引节点表的做法，而是先将文件的更改写入到临时文件（称作日志， journal）中。在数据成功写到存储设备和索引节点表之后，再删除对应的日志条目。 ext3文件系统，它采用和ext2文件系统相同的索引节点表结构，但给每个存储设备增加了一个日志文件，以将准备写入存储设备的数据先记入日志。 ext4文件系统，扩展ext3文件系统功能的结果是ext4文件系统。 Reiser文件系统。 JFS文件系统，最老的日志文件系统之一， 是IBM在1990年为其Unix衍生版AIX开发的。 XFS文件系统，美国硅图公司（SGI）最初在1994年为其商业化的IRIX Unix系统开发的。 写时复制文件系统写时复制（copy-on-write， COW）的技术。COW利用快照兼顾了安全性和性能。如果要修改数据，会使用克隆或可写快照。修改过的数据并不会直接覆盖当前数据，而是被放入文件系统中的另一个位置上。即便是数据修改已经完成，之前的旧数据也不会被重写。 ZFS文件系统，没有使用GPL许可。OpenZFS项目有可能改变这种局面。 Btrf文件系统，被称为B树文件系统。它是由Oracle公司于2007年开始研发的。 操作文件系统创建分区：fdisk工具用来帮助管理安装在系统上的任何存储设备上的分区。创建文件系统：每个文件系统命令都有很多命令行选项，允许你定制如何在分区上创建文件系统。 逻辑卷管理如果硬盘上没有地方了，你就必须弄一个更大的硬盘，然后手动将已有的文件系统移动到新的硬盘上。Linux逻辑卷管理器（logical volume manager， LVM）软件包可以用来做动态地添加存储空间。 安装软件程序Linux开发人员通过把软件打包成更易于安装的预编译包，在Linux上能见到的各种包管理系统（package management system， PMS），以及用来进行软件安装、管理和删除的命令行工具。 基于 Debian 的系统dpkg命令是基于Debian系PMS工具的核心。包含在这个PMS中的其他工具有： apt-get apt-cache aptitude 基于 Red Hat 的系统和基于Debian的发行版类似，基于Red Hat的系统也有几种不同的可用前端工具。常见的有以下3种。 yum：在Red Hat和Fedora中使用。 urpm：在Mandriva中使用。 zypper：在openSUSE中使用。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://veinin.com/categories/读书笔记/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://veinin.com/tags/Linux/"},{"name":"Linux 命令行","slug":"Linux-命令行","permalink":"http://veinin.com/tags/Linux-命令行/"}]},{"title":"《单核工作法》读书笔记","slug":"reading-notes-monotasking","date":"2017-11-12T15:30:00.000Z","updated":"2018-03-30T14:59:23.142Z","comments":true,"path":"2017/11/12/reading-notes-monotasking/","link":"","permalink":"http://veinin.com/2017/11/12/reading-notes-monotasking/","excerpt":"《单核工作法图解》是Staffan先生多年自我管理实践与咨询经验的结晶，阅读这本书让人收获颇多。该书轻松易读，引用了大量前沿研究，也提出了一系列可实践的方法。 自我管理方法不是科学，是技术。脑科学的研究日新月异，但多数人不会去阅读科研文献，就需要有人把这些新发现翻译成可操作的技术，才能运用到生活中，所以自我管理方法也在随着科学的发展而不停前进。 正确的方法是一个方面，另一个重要的方面是，你能不能把正确的方法转化为持续的行动，并且养成长久的习惯。讲方法的书其实用不着贪多求全，关键是看你能不能用起来。","text":"《单核工作法图解》是Staffan先生多年自我管理实践与咨询经验的结晶，阅读这本书让人收获颇多。该书轻松易读，引用了大量前沿研究，也提出了一系列可实践的方法。 自我管理方法不是科学，是技术。脑科学的研究日新月异，但多数人不会去阅读科研文献，就需要有人把这些新发现翻译成可操作的技术，才能运用到生活中，所以自我管理方法也在随着科学的发展而不停前进。 正确的方法是一个方面，另一个重要的方面是，你能不能把正确的方法转化为持续的行动，并且养成长久的习惯。讲方法的书其实用不着贪多求全，关键是看你能不能用起来。 怎样的方法是真正可以帮助我们的方法？两点心得与你分享：一、它应是一套有逻辑的系统方法，而不光是鸡汤；二、这套方法应当易于使用。 果壳中的单核工作法什么是单核工作法？快捷清单 是单核工作法的核心。它最多存放5项当前最重要的任务。如果还要添加更多的任务，就必须删掉原有任务。 单核时段 只用于专心处理快捷清单上的一项任务。以全景闹钟作为单核时段的结束。 全景闹钟 应该设置在分针的下一个竖直位置，例如9:00、9:30、10:00，但距离现在不少于25分钟。在闹钟响铃时，把注意力从单核时段切换到全景时段。 全景时段 期间查看所有的待办任务，并且思考“拉金问题”（Lakein’squestion）：此时此刻，我的时间最好用来做什么？ 颠倒优先级 是指把紧急任务排到重要任务之前，应该避免。完成最重要的任务，我们的长期目标才能实现。 单核工作法的五大原理 原理1：已经开始的任务会无条件地占据我们每天的所思所想，直到被完成或删除。 原理2：多任务切换不仅会拖慢速度，而且注定会耗尽大脑能量。 原理3：我们应该负起区分优先级的责任，选出现在头号重要的事来做。因为会不断有各种事情出现在我们脑海中，值得做的事数不清。 原理4：经常休息、好好睡觉、锻炼身体、吃得健康——我们必须在这些事情上进行投资，才能在日常工作中稳步前进。 原理5：我们的方法必须适应环境；要根据自己最新的个人经验，一点一点调整。没有放之四海皆准的方法。 颠倒优先级“我把问题分成两类：重要的和紧急的。紧急的问题不重要，重要的问题从来不紧急。”把紧急任务放在重要任务之前做，就是颠倒优先级。要事第一。你花在紧急事情上的时间越多，紧急工作就会堆积得越高。那些本来重要但不紧急的任务也会变成紧急任务。 “我没时间”是谎言我们每天都有新的24小时，说“不”的原因并非缺少时间，真实原因是：我们给其他任务排了更高的优先级。因此，别再说“我没时间”了。制定你的优先级顺序，就是要选择把时间用在哪里。一旦定下来就别不好意思。保持透明度，允许其他人直面和质疑你的优先级排序，他们也会尊重和接受你的“不”。千万别说“我没时间”了。 全景闹钟使用计时器。使用单核工作法时，为了在全景模式和单核模式中切换，我们要在单核时段开始之前设置定时响铃的全景闹钟。闹钟响铃提醒我们重新评估优先级。 削减待办任务本周目的 把你的专注点放在“为什么”上。在这一周，你最想取得什么进展、得到什么收获、产出什么成果？把首要目的写入一张索引卡片，贴在工作间隔板上。每当迷茫的时候，本周目的可以提醒你。 快捷清单 包含当前最重要的5项任务。每天早晨把它们写在一张纸上。如果还要添加更多的任务，必须去掉原有的——要么完成一项、要么直接删掉一项。 集草器清单 收集一些未排序的任务和想法，都是你没有拒绝、但也不会马上做的事情。集草器清单则完全没有限制，也不排列优先级。你可以时不时添加内容进去。有什么点子就集中放在这里，免得一转身忘了。表格中的每项任务应该包括“目标、利益关系人、进入清单的日期”这三项属性。 除草 是删掉集草器清单里的内容，每个星期都要做。除草是一项必要工作，以便保持清单可读、及时、可靠。你随时都可以根据需要在集草器清单里增加内容，但应该每周做一次批量清理。 现在专注一件事多任务的误区 误导雇主们到处寻找三头六臂的人才，看谁有同时玩转很多事的本领。我们自以为能多线程处理任务，其实只是在多个任务间切换。任务切换会给手头的工作带来更多错误，拖慢速度。 单核与全景 两种时段帮你建立节奏感。单核工作意味着聚焦放大一项且仅此一项任务；全景总览意味着放眼全局，选择当前最重要的一件事。我们要在这两种模式间互相切换。 戒绝通知 的方法要求在单核工作期间关掉你能听到和看到的通知提醒。看一眼电子邮件之后要重新达到之前的工作状态，所花费的时间超过一分钟。自动推送的通知消息会引发服务生效应的负面作用，妨碍我们对有价值任务的专注。 志愿者小时 是应对中断的一个实用策略。如果同事在上午找你讨论问题，可以引导他的需求，安排一次下午的会议。这样你就有继续工作的余地，也能为同事的问题提前做准备。 时间压力 是自己给自己的。别人可能会说他的事情比较急，但时间压力是我们的内部事务。使用单核工作法，不用担心自己没有尽力，因为我们已将重要的任务排在紧急的任务之前。 永不拖延时间不一致 是指人们在评估自己未来的忙碌程度时，会认为近期超忙，远期不那么忙。这是人类思维的误区。跳出误区的方法是，现在就做最重要的事，对紧急程度不作考虑。 可支配时间 的浪费意味着，你本来有一段受保护的时间来处理最重要的任务，但却花在了其他事情上。我们必须确保足够珍视可支配时间的价值。浪费掉的时间不会再回来。 服务生效应 让我们知道，未完成的任务更容易被记住。正确利用这个效应有助于停止拖延；错误使用则会让拖延更严重。可以动用潜意识思维来促使我们完成最重要的任务，而不是其他任务。 自动坚持任务 是服务生效应的延伸。人类有一种强烈的意愿，想要完成被中断的任务。在下午下班前开始一项任务，这会鼓励你自己明天早晨回来继续做这件事。 内在动力 比奖励和惩罚的影响更大。自主是为自己的选择负起责任。专精是一种不断渴求进步的心态。目的可以激发你成为比自己更伟大事物的一部分。 循序渐进任务分解 可能是战胜拖延最有效的方式。开始做一项小任务，要比开始做一项大任务更容易。但要把大任务的整体目的牢记在心，而且不要提前把所有子任务规划得太详细。 拉金问题 ：“此时此刻我的时间最好用来做什么？”这是我们必须经常问自己的问题。要让工作取得成效，就必须经常检查成果并调整规划。 时间盒子 是要先确定：什么时候开始，什么时候结束，专注在什么任务上。这与工作成果的多少好坏无关，纯粹与注意力有关。当然，良好的专注度会带来更高的产出。 幼鸟先飞 让我们把想法尽早分享给别人，从而获得反馈。这些反馈有助于确定下一步行动的最佳方向：看，这些是已经实现的，接下来怎么做最好？ 虚假紧急 是一个坑人的骗局，让你把力气花在一些次要的任务上。它让你进入来者不拒的响应状态。但是用客观标准衡量，这些任务其实不重要，反而耽误事。它们让你忙来忙去，阻碍了真正的工作。 简化协作富足心态 是把你的时间、知识和人脉分享给同事。这不仅仅是助人为乐，他们也会回过头来分享给你。[1]对自己面前的选项有一个全面认识可以帮你打开局面，得到双赢的解决方案。 相处的责任 我们都应该承担起来。要明白，职场中的每个人都是和你我一样的独立个体。通过认识到他们的强项和弱项所在，我们可以更好地在协作中获益。 高效会议 要求你不仅仅是例行公事地逢会必到。这场会议有没有限定一项会议目的？你的贡献是否无关紧要？你自己组织会议时也要注意，如果没有清晰地描述出唯一的会议目的，就不要发出邀请。 议会场合 着眼于未来、以更有创造性的方式来讨论事情。永远不要为过去的事件责怪任何人，不要为核心价值观争论不休。想想从这里出发该如何往前走，是一种更有建设性的思路。 透明度 要求我们做到言出必践。如果这样还是落入了认知失调的陷阱，就必须后退一步，以开放的心态环顾四周，找出一条让各方共赢的新路径。 给创意充电经常休息 不仅可以让大脑歇口气，还能够激活潜意识思维的创造力。当你休息回来时，经常会有很棒的新想法。 充氧的大脑 是我们散步或运动时得到的效果。研究发现，成人如果每周进行150分钟的身体锻炼，就更不容易在白天昏昏欲睡，也更不容易出现注意力涣散的情况。 健康饮食 会影响到我们思维、创意和正确记忆的能力。那些快速释放葡萄糖的食物会让我们的能量忽高忽低。水果、蔬菜、全麦食品和适量摄入的蛋白质能产生更稳定的输出，给大脑持续提供能量。 充足睡眠 的原则已经被证实可以提高生产力、减少犯错。睡眠不足还意味着失去了快速眼动睡眠时间，导致难以完成记忆编码，无法对新记忆进行删除和整理。 思考的时候拿支铅笔 能够补充我们极度有限的工作记忆。大脑的结构天生不适合同时思考两件事情，而写下来的笔记更有利于前瞻记忆对问题进行处理。 思维导图 对长期记忆很有帮助。一项研究还显示它能提高批判性思维能力。我们的大脑喜欢在概念之间建立连接，可惜顺序结构的笔记和线性思维方式都做不到这一点。 本文大部分内容摘自：《单核工作法》，豆瓣读书、图灵社区","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://veinin.com/categories/读书笔记/"}],"tags":[{"name":"时间管理","slug":"时间管理","permalink":"http://veinin.com/tags/时间管理/"},{"name":"单核工作法","slug":"单核工作法","permalink":"http://veinin.com/tags/单核工作法/"}]},{"title":"Centos 从官方 Yum Repositories 安装 MySQL","slug":"centos-install-mysql","date":"2017-11-08T13:55:49.000Z","updated":"2017-11-08T14:12:47.019Z","comments":true,"path":"2017/11/08/centos-install-mysql/","link":"","permalink":"http://veinin.com/2017/11/08/centos-install-mysql/","excerpt":"介绍2013年10月，MySQL开发团队正式启动了对 Yum 版本库的支持。这意味着您现在可以确保您拥有从源代码直接安装的最新版本的 MySQL！本文将在全新的CentOS 6中安装 MySQL 5.7。5.7是当前默认最新版本，当然你也可以选择直接安装其他版本，可参考本文关于 选择指定版本安装章节。","text":"介绍2013年10月，MySQL开发团队正式启动了对 Yum 版本库的支持。这意味着您现在可以确保您拥有从源代码直接安装的最新版本的 MySQL！本文将在全新的CentOS 6中安装 MySQL 5.7。5.7是当前默认最新版本，当然你也可以选择直接安装其他版本，可参考本文关于 选择指定版本安装章节。 安装Yum 版本库文件需要从 MYSQL 开发者网站下载，安装完成后，使用 yum update 来确保你运行的是最新的MySQL版本，包括其安全更新，Yum 会帮你解决任何依赖关系，这使你安装过程变成很简单。 刚开始，你需要访问 MySQL Repositories ，选择 MySQL Yum Repository，根据你 CentOS 的版本，选择相应的下载链接，然后点击 Download。 右键 “No thanks, just start my download.” ， 点击 “复制链接地址”。 登录到您的服务器，根据复制的连接地址然后下载此文件。以下只是一个示例网址 - 你可能需要检查这个地址是否正确：1wget https://dev.mysql.com/get/mysql57-community-release-el6-11.noarch.rpm 从本地文件中安装下载好的 rpm 文件:1sudo yum localinstall mysql57-community-release-el6-11.noarch.rpm 您现在已经在服务器上从官方存储库安装了，但尚未安装任何软件。存储库包括MySQL服务器，MySQL Workbench管理工具和ODBC驱动程序。让我们安装MySQL服务器：1sudo yum install mysql-community-server 启动 MySQL 服务：1sudo service mysqld start 配置MySQL在重新启动时自动启动：12sudo chkconfig mysqld onchkconfig --list mysqld 到此，你的MySQL服务已经安装完成。 重置 Root 密码如果你安装的是 MySQL 5.7 版本，root 密码会自动生成，并在启动日志 /var/log/mysqld.log 里面输出。 获取初始密码：12grep &quot;password&quot; /var/log/mysqld.log2017-11-08T05:09:31.492454Z 1 [Note] A temporary password is generated for root@localhost: 1!Ta0EEis-yR 12登录 root 账号，如果默认密码为空，请去除 -p 参数：mysql -uroot -p &apos;1!Ta0EEis-yR&apos; 用你的新密码替换字符串 “ your_new_password “，如果你的版本是 5.6 或之前版本，请使用一下命令:123UPDATE mysql.user SET Password=PASSWORD(&apos;your_new_password&apos;) WHERE User=&apos;root&apos;;flush privileges;exit 如果你的版本是 5.7 版本，请使用以下命令：1ALTER USER USER() IDENTIFIED BY &apos; your_new_password &apos;; 如果提示：ERROR 1819 (HY000): Your password does not satisfy the current policy requirements，那是因为默认开启了简单密码检查政策，你可以通过以下命令关闭其功能：1set global validate_password_policy=0; 选择指定版本安装使用 MySQL Yum 存储库时，默认情况下选择最新的 GA 版本（当前为 MySQL 5.7）进行安装。 在 MySQL Yum 存储库中，MySQL社区服务器的不同版本托管在不同的子库中。最新的 GA 系列（目前是 MySQL 5.7）的子库是默认启用的，所有其他系列的子库（例如MySQL 5.6版本）默认是禁用的。可以使用以下命令查看 MySQL Yum 存储库中的所有子存储库，并查看其中哪些被启用或禁用：1yum repolist all | grep mysql 如果要安装最新的版本，不需要配置。如果要选择特定版本，请在运行安装命令之前，禁用最新 GA 版本的子库，并启用特定版本的子库。如果你的平台支持 yum-config-manager，你可以通过以下这些命令来实现，这些命令将禁用 5.7 版本的 subrepository，并启用5.6 版本的 subrepository：12sudo yum-config-manager --disable mysql57-communitysudo yum-config-manager --enable mysql56-community 除了使用 yum-config-manager 命令之外，还可以通过手动编辑 /etc/yum.repos.d/mysql-community.repo 文件来选择发行版，项目是一个典型的文件系列子库的条目信息：123456[mysql57-community]name=MySQL 5.7 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 找到要配置的子库的条目，然后编辑该 enabled 选项。指定 enabled=0 禁用子库，或 enabled=1 启用子库。例如，要安装MySQL 5.6，请确保您拥有 enabled=0 MySQL 5.7版本的上述子目录条目，并且具有 enabled=1 MySQL 5.6版本的条目：1234567# Enable to use MySQL 5.6[mysql56-community]name=MySQL 5.6 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-5.6-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 最后再运行安装命令（mysql-community-server），那么你安装到的是你想要的指定版本的 MySQL。","categories":[],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://veinin.com/tags/CentOS/"},{"name":"MySQL","slug":"MySQL","permalink":"http://veinin.com/tags/MySQL/"}]},{"title":"Lua 表序列化与反序列化","slug":"lua-serialize-table","date":"2017-11-01T14:11:17.000Z","updated":"2017-11-01T14:49:03.749Z","comments":true,"path":"2017/11/01/lua-serialize-table/","link":"","permalink":"http://veinin.com/2017/11/01/lua-serialize-table/","excerpt":"前言今天看了下同事写的关于 Lua 序列化的代码，觉得代码存在几个问题，其主要欠缺以下几点： 1.支持循环引用的 table，反序列后，能正确恢复循环引用状态，如：12local a = &#123;1, 2, 3&#125;a.b = &#123;4, 5, 6, a&#125;","text":"前言今天看了下同事写的关于 Lua 序列化的代码，觉得代码存在几个问题，其主要欠缺以下几点： 1.支持循环引用的 table，反序列后，能正确恢复循环引用状态，如：12local a = &#123;1, 2, 3&#125;a.b = &#123;4, 5, 6, a&#125; 2.字符串内支持内嵌双引号、支持转义字，如一下字符串：1local s = \"ss\\\"aa\\\"bb\\ncc\" 序列化后我希望是这样子：1'ss\"aa\"bb\\ncc' 3.Table 数组部分序列化后隐藏每个值得索引值，如：1local t = &#123;4, 7, 9&#125; 如果保留数组的索引值，会是这样子：1&#123;[1]=4,[2]=7,[3]=9&#125; 为了更加节省空间，我希望的是这样子：1&#123;4,7,9&#125; 实现对于以上几点要求，Google 搜了下，并没有找到满足上面需求的合适版本，于是在前人的基础上做了一些改进。实现部分，序列化函数函数为 table.tostring。反序列化函数相对来说比较简单，可以直接通过函数loadstring进行加载，下面实现为函数 table.loadstring 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function table.tostring(t) local mark = &#123;&#125; local assign = &#123;&#125; local function serialize(tbl, parent) mark[tbl] = parent local tmp = &#123;&#125; for k, v in pairs(tbl) do local typek = type(k) local typev = type(v) local key = typek == \"number\" and \"[\" .. k ..\"]\" or k if typev == \"table\" then local dotkey = parent .. (typek == \"number\" and key or \".\" .. key) if mark[v] then table.insert(assign, dotkey .. \"=\" .. mark[v]) else if typek == \"number\" then table.insert(tmp, serialize(v,dotkey)) else table.insert(tmp, key .. \"=\" .. serialize(v, dotkey)) end end else if typev == \"string\" then v = string.gsub(v, \"\\n\", \"\\\\n\") if string.match( string.gsub(v,\"[^'\\\"]\",\"\"), '^\"+$' ) then v = \"'\" .. v .. \"'\" else v = '\"' .. v .. '\"' end else v = tostring(v) end if typek == \"number\" then table.insert(tmp, v) else table.insert(tmp, key .. \"=\" .. v) end end end return \"&#123;\" .. table.concat(tmp, \",\") .. \"&#125;\" end return serialize(t, \"ret\") .. table.concat(assign,\" \")endfunction table.loadstring(str) local chunk = loadstring(\"do local ret = \" .. str .. \" return ret end\") if chunk then return chunk() endend 测试代码：12345678910111213141516171819local t = &#123;a = 1, b = 2&#125;t.rt = &#123;c = 3, d = 4, t&#125;local s = table.tostring(t)print(s) -- 输出 &#123;b=2,a=1,rt=&#123;c=3,d=4&#125;&#125;ret.rt[1]=retlocal tl = table.loadstring(s)assert(tl.a == t.a)----------------------------------------------local t = &#123;['foo']='bar', 11, 22, 33, \"ss\\\"aa\\\"bb\\ncc\", \"hello\", &#123;'a','b'&#125;&#125;local s = table.tostring(t)print(s) -- 输出 &#123;11,22,33,'ss\"aa\"bb\\ncc',\"hello\",&#123;\"a\",\"b\"&#125;,foo=\"bar\"&#125;local tl = table.loadstring(s)assert(tl.foo == t.foo)assert(tl[4] == 'ss\"aa\"bb\\ncc') 参考 云风的个人空间 lua-users wiki","categories":[{"name":"Lua","slug":"Lua","permalink":"http://veinin.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://veinin.com/tags/Lua/"},{"name":"Lua Serialize Table","slug":"Lua-Serialize-Table","permalink":"http://veinin.com/tags/Lua-Serialize-Table/"}]},{"title":"《番茄工作法图解》读书笔记","slug":"pomodoro-technique","date":"2017-09-24T14:06:59.000Z","updated":"2017-12-04T16:00:40.860Z","comments":true,"path":"2017/09/24/pomodoro-technique/","link":"","permalink":"http://veinin.com/2017/09/24/pomodoro-technique/","excerpt":"这本书以我采用番茄工作法的切身经历，向你传授这一工作法的实施全过程，你能看到它如何提高了我的工作效率。另外书中还加入了一些有关人脑思维的研究成果，用以揭示番茄工作法的原理；还包括采用该工作法的若干影响；以及如何根据需要，对该工作法进行调节和扩充。 番茄工作法能帮你与时间化敌为友，不会再因为还有一小时、一天、一周、一个月的时限而充满焦虑，你要做的就是定好25分钟番茄钟，然后全然专注于手头的任务。如果番茄钟响铃，25分钟结束，而任务还没完成，这并不代表失败。相反，这铃声在为你已连续地工作了一整段时间而喝彩。","text":"这本书以我采用番茄工作法的切身经历，向你传授这一工作法的实施全过程，你能看到它如何提高了我的工作效率。另外书中还加入了一些有关人脑思维的研究成果，用以揭示番茄工作法的原理；还包括采用该工作法的若干影响；以及如何根据需要，对该工作法进行调节和扩充。 番茄工作法能帮你与时间化敌为友，不会再因为还有一小时、一天、一周、一个月的时限而充满焦虑，你要做的就是定好25分钟番茄钟，然后全然专注于手头的任务。如果番茄钟响铃，25分钟结束，而任务还没完成，这并不代表失败。相反，这铃声在为你已连续地工作了一整段时间而喝彩。 什么是番茄工作法？简单说，就是列出你当天要做的事，设置25分钟闹钟，然后从第一件事开始。此外还要有每日回顾、做每日承诺、控制中断、预估要花的工夫等。这本书中我会以自己为例，向你展示如何使用番茄工作法，包括如何记录活动，以及如何挑出最重要的任务。 在番茄工作法中，1个番茄钟等于25分钟的努力。这是一个不可分割的抽象单位，是一段“一视同仁”的时间。你的基本承诺是，花上25分钟，尽可能地努力做好。在这段时间内，关键不在于当前活动是否能在当前番茄钟内完成，关键是在这一刻你尽了全力。 番茄工作者的一天中的5个阶段 计划：在一天的开始，从积压的工作（称为“活动清单”）中提取最重要的活动，填写到“今日待办”表格中。这就是你当天的自我承诺。 跟踪：确定当天活动后，扭启25分钟的番茄钟，从当天活动的第一项开始进行。在每个25分钟的时间段（称为一个番茄钟）内，你要收集一些过程指标，比如计算遇到的中断次数。 记录：在一天结束时，将当天收集的数据归档，写入“记录”表格。如果你跟踪了中断次数，就把中断次数写下来。 处理：从所记录的原始数据中提取有用信息。例如，可以计算在每个25分钟的时间段，平均遇到几次中断。 可视化：最终你要将信息以某种方式组织起来，从中找出改进流程的思路。如果你想获得最适合现实情况的工作习惯，在自我调整过程中，基本上每天都要做这样的回顾。 所需工具 番茄钟一枚 铅笔一支（最好带橡皮） 纸质表格三张（白纸即可，横格纸更好） “今日待办”表格，列出打算在今天进行的活动。每天早上这张表要换新的。 “活动清单”表格，列出最近要进行的活动，随想随填，不用排序。同一张“活动清单”表格可以用很多天，增加新的活动，划掉已完成的。 记录表格，记录所采样的流程指标，以便对流程进行改进。同一张“记录”表格可以用很多天，以便比较每天的跟踪记录。 基本方法将要完成的活动全部填入“活动清单”表格，每天早晨，从其中选出数项要在今天进行的活动，抄入“今日待办”表格。 开始工作 在“今日待办”中选择一项最重要的活动 启动番茄钟，时间设定为25分钟 开始工作，直到番茄钟响铃•在“今日待办”表格该活动右侧标一个× 休息片刻（3～5分钟） 开始下一个番茄钟，继续工作，直到完成这项活动，在“今日待办”表格上划掉它 每四个番茄钟后，多休息一会儿（15～30分钟） 处理中断你将学习如何以合理、有效的方式处理番茄钟时间内的中断和干扰。 番茄钟期间的中断有以下两种形式 内部中断具体地说，是直觉向心智发出信号，告诉自己去做当前专注活动以外的事情。要对付内部中断，最佳策略是可视化、接受，然后纳入计划或删除。 外部中断有人找你询问或请你帮忙，并且等你答复。接下来我们看，对于这两类中断，番茄工作法都有相应的处理策略。外部中断具有互动性。有人正在等你答复。他们试图阻止你画×，而你需要一个策略来减少中断。所以必须“扭转”番茄钟和中断之间的依赖关系。如电子邮件和电话很容易，你可以将其关闭。发电子邮件的人不会期待在25分钟内就收到回信。假如有人找你面谈，在不影响结果的前提下，可以请求对方尽量推迟。对于你的同事来说，你今天答复还是周五答复，结果可能是一样的。在对方接受的范围内，建议他尽量往后安排。用稍后的番茄钟重新计划中断事件，而不要在当时直接处理，这样做好处多多。 处理外部中断的策略 告知：“我手头有事，正忙。” 协商：“周五再帮你做，行吗？” 计划：写下活动名称，稍后为它计划未来的番茄钟。 答复：按照承诺回电或答复，不然的话，下次别人就没法信任你了。 原子性番茄钟具有原子性。不可分割。它是这套流程方法中最小的货币单位。如果任务被放下了，无论是暂时的还是长期的，当前番茄钟都必须作废。它就不能算数了，也不应该画×。你得扭启一个新的25分钟番茄钟代替它。如果需要，可以先休息一下再开始。 预估任务预估和测量在番茄工作法中必不可少。如果没有它们，每天要做计划是很困难的。番茄工作法要求花时间做回顾，这样才能不断改进，继往开来。设法将你“认为自己能做的”与“实际做到的”相对应。跟踪和记录是番茄工作法中的测量方法。你无法预言会出现什么新情况、新问题。但可以通过训练和监控，积累做预估的经验和技巧。 计算预估的“货币”单位是番茄钟。因为番茄钟的原子性，不能使用小数，如1/2或2.2个番茄钟是不行的。 假如一项活动预估超过7个番茄钟，说明它太复杂了。需要拆分这项活动。拆开的每项小活动在“活动清单”表格中单独占一行，各自有预估值。活动越大，预估越不准。 如果一项活动预估不够1个番茄钟，则可以在它旁边标个0。并不是说它要花0个番茄钟来完成，只是表示时间花费小于1个番茄钟。这样的活动在“活动清单”表格中仍然各自占一行。 本来预估这项活动需要若干个番茄钟，但这些番茄钟用完了，这时要做二次预估。猜测要完成这项活动还需要多少个番茄钟。如果二次预估也不合要求，你可以做三次预估，也是最终预估。 如果三次预估的数目还不够完成活动，那真是有点失败了。你得分析一下，为什么一次又一次反复地低估这件事？也许应当将活动拆开，降低复杂度。按照常理，活动越复杂，预估越不准。 应变番茄工作法是守则。它提供简单而具体的最佳实践，容易上手。这可能意味着它不适合所有的人或环境。但番茄工作法也内置了应变能力。 当你了解应用番茄工作法的常规方法之后，可能会有调整它的想法。很好。这就是收集跟踪数据、做每日回顾的目的。但是，请尝试坚持使用常规方法，至少两周内不要做任何改动。你需要亲身经历，以便确切知道哪里适合你、哪里不适合。 刚开始学习使用番茄工作法，简单朴实就是最好的。一段时间后，你可以根据个人情况进行一些优化。比如说，我在一天里要花大量时间来写电子邮件。为了避免每次收到新邮件都会中断我手头的活动，我可以每天分配两个番茄钟，也就是50分钟来写回信。 番茄工作法的默认时间表中，每隔三个短休息就要有一个长休息，但不是强制性的，而要根据你的角色和工作内容而定，包括工作场所和个人状态。 番茄工作法流程示意图 参考 《番茄工作法图解》，豆瓣读书","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://veinin.com/categories/读书笔记/"}],"tags":[{"name":"时间管理","slug":"时间管理","permalink":"http://veinin.com/tags/时间管理/"},{"name":"番茄工作法","slug":"番茄工作法","permalink":"http://veinin.com/tags/番茄工作法/"}]},{"title":"《大教堂与集市》读书笔记","slug":"reading-notes-the-cathedral-the-bazaar","date":"2017-09-11T12:57:54.000Z","updated":"2017-11-24T16:38:12.197Z","comments":true,"path":"2017/09/11/reading-notes-the-cathedral-the-bazaar/","link":"","permalink":"http://veinin.com/2017/09/11/reading-notes-the-cathedral-the-bazaar/","excerpt":"这是一本关于黑客行为与文化的书籍。本书并没有给出基础理论上的创新，只是描述了这样的事实：开源软件系统性地利用开放式开发和分布式同行评审（peerreview），不仅降低了成本，还提高了软件质量。 作者EricS.Raymond作为黑客文化的第一理论家，他通过观察和参与，对黑客这个群体的习俗、信念及关系有着深入而广泛的研究。他极力为“黑客”（hacker）一词正名，强调“黑客”并不是媒体报道中的计算机违法分子，而是那种着迷于计算机技术并通过编程提供极具价值软件的人。 黑客（hacker）一词，原指喜欢通过智力和创造性方法挑战难题的人，尤指那些热衷于计算机技术的编程高手。由于媒体报道中出现的黑客事件往往和计算机犯罪相连，导致人们常常误认为黑客是利用网络入侵他人系统的破坏者。事实上，这些破坏者应该被称为cracker，即“骇客”。","text":"这是一本关于黑客行为与文化的书籍。本书并没有给出基础理论上的创新，只是描述了这样的事实：开源软件系统性地利用开放式开发和分布式同行评审（peerreview），不仅降低了成本，还提高了软件质量。 作者EricS.Raymond作为黑客文化的第一理论家，他通过观察和参与，对黑客这个群体的习俗、信念及关系有着深入而广泛的研究。他极力为“黑客”（hacker）一词正名，强调“黑客”并不是媒体报道中的计算机违法分子，而是那种着迷于计算机技术并通过编程提供极具价值软件的人。 黑客（hacker）一词，原指喜欢通过智力和创造性方法挑战难题的人，尤指那些热衷于计算机技术的编程高手。由于媒体报道中出现的黑客事件往往和计算机犯罪相连，导致人们常常误认为黑客是利用网络入侵他人系统的破坏者。事实上，这些破坏者应该被称为cracker，即“骇客”。 Eric在本书中向大家展示了两种最为经典且截然不同的模式：大教堂模式 和 集市模式。传统大型软件公司的开发模式就像是艰难而缓慢的大教堂建造工程，它有着严密的管理和封闭的集中式结构，但在创新上、生产力上和Bug控制上却落后于集市模式。集市模式是一种并行的、对等的扁平化开发结构，其参与者大多来自于互联网上的志愿者，结构松散，来去自由，就像是一个乱糟糟的集市，但就是这样的组织形式，却取得了像Linux这样令人惊叹的成功。 我们可以看到，互联网和移动智能终端已经日益影响着每个人的日常生活，而你每天访问的互联网网站，绝大部分基于开源的操作系统、Web服务器和数据库，你所使用的智能手机多采用 Andriod 或 iOS 系统，Andriod 源于 Linux，iOS 源于开源的 Darwin（Darwin 则基于开源的 Mach 和 FreeBSD 开发），可以说，只要你上网或使用智能手机，你就在不知不觉中使用了开源软件。开源对软件业和互联网带来了巨大影响，并正在和将会对人们的工作和生活产生更显著的影响，正如Eric在前言中所说的，对于任何一个对计算机有所依赖的人，对于任何一个要在未来工作和生活的人，了解一些开源文化，都是很有意义的。 黑客圈简史真程序员（Real Programmer）通常具备工程学和物理学背景，并常常是业余无线电爱好者。使用机器语言、汇编语言、FORTRAN或者其他一些已经被人们遗忘了的古老的编程语言。 早期的黑客20世纪60年代到70年代期间，第一个横贯美国大陆的高速计算机网络开始出现，使得位于各地的研究者能够以前所未有的速度和灵活性交换信息，这些电子高速公路把散落全美各地的黑客聚集到一起，构成了产生黑客文化的关键力量。 Unix的兴起最开始的操作系统都是用汇编语言精心编写的，目的是充分利用机器的效能。但因为机器的更新换代，用户往往要为那些新机器重新编写软件，也就造成了每次都去做类似发明轮子和钻木取火的事。黑客Ken Thompson，参与了分时操作系统Multics的开发工作，因为其显示出庞大而又无用之物的迹象后，贝尔实验室从这个项目中退出了。出于对Multics的执念，KenThompson开始尝试将Multics的一些理念和自己的一些想法融合起来，准备开发一种新的系统：Unix。与此此时，黑客Dennis Ritchie为还处于雏形阶段的UNIX发明了一种新的语言：C语言。因其设计为好用、限制少和灵活方便的语言，很快在贝尔实验室流行了起来。Thompson和Ritchie是最早意识到当时硬件和编译技术都已经好到能让整个操作系统用C语言编写的那批人之一。于是，Unix和C组合在了一起，并很快因其可移植性、极为广泛的计算作业，很快被数以千计的黑客们接受。 远古时代的终结一群没有组织的微机爱好者决心让普通大众都享受到计算机的威力。很多实验室随着人工智能的首次商业化尝试而四分五裂，受一些新成立公司的高薪职位吸引，实验室里室里最优秀的人才正纷纷出走。RichardM.Stallman（人们更熟悉他的名字缩写RMS，这也是他常用的登录名）离开实验室，创建了自由软件基金会（Free Software Foundation），献身于生产高质量的自由软件。并在1982年用C语言重新构建了整个Unix的克隆，并免费发布，这就是后来广为人知的GNU（Gnu’sNotUNIX，这是一种递归式的缩写）操作系统，GNU迅速成为黑客活动的焦点。 “专有UNIX”时代黑客圈形成了两大阵营，一边是围绕Internet和Usenet而形成的相对有凝聚力的“网络部落”（他们中绝大多数使用运行着UNIX的小型机或工作站级别的机器），一边则是没有网络的分散在各个角落的微机爱好者。这一阶段，一些严重的计算机破坏（cracking）事件开始被主流媒体报道，记者们误用黑客（hacker）一词来形容那些破坏者，这种不幸的误用一直延续至今。随着20世纪90年代的到来，已经有十多年发展的工作站技术，受到了明显的威胁，基于Intel386系列芯片的廉价且高性能的个人计算机出现了，历史上第一次，黑客个人有能力购买一台家用机器，而UNIX则有能力提供运行于其上的整个开发环境，并能连上互联网。但是，动辄数千美元的商业UNIX仍然太贵了，价格也没怎么降下来，人们清楚地看到，十多年来对专有UNIX的商业化努力显然已经失败了。 早起的自由UNIX如果软件复杂到操作系统这样的程度，就必须要有一个精心协作的团队，团队要比较小，而且紧密互动，不管是以前还是现在，这都是很典型的开发模式。FSF一直未能完成的HURD使得Helsinki大学一名叫Linus Torvalds的学生有了施展才能的空间，1991年，他开始为386机器开发自由UNIX内核，使用的正是FSF提供的软件套件。Linus很快获得了成功并吸引了互联网上的黑客们，他们帮助Linus一同开发Linux：一个全功能的UNIX，源代码完全免费，而且可以再发布。 Web大爆发公众发现了互联网。20世纪90年代早期，普通大众一个月花不了多少美元就可以连上互联网，WWW发明以来，互联网本来就很快的增长速度更是加速到了不可思议的地步。1994年，若干种不同版本的自由UNIX（Linux和386BSD的后裔）成为黑客活动的主要焦点。Linux开始被商业公司刻录在CD-ROM上发布，并且非常畅销。互联网成为主流后，黑客文化开始受到尊敬，并有了一定政治影响力。 大教堂与集市两种完全不同的开发模式：绝大多数商业公司所采用的“大教堂”模式和 Linux 世界采用的“集市”模式。 大教堂模式和集市模式最关键的区别在大教堂建筑者看来，bug是棘手的、难以发现的、隐藏在深处的，要经过几个人数月的全心投入和仔细检查，才能有点信心说已经剔除了所有错误。而发布间隔越长，倘若等待已久的发布版本并不完美，人们的失望就越发不可避免。对集市模式而言则完全不同，在上千名合作开发者热切钻研每个新发布版本的情况下，你可以假定bug是浅显易找的，或者至少可以很快变得浅显易找。所以你会频繁发布以获取更多的修正，其副作用是良性的：即便发布中有些小问题，你也不会损失太多。 开发者和测试者对程序有着不匹配的思维模式测试者是从外往内看，程序员是从内往外看。对于不开放源码的软件开发，开发者与测试者往往局限于自己的角色，各说各话，都对对方倍感沮丧。开源开发打破了这种困境，由于大家都有真实的源码，开发者和测试者很容易发展出一个共享的表达模式并进行有效的交流。 集市模式的成功LinusTorvalds的开发风格是：早发布、常发布、委托所有能委托的事、开放到几乎是混乱的程度，这些都令人感到惊讶不已。在Linux社区里，没有建筑大教堂那样的安静和虔诚，倒更像是一个乱糟糟的大集市，充满了各种不同的计划和方法。而既稳定又一致的一个操作系统就这么诞生了。 1.好的软件作品，往往源自于开发者的个人需要。2.优秀的程序员知道写什么，卓越的程序员知道改写（和重用）什么。以LinusTorvalds为例，他并没有尝试从零开始写Linux，而是以重用Minix（一个用于PC机的迷你型UNIX类操作系统）的代码和理念作为开始，虽然Linux中所有Minix代码最终都被移除或重写，但它在Linux成长初期确实起到了类似脚手架的作用。3.在你第一次把问题解决的时候，你往往并不了解这个问题，第二次你才可能知道怎么把事情做好。所以，如果你想做对事情，至少要再做一次。4.如果你有正确的态度，有趣的事情自然会找到你。5.当你对一个程序不再感兴趣时，你最后的责任就是把它交给一个可以胜任的接棒者。6.把你的用户当成开发合作者对待，如果想让代码质量快速提升并有效排错，这是最省心的途径。7.早发布，常发布，倾听用户的反馈。8.如果有足够多的beta测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。或者说得更通俗一些：“只要眼睛多，bug容易捉。”9.聪明的数据结构配上愚笨的代码，远比反过来要好得多。10.如果你把beta测试者当做最珍贵的资源对待，他们就会成为你最珍贵的资源。11.仅次于拥有好主意的是，识别来自用户的好主意，有时后者会更好。12.通常，那些最有突破性和最有创新力的解决方案来自于你认识到你对问题的基本观念是错的。13.“设计上的完美不是没有东西可以再加，而是没有东西可以再减。”14.任何工具都应具备预期内的功能，但一个伟大的工具能给你带来预期外的功能。15.写网关类软件时，尽可能不要干扰数据流，而且绝不要扔掉信息，除非接收方强迫你这么做。16.当你的语言还远不是图灵完备（Turing-complete）的时候，语法糖[4]会让你受益良多。17.系统的安全性只取决于它所拥有的秘密。谨防虚假的秘密。18.想要解决一个有趣的问题，先去找一个让你感兴趣的问题。在某些工作场所，开发人员不将代码看作是自己的“领土”，而是鼓励别人发现其中的bug和潜在改进点，这些场所中软件改善速度之快，与别处相比是不可同日而语的。19.如果开发协调者有一个至少像Internet这样好的沟通媒介，并且知道如何不靠强制来领导，那么多人合作必然强于单兵作战。 集市模式的必要条件不可能从零开始实施集市模式。需要拿出一个像样的承诺。程序此时并不需要特别好，它可以简陋、有错、不完整，文档可以少得可怜。但它至少要做到：(a)能运行，(b)让潜在的合作开发者相信，这个软件在可预见的未来，能演变成一个非常棒的东西。项目领导人必须要有高度的设计直觉和聪明才智。一定水准的设计和编码能力。集市项目的协调人或领导人必须要有很好的人际交往和沟通能力。 开源项目如果失败了，根本不会是因为机器、网络或办公场地，它们死掉的唯一原因就是开发者们不再感兴趣了。开源成功的一个最重要成果，就是告诉我们，“玩”是创造性活动中最具经济效能的工作模式。 开垦心智层所谓黑客，是一个通过贡献礼物表现出他（或她）既拥有技术能力又懂得声誉竞争如何运转的人。对是否为黑客的判断是一种感知和认同，只能由那在文化中已经做得很好的人给出。 黑客意识形态的多样性差异可以体现在热忱度上：开源仅仅是一个便利的手段（好工具、有趣的玩具、有意思的游戏），还是说其本身就是目的？差异还体现在敌对性上：反对商业软件，以及反对那些试图支配商业软件市场的公司。 文化中的禁忌： 分化一个项目会遇到强大的社会压力，只有在极为必要的情况下才使用，而且要重新命名和做出大量的公开解释。 在没有项目主持人认可的情况下发布更新是令人不悦的，除非是特殊情况（如本质上不重要的移植bug修复）。 在项目历史、致谢表或维护列表中移除某个人的名字是绝对不可以的，除非当事人明确表示同意。 所有权和开放源码一个软件项目的“所有者”就是在社区中众所周知的对软件版本改动有唯一发布权的那个人。 通常有三种方式获得开源项目的所有权： 第一种也是最显然的，就是去创建这个项目，当这个项目在开始时就只有一个维护者而且这个维护者仍然起作用的时候，所有权问题是连提都不该提的。 第二种方式是获取前任对所有权的移交（有点像“接力棒传递”）。这在社区中很容易理解，当项目“所有者”不愿意或者不能在开发和维护中投入必要的时间时，他（她）有义务将项目移交给一个有能力的继任者。 第三种方式是一个项目需要维护但项目所有者已经消失或失去兴趣了。如果你想维护该项目，你的责任是努力找到这个“所有者”，如果找不到，你可以在相关场所（比如Usenet上专注于该应用领域的新闻组）声明该项目似乎是一个“孤儿”，而你想为之负责。 声誉的多面性追求同侪中声誉（声望）的意义何在？ 首先，也是最明显的一点，在同侪中拥有好名声是一种最基本的激励，出于前面提到的进化上的原因，我们都渴望体验它。（一些人试着将这种对声誉的内驱力做各种升华，使其看起来和同侪没有那么明显的关联性， 第二，声誉是很好的吸引他人注意和合作的途径（在纯礼物经济中，这是唯一的途径）。如果一个人慷慨、智慧、公平交易、有领导能力，或者有其他优秀品质，就更容易让人相信和他合作能获得好处。 第三，如果你所处的礼物经济和交换经济或命令体系互相关联交织，你的名声就可能传播到后两种环境中，使你在那里获得更高的地位。 冲突的起因把开源软件中的冲突辨识为以下主要四类： 谁来做有约束力的决定？ 谁该得到荣誉或责备，因为什么？ 如何防范劳动成果被复制？如何防范流氓版本使bug跟踪变得更复杂？·从技术上讲，什么是正确的事？ 从技术上讲，什么是正确的事情？ 任何一种项目冲突解决理论，必须要解决三个问题： 谁来负责做设计决策？ 如何决定哪个贡献者应该被授予荣誉，如何授予？ 如何保持项目团队和产品不被分裂为多个分支？ 本书这几篇文章仅仅是个开端而非定论，开源软件还有太多的问题没有解决。开源现象引发了其他创造性工作领域以及知识产权相关的许多问题，但未能真正给出较好的答案。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://veinin.com/categories/读书笔记/"}],"tags":[{"name":"开源","slug":"开源","permalink":"http://veinin.com/tags/开源/"}]},{"title":"《时间管理》读书笔记","slug":"reading-notes-time-management","date":"2017-09-02T07:39:00.000Z","updated":"2017-09-02T08:30:36.891Z","comments":true,"path":"2017/09/02/reading-notes-time-management/","link":"","permalink":"http://veinin.com/2017/09/02/reading-notes-time-management/","excerpt":"市面上很多关于时间管理的书籍和文字，但几乎很多著作都大同小异，在读这类书籍或文章时大部分反而是在浪费时间。事实上，有关时间管理的原则，你需要知道的大约只有50条，一旦你了解了这些原则，你就了解了关于这一主题你所需要了解的一切。所有50条原则，都囊括在了这本书上，而你只需要向这本书投资1小时的时间，就能带来不错的回报。","text":"市面上很多关于时间管理的书籍和文字，但几乎很多著作都大同小异，在读这类书籍或文章时大部分反而是在浪费时间。事实上，有关时间管理的原则，你需要知道的大约只有50条，一旦你了解了这些原则，你就了解了关于这一主题你所需要了解的一切。所有50条原则，都囊括在了这本书上，而你只需要向这本书投资1小时的时间，就能带来不错的回报。 作者关于时间管理的十个重要观点1.自我意识是先决条件意识到自己对时间的感觉，可以使你更加了解自己。如果你不了解你是如何花费时间的，你便没有能力有效地管理你的时间。自己欺骗自己毫无意义。我们对时间的感觉取决于我们做什么，当我们上网、看视频节目时，我们对时间失去了控制住。时间飞逝而过。然而如果我们到家的时候，因为饥饿难耐，随意将什么东西扔进微波炉加热，而那五分钟的等待仿佛无穷无尽。记时间日志会使你对自己不断贬值的资产–生命时光–保持敏感。 每个人每周有168个小时，或者每个月大约有720小时的时间。每个小时都很重要，你应该认真回顾你目前是如何利用你的时间的。 比如我一周168小时是这样度过的：睡觉 - 56小时吃饭 - 3.5小时学习、阅读 - 7小时上网、看视频、玩游戏 - 45小时打电话、发短信 - 5小时运动 - 7小时工作时间 - 37.5小时其他杂物 - 17小时总计 - 168小时 总结过后，你会发现，天哪，我居然用接近30% 时间用来上网、看视频、玩游戏！！！如果能在这方面做出一些优化，多利用一些时间去做更多其他更有意义的事情，那将会更好。 2.设定目标，提供线路图只有当你确定了努力的方向和目标时，你才能决定一个如何安排你的时间。目标设定决定了你6个月、一年或者5年后，你想要在哪里，想要做什么。一旦你确定了目标，就需要采取步骤，对时间做出承诺。 比如，我需要在一年内实现看完100本书的目标。这个目标应具备了四个最重要的标准：具体、有时间范围、很现实、对于目标制定者来说，它很重要。如果说看完一本书平均要花 3.5小时，那么看完100本就需要350小时，也就是每周需要7小时来阅读才能保证完成，而这就是你设定的一个目标。 3.选择是艰难的时间管理最终就是关于如何做出选择的。梦想的实现绝非轻而易举，有了目标后，你就必须做出选择。彻底的反省，你到底想要得过且过，做你现在马上想做的事情，还是为了未来着想，做哪些能让你今后过上自己想要的生活的事情呢？生活是不公平的，不是说你努力奋斗就一定能得到想要的东西。但你可以通过正确的选择，保持一种成功的姿态，获得更大的机会，去实现想要达成的目标。时间管理的选择也是如此，只有你自己能够做出选择，没人代替你。 4.创造时间匹配时间和精力有效地时间管理不仅仅是寻找一天中额外时间，还要将你的有效时间和你的有效精力匹配起来。尝试在感觉最清醒的啥时候去从事最艰巨的任务。 空闲时间利用你一天中的空隙时间来减少不必要的浪费，在你慢条斯理、无所事事的时，尝试做一些更加有意义的事情。比如利用你排队打饭来进行快速阅读、记单词啥的。 5.不要拖延时间管理的大敌之一，梦想的杀手。很多人都有良好的愿望，他们“总有一天”要去做什么。但“总有一天”从未变成“今天”。拖延源自一种非常强大的物理法则—-惯性。物体，包括人，倾向于呆在原地不动。为了实现向前移动，则需要推动自己。 战胜拖延策略： 在口袋里放一张纸片或索引卡，用粗体字写上你要达成的目标。 将大项目分解成易管理的小块。 教会自己的头脑（意识）识别懒惰或拖延最初的蛛丝马迹。 坚持通过某种方式做好笔记。 那些培养强大精神力量的人更有可能： 按时间表、计划行事 做出正确的选择 保持良好的注意力 战胜拖延 6.杂乱不堪是大敌杂乱会引起情绪紧张，导致无所作为，降低效率。如果你能够清理你的工作区域、你的生活，你将显著增加你的工作成效。 7.计划和准备是值得花精力去做的提前决定某一给定的时期内，你要做的具体事情是什么。很多人都不喜欢做计划。我们生活中这样一个充满行动的社会，以至于我们每日总是忙忙碌碌，很少有时间停下来思考我们正在做什么，以及我们为何而做。做好计划意味着：每一个小时的计划抵得上五小时的执行。 每天花10分钟来规划你这一天该如何度过，通过思考来提高实现你想达到之事的几率。比如为制定这些问题： 要完成哪些工作？ 有多少时间可以用来完成这些工作？ 需要完成的工作之间存在逻辑顺序吗？ 8.制定任务清单，确定优先次序现你所有计划和准备的实物是任务清单。通过任务清单体确认你所要做的事情是什么，以及你将如何和合适去做每一件事。 制作任务清单理由: 便于组织你的时间，为你的每一天创建一个时间框架。 减轻你的压力。 让你去考虑该如何使用你的时间以及为何这样使用。 制作任务清单的过程就像在写一部微型小书，主题就是你自己，而且你永远不知道，在制作任务清单的执行过程中，会迸发出什么样的想法和观点。 任务清单四个象限： 重要而紧急 重要但不紧急 紧急但不重要 既不紧急也不重要可以按照 1 -&gt; 3 -&gt; 2 -&gt; 4顺序完成不同象限工作。 9.专心致志是问题的关键所在二八定律你的80%的成就来自于你20%的行为。如销售人员80%的收入往往来自于他们20%的客户。投资者知道，80%的收益来自于他们20%的投资。如果你正从一个或两个活动（“20%”）中获得大部分成果（“80%”），那么这一两个活动就是你应该集中精力去做的。把大部分精力都投入到那些真正能够给你带来“最大收益”的项目上去。 集中精力分心和干扰是专注的大敌。学会如何集中精力，即通过训练在同一时间将你的思维专注于某一件事情上，来强化你的思想力量。当你试图同时做不止一件事情时，你便削弱了你正在做的每一件事情的有效性。那些一心二用，并认为每一件事他们都做的好的人，不过是在自欺欺人而已。 减少分心，排除干扰。 对于分心的因素： 远离互联网。 关掉手机。 关掉所有电子邮件提示。 拔掉电视机插头。 将一切电子产品（如视频游戏）移出工作区域。 对于干扰因素： 如有可能，把工作时房门关上。 如果不可能，而且周围有其他人，那么你便：A) 戴上一顶棒球帽，将帽舌下拉，表现出不友善的样子。B) 避免同经过的人进行目光接触。C) 戴耳机（即使什么都不播放）D) 把一盒面巾纸放旁边，把其中几张弄的皱巴巴的放在一旁，表明你感冒了。 10.选择对你来说行之有效的时间管理技巧上面一些时间管理技巧，有一些可能让你感到有意义，有些则不然。你可以对不同的方法进行试验和尝试。关键是努力把你每小时使用的尽可能合理有效。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://veinin.com/categories/读书笔记/"}],"tags":[{"name":"时间管理","slug":"时间管理","permalink":"http://veinin.com/tags/时间管理/"}]},{"title":"《如何阅读一本书》读书笔记","slug":"how-to-read-a-book","date":"2017-08-25T16:09:37.000Z","updated":"2018-03-05T15:17:36.746Z","comments":true,"path":"2017/08/26/how-to-read-a-book/","link":"","permalink":"http://veinin.com/2017/08/26/how-to-read-a-book/","excerpt":"这是一本为阅读的人，或是想要成为阅读的人而写的工具书。尤其是想要阅读书的人。说得更具体点，这本书是为那些想把读书的主要目的当作是增进理解能力的人而写。这本说针对的不是虚构的作品，如小书、戏、史诗剧，而是一些的论说性的书籍，如社会、人文、工具书的这类，而后者是大部分人的兴趣所在。阅读的目标是为获得资讯而读，以及为求得理解而读。如果你想读一本有助于增进理解力的好书，那这本书可以帮忙，这本书的主题就是阅读好书的艺术。","text":"这是一本为阅读的人，或是想要成为阅读的人而写的工具书。尤其是想要阅读书的人。说得更具体点，这本书是为那些想把读书的主要目的当作是增进理解能力的人而写。这本说针对的不是虚构的作品，如小书、戏、史诗剧，而是一些的论说性的书籍，如社会、人文、工具书的这类，而后者是大部分人的兴趣所在。阅读的目标是为获得资讯而读，以及为求得理解而读。如果你想读一本有助于增进理解力的好书，那这本书可以帮忙，这本书的主题就是阅读好书的艺术。 阅读的分类第一种阅读，也就如我们平时看报纸、看电视新闻、刷微信公众号，甚至看电影等等。这种是阅读只是为了获得咨询，此时你的阅读技巧、理解能力完全能与作者相当，这种读物只能增加你的资讯，并不能提升你的理解能力。这在这本书的作者眼里，这种阅读其实不算真正的阅读。 第二种阅读，主动的阅读，其实就是一个人面对他本身并不理解的东西，书本的内容超出了你的理解。既然我们想提升自己，获得更深层次的理解，就必须向比你更厉害的人学习。而面对这种阅读，是没有任何外力可以帮助你的，你就是要读这本书，你什么都没有，只凭内心的力量，玩味着眼前的字句，慢慢提升自己，从只有模糊的概念到更清楚地理解为止。这样的一种提升，是在阅读时的一种脑力活动，也就更高的阅读技巧。这种阅读就是让一本书向你既有的理解力做挑战。只有这种方式是真正的阅读。 阅读的层次作者把阅读分为四种层次，阅读的层次是渐进的，更高的层次包含了较低层次的特性。 基础阅读第一层阅读，只要熟练了这个层次的阅读，也就摆脱了文盲的状态。在熟练这个层次的过程中，一个人可以学习到阅读的基本艺术，接受基础的训练，获得初步的阅读技巧。这个阶段是一个学习如何阅读的阶段，对我们来说，如果已经完成九年义务教育，应该都能完成这一层次的阅读，也就是说能结合语境理解字面上的意思。 在儿童具备纯熟的阅读能力之前，至少需要四个截然不同的阶段。第一个阶段，阅读准备阶段，相当于学前将于的或幼稚园的学习经验。第二个阶段，认字，相当于一年级学生典型的学习经验。第三个阶段，字汇的增长及对课文的运用，有能力阅读一些交通标志，或图片说明，填写政府有关的简单表格等等 。第四个阶段，这个阶段，学生要从小学到初中毕业。有一定的读写能力，几乎可以阅读所有读物，但还不够老练。 检视阅读（略读）特点在于强调时间。在这个层次，必须在规定的时间完成一项阅读。譬如用十五分钟读完一本书，或是同样的时间念完两倍数量的书。与基础阅读相比，检视阅读才算进入了阅读的层次，这是一种让你在有限的时间内尽量抓住一本书的重点的阅读方法。而这一层次，恰恰是很多人所没有掌握的。进行检视阅读的情况大概有两种，一种是让你想在有限的时间当中，对一本书有个基础的了解，然后再决定你是否继续精读下去。而另外一种是，有很多书其实并不适合花大量精力在上面，也就不适合精读，通常面对这类书籍的时候，检视阅读往往是了解一本书的最好方式。 检视阅读分两种： 第一，有系统化的略读和粗读略读和粗读可以让我们发现这本书值不值得多花时间去仔细阅读，并且，略读也能告诉你许多这本书有关的事。略读的习惯有关用不着花太多时间，下面是一些建议：（1）先看书名页，然后如果有序就先看序。要很快的看过去，特别注意副标题，或其他相关说明或宗旨，或是作者写作本书的特殊角度。（2）研究目录页，对这本书的基本架构做概括性的理解。这就像出发旅行前，先看下地图一样。（3）如果书中附有索引，也要检阅一下，大多数论说类的书籍都有有索引。这样能款苏评估这本书涵盖了那些议题的范围。（4）如果输有包着书衣，不妨读一下出版者的介绍，这应该有作者对本书的主旨描述，这可以让你快速判断这本书是否有可取的内容，而不是根本没任何重要的东西。（5）从本书的目录概的初步印象中，挑几个看起来跟主题息息相关的篇章来看。特别是看看这些篇章的开头或结尾的摘要说明。（6）最后一步，把书打开，东翻翻西翻翻，念个一两段，有时候连续读几页，但不要太多。，就用这样的方法把全书翻过一遍，随时寻找主要论点的讯号，留意主题的基本脉动。通过以上几个步骤，你可以在不到一小时的时间里，对这本书已经了解了很多。尤其，你应该了解这本书是否包含想继续挖掘下去的内容，是否值得你继续投下时间与注意？你应该比以前更清楚这本书该归类为哪一个种类，以便将来有需要时好作参考。 第二，粗浅的阅读每个人都有这样的经验：对一本难书包着高度的期望，结果却只是在徒劳无益的挣扎而已。最后得出一个结论：一开始读这本书就是个错误。但这只是对阅读一本难书的期望过高而已。头一次面对一本难读的书的时候，从头到尾先读一遍，碰到不懂的地方不要停下来查询或思索。只注意你能理解的部分，不要为一些设法立即了解的东西而停顿。略过不懂的部分，集中精力去了解你看得懂的部分。从头到尾了解一遍之后，就算只有50%或更少，都能帮助你后来重读第一次略过的部分，增进理解。就算不重读，这本难度很高的书你也理解了一半，比什么都不了解来的更好些。 - 分析阅读（精读）这个层次更复杂，更系统化。如果你的目标只是获得资讯或消遣，就没有必要用到分析阅读。如果说检视阅读是在有限的时间内，最好也最完整的阅读，那么分析阅读就是在无限的时间里，最好也最完整的阅读。在这个层次，我们需要在略读的基础上，更加主动的去提出问题，并且用自己的语言尝试解释这本书的内容。也就是在精读的时候，我怎么样用自己的话把这一段、这一章、甚至整本书的内容说出来。分析阅读的规则是一个理想化的阅读。没有多少人用过这样的方法来阅读一本书。而使用过这些方法的人，可能也没办法用这些规则来阅读许多本书。无论如何，这些规则只是衡量阅读层次的理想标准。如果你是个好读者，也就能达到你应该达到的阅读层次。一个读得很广泛，却读不精的人，与其值得赞美，不如值得同情。就像霍布斯所说：“如果我像一般人一样读那么多书，我就跟他们一样愚蠢了。”当然，许多书都值得精读。但有更多的书只要浏览一下就行了。要成为一个好读者，就要懂得依照一本书的特质，运用不同的阅读技巧来阅读。 分析阅读分为三个阶段： 第一个阶段（找出一本书在谈些什么规则） 规则一，依照书本的种类与主题作分类。你一定要知道自己在读的是哪一类书，而且要越早知道越好。最好早在你开始阅读之前就先知道。主要分类法，一种是虚构的小说类，另一种是传达知识，说明性的论说类。论说性作品又区分为理论性和实用性作品。 规则二，用最简短的句子说出整本书在谈些什么。如对亚当斯密的《国富论》，可以缩减为一下篇幅：本书在探讨国家财富的资源。任何一个以劳力为主的经济体制，都要考虑到薪资的给付，资本利润的回收，积欠地主的租金等关系，这些就是物品价格的基本因素。本书探讨到如何更多元化的有效运用资本，并从金钱的起源与使用，谈到积累资本及使用资本。本书接着经验不同的国家在不同状况下的富裕发展，比较了不同财经系统，讨论了自由贸易的好处。 规则三，按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。这个规则是可以有一套运用的公式的，比如大纲排列如下：（1）作者将全书分为五个部分，第一部分谈的是什么，第二部分谈的是什么，第三部分谈的是别的事，第四部分则是另外的观点，第五部分优势另一些事。（2）第一个主要部分又分为三个段落，第一段落为X，第二段了为Y，第三段了为Z。（3）在第一部分的第一个阶段，这种有四个重点，第一个重点是A，第二个重点是B，第三个重点是C，第四个重点是D等等。 规则四，找出作者在问的问题，或作者想要解决的问题。可以列出简短的公式：某件事存在吗？是什么样的事？发生的原因是什么？或是在什么样的情况下存在？或为什么会有这件事的存在？这件事的目的是什么？造成的影响是什么？特性及特征是什么？与其他类似事件，或不相同事件的关联是什么？这件事是如何进行的？以上这些都是理论性的问题。有哪些结果可以选择？应该采取什么样的手段才能获得某种结果？要达到某个目的，应该采取哪些行动？以什么顺序？在这些条件下，什么事是对的，或怎样才会更好，而不是更糟？在什么样的条件下，这样做会比那样做好一些？以上这些都是实用的问题。 第二个阶段（找出一本书到底在说什么的规则） 规则五，诠释作者使用的关键字，与作者达成共识。这个规则共分两个部分，第一个部分是找出重要单字，那些举足轻重的单字。第二部分是确认这些单字在使用时的最精确的意义。 规则六，从最重要的句子中抓出作者的重要主旨。 规则七，找出作者的论述，重新架构这些论述的前因后果，以明白作者的主张。如果可以，找出书中说明重要论述的段落。但是，如果这个论述并没有这样表达出来，你就要去架构出来。你要从这一段或那一段中挑选句子出来，然后整理出前后顺序的主旨，以及其组成的论述。规则八，确定作者已经解决了哪些问题，还有哪些是未解决的。在未解决的问题中，确定哪些是作者认为自己无法解决的问题。 第三阶段（公正的评断一本书） A.智慧礼节的一般规则 规则九，在你说出“我同意”，“我不同意”，或“我暂缓评论”之前，你一定要能肯定地说：“我了解了。”除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。 规则十，不要争强好胜，非辩到底不可。当你不同意作者的观点时，要理性地表达自己的意见，不要无理地辩驳或争论。如果你知道或怀疑自己是错的，就没有必要去赢得那场争辩。 规则十一，尊重知识与个人观点的不同，在作任何评断之前，都要找出理论基础。 B.批评观点的特别标准 规则十二，证明作者的知识不足（uninformed），缺少某些与他想要解决的问题相关的知识。 规则十三，证明作者的知识有错误（misinformed），理念不正确。 规则十四，证明作者不合逻辑，推论无法令人信服。 规则十五，证明作者的分析不完整，并没有解决他一开始提出来的所有问题，或是他并没有尽可能善用他手边的资料，或是他并没有看出其间的含意与纵横交错的关系，或是他没法让自己的想法与众不同。 主题阅读也是最高层次的阅读。这是最复杂、最系统化的阅读。虽然它要求非常多，也不被人熟知，但却是所有阅读活动中最有收获、最能获益良多的阅读方式。这个阅读层次已经不仅仅局限于一本书了，而是针对一个主题问题，找出与主题相关的书籍以及这些书籍当中与主题相关的章节，针对这些进行检视阅读或分析阅读。在主题阅读中，你关心的主题才是你的重点，而不是你阅读的书。在这个阶段，检视阅读已经是读者在阅读时主要的工具或手段了。 在主题阅读中有两个阶段。准备阶段，另一个是主题阅读本身。 第一阶段，观察研究范围：主题阅读的准备阶段（1）针对你要研究的主题，设计一份试验性的书目。你可以参考图书馆目录、专家的建议与书中的书目索引。（2）浏览这份书目上所有的书，整体进行检视阅读一遍，确定哪些与你的主题相关，并就你的主题建立起清楚的概念。 第二阶段主题阅读：阅读所有第一阶段收集到的书籍（1）浏览所有在第一阶段被认定与你主题相关的书，找出最相关的章节。（2）根据主题创造出一套中立的词汇，带引作者与你达成共识——无论作者是否实际用到这些词汇，所有的作者，或至少绝大部分的作者都可以用这套词汇来诠释。（3）建立一个中立的主旨，列出一连串的问题——无论作者是否明白谈过这些问题，所有的作者，或者至少大多数的作者都要能解读为针对这些问题提供了他们的回答。（4）界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。你要记住，各个作者之间或之中，不见得一定存在着某个议题。有时候，你需要针对一些不是作者主要关心范围的事情，把他的观点解读，才能建构出这种议题。（5）分析这些讨论。这得把问题和议题按顺序排列，以求突显主题。比较有共通性的议题，要放在比较没有共通性的议题之前。各个议题之间的关系也要清楚地界定出来。注意：理想上，要一直保持对话式的疏离与客观。要做到这一点，每当你要解读某个作家对一个议题的观点时，必须从他自己的文章中引一段话来并列。 最后，虽然这本说提到的这些阅读方法对于论说性书籍普遍比较适用，但并说是说这些方法适合所有人，只有真是你觉得最适合你自己的读书方法才是好方法。如果你已经有了自己觉得比较合适的阅读方法，其实没必要去强求，用自己的方法就好。 本文大部分内容摘自： 《如何阅读一本书》，豆瓣读书 【Simple Read】如何阅读一本书？，bilibili","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://veinin.com/categories/读书笔记/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://veinin.com/tags/读书/"},{"name":"如何阅读一本书","slug":"如何阅读一本书","permalink":"http://veinin.com/tags/如何阅读一本书/"}]},{"title":"Lua C API简介(中篇)","slug":"lua-c-aip-02","date":"2017-08-06T14:15:58.000Z","updated":"2017-11-24T16:37:33.514Z","comments":true,"path":"2017/08/06/lua-c-aip-02/","link":"","permalink":"http://veinin.com/2017/08/06/lua-c-aip-02/","excerpt":"在运行C程序时，可以调用Lua脚本。C程序可以向Lua传入参数，然后通过Lua返回结果。使用C API调用Lua函数方法很简单，我们最开始先将要调用的函数入栈，然后依次将要传入的参数入栈，调用pcall函数。最后，再从栈中获取函数返回的值。","text":"在运行C程序时，可以调用Lua脚本。C程序可以向Lua传入参数，然后通过Lua返回结果。使用C API调用Lua函数方法很简单，我们最开始先将要调用的函数入栈，然后依次将要传入的参数入栈，调用pcall函数。最后，再从栈中获取函数返回的值。 调用Lua简单脚本123-- helloscript.luaio.write(\"This is comming from lua\\n\") 12345678910111213141516171819202122232425262728293031323334353637383940// helloscript.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"lua.h\"#include \"lauxlib.h\"#include \"lualib.h\"void error(lua_State *L, const char *fmt, ...);int main()&#123; lua_State *L = luaL_newstate(); luaL_openlibs(L); if(luaL_loadfile(L, \"call_lua.lua\")) error(L, \"luaL_loadfile failed.\\n\"); printf(\"In C, calling Lua\\n\"); if(lua_pcall(L, 0, 0, 0)) error(L, \"lua_pcall() failed.\", lua_tostring(L, -1)); printf(\"Back in C again\\n\"); lua_close(L); return 0;&#125;void error(lua_State *L, const char *fmt, ...) &#123; va_list argp; va_start(argp, fmt); vfprintf(stderr, fmt, argp); va_end(argp); lua_close(L); exit(EXIT_FAILURE);&#125; 相关函数解析luaL_loadfile(L, &quot;script.lua&quot;);lua_loadfile 等价于 luaL_loadfilex，加载为 Lua 代码块。此函数的返回值和 lua_load 相同，不过它还可能产生一个叫做 LUA_ERRFILE 的出错码。这种错误发生于无法打开或读入文件时，或是文件的模式错误。和 lua_load 一样，这个函数仅加载代码块不运行。 lua_pcall(L, number_of_args, number_of_returns, errfunc_idx);调用Lua函数，第二个参数位传入参数数量; 第三个参数为调用函数返回值数量; errfunc_idx 是0，则返回在栈顶的错误消息就和原始错误消息完全一致，否则，msgh 就被当成是错误处理函数在栈上的索引位置。 编译、运行(系统：OSX Lua版本:5.3.0)：12345$ cc -o helloscript helloscript.c -I /usr/local/include/ -L /usr/local/lib/ -llua$ ./helloscriptIn C, calling LuaThis is comming from luaBack in C again 调用Lua函数，传值并返回12345678910-- call_lua_func.lua function sayHello() io.write(\"This is comming from lua.sayHello.\\n\")endfunction add(a, b) print(\"This is comming from lua.add. arg.a =\", a, \" arg.b =\", b) return a + bend 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 04_call_lua_func.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"lua.h\"#include \"lauxlib.h\"#include \"lualib.h\"void error(lua_State *L, const char *fmt, ...);int main()&#123; lua_State *L = luaL_newstate(); luaL_openlibs(L); if(luaL_loadfile(L, \"call_lua_func.lua\")) error(L, \"luaL_loadfile failed.\\n\"); if(lua_pcall(L, 0, 0, 0)) error(L, \"lua_pcall failed.\\n\"); printf(\"In C, calling Lua-&gt;sayHello()\\n\"); lua_getglobal(L, \"sayHello\"); //Tell it to run test2.lua -&gt; sayHello() if(lua_pcall(L, 0, 0, 0)) error(L, \"lua_pcall failed.\\n\"); printf(\"Back in C again\\n\"); printf(\"\\nIn C, calling Lua-&gt;add()\\n\"); lua_getglobal(L, \"add\"); //Tell it to run test2.lua -&gt; add() lua_pushnumber(L, 1); lua_pushnumber(L, 5); if(lua_pcall(L, 2, 1, 0)) error(L, \"lua_pcall failed.\\n\"); printf(\"Back in C again\\n\"); int returnNum = lua_tonumber(L, -1); printf(\"Returned number : %d\\n\", returnNum); lua_close(L); return 0;&#125;void error(lua_State *L, const char *fmt, ...) &#123; va_list argp; va_start(argp, fmt); vfprintf(stderr, fmt, argp); va_end(argp); lua_close(L); exit(EXIT_FAILURE);&#125; 相关函数解析在 Lua 脚本中， sayHello 函数只做输出操作，而 add 函数则需要传入两值，并进行加法操作并返回结果。 从 C 层在调用 Lua 脚本层时，首先要把被调用的函数压入栈中，可以通过 lua_getglobal 函数把调用函数入栈。 把需要传递给被调用函数的参数用 lua_push* 函数按正序压栈。 最后调用一下 lua_call，把要传入的参数个数及返回值个数一起传进去。 当函数调用完毕后，所有的参数以及函数本身都会出栈。紧接着函数的所有返回值这时则被压栈。Lua 会保证返回值都放入栈空间中。函数返回值将按正序压栈（第一个返回值首先压栈），因此在调用结束后，最后一个返回值将被放在栈顶。 编译、运行123456789101112131415$ cc -o callluafunc callluafunc.c -I /usr/local/include/ -L /usr/local/lib -llua$ ./callluafuncIn C, calling Lua-&gt;sayHello()This is comming from lua.sayHello.Back in C againIn C, calling Lua-&gt;add()This is comming from lua.add. arg.a = 1.0 arg.b = 5.0Back in C againReturned number : 6 表传递在对Lua函数调用值传递时经常涉及到表的传递。通过下面代码我们来讨论它是如何执行的。 1234567891011121314-- call_lua_table.lua-- 该函数接受一个 table，并且将新建一个 talbe，将穿入的 table 键值都插入新建 table 中，并记录数据长度，最后返回新建立的 table。function tablehandler(t) local returnedt = &#123;numfields = 1&#125; for i, v in pairs(t) do returnedt.numfields = returnedt.numfields + 1 returnedt[tostring(i)] = tostring(v) end io.write(\"this is comming from table handler. table num fields : \", returnedt.numfields, \"\\n\") return returnedtend 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 05_call_lua_table.c #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"lua.h\"#include \"lauxlib.h\"#include \"lualib.h\"void error(lua_State *L, const char *fmt, ...);int main()&#123; lua_State *L = luaL_newstate(); luaL_openlibs(L); if(luaL_loadfile(L, \"call_lua_table.lua\")) error(L, \"luaL_loadfile failed.\\n\"); if (lua_pcall(L, 0, 0, 0)) error(L, \"lua_pcall failed\"); printf(\"In C, calling Lua-&gt;tablehandler()\\n\"); lua_getglobal(L, \"tablehandler\"); lua_newtable(L); //新建一个table入栈 lua_pushliteral(L, \"firstname\"); //键为\"firstname\"入栈，此时table位置-2 lua_pushliteral(L, \"Veinin\"); //值为\"Veinin\"入栈，次数table位置-3 lua_settable(L, -3); //把key和value放入表中，操作完成后键和值都会被弹出栈 lua_pushliteral(L, \"lastname\"); lua_pushliteral(L, \"Guo\"); lua_settable(L, -3); if(lua_pcall(L, 1, 1, 0)) //执行调用函数 error(L, \"lua_pcall failed\"); printf(\"============ Back in C again, Iterating thru returned table ============\\n\"); lua_pushnil(L); //第一个键， const char *k, *v; while(lua_next(L, -2)) &#123; //table现在在-2位置，lua_next得到一个键-值对，分别入栈 v = lua_tostring(L, -1); k = lua_tostring(L, -2); lua_pop(L, 1); //’值’出栈，‘键’不出栈，保留做下一次迭代 printf(\"%s = %s\\n\", k, v); &#125; lua_close(L); return 0;&#125;void error(lua_State *L, const char *fmt, ...) &#123; va_list argp; va_start(argp, fmt); vfprintf(stderr, fmt, argp); va_end(argp); lua_close(L); exit(EXIT_FAILURE);&#125; 相关函数解析对于 C 层代码，我们可以通过 lua_newtable 函数创建一张空表，并将其压栈，该函数它等价于 lua_createtable(L, 0, 0)。然后通过 lua_pushliteral 把键和值分别压入栈中，并通过 lua_settable 把 key 和 value 放入 table 中，做一个等价于 t[k] = v 的操作，在操作完成后，这个函数会将键和值都弹出栈。 在被调用函数 tablehandler 返回后，此时，栈中存在的只是函数的返回值，而它目前是一张 table，对于迭代输出 table 中的值，上面给出了一种典型的遍历方法。 1int lua_next (lua_State *L, int index); lua_next 可以从栈顶弹出一个键，然后把索引指定的表中的一个键值对压栈（弹出的键之后的 “下一” 对），在这一步开始之前我们需要调用 lua_pushnil(L) 设置第一个键为缺省值，然后再调用 lua_next 。通常，我们会在下一个迭代到来之前，把‘值’出栈，但会保留‘键’做下一次迭代操作。 编译、运行123456789101112$ cc -o 05_call_lua_table 05_call_lua_table.c -I /usr/local/include/ -L /usr/local/lib/ -llua$ ./05_call_lua_tableIn C, calling Lua-&gt;tablehandler()this is comming from table handler. table num fields : 3============ Back in C again, Iterating thru returned table ============lastname = Guofirstname = Veininnumfields = 3","categories":[{"name":"Lua","slug":"Lua","permalink":"http://veinin.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://veinin.com/tags/Lua/"},{"name":"Lua C API","slug":"Lua-C-API","permalink":"http://veinin.com/tags/Lua-C-API/"}]},{"title":"Lua C API简介(上篇)","slug":"lua-c-api-01","date":"2017-08-05T08:14:27.000Z","updated":"2017-11-24T16:34:28.798Z","comments":true,"path":"2017/08/05/lua-c-api-01/","link":"","permalink":"http://veinin.com/2017/08/05/lua-c-api-01/","excerpt":"Lua 的 C API 是一个 C 代码与 Lua 进行交互的函数集，也就是宿主程序跟 Lua 通讯用的一组 C 函数。它由以下部分组成：读写Lua全局变量的函数，调用Lua函数的函数，运行 Lua 代码片段的函数，注册 C 函数然后可以在 Lua 中被调用的函数，等等。","text":"Lua 的 C API 是一个 C 代码与 Lua 进行交互的函数集，也就是宿主程序跟 Lua 通讯用的一组 C 函数。它由以下部分组成：读写Lua全局变量的函数，调用Lua函数的函数，运行 Lua 代码片段的函数，注册 C 函数然后可以在 Lua 中被调用的函数，等等。 所有的 API 函数按相关的类型以及常量都声明在头文件 lua.h 中。而另一个相关头文件 lauxlib.h 则是API接口的一个辅助库（auxlib），其中定义的函数都以luaL_开头（如lual_loadbuffer），辅助库利用了lua.h中提供的基础函数提供了更高层次的抽象。auxlib 没有存取 Lua 内部的权限，它所完成的所有工作都是通过正式的基本 API。 第一个示例程序一个独立的Lua解释器的实现123456789101112131415161718192021222324#include#include#include \"lua.h\"#include \"lauxlib.h\"#include \"lualib.h\"int main(void)&#123; char buff[256]; int error; lua_State *L = luaL_newstate(); //opens lua luaL_openlibs(L); //open the standar libraries while(fgets(buff, sizeof(buff), stdin) != NULL) &#123; error = luaL_loadstring(L, buff) || lua_pcall(L, 0, 0, 0); if(error) &#123; fprintf(stderr, \"%s\\n\", lua_tostring(L, -1)); lua_pop(L, 1); &#125; &#125; lua_close(L); return 0;&#125; luaL_newstate 函数创建一个新的 Lua 状态机。它以一个基于标准 C 的 realloc 函数实现的内存分配器调用 lua_newstate 。Lua 中没用定义任何全局变量，它所有状态都保存在动态结构lua_State中，而指向这个函数的指针做为所有Lua函数的第一个参数，这样的实现方式使得Lua能够重入且在多线程中的使用做好准备。 函数 luaL_openlibs 打开指定状态机中的所有 Lua 标准库。 当状态机标准库载入后，对于用户输入的每一行，C 程序首先调用 luaL_loadstring 将字符串加载为 Lua 代码块，并通过 lua_pcall 以保护模式运行从chunk中调用返回的代码。lua_pcall 在没有错误的情况下返回0，如有错误发送，错误信息将被压入栈中，我们可以通过 lua_tostring 来得到这条信息，输出它，最后调用 lua_pop 将它从栈中删除。 编译、运行（Lua版本:5.3 系统:OS X）：1234567$ cc -o first first.c -I/usr/local/include -L/usr/local/lib -llua -lm$ ./firstprint(\"hello\")hellohehe[string \"hehe...\"]:2: syntax error near 在有错误的情况下，该程序将错误信息输出到标准错误流中，而Lua核心绝不会直接输出任何东西到任务输出流上，它通过返回错误代码和信息来发出错误信号。每个应用程序都可以适当的用最适合它们自己的方式来处理这些错误信息。如下代码，它只是输出一条错误信息，关闭lua_State，并退出整个应用程序：123456789void error(lua_State *L, const char *fmt, ...)&#123; va_list argp; va_start(argp, fmt); vfprintf(stderr, fmt, argp); va_end(argp); lua_close(L); exit(EXIT_FAILURE);&#125; 栈当 Lua 与 C 之间交换数据时我们面临两个问题，一个是动态与静态类型系统的不匹配，另一个则是自动和手动内存管理的不一致。Lua 使用一个虚拟栈来与 C 互相传值，栈上的的每个元素都是一个 Lua 值。第一次调用 Lua 时，首先值会压入栈中，然后调用 Lua （这个值会被弹出），我们要做的就是把值按类型用不同的函数压入栈中，然后再用相应的函数把值从栈中取出。当然，对于栈来说，它始终遵循 LIFO 规则，你可以自由的查询栈上的任何元素，也可以在任何位置插入和删除元素。 压入元素API有一系列的压入函数，如空值: lua_pushnil()、整数 lua_pushnumber()、任意字符串 lua_pushlstring()、C风格字符串 lua_pushstring() …1234567void lua_pushnil(lua_State *L);void lua_pushboolean(lua_State *L, int bool);void lua_pushnumber(lua_State *L, lua_Number n);void lua_pushinteger(lua_State *L, lua_Integer n);void lua_pushunsigned(lua_State *L, lua_Unsigned n);void lua_pushlstring(lua_State *L, const char *s, size_t len);void lua_pushstring(lua_State *L, const char * s); 当你使用 Lua API 时， 就有责任保证做恰当的调用。 特别需要注意的是， 你有责任控制不要堆栈溢出。 你可以使用 lua_checkstack 这个函数来扩大可用堆栈的尺寸。无论你何时调用 Lua 调用 C，都要保证栈空间至少有 LUA_MINSTACK 大小的空闲，这个值定义在了 lua.h 中，通常位20。因此，只要你不是不断的把数据压栈， 通常你不用关心堆栈大小。1int lua_checkstack(lua_State *L, int sz); 查询元素栈中的元素通过索引值查询，第一个元素索引为 1，最后一个元素位 n。当索引值为负时，从栈顶开始找，如 -1 也可以表示最后一个元素，-2 指栈顶的前一个元素。例如可以调用 lua_tostring(L, -1) 来调用栈顶元素。 API 提供了一套 lua_is* 函数来检查指定类型的值，如 lua_isnumber，lua_isstring 等，这些函数只检查是否能转换成指定类型。1int lua_is...(lua_State *L, int index); 还有一个 lua_type 函数，它返回栈中元素的类型，在 lua.h 中，每种类型都定义了一个常量 LUA_TNIL 、LUA_TBOOLEAN 、LUA_TNUMBER 、LUA_TSTRING 、LUA_TTABLE 、LUA_TFUNCTION 、LUA_TUSERDATA 。 为了从栈中获取值，还提供了 lua_to* 函数。如给定元素不正确则返回 0 或 NULL。123456int lua_toboolean(lua_State *L, int index);lua_Number lua_tonumber(lua_State *L, int index);lua_Integer lua_tointeger(lua_State *L, int index);lua_Unsigned lua_tounsigned(lua_State *L, int index);const char * lua_tostring(lua_State *L, int index);size_t lua_strlen(lua_State *L, int index); 在上面的例子中，我们检查一个类型值时，通常你需要用 lua_is* 函数来检查，但在Lua 5.2 中新增了如下 lua_to* 函数，在传入值 isnum，如果 isnum 不是 NULL ， *isnum 会被设为操作是否成功。123lua_Number lua_tonumberx(lua_State *L, int index, int *isnum);lua_Integer lua_tointegerx(lua_State *L, int index, int *isnum);lua_Unsigned lua_tounsignedx(lua_State *L, int index, int *isnum); 其他栈操作除了上面所列的栈操作函数，在 C 和 Lua 交换值时，我们还可以通过以下 API 来对栈进行操作：12345678int lua_gettop(lua_State *L);void lua_settop(lua_State *L, int index);void lua_pushvalue(lua_State *L, int index);void lua_remove(lua_State *L, int index);void lua_insert(lua_State *L, int index);void lua_replace(lua_State *L, int index);void lua_copy(la_State *L, int formidx, int toidx);void lua_pop(lua_State *L, int n); lua_gettop 返回栈顶的索引值；lua_settop 它将把堆栈的栈顶设为这个索引。如果新的栈顶比原来的大，超出部分的新元素将被填为nil，如果index为0，把栈上所有元素移除；lua_pushvalue 把栈上给定索引处的元素作一个副本压栈；lua_remove 删除指定索引位置的值；lua_insert 将栈顶值移动到指定位置；lua_replace 把栈顶元素放置到给定位置而不移动其它元素 （因此覆盖了那个位置处的值），然后将栈顶元素弹出。lua_copy 从索引 fromidx 处复制一个值到一个有效索引 toidx 处，覆盖那里的原有值。 不会影响其它位置的值。lua_pop从栈中弹出 n 个元素。lua_settop(L,0) 可以清空栈顶，而 lua_pop 真是利用了这一技巧: 1#define lua_pop(L,n) lua_settop(L, -(n)-1) 栈操作实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include \"lua.h\"#include \"lauxlib.h\"static void stackDump(lua_State *L)&#123; int i; int top = lua_gettop(L); for(i = 1; i &lt;= top; i++) &#123; int t = lua_type(L, i); switch(t) &#123; case LUA_TNIL: printf(\"nil\"); break; case LUA_TBOOLEAN: printf(lua_toboolean(L, i) ? \"true\" : \"false\"); break; case LUA_TNUMBER: printf(\"%g\", lua_tonumber(L, i)); break; case LUA_TSTRING: printf(\"%s\", lua_tostring(L, i)); break; default: printf(\"%s\", lua_typename(L, t)); &#125; printf(\" \"); &#125; printf(\"\\n\\n\");&#125;int main(void)&#123; lua_State *L = luaL_newstate(); lua_pushboolean(L, 1); lua_pushinteger(L, 100); lua_pushnumber(L, 10.011); lua_pushstring(L, \"hello\"); lua_pushnil(L); stackDump(L); lua_pushvalue(L, 1); //将索引为1的元素压入栈顶 stackDump(L); lua_settop(L, 4); //设置栈顶为4 stackDump(L); lua_insert(L, 3); //移动栈顶元素到3 stackDump(L); lua_replace(L, 3); //将栈顶元素移动到3位置，弹出栈顶元素 stackDump(L); lua_copy(L, 2, 3); //将索引为2的元素复制到3位置 stackDump(L); lua_pop(L, 3); //剩余3个元素出栈 stackDump(L); lua_close(L); return 0;&#125; 编译、运行：12345678910111213$ cc -o stack_test stack_test.c -I /usr/local/include/ -L /usr/local/lib/ -llua$ ./stack_testtrue 100 10.011 hello niltrue 100 10.011 hello nil truetrue 100 10.011 hellotrue 100 hello 10.011true 100 10.011true 100 100","categories":[{"name":"Lua","slug":"Lua","permalink":"http://veinin.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://veinin.com/tags/Lua/"},{"name":"Lua C API","slug":"Lua-C-API","permalink":"http://veinin.com/tags/Lua-C-API/"}]},{"title":"Java8编程：Streams API","slug":"java-8-streams-api","date":"2017-05-25T16:32:05.000Z","updated":"2017-11-24T16:33:32.406Z","comments":true,"path":"2017/05/26/java-8-streams-api/","link":"","permalink":"http://veinin.com/2017/05/26/java-8-streams-api/","excerpt":"在Java日常编程中，我们使用的最多的API可能是集合了，集合几乎在所有的单元模块中都会出现。而如果使用集合就必须对集合进行处理，往往开发人员可能需要使用循环去进行重复检查处理。为了简化流程，我们使用SQL查询语句进行数据分组来的更加简单。例如： 1SELECT name FROM person WHERE age &gt; 20; 上诉表达式可以快速的帮你找出年龄大于20的人，但当数据量大的时候，类似的处理效率又成了问题，有些开发人员会想到使用多核进行数据处理，缺乏相关经验的Java开发人员却是非常容易编写出错百出的并行处理代码的。流是Java 8引入的一组新API，我们可以使用流像使用SQL语句一样声明性的方式的进行数据处理。此外，使用流还可以在无须编写额外多线程代码的情况下透明的并行处理。","text":"在Java日常编程中，我们使用的最多的API可能是集合了，集合几乎在所有的单元模块中都会出现。而如果使用集合就必须对集合进行处理，往往开发人员可能需要使用循环去进行重复检查处理。为了简化流程，我们使用SQL查询语句进行数据分组来的更加简单。例如： 1SELECT name FROM person WHERE age &gt; 20; 上诉表达式可以快速的帮你找出年龄大于20的人，但当数据量大的时候，类似的处理效率又成了问题，有些开发人员会想到使用多核进行数据处理，缺乏相关经验的Java开发人员却是非常容易编写出错百出的并行处理代码的。流是Java 8引入的一组新API，我们可以使用流像使用SQL语句一样声明性的方式的进行数据处理。此外，使用流还可以在无须编写额外多线程代码的情况下透明的并行处理。 简介什么是流？流不是数据结构，也不保存数据，流只是一些了的算法和计算的操作序列。其定义包含以下几种元素： 元素序列，以顺序方式提供给流的一组数据，流通过这组数据进行处理计算。 源，提供给流的一个数据源，如集合、数组或I/O资源。 聚合操作，流支持使用顺序或并行进行一系列诸如筛选、查找、匹配、分组、截取的聚合元素操作。 流水线，很多流操作会返回另外一个流，这些操作组合起来形成一个流水线。 自动迭代，流在元素上面的迭代操作是内部迭代进行的，流只能被遍历一次。与其相反，我们常用的如for-each操作被称为外部迭代。 本文大部分例子都是一系列的Person类集合操作，代码清单如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Person &#123; private final String name; private final boolean married; private final int age; private final Sex sex; public Person(String name, boolean married, int age, Sex sex) &#123; this.name = name; this.married = married; this.age = age; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public boolean isMarried() &#123; return married; &#125; public int getAge() &#123; return age; &#125; public Sex getSex() &#123; return sex; &#125; public enum Sex &#123;MALE, FEMALE&#125; public enum AgeDistribution &#123;YOUTH, MIDDLE, ELDERLY&#125;&#125;List&lt;Person&gt; persons = Arrays.asList( new Person(&quot;Mathews&quot;, false, 10, Sex.Male), new Person(&quot;Silvia&quot;, true, 30, Sex.FEMALE), new Person(&quot;Veinin&quot;, false, 25, Sex.Male), new Person(&quot;Bales&quot;, true, 60, Sex.FEMALE), new Person(&quot;Baldry&quot;, true, 40, Sex.FEMALE), new Person(&quot;Sims&quot;, true, 55, Sex.Male),); 流操作java.util.stream.Stream接口定义了许多流操作方法，我们把他们分为两大类： 中间操作流，操作完后会返回另一个流Stream&lt;T&gt;，可以跟其他流处理操作连接起来。连接起来的中间操作不会立即执行。| 操作 | 操作参数 | 函数描述符 || :–: | :: | :–: || filter | Predicate | T -&gt; boolean || distinct | | || limit | | || skip | | || map | Function&lt;T, R&gt; | T -&gt; R || sorted | Comparator | (T, T) -&gt; int| 终端操作流，执行所有流水线操作，并关闭流操作生成结果，其结果不是任何流的值，比如Integer、List、Map、Void等。| 操作 | 目的 || :-: | :: || forEach | 消费流中的元素，应用于制定Lambda操作，返回void || count | 返回流操作结果的个数 || collect | 把流操作结果归纳成一个集合 | 中间操作与终端操作结合后，看起来会是这样子： 1234long count = persons.stream() .filter(Person::isMarried) // 中间操作 .limit(3) // 中间操作 .count(); // 终端操作 上面的流操作包含以下元素： 数据源，persons集合 中间操作链，filter与limit构成一条流水线 终端操作, 执行流水线，并调用count生成结果。 构建流创建一个流有许多种方式，大部分需要流操作的对象都有提供构建流的API。但总体来说可以归纳成以下几种： 通过集合生成流，Collection接口提供了一个默认方法 stream() 用来返回一个流对象 Stream&lt;T&gt; ,如果需要并行处理数据，可以通过 paralleStream() 返回一个并行流。 通过值创建流，Stream 接口中提供了 Stream.of(T) 静态方法，也可以通过 Stream.empty() 返回一个空的流对象。 通过数组创建流，静态方法 java.util.Arrays.stream() 可以从数组中创建一个流。如 IntStream stream = Arrays.stream(new int[]{1, 2, 3}) 。 通过文件生成流， java.nio.file.Files 中提供了多个静态方法可以从文件中生成一个流。 创建无限流，所谓无限流，是指不像上面的流创建方法从指定大小的数据源中得到一个流，它通过给定函数创建一个值，并可以永久的执行下去不断产生新值，一般来说我们通过 limit(n) 来限制这种流。Stream 提供了两个静态方法： Stream.iterate 和 Stream.generate 来产生一个无限流。 123456789// 迭代，从0开始，对每次生产的整数n做加1运算，生产10个数后输出。Stream.iterate(0, n -&gt; n + 1) .limit(10) .forEach(System.out::println);// 生成，接受一个Supplier&lt;T&gt;类型的Lambda表达式来提供新值，生产5个值后打印输出Stream.generate(Math::random) .limit(5) .forEach(System.out::println); 使用流筛选Stream 接口提供了 filter() 方法接受一个谓词参数 Predicate&lt;T&gt; ，返回一个包含所有符合谓词筛选条件的元素的流。例如，我们需要筛选所有已婚人士： 123List&lt;Person&gt; marriedPersons = persons.stream() .filter(Person::isMarried) .collect(toList()); 筛选各异元素Stream 还提供了一个 distinct() 的方法，通过调用元素的 hashCode() 和 equals() 方法来实现元素各异的对比，产生一个没有重复值的流。例如，筛选列表中不重复的值： 1234List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 1, 2, 3);numbers.stream() .distinct() .forEach(System.out::println); // 输出 1, 2, 3 截短流Stream.limit(n)、 Stream.skip(n) 可以对筛选过的流元素进行截短， limit 和 skip 是互补的， limit 截取前n个元素，而skip则是跳过前n个元素，如果元素不足，会返回一个空流。 12345678List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);numbers.stream() .limit(2) .forEach(System.out::println); // 输出 1, 2 numbers.stream() .skip(2) .forEach(System.out::println); // 输出 3, 4, 5 映射有时候我们可能需要从某组元素中提取一组特定对象，比如上Person列表中提取每个人的名字。 Stream.map() 方法能满足我们的需求。 map 方法接受一个 Function&lt;T, R&gt; Lambda表达式作为参数。 123List&lt;String&gt; personNames = persons.stream() .map(Person::getName) .collect(toList()); 扁平化流流的扁平化与映射采用一对一映射关系不同，使用 flatMap 会将map映射时生成的单个流都合并起来。假如给你一个 Stream&lt;List&lt;String&gt;&gt; 流，需要生成一个 Stream&lt;String&gt; 流，并且去除重复的 String 元素时， flatMap 就能派上用场。 12345678Stream&lt;List&lt;String&gt;&gt; integerListStream = Stream.of( Arrays.asList(&quot;Mathews&quot;, &quot;Veinin&quot;), Arrays.asList(&quot;Veinin&quot;, &quot;Baldry&quot;), Arrays.asList(&quot;Sims&quot;));Stream&lt;Integer&gt; stringStream = integerListStream .flatMap(Collection::stream).distinct();stringStream.forEach(System.out::println); 输出： 1234Mathews Veinin Baldry Sims 流的查找与匹配对数据处理的常用功能离不开查找与匹配，Stream API提供了对流的查找匹配相关函数： anyMatch，流中是否有一个元素匹配，返回一个boolean值 allMatch，流中的所有元素是否都匹配，返回一个boolean值 noneMatch， 流中没有任何一个匹配的元素，返回一个boolean值 findAny，返回流中的任一一个元素，返回一个Optional对象。 findFirst，返回流中的第一个出现的元素，返回一个Optional对象。 1234567891011121314persons.stream().anyMatch(Person::isMarried); // 是否有已婚人士persons.stream().allMatch(p -&gt; p.getAge() &lt; 20); // 是否所有人都小于20岁persons.stream().noneMatch(p -&gt; p.getAge() &gt; 30); // 是否没有一个大于30岁的人// 找出任一一个已婚人士，如果有则输出persons.stream() .filter(Person::isMarried) .findAny() .ifPresent(System.out::println); // 找出元素序列中的第一个人，如果找到则输出persons.stream() .findFirst() .ifPresent(System.out::println); 关于Optional类Optional 是Java8新引入的一个类，它是一个可以为null值的容器对象。如果值存在， isPresent() 将会返回 true，并可以通过 get() 方法获取到这个值。关于 Optional的设计思想在 Google Guava 代码库中其实早就已经存在了。当我们在调用函数后，其返回值我们无法判断是否为null时，就可以返回一个 Optional&lt;T&gt; 对象，来代替你的返回值，提示调用者，此返回值可能为空。其使用语法大致为这样：1234Optional&lt;String&gt; name = person.getName();if (name.isPresent()) &#123; System.out.println(name.get());&#125; 归纳map 操作是将一组元素映射成一组新的值，而 reduce 操作则是把这些映射过的元素进行组合操作，通过指定运算规则产生另一个结果。如计算一组数值的平均值、最大、最小值，这些操作都可以归类的归纳操作。常用的 归纳 操作包括：sum、min、max、average、count。比如，我们需要对所有人计算年龄和、最大年龄、最小年龄： 1234567891011int totolAge = persons.stream() .map(Person::getAge) .reduce(0, Integer::sum); Optional&lt;Integer&gt; maxAge = persons.stream() .map(Person::getAge) .reduce(Integer::max);Optional&lt;Integer&gt; minAge = persons.stream() .map(Person::getAge) .reduce(Integer::min); reduce 接受两个参数： 初始值 计算用的lambda表达式，类型为BinaryOperator，讲两个元素结合起来，产生一个新值。 数值流基本数据类型操作流对基本数据类型的装箱、拆箱操作是非常耗时的操作。Stream API提供了3种流接口来解决这个问题：IntStream、LongStream、DoubleStream。上面的归纳操作我们可以使用原始数据类型流来优化： 1234567int totalAge = persons.stream() .mapToInt(Person::getAge) // 返回一个 IntStream .sum();OptionalInt maxAge = persons.stream() .mapToInt(Person::getAge) .max(); 数值范围生成流有时我们需要生成一窜制定范围内的数值，并进行相关操作，比如对1-100范围内的数求和，对于这种操作我们可以使用 range 和 rangeClosed， range 对于 rangeClosed 来说， 前者的结束值将不被包含。 12int total = IntStream.range(1, 100).sum(); // 1-99 数值求和int total = IntStream.rangeClosed(1, 100).sum(); // 1-100 数值求和 分组分组是一个常见的数据库操作，在Java 8之前，我们用代码对数据分组很麻烦，并且容易出错。但如果使用Java 8提供的函数式接口 Collectors.groupingBy 这将变得很简单。如我们将人的性别进行分组，传统的Java操作看起来是这样的： 123456789Map&lt;Sex, List&lt;Person&gt;&gt; personBySex = new HashMap&lt;&gt;();for (Person person : persons) &#123; List&lt;Person&gt; personByList = personBySex.get(person.getSex()); if (personByList == null) &#123; personByList = new ArrayList&lt;&gt;(); personBySex.put(person.getSex(), personByList); &#125; personByList.add(person);&#125; 使用 Collectors.groupingBy 后，我们的代码将大大简化： 1Map&lt;Sex, List&lt;Person&gt;&gt; personBySex = persons.stream().collect(groupingBy(Person::getSex)); 有时候，还需要进一步进行多级分组，如除了性别外，我们还需要对年龄分布进行分组，把人分为年轻组、中年组和老年组： 123456789101112Map&lt;Sex, Map&lt;AgeDistribution, List&lt;Person&gt;&gt; personBySex = persons.stream().collect( groupingBy(Person::getSex), groupingBy(person -&gt; &#123; if (person.getAge &lt;= 30) &#123; return AgeDistribution.YOUTH; &#125; else if (person.getAge &lt;= 50) &#123; return AgeDistribution.MIDDLE; &#125; else &#123; return AgeDistribution.ELDERLY; &#125; &#125;) ); 分区分区是分组的一种特殊处理方式，分区函数讲返回一个boolean值，并把元素分为两类（true or false），存储于 Map&lt;Boolean, T&gt; 当中。Collectors.partitioningBy 提供了这种分区功能，如我们需要对已婚、未婚人士分区时： 1234Map&lt;Boolean, List&lt;Person&gt;&gt; partitionedPerson = persons.stream() .collect(partitioningBy(Person::isMarried)); List&lt;Person&gt; marriedPersons = partitionedPerson.get(true); // 获得已婚组 并行流并行流是把一个问题分解成多个子问题，通过多个线程分别处理每个子问题的流。在处理问题的时候，使用并行流，可以充分利用多核CPU的优势，让任务分摊到每个CPU，让所有CPU都忙起来。 求和运算就是个很好的利用并行处理的例子，传统的Java代码看起来是这样的： 1234567public static long sum(long n) &#123; long result = 0; for (int i = 1; i &lt;= n; i++) &#123; result += i; &#125; return result;&#125; 通过流，我们可以简化其操作： 1234public static long sequentialSum(long n) &#123; return LongStream.rangeClose(1L, n) .reduce(0L, Long::sum);&#125; 使用parallel()方法，我们可以把上面的顺序计算的流转换成并行计算的流： 12345public static long parallelSum(long n) &#123; return LongStream.rangeClose(1L, n) .parallel() .reduce(0L, Long::sum);&#125; 高效的使用并行流并不是说任何流操作，当使用并行的时候都会提升性能的，相反，如果使用不当，并行流效率将会大打折扣，甚至效率也会更加底下。例如如果我们使用 Stream.iterator 进行累计并行计算： 123456public static long parallelSum(long n) &#123; return Stream.iterate(1L, i -&gt; i + 1) .limit(n) .parallel() .reduce(0L, Long::sum);&#125; 上面代码运行效率和传统的for循环对比，运行时间可能要慢上几倍，究其原因是因为 iterate 生成的是进行过装箱操作的对象，iterate 操作原理也很难使其分成多个子任务来单独运行。 对于是否并行流操作，可以先考虑一下几个问题： 留意装箱操作，自动装箱、拆箱操作性能将大大降低。 有些操作顺序流天生就比并行流要快，如limit和findFirst操作都依赖于元素顺序。 对于较小的数据量，并行流不是一个好的方式。 考虑流背后的数据结构是否利于分解，如ArrayList拆分效率比LinkedList要高很多。 考虑流水线的中间操作改变分解、合并过程后是否会降低性能。 总结 一个流操作包含数据源、中间操作链和终端操作。 我们可以通过值、集合、数组、文件以及 iterate 和 generate 生成一个流。 使用 filter 、 distinct 、 limit 、 skip 对流进行筛选和切片。 使用 map 和 reduce 进行映射和归纳操作。 使用 anyMatch 、 allMatch 、 noneMatch 进行流匹配操作，使用 findAny 和 findFirst 进行流查找操作。 对于需要装箱、拆箱的流操作，我们可以使用 IntStream 、 DoubleStream 、 LongStream 。 可以用 groupingBy 对流元素进行分组、用 partitioningBy 进行分区。 通过 parallel 我们可以很容易让一个流操作并行化，但是否选择并行流，我们需要考虑很多因素。 参考 Java 8 in Action java2s stackoverflow","categories":[{"name":"Java","slug":"Java","permalink":"http://veinin.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://veinin.com/tags/Java/"},{"name":"Streams API","slug":"Streams-API","permalink":"http://veinin.com/tags/Streams-API/"}]},{"title":"Java 8编程：Lambda表达式","slug":"java-8-lambda","date":"2017-05-20T10:10:23.000Z","updated":"2017-08-25T16:32:39.334Z","comments":true,"path":"2017/05/20/java-8-lambda/","link":"","permalink":"http://veinin.com/2017/05/20/java-8-lambda/","excerpt":"简介Lambda表达式是Java 8中包含的一个新的重要功能。它们提供了一种更加清晰简明的方法通过使用表达式来表示一个方法接口。将代码行为参数化，让代码更好的适应不断变化的需求，减轻程序员的工作量。它完全取代以往的匿名内部类功能，使代码更加简洁、灵活、易懂。此外，新的并发功能能让我们的代码充分利用多核优势。","text":"简介Lambda表达式是Java 8中包含的一个新的重要功能。它们提供了一种更加清晰简明的方法通过使用表达式来表示一个方法接口。将代码行为参数化，让代码更好的适应不断变化的需求，减轻程序员的工作量。它完全取代以往的匿名内部类功能，使代码更加简洁、灵活、易懂。此外，新的并发功能能让我们的代码充分利用多核优势。 匿名内部类简化匿名内部类表达式可以简单的理解为传递匿名函数的一种方式：它没有名称，只有参数列表、函数主体和返回类型。最常见的GUI编程中匿名内部类就经常出现，如使用一个EventHandler来处理Button的响应事件： 123456Button button = new Button(&quot;Send&quot;);button.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; public void handle(ActionEvent event) &#123; label.setText(&quot;Click!&quot;); &#125;&#125;); 使用Lambda表达式取代匿名内部类的话，它看起来会变成这样： 1button.setOnAction((ActionEvent event) -&gt; label.setText(&quot;Click!&quot;)); Lambda表达式语法Lambda表达式通过一行代码来解决了匿名内部类的庞大性，我们可以理解为它解决了匿名内部类的“垂直为题”。 Lambda表达式由三部分组成： 12 参数 箭头 主体(int x, int y) -&gt; x + y 参数列表 ：这里有类型为int的x和y组成 箭头 ：箭头把参数与Lambda主体分隔开 Lambda主体 ：对x和y进行加法运算，并作为返回值返回 Lambda基本语法可以理解为： 123(parameters) -&gt; expression或(parameters) -&gt; &#123;statements;&#125; 使用实例： 12345(int a, int b) -&gt; a * b // 组合两个值 () -&gt; &quot;Veinin&quot; // 返回一个值() -&gt; &#123; return &quot;Veinin&quot;; &#125; // 使用return() -&gt; new Object() // 创建对象 (String name) -&gt; System.out.println(name); // 消费一个对象 在哪里以及如何使用Lambda我们可以在函数式接口中使用Lambda表达式，那么什么是函数式接口呢？函数式接口其实就是定义一个抽象方法的接口。如我们常用的Java API中的Comparator和Runnable接口: 1234567public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125;public interface Runnable &#123; void run();&#125; Lambda允许你直接以内联的形式为函数接口的抽象提供实现，并把整个表达式作为函数式接口的一个实例。我们也可以用匿名内部类来实现相同的功能，但那相对来说说比较笨拙。 Lambda使用函数式接口为了应用不同的Lambda表达式，Java API已经为我们提供了几个函数式接口。比如我们之前熟悉的Comparable、Runnable和Callable。Java 8中也引入了几个新的函数式接口，他们都定义在了java.util.function中。 Functionalinterface注解如果我们去查询新的Java AP，会发现函数式接口通常都会带有@Functionalinterface标注。这个标注表示该接口被设计成了一个函数式接口。如果你使用@Functionalinterface定义一个接口，而它却不是函数式接口的话，编译器将会返回一个提示错误。 Predicatejava.util.function.Predicate 定义了一个test的抽象方法，它接收一个泛型T对象，并返回一个boolean值。在设计需要使用类型T对象的布尔值表达式时，我们可以使用这个接口。如判断String对象是否为空： 1234567891011@(Blog)FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125;Predicate&lt;String&gt; nonEmptyPredicate = (String s) -&gt; s.isEmpty();List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;, &quot;&quot;, &quot;bbb&quot;);for (String str : list) &#123; System.out.println(nonEmptyPredicate.test(str));&#125; Consumerjava.util.function.Consumer 定义了一个accept的抽象方法，返回值为void，顾名思义，该接口可以接受一个对象，消费对象，对其进行某些操作。如打印List里面的所有对象： 1234567891011@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125;Consumer&lt;Integer&gt; forEach = (Integer i) -&gt; System.out.println(i);List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3);for (Integer number : numbers) &#123; forEach.accept(number);&#125; Functionjava.util.function.Function&lt;T, R&gt; 接口定义了一个apply抽象方法，它接收一个参数T，并返回一个R对象。如果你输入了一个对象，并需要把对象映射到其他对象上去，则可以使用该函数接口定义一个Lambda表达式来实现你的功能。 123456789101112131415@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t);&#125;public static &lt;T, R&gt; List&lt;R&gt; map(List&lt;T&gt; list, Function&lt;T, R&gt; f) &#123; List&lt;R&gt; result = new ArrayList&lt;&gt;(); for (T s : list) &#123; result.add(f.apply(s)); &#125; return result;&#125;List&lt;String&gt; strings = Arrays.asList(&quot;aaa&quot;, &quot;bb&quot;);List&lt;Integer&gt; result = map(strings, (String s) -&gt; s.length()); Supplierjava.util.function.Supplier 接口定义了一个get抽象方法，不接受参数，但会返回一个T对象，我们可以把它当做一个工厂方法，返回特定对象。 1234567891011@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; T get();&#125;public static Person produce(Supplier&lt;Person&gt; supp) &#123; return supp.get();&#125; Person person = new Person();Person sPerson = produce(() -&gt; person); 其他函数式接口 UnaryOperator，接收一种类型参数对象，并返回相同的类型的值。描述符为: T -&gt; T BinaryOperator，接收两个相同类型的参数对象，并返回一个同类型的值。描述符为：(T, T) -&gt; T BiPredicate，接收两个类型参数对象，并返回一个boolean值。描述符为：(T, U) -&gt; boolean BiConsumer，接收两个输入参数，没有返回值。描述符为：(T, U) -&gt; void BiFunction，接收两个输入参数，产生一个结果。描述符为：(T, U) -&gt; R 原始数据类型特化Java类型分为两类，一种是引用类型（如Integer、String、List），另外一种是原始数据类型（如int、double、float、byte等）。涉及原始数据类型对引用数据类型的转换时，Java有一个自动装箱机制，比如自动将int类型转换成Integer，反之亦然。 Java 8也特地提供了避免自动装箱操作的相应的类型函数版本。如IntPredicate可以来解决Integer的自动装箱操作： 123456789@FunctionalInterfacepublic interface IntPredicate &#123; boolean test(int value);&#125;IntPredicate evenNumbers = (int i) -&gt; i % 2 == 0;for (int i = 0; i &lt; 1000; i++) &#123; // 避免1000此自动装箱操作 evenNumbers.test(i);&#125; 方法引用方法引用可以重复使用现有的方法，并可以像Lambda一样传递他们。在某些情况下，它比起Lambda表达式来说更加易读，也更加易懂。如下面对人的年龄排序例子： 12persons.sort((Person p1, Person p2) -&gt; p1.getAge().compareTo(p2.getAge())); 使用方法引用和java.util.Comparator.comparing，我们可以进一步简化为： 1persons.sort(comparing(Person::getAge)); 方法引用可以看作为调用特定方法的Lambda的快捷写法。它的基本思想是：如果你使用一个Lambda是直接去调用一个方法，那么最好是用名称来调用，而不是去描述如何调用。使用方法引用，将使你的代码可读性更好。如Person::getAge (注意:不需要括号，因为没有调用此方法) 就是指明引用了Person类中定义的getAge()方法，它实际上是Lambda表达式(Person person) -&gt; person.getAge()的快捷写法。 方法引用分类 静态方法的方法引用 : 如Long::parseLong 任意类型实例方法的方法引用 : 如Stirng::length 现有对象的实例方法的方法引用 : 如person对象的一个getValue方法，写作：person::getValue 构造函数引用对于构造函数，我们可以通过类名称和关键字new来指明一个构造函数引用，如Person::new。如通过一个无参构造函数构造一个Person对象： 12Supplier&lt;Person&gt; sup = Person::new;Person p1 = sup.get(); 等价于 12Supplier&lt;Person&gt; sup = new Person();Person p1 = sup.get(); 如果你的构造函数是Person(Integer age)，那么Funciton函数接口适合它： 12Funciton&lt;Integer, Person&gt; sup = Person::new;Person p1 = sup.get(12); 相应的如果是三个参数，我们还可以使用BiFunciton函数接口。 方法引用例子123(Person person) -&gt; person.getAge() 简化 Person::getAge(String s) -&gt; s.length() 简化 String::length(String s) -&gt; System.out.println(s) 简化 System.out::println 复合使用Lambda表达式Java8中提供的很多函数式接口都提供了允许复合使用Lambda表达式的方法，其复合方法都使用了default关键字标识。 比较器复合在进行排序功能时，如我们需要进行逆序排序，那么我们可使用Comparator函数中提供的reversed来排序： 12345default Comparator&lt;T&gt; reversed() &#123; return Collections.reverseOrder(this);&#125;persons.sort(comparing(Person::getAge).reversed()); 在我们进行排序的同时，如果发现相同的值时，可能需要比较第二个值来进行排序，比如人的年龄相同的话则按身高排序，我们就可以使用符合语句thenComparing来进一步操作： 123persons.sort(comparing(Person::getAge) .reversed() .thenComparing(Person::getHeight)); 谓词复合谓词复合Predicate提供了and、or和negate三个方法，这其实是我们常用的与、或、非操作。如我们需要判断一个人：未婚、年龄在20-25岁之间且职业是程序狗或教师。 123456789Predicate&lt;Person&gt; married = Person::isMarried;Predicate&lt;Person&gt; condition = married.negate() .and((s) -&gt; s.getAge() &gt;= 20) .and((s) -&gt; s.getAge() &lt;= 25) .and((s) -&gt; s.getProfession().equeas(&quot;programmer&quot;)) .or((s) -&gt; s.getProfession().equeas(&quot;teacher&quot;));Person person = new Person(20, false, &quot;programmer&quot;);condition.test(person) 函数复合Funciton接口提供了andThean和compose两个默认方法，可以把Function相关的Lambda表达式复合起来。 1234567Function&lt;Integer, Integer&gt; f = x -&gt; x * x;Function&lt;Integer, Integer&gt; g = x -&gt; x - 1;Function&lt;Integer, Integer&gt; t = f.andThen(g);Function&lt;Integer, Integer&gt; c = f.compose(g);int result = t.apply(2); // 先调用f，然后调用g，输出3int result = c.apply(2); // 先调用c，然后调用f，输出1 总结 Lambda表达式可以理解为一种匿名内部类，它没有名称，只有参数列表、函数主体和返回类型。 只有一个抽象方法的接口我们称之为函数式接口，Lambda表达式与函数式接口配合使用。 Java 8自带了很多函数式编程接口，能满足我们大部分需求，这些函数定义在java.util.function包里面。为了避免Java的装箱操作，大部分通用的函数接口都提供了针对原始数据类型的特定接口。 Lambda表达式可以把行为参数化，我们可以通过参数传递方法引用。 函数式接口很多默认的方法促使我们可以组合Lambda表达式，进行流水线式的操作。 参考 Java 8 in Action java2s Lambda Expressions","categories":[{"name":"Java","slug":"Java","permalink":"http://veinin.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://veinin.com/tags/Java/"},{"name":"Lambda","slug":"Lambda","permalink":"http://veinin.com/tags/Lambda/"}]},{"title":"《代码整洁之道》读书笔记","slug":"reading-notes-clean-code","date":"2017-02-19T03:29:48.000Z","updated":"2017-11-24T16:32:22.255Z","comments":true,"path":"2017/02/19/reading-notes-clean-code/","link":"","permalink":"http://veinin.com/2017/02/19/reading-notes-clean-code/","excerpt":"什么是代码整洁？有多少程序员，可能就会就有多少定义。本书以详细到吓死人的程序告诉你对代码整洁的看法。它会告诉你关于整洁变量名的想法，关于整洁函数的想法，如此等等。它是一本教你如何编出写好程序的书籍。读完后，我们能知道许多关于代码的事，而且，我们还能说出好代码和糟糕代码之间的差异。我们将了解如何写出好代码。我们也会知道，如何将糟糕的代码改写成好代码。","text":"什么是代码整洁？有多少程序员，可能就会就有多少定义。本书以详细到吓死人的程序告诉你对代码整洁的看法。它会告诉你关于整洁变量名的想法，关于整洁函数的想法，如此等等。它是一本教你如何编出写好程序的书籍。读完后，我们能知道许多关于代码的事，而且，我们还能说出好代码和糟糕代码之间的差异。我们将了解如何写出好代码。我们也会知道，如何将糟糕的代码改写成好代码。 有意义的命名取名字最难的地方在于需要良好的描述技巧和共有的文化背景，与其说这是一种技术、商业或管理问题，倒不如说这是一种教学问题。好名字可以提升你的代码可读性，可以让你代码更易维护和重构。 名副其实选好名字要花时间，但省下来的时间比花掉的时间多。注意命名，一旦发现更好的名称，就换掉旧的。这样做，读你代码的人（包括你自己）都会开心。 变量、函数或类名应该能答复所有大问题，它该告诉你，它为什么存在，它做什么事，应该怎么用。如果名称需要用注释来补充，那就不算名副其实。如： 1int d; //消失的时间，以日记 名称d什么都没说嘛，我们应该指明对象和计量单位的名称： 123int elspedTimeInDays;int daysSinceCreation;int fileAgeInDays; 选择体现本意的名称能让人更容易理解和修改。 1234567public List&lt;int[]&gt; getThem() &#123; List&lt;int[]&gt; list1 = new ArrayList&lt;&gt;(); for (int[] x : theList) if (x[0] == 4) list1.add(x); return list1;&#125; 看完上面代码，我们可以产生以下问题： 它是什么东西？ 它有什么意义？ 值4是什么东西？ 它返回列表用来干嘛？ 问问开发它得程序员，程序员可能会说：我们正在开发扫雷游戏，theList是单元格列表，4是一种状态，我们需要从这里获取到关于这种状态的所有值。 当然，我们可以通过询问来读懂代码，但这不值得提倡，我们可以做的更好，只需要简单改下名字，就能轻易知道发生了什么。 1234567public List&lt;int[]&gt; getFlaggedCells() &#123; List&lt;int[]&gt; flaggedCells = new ArrayList&lt;&gt;(); for (int[] cell : gameBoard) if (cell[STATUS_VALUE] == FLAGGED) flaggedCells.add(x); return flaggedCells;&#125; 做有意义的区分如果程序员只是为了满足编译器或解释器两样不同的东西，从而写代码，那就会制造麻烦。以数字系列命名（a1、a2，…aN），这样纯属误导，完全可以提供更加正确信息。 1copyChars(char a1[], char a2[]) 上面函数的参数名称，如果改名为source和distination，这个函数会像样很多。 使用可搜索的名称单字母名称和数字常量有个问题，就是很难在一大片文字中找出来。找MAX_LASSES_PER_STUDEN很容易，但找数字7很难。同样“e”也不是一个便于搜索的好变量名，它是英文中最常用的字母，每个程序、每段代码都可能出现。由此可见，长名称胜于短名称。搜索可得到的名称胜于胡编乱造的名称。 类名和方法名类名和对象一个是名词或短语，如Customer、WikiPage。类名不应该是动词。方法名应当是动词或动词短语，如postPayment、deletePage。属性访问、修改和断言都应根据其值命名，如前缀加上get、set或is。 函数短小函数的第一规则是短小，第二条规则是还要更短小。应该有多短小？它看起来应该是这样子： 123456public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) &#123; if (isTestPage(pageData)) includeSeteupAndTeardownPage(pageData, isSuite); return pageData.getHtml();&#125; 只做一件事一个函数应该做一件事，做好这件事，只做一件事。函数遵循单一权责原则、开放闭合原则。如果函数只做该函数名下的同一抽象层上的步骤，则函数就是只做了一件事。 每个函数一个抽象层级要确保函数只做一件事，那么函数语句都必须在同一抽象层级上。让代码拥有自顶向下的阅读顺序，每个函数后面都跟着下一抽象层级的函数。把函数分为： 高级抽象层 中级抽象层 还有低等抽象层 123getHtml() // 高String pageName = PathParser.render(pagePath)。 // 中.append(\"\\n\") // 低 函数中的语句都要在同一抽象层级上。 函数参数函数参数最理想的数量是零，其次是一，再次是二，应尽量避免三，有足够的特殊理由才能用三个以上参数（所以无论如何都不要这么做）。 一元函数普遍形式单个参数有两种普遍理由，你也许会为关于那个参数的问题，就像： 1boolean fileExists(\"MyFile\") 也可能是操作该参数，将其转换成其他什么东西，再输出之，例如： 1InputStream fileOpen(\"MyFile\") 标识参数标识参数丑陋不堪，向函数传入布尔值简直骇人听闻的做法。比如: render(true)对于可怜的读者来说仍然摸不着头脑，看到 render(Boolean isSuite) 也许稍有帮助，但仍不够，应该一分为二：reanderForSuite() 和 renderForSingleTest() 二元函数两个参数的函数比一元函数难懂。例如writeField(name比writeField(outputStream, name好懂。尽管两种意义都很清楚，但扫一眼就明白还是第一种。应尽量利用一些机制将二元函数转成一元函数，例如 writeField 方法写成 outputStream 的成员之一，比如这样： outputStream.writeField(name。当然，有些时候两个参数刚好。如 Point(0, 0) 笛卡尔点天生就拥有两个参数。 三元函数比二元函数难懂的多，写三元函数前一定要想清楚。设想 assertEquals(message, expected, actual) 有多少次你读到message时错以为expected呢？ 参数对象如果函数看来需要两个、三个或三个以上的参数，就说明其中一些参数应该封装成类了。如: 12Circle makeCircle(double x, double y, double radius);Circle makeCircle(Point center, double radius); 分隔指令与询问函数要么做什么事，要么回答什么事，但二者不可兼得。下面是设置某个属性，返回是否成功的代码语句： 123boolean set(String attribute, String value);if (set(\"username\", \"unclebob\"))... 从读者的角度来说，并不一定能明白set的含义，你可以改名命名为 setAndCheckIfExists，但对if帮助也不大。解决方案是把指令与询问分隔开来： 123if (attributeExists(\"username\")) &#123; setAttribute(\"username\", \"unclebob\");&#125; 抽离try/cache代码块try/cache代码块丑陋不堪，它搞乱了代码结构，把错误处理与正常的流程混为一谈。最好把try和cache代码块的主题部分抽离出来。 函数只做一件事，而错误处理就是一件事。 12345678910public void delete(Page page) &#123; try &#123; deletePageAndAllRefreces(page) &#125; cache (Exception e) &#123; logError(e); &#125;&#125;private void deletePageAndRefrences(Page page) throws Exceptio &#123;&#125; Don’t repeat yourself一次且仅一次（once and only once，简称OAOO）又称为Don’t repeat yourself（不要重复你自己，简称DRY）或一个规则，实现一次（one rule, one place）是面向对象编程中的基本原则，程序员的行事准则。旨在软件开发中，减少重复的信息。DRY的原则是──系统中的每一部分，都必须有一个单一的、明确的、权威的代表──指的是（由人编写而非机器生成的）代码和测试所构成的系统，必须能够表达所应表达的内容，但是不能含有任何重复代码。当DRY原则被成功应用时，一个系统中任何单个元素的修改都不需要与其逻辑无关的其他元素发生改变。此外，与之逻辑上相关的其他元素的变化均爲可预见的、均匀的，并如此保持同步。 – 摘录维基百科 注释请记住，唯一真正好的注释就是你想办法不去写注释。注释的恰当用法是弥补我们用代码表达意图时遭遇的失败。注意，用了“失败”一词。注释总是一种失败。我们总无法找到不用注释就能表达自我的方法。所以要有注释，这并不值得庆贺。 注释不能美化糟糕的代码写注释的动机之一是糟糕的代码存在。我们编写一个模块，发现它令人困扰、乱起八糟，它烂透了！我们告诉自己：“喔，最好写点注释”。与其花时间编写解释你搞出来的糟糕代码的注释，还不如花时间清洁那堆糟糕的代码。 用代码来阐述能用函数或变量时，就别用注释。你愿意看到： 12// Check to see if the employee is eligible for full benifitsif (employee.flags &amp; HOURLY_FLAG &amp;&amp;employee.age &gt; 65) 还是这个？ 1if (employee.isEligibleForFullBenefits()) 只要你想上几秒钟，就能用代码解释你大部分的意图。很多时候，简单到需要创建一个描述与注释所言同一事物的函数即可。 好注释 法律信息，例如版权及著作权。 提供信息的注释，例如描述抽象方法的返回值。 警告，警告其他情况会出现某种后果的注释。 // TODO 注释，解释为什么该函数现在无所作为，将来会怎么用。 公共AIP注释，标准Java库中的javadoc就是一例。 坏注释 多余的注释，如读注释的时间比读代码花的时间还长的注释。 循环式注释，所谓每个函数、每个变量都要有个注释是愚蠢可笑的。这类注释徒然让代码变得散乱，满口胡言，让人迷糊不接。 注释掉的注释，其他人不敢删除注释掉的代码，他们会想，代码依然放在那儿，一定有其原因，而且这段代码很重要，不能删除。注释掉的对堆积在一起，就像破酒瓶底的残渣一样。 日志式注释，冗长的日志式记录只会让模块变得凌乱不堪，版本管理软件完全可以解决。 废话注释，这类注释废话连篇，当代码修改后，这类注释边做了谎言一堆。如果你在写（或粘贴）注释时都没心思，怎么指望读者从中受益。 12345678910111213141516/** The name. */private String name;/** The version. */private String name;/** The name. */ private String info;/** Returns the day of the month* @return the day of the month*/public int getDayOfMonth() &#123; return dayOfMonth;&#125; 格式代码格式很重要，代码格式不可忽略，必须严肃对待。代码格式关乎沟通，而沟通是专业开发者的头等大事。原始代码修改很久之后，其代码风格和可读性仍会影响到可维护性和拓展性。 垂直格式源代码当个文件应该有多大？例举了市面上常见的8个开源项目，其中大多数文件为200行，最长的500行单个文件组合起来就构建了出色的系统。 垂直方向区隔几乎所有代码都是从上往下读，从左往右读。每行展示一个表达式或一个子句，每组代码行展示一条完整的思路。这些思路用个空白行区间隔开。在封包声明、导入声明和每个函数直接用空白行隔开，没一个空白行都是一条线索，标识出新的独立概念。 垂直距离变量声明应该尽可能的靠近其使用位置。实体变量应该房子类的顶部或底部声明。若一个函数调用了另外一个函数，就应该把他们放在一起，而且调用者应该尽可能的放在被调用者上面。这样，程序就自然有序了。你是否曾经在某个类中摸索，从一个函数跳到另外一个函数，上下求索，想要搞清楚他们的关系，最后却被搞糊涂了？ 关系密切的概念应该相互靠近。 变量声明应该尽可能的靠近其使用位置。本地变量应该在函数顶部出现，实体变量一个在类顶部声明。 横向格式遵循无需拖动滚动条到右边原则。虽然近年来显示器屏幕越来越宽，但并不是所以人的显示器都和你一样，普遍来说推荐屏幕单行代码长度为80上限，当然也不用死守这个数值，推荐上限不超过120个字符。 水平方向空格使用使用空格字符将彼此紧密相关的事物联系到一起，也用空格字符把相关性较弱的事物分割开。 赋值操作符左右边、每一个函数参数右边加上空格 不在函数名与左圆括号之间加空格，因为函数与其参数密切相关 算数运算符优先级高的不用空格，优先级低的加空格 123public static double determinant(double a, double b, double c) &#123; return b*b - 4*a*c;&#125; 水平对其应该对其一组声明中的变量名，或一组复制语句中的右值： 1234private Socket socket;private InputStream output;private FileNesseContext context;private boolean hasError; 团队规则每个程序员都有自己喜欢的规则，但如果在一个团队中的工作，就是团队说了算。一组开发者应当认同一种格式风格，每个成员都应该采用那种风格。我们想要软件拥有一以贯之的风格。我们不想让它显得是由一大票意见相左的个人所写成。好的软件系统是由一些列读起来不错的代码文件组成的。它们拥有一致和顺畅的风格。读者要能确信它们在一个源文件中看到的风格在其他文件中也是同样的用法。绝对不要用各种不同的风格来编写源代码，这样会增加其复杂度。 对象和数据结构将变量设置为私有（private）有一个理由：我们不想其他人依赖这些变量。我们还想在心血来潮时能自由修改其类型或实现。 数据抽象隐藏实现并不只是在变量之间放上一个函数层那么简单。隐藏实现关乎抽象！ 类并不简单的用取值器将其变量推向外间，而是暴露抽象接口，以便用户无需了解数据结构的实现就可以操作数据本地。 1234567891011// 具体点public class Point &#123; public double x; public double y;&#125;// 抽象点public interface Point &#123; double getX(); double getY();&#125; 后者代码更佳，抽象的数据存取策略让你不知道该实现是在矩形坐标系中还是在极坐标系中。我们不愿意暴露数据细节，更愿意以抽象形态表述数据。 数据、对象的反对称性过程式代码： 1234567891011121314151617181920public class Square &#123; public Point topLeft; public double side;&#125;public class Rectangle &#123; public Point topLeft; public double height; public double width;&#125;public static double area(Object object) &#123; if (object instanceof Square) &#123; Square S = (Square) object; return s.side * s.side; &#125; else if (shape instanceOf Rectangle) &#123; Rectangle r = (Rectangle) object; return r.height * r.width; &#125;&#125; 在面向对象方案中我们只需要一个area()多态方法，如果添加新形状只需要重新实现指定接口的一个类。 123public interface Shape &#123; double area();&#125; 过程式代码难以添加新数据结构，因为必须修改所有函数。面向对象代码难以添加新函数，因为必须修改所有类。在任何一个复杂的系统中，有需要添加新数据类型而不是新函数的时候，这时对象和面向对象就比较合适。另一方面，当想添加新函数而不是新数据类型的时候，过程式代码更合适。 数据传送对象最为精炼的数据结构，是一个只有公共变量，没有函数的类。这种数据结构对于数据通信传送、解析是非常有用的。在应用程序代码中“豆”（bean）结构对半封装可能会对某些OO纯化论者感觉舒服些，不过通常没有其他好处。 1234567891011public class Address &#123; private String street; public void Address(String street) &#123; this.street = street; &#125; public String getStreet() &#123; return street; &#125;&#125; 往往我们会看到开发者往这类数据结构中塞进业务规则方法，把这类数据结构当做对象来用。这不是理智的行为，业务它导致了数据结构和对象的混杂体。 错误处理别返回null值你是否见过几乎每行代码都在检查null值得应用程序： 123456789public void registerItem(Item item) &#123; if (item != null) &#123; ItemRgister registry = peristentStore.getItemRegistry(); if (registry != null) &#123; Item existing = registry.getItem(item.getId); // ... &#125; &#125;&#125; 这种代码看似不坏，其实糟糕透了！返回null值基本在给自己增加工作量，也是在给调用者添乱。只要有一处没有检查null值，应用程序就会失控。例如对于空指针异常，我们可能在运行时的得到异常，也许有人在代码顶端捕获异常，也可能没有捕获。如果你打算在代码中返回null值，不如抛出异常，或返回特定对象，如Java 8 引入的Optional对象。 别传递null值返回null值是很糟糕的做法，但将null值传递给其他方法就更糟糕。 123public double xProjection(Point p1, Point p2) &#123; return (p2.x - p1.x) * 1.5;&#125; 上面代码如果我们传入null值，将得到一个空指针异常。当然我们也可以在函数里面进行错误处理： 12345public double xProjection(Point p1, Point p2) &#123; assert p1 != null : \"p1 should not be null\"; assert p2 != null : \"p2 should not be null\"; return (p2.x - p1.x) * 1.5;&#125; 看上去很美，但认为解决问题，因为还是会得到运行时异常。最恰当的做法就是禁止传入null值。 单元测试TDD关于TDD相关可以参考文章《TDD并不是看上去的那么美》以及文章中的相关讨论。 整洁的测试有三个要素：可读性、可读性、可读性。单元测试应该和其他代码中一样：明确、简介，还有足够的表达力。测试代码应该竟可能时候的位子表达大量内容。 每一个测试一个断言，或者是单个测试中断言的数量应该最小化。 每个测试一个概念，好测试应该每个测试一个概念，而不是把所有事情都混在一起。 类类的组织类应该从一组变量列表开始，如果有静态变量，一个先出现。然后是私有静态变量，以及私有实体变量。很少会有公共变量。函数紧跟变量列表之后。公共函数调用的私有工具函数紧随该调用函数后面（自顶向下原则）。 类应该短小与函数一样，类的第一原则是应该短小。第二条原则是还要更短小。多小合适呢？对于类来说，采用不同的衡量方法，计算权责。类名应该描述其权责。命名可以用来帮助判断类的长度。类名越含混，该类拥有的权责就越多。 单一权责原则参考维基百科 内聚参考维基百科 Kent Beck关于简单设计的四条原则 运行所有测试 不可重复 表达了程序员的意图 尽可能减少类和方法的数量 以上规则按其重要程度排列 总结习艺只要有二：知和行。你一个学习得到有关原则、模式和实践的知识，穷尽应知之事，并且要对其了如指掌，通过刻苦实践掌握它。学写整洁代码很难。它可不止要求掌握原则和模式。你得在这上面花功夫。你须自行实践，且体验自己的失败。你须观察他人的实践与失败。你须看看别人是怎样蹒跚学步，再转头研究他们的路数。你须看看别人是如何绞尽脑汁做出决策，又是如何为错误决策付出代码。如果你是一个程序员，或你想成为更好的程序员，都推荐你阅读这本书。能编写整洁代码的程序员就像艺术家，他能用一系列变换把一块白板变作由优雅代码构成的系统。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://veinin.com/categories/读书笔记/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://veinin.com/tags/编程/"},{"name":"代码整洁","slug":"代码整洁","permalink":"http://veinin.com/tags/代码整洁/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-02-17T10:10:23.000Z","updated":"2017-03-01T16:07:31.003Z","comments":true,"path":"2017/02/17/hello-world/","link":"","permalink":"http://veinin.com/2017/02/17/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://veinin.com/categories/Hexo/"}],"tags":[]}]}