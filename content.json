{"meta":{"title":"Veinin","subtitle":null,"description":null,"author":"Veinin Guo","url":"https://veinin.com"},"pages":[{"title":"关于我","date":"2017-02-17T07:41:01.000Z","updated":"2018-08-12T16:40:14.006Z","comments":true,"path":"about/index.html","permalink":"https://veinin.com/about/index.html","excerpt":"","text":"这是一个使用 Hexo 构建的个人技术博客，Hexo 是一个快速、简洁且高效的博客框架，主题使用的是 NexT，本博客托管于 GitHub。 标签男，90后，湖南郴州人，未婚，程序员，游戏服务端开发工程师。 爱好写代码，好的程序员能写出人能读懂的代码。写作，作为一个理科生，语文成绩居然是最好的。游戏，记得玩的第一款PC游戏是暴力摩托，感受和经历过中国游戏从“毒品”到“艺术”历程。煮饭，享受一群人为你剥蒜的乐趣。读书，读书破万卷，下笔如有神。旅行，读万卷书不如行万里路。 联系方式邮箱：veininguo@gmail.comGitHub：https://github.com/veinin"},{"title":"书单","date":"2018-08-08T16:02:49.988Z","updated":"2018-08-08T16:02:49.988Z","comments":true,"path":"booklist/index.html","permalink":"https://veinin.com/booklist/index.html","excerpt":"","text":"这是本人近几年在读以及即将要读的书籍清单，推荐给每一个后端程序员，书单不定期更新。 编程语言C C和指针 C专家编程 C陷阱与缺陷 C++ C++ 沉思录 C++ Primer Effective C++ More Effective C++ C++ templates C++标准库 C++并发编程实战 Lua Lua设计与实现 Lua程序设计 Java Effective java Java并发编程实战 Head First 设计模式 网络 Linux多线程服务端编程 : 使用muduo C++网络库 UNIX 络编程 卷1：套接字联 API UNIX 络编程 卷2：进程间通信 TCP/IP详解 卷1：协议 TCP/IP详解 卷2：实现 TCP/IP详解 卷3：TCP事务协议、HTTP、NNTP和UNIX域协议 TCP/IP 入门经典 Netty 实战 图解 HTTP 图解 TCP IP 网络是怎样连接的 算法 算法：C语言实现 : (第1～4部分) 垃圾回收的算法与实现 算法图解 数据库 Redis 设计与实现 Redis 实战 高性能 MySQL 设计模式 设计模式：可复用面向对象软件的基础 HeadFirst设计模式 图解设计模式 软件开发 大教堂与集市 人月神话 程序设计实践 重构-改善既有代码设计 代码大全 编码整洁之道 修改代码的艺术 微服务设计 工具 Vim实用技巧 UML精粹 Linux POSIX 多线程程序设计 UNIX 环境高级编程 Linux 系统编程 深入理解 LINUX 络技术内幕 Linux命令行与shell脚本编程大全 游戏开发 体验引擎 : 游戏设计全景探秘 大型多人在线游戏开发(2006) 网络多人游戏架构与编程 持续交付 第一本Docker书 Docker生产环境实践指南 持续交付36讲 理财 富爸爸，穷爸爸 小狗钱钱 解读基金+我的投资观与实践 心理学 拖延心理学 : 向与生俱来的行为顽症宣战 自控力 : 斯坦福大学最受欢迎心理学课程 效率 如何阅读一本书 时间管理 : 如何充分利用你的24小时 番茄工作法图解 : 简单易行的时间管理方法 单核工作法图解 : 事多到事少,拖延变高效 历史 人类简史 : 从动物到上帝 其他…待整理"},{"title":"","date":"2017-02-17T07:34:12.000Z","updated":"2017-02-17T07:37:36.227Z","comments":false,"path":"categories/index.html","permalink":"https://veinin.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-17T07:38:13.000Z","updated":"2017-02-17T07:39:32.187Z","comments":false,"path":"tags/index.html","permalink":"https://veinin.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"快节奏多人游戏（4）：延迟补偿","slug":"fast-paced-multiplayer-04","date":"2019-03-14T14:25:00.000Z","updated":"2019-03-20T13:51:56.171Z","comments":true,"path":"2019/03/14/fast-paced-multiplayer-04/","link":"","permalink":"https://veinin.com/2019/03/14/fast-paced-multiplayer-04/","excerpt":"介绍前面 3 篇文章阐述了游戏客户端-服务器的架构，我们总结如下： 服务器从所有客户端获取带有时间戳的输入 服务器处理输入后更新游戏世界状态 服务器将游戏世界的快照发送给所有客户端 客户端发送输入并在本地模拟其效果 客户端获得游戏世界更新，同步预测状态和权威状态，并插入其他实体已知的过去状态。 从玩家的角度来看，这里有两个重要的结论： 玩家可以看到现在的自己 玩家可以看到其他实体的过去 这种情况通常表现会不错，但对于时间和空间都非常敏感的事件来说这就会产生问题，例如：爆头射击敌人。","text":"介绍前面 3 篇文章阐述了游戏客户端-服务器的架构，我们总结如下： 服务器从所有客户端获取带有时间戳的输入 服务器处理输入后更新游戏世界状态 服务器将游戏世界的快照发送给所有客户端 客户端发送输入并在本地模拟其效果 客户端获得游戏世界更新，同步预测状态和权威状态，并插入其他实体已知的过去状态。 从玩家的角度来看，这里有两个重要的结论： 玩家可以看到现在的自己 玩家可以看到其他实体的过去 这种情况通常表现会不错，但对于时间和空间都非常敏感的事件来说这就会产生问题，例如：爆头射击敌人。 延迟补偿当你用你的狙击步枪完美的瞄准了敌人头部，并扣动了扳机，这将是你不能错过的时刻。 但是你并没有打到。 为什么会这样呢？ 在之前的客户端-服务器架构解释中，这是因为你射击敌人的头部是在 100 毫秒之前的位置，而不是你射击时的实际位置。 在某种程度上，它就像在光速的宇宙中游玩，你瞄准了敌人过去的位置，但是当你扣动扳机时他已经消失了。 幸运的是，有一个相对简单的解决方案，大多数时候这对大多数玩家来说是都是会有一个不错的体验（下面内容讨论了一个例外）。 以下是它的工作原理： 当你准备瞄准射击时，客户端会将此事件发送给服务器，服务器会提供完整信息：瞄准射击的确切时间戳以及武器的确切目标。 至关重要的一步，由于服务器获得带有时间戳的所有输入，因此它可以在过去的任何时刻以可信任的方式重构游戏世界。特别是它可以在任何时间点完全按照任何客户的样子重构游戏世界。 这意味着服务器可以在你瞄准射击的瞬间确切地知道武器瞄准的内容。虽然对客户端来说敌人头部是的过去位置，但服务器是知道敌人头部在你现在的瞄准位置。 服务器在射击的时间点处理镜头，并更新客户端。 现在每个人都很开心！ 服务器很高兴，因为他是服务器，他总是很开心。 你也很高兴，因为你瞄准了敌人的头部，进行射击，并得到一个爆头奖励！ 敌人可能是唯一一个不完全开心的人。如果他在被击中时站着不动，这是他的错，对吧？如果他在动……哇，你是一个非常棒的狙击手。 但是，如果他处于空位，背后是一堵墙，然后在他认为自己安全的情况下，在几分之一秒后被枪杀了怎么办？ 嗯，这可能发生。这是你做出的权衡。因为你过去向他射击，他在掩护后的几毫秒可能仍会被射杀。 这有点不公平，但对于每个参与者来说，这是最合适的解决方案。错过了一次不容错过的射击会更糟糕！ 结论这是我对于快节奏多人游戏的最后一篇文章。很显然很多事情很难做到正确，但是对于正在发生的事情有明确的概念性理解，这并不是很困难。 虽然这些文章的读者都是游戏开发者，但它也发现了另一群对这个感兴趣的读者：游戏玩家！从游戏玩家的角度来看，理解为什么有些事情以这种方式发生也是非常有趣的。 进一步阅读尽管这些技术看起来很聪明，但我不能说对它们有任何功劳，这些文章只是我从其他渠道学到的一些概念所整理成的简单易懂的指南，其中包括文章、源代码以及一些实验。 关于这个主题相关的文章你可以参考：What Every Programmer Needs To Know About Game Networking 与 Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization 系列文章目录： 快节奏多人游戏（1）：客户端与服务器架构 快节奏多人游戏（2）：客户端预测与服务器协调 快节奏多人游戏（3）：实体插值 快节奏多人游戏（4）：延迟补偿 翻译原文","categories":[{"name":"多人游戏","slug":"多人游戏","permalink":"https://veinin.com/categories/多人游戏/"}],"tags":[{"name":"多人游戏","slug":"多人游戏","permalink":"https://veinin.com/tags/多人游戏/"},{"name":"多人游戏网络同步","slug":"多人游戏网络同步","permalink":"https://veinin.com/tags/多人游戏网络同步/"}]},{"title":"快节奏多人游戏（3）：实体插值","slug":"fast-paced-multiplayer-03","date":"2019-03-10T12:05:00.000Z","updated":"2019-03-20T13:50:04.106Z","comments":true,"path":"2019/03/10/fast-paced-multiplayer-03/","link":"","permalink":"https://veinin.com/2019/03/10/fast-paced-multiplayer-03/","excerpt":"介绍在本系列的第一篇文章中，我们介绍了权威服务器的概念及其防止客户欺骗的用处。然而，天真地使用这种技术可能会导致关于可玩性和响应性的潜在问题。在第二篇文章中，我们提出了客户端预测作为克服这些限制的方法。 这两篇文章的最终结果传递的一组概念与技术是允许玩家通过互联网连接到权威的服务器，并在传输延迟的情况下，让玩家以一种完全像玩单机游戏的感觉方式控制游戏中的角色。 在本文中，我们将对连接到同一服务器的其他玩家进行探索。","text":"介绍在本系列的第一篇文章中，我们介绍了权威服务器的概念及其防止客户欺骗的用处。然而，天真地使用这种技术可能会导致关于可玩性和响应性的潜在问题。在第二篇文章中，我们提出了客户端预测作为克服这些限制的方法。 这两篇文章的最终结果传递的一组概念与技术是允许玩家通过互联网连接到权威的服务器，并在传输延迟的情况下，让玩家以一种完全像玩单机游戏的感觉方式控制游戏中的角色。 在本文中，我们将对连接到同一服务器的其他玩家进行探索。 服务器时间步长在上一篇文章中，我们描述服务器的行为非常简单：它读取客户的输入，更新游戏状态，并发送结果给客户端。但当多个客户端连接时，服务器的主循环将会有所不同。 在多个客户端同时连接同一个服务器的情况下，多个客户端可能同时发送输入信息，并且速度将非常快（玩家可以快速的发送诸如按箭头按键、移动鼠标或者点击屏幕的输入操作）。服务器接受每个客户端的输入操作然后马上广播更新后的游戏世界状态将是非常消耗CPU和网络带宽的。 一个更好的方式是对接受的每个客户端输入进行排队，而不需要接受一个就马上进行处理。相反，游戏世界以一个较低的频率周期性的更新。例如每秒更新 10 次，每次更新之间产生的延迟（这种情况下为 100 毫秒），我们称之为步长。在每次更新循环的迭代中，所有未处理的客户都输入指令都将应用到游戏世界中去（处理这些指令的时间增量可能比时间步长更小一些），并将新状态广播给客户端。 总之，服务器游戏世界里面的更新步长速率是根据客户端的输入而独立存在的，并且是可以被预测的。 处理低频率更新从客户的角度来看，上面提到的方案可以很容易的进程预测，客户都的预测工作因为与延迟无关，因此在相对不频繁的状态更新的中也是可以进行预测的。但是，由于客户端的低频率广播（继续使用100毫秒的示例），客户端得到的关于其他实体可能在游戏中移动的信息是非常少的。 在下面的第一个实现中，我们将在接受到服务器的状态更新后再更新角色的位置信息，但这回导致角色的运动非常不稳定，你可能看到的是每 100 毫秒玩家就瞬移一次，而不是很平滑的移动到目的地。 根据你正在开发的游戏类型中，有很多方法可以解决这个问题。一般来说，你的游戏实体越可预测，那么就越容易做到正确。 航位（Dead reckoning）推算假设你正在制作一款赛车游戏，一辆正在快速行驶的汽车是非常容易预测的。例如，如果它以每秒100米的运行速度，一秒钟后它距离开始的地点大约是100米。 为什么只能是概略的计算呢？因为一秒钟内，汽车可能会加速或者减速，抑或是转向左侧或右侧一点，这里的关键字是“一点”。不管玩家实际在做什么，汽车的可操作性使得其在高速运行时的任何一个时间点的位置高度依赖于其之前的位置、速度和方向。换句话说，赛车是不可能立即就旋转 180 度的。 这种情况下，我们应该如何在每 100 毫秒的步长情况下发送服务器的更新呢？客户端每收到一次其他车辆的速度和方向后，在接下来的 100 毫秒它将无法再接收到任何新的信息，但客户端却依旧需要显示车辆正在运行。最简单的解决方案是假设汽车的方向和加速度都会在 100 毫秒内保持不变，我们可以使用这个参数在本地运行汽车的物理模拟。然后，100 毫秒后，当服务器的更新到达时，再将汽车的位置进行校正。 在很多变动的因素下，这些校正的参数可能会很大，当然也可能相对较小。如果玩家确实把汽车保持在直线上并且不改变汽车的速度，那么预测的位置将和校正位置完全相同。另外，如果玩家遭受到了撞击，那么预测的位置可能会有非常大的错误。 需要注意的是航行位置推算可以应用于低速的情况，例如战舰。事实上，“航位推算”一词来源于海上航行。 实体插值在某些情况下，根本无法运用航位推算，特别是在玩家的方向和速度可以可以立刻改变的情况下。例如，在 3D 射击游戏中，玩家通常会以非常高的速度进行跑动、停止和转向操作，这使得航位推算根本无法应用，因为根据玩家之前的位置和速度的数据根本无法预测接下来会发生什么。 当服务器发送权威数据时，你不能只更新玩家的位置，这样你只会让玩家每 100 毫秒只更新一次位置，这会让游戏无法继续玩下去。 你需要解决的是在你拥有的每 100 毫秒的权威位置数据里面，如何和向玩家展示中间发生了什么事情。解决这个问题的关键是展示其他玩家相对当前玩家来说的过去时间。 假设你在 t = 1000 时收到位置数据，并且你已经在 t = 900 时也收到了数据，因此你现在知道玩家在 t = 900 和 t = 1000 时的位置数据。你可以在 t = 1000 和 t = 1100 显示其他玩家从 t = 900 到 t = 1000 所做的事情。在“延迟”显示100毫秒的情况下，通过这种方式，你始终会显示用户的实际移动数据。 用于从 t = 900 到 t = 1000 进行插值的位置数据取决于游戏。通常插值效果以及不错了，如果觉得还不够好，你可以让服务器在每次更新时发送更详细的移动数据。例如，玩家紧随一系列的直线段，或每隔 10 ms 采样一次的位置，这样的插值看起来会更好（在你发送一些增量的小规模移动数据时，你可以针对此特殊情况对线路上的数据格式进行大量优化，因此你不太需要为此发送10倍数量级的数据）。 请注意，使用这种技术，每个玩家看到游戏世界的渲染都会略有不同，因为每个玩家虽能看到现在的自己，但看到的其他实体却是过去的行为。然而，即使对于快节奏的游戏，看到具有 100 毫秒延迟的其他实体通常也是显而易见的。 这里有一些例外，当你需要很多空间和时间精度时，例如当玩家向其他玩家射击时，由于看的是过去的其他玩家，你的目标是延迟 100 毫秒的，也就是说，你的射击的是 100 毫秒前目标！我们将在下一篇文章中讨论这个问题。 总结在具有权威服务器的客户端-服务器环境中，因为不太频繁的更新与网络延迟，你仍然必须给予每个玩家显示连续性和平稳移动的假象。在本系列文章的第2部分中，我们探索了一种使用客户端预测和服务器协调来实时显示用户控制的玩家的移动方法，这可确保用户输入会立即对本地玩家产生影响，消除因为延迟而导致游戏无法继续下去的影响。 但是，游戏中的其他实体仍然是个问题。在本文中，我们探讨了两种处理它们的方法。 第一种方法，航位推算，适用于实体的位置可以从先前的实体数据（例如位置，速度和加速度）进行预估的游戏。当不满足这些条件时，此方法将不可行。 第二个方法，实体插值，当你根本无法预测实体未来的位置时，且它仅能使用服务器提供的真实实体数据时，你可以显示其他实体时在时间上稍微做一些延迟让步。实际效果是用户能看到玩家自己在当前的实际数据，但其他实体看到的却是过去。这通常会带来难以置信的无缝体验。 但是，如果不做其他事情，当需要高分辨率和时间精度时，例如对一个移动的目标进行瞄准射击，上面的做法将不可用：当客户端2渲染客户端1的位置与服务器端客户端1的位置不匹配时，这会让爆头射击变得不可用。由于没有了爆头射击功能，游戏也会变得不完整，我们将在下一篇文章中处理这个问题。 系列文章目录： 快节奏多人游戏（1）：客户端与服务器架构 快节奏多人游戏（2）：客户端预测与服务器协调 快节奏多人游戏（3）：实体插值 快节奏多人游戏（4）：延迟补偿 翻译原文","categories":[{"name":"多人游戏","slug":"多人游戏","permalink":"https://veinin.com/categories/多人游戏/"}],"tags":[{"name":"多人游戏","slug":"多人游戏","permalink":"https://veinin.com/tags/多人游戏/"},{"name":"多人游戏网络同步","slug":"多人游戏网络同步","permalink":"https://veinin.com/tags/多人游戏网络同步/"}]},{"title":"快节奏多人游戏（2）：客户端预测与服务器协调","slug":"fast-paced-multiplayer-02","date":"2019-03-06T14:10:00.000Z","updated":"2019-03-20T13:49:39.403Z","comments":true,"path":"2019/03/06/fast-paced-multiplayer-02/","link":"","permalink":"https://veinin.com/2019/03/06/fast-paced-multiplayer-02/","excerpt":"介绍在本系列文章的第一篇文章中，我们探讨了一个客户端-服务器模型，它具有一个权威的服务器和愚蠢的客户端，客户端只是输入发送指令到服务器，然后服务器发送更新后的游戏状态给客户端进行展示。 该方案的简单实现会导致客户端输入指令和屏幕上的更新之间产生延迟。例如一个玩家按下了右键，角色开始移动前需要等待半秒钟，这是因为客户端的输入必须首先发送给服务器，服务器必须处理输入并计算出最新的游戏状态，并且把更新后的游戏状态再次发送给客户端。 在因特网这类网络环境中，这里的延迟可能只是十分之几秒，游戏可能感觉最多时没有反应，或者最坏的情况下，游戏会无法继续玩下去。在本文中，我们将找到最小化延迟甚至消除该问题的方法。","text":"介绍在本系列文章的第一篇文章中，我们探讨了一个客户端-服务器模型，它具有一个权威的服务器和愚蠢的客户端，客户端只是输入发送指令到服务器，然后服务器发送更新后的游戏状态给客户端进行展示。 该方案的简单实现会导致客户端输入指令和屏幕上的更新之间产生延迟。例如一个玩家按下了右键，角色开始移动前需要等待半秒钟，这是因为客户端的输入必须首先发送给服务器，服务器必须处理输入并计算出最新的游戏状态，并且把更新后的游戏状态再次发送给客户端。 在因特网这类网络环境中，这里的延迟可能只是十分之几秒，游戏可能感觉最多时没有反应，或者最坏的情况下，游戏会无法继续玩下去。在本文中，我们将找到最小化延迟甚至消除该问题的方法。 客户端预测即使有一些作弊的玩家，大多数的时候服务器都可以处理有效的请求（来自非作弊客户端和欺骗那些在特定时间没有欺骗的客户）。这意味着收到的大部分输入都是有效的，并会按预期更新游戏状态。也就是说，如果你的角色位于坐标（10, 10）并按下右箭头键，它将结束于坐标（11,10）。 我们可以利用这个优势，如果游戏世界足够确定（即给定游戏状态和一组输入，结果是完全可预测的）。 假设我们有一个 100 毫秒的延迟，并且从一个方格移动到下一个方格的角色动画也需要 100 毫秒，使用上文提到的简单实现，这个操作加上延迟则需要花费 200 毫秒： 由于世界是确定性的，我们可以先假设我们发送到服务器的输入将成功执行。在此假设下，客户端可以在处理输入后预测游戏世界的状态，并且大多数情况下这将是正确的。 我们可以发送输入并开始渲染输入的结果，就像它们已经成功一样，而不是发送输入并等待新游戏状态开始呈现它。通常情况下，我们等待服务器发送的“真实”游戏状态将匹配本地计算的状态： 现在玩家的动作和屏幕上的结果之间绝对没有延迟，而服务器仍然具有权威性（如果被黑客攻击的客户端会发送无效输入，它可以在屏幕上呈现任何想要的内容，但它不会影响服务器状态）。 同步问题在上面的例子中，我仔细选择了的延迟数字能游戏一切正常。但是，请考虑稍微修改的情况：假设我们对服务器有 250 毫秒的延迟，从正方形移动到下一个需要 100 毫秒。我们可以说玩家连续按下了右键2次，并试图向右移动2个方格。 使用上面的客户端预测技术，这将会发生以下事情： 当新的游戏状态到来时，我们在 t = 250 毫秒遇到一个有趣的问题。客户端此时预测的状态是 x = 12，但服务器说新的游戏状态是 x = 11。由于服务器是权威的，因此客户端必须将角色移回 x = 11。但是，一个新的服务器状态会在 t = 350 到达，表示 x = 12，所以玩家角色将再次跳转到当前正确的游戏状态。 从玩家的角度来看，他按了两次右箭头键，角色向右移动了两个方格，在那里站了 50 毫秒，向左跳了一个方格，在那里站了 100 毫秒，又向右跳了一个方格。你可以想象，这种游戏体验是不可接受的。 服务器对账解决这个问题的关键是要意识到客户端在当前时间看到游戏世界，但由于滞后，它从服务器获得的更新实际上是过去的游戏状态。当服务器发送更新的游戏状态时，它还没有处理客户端发送的所有命令。 但是，要解决这个问题并不是非常困难。首先，客户端为每个请求添加序列号，在我们的例子中，第一次按键是请求 #1，第二次按键是请求 #2。然后，当服务器回复时，它包括它处理的最后一个输入的序列号： 现在，在 t = 250 时，服务器会说 “基于我看到你的请求 #1，你的位置是 x = 11”。因为服务器是权威的，所以它将字符位置设置为 x = 11。现在让我们假设客户端保留了它发送给服务器的请求的副本。基于新的游戏状态，它知道服务器已经处理了请求 #1，因此它可以丢弃该副本。但它也知道服务器仍然必须发回处理请求 #2 的结果。因此，再次应用客户端预测，客户端可以基于服务器发送的最后权威状态以及服务器尚未处理的输入来计算游戏的“当前”游戏状态。 因此，在 t = 250 时，客户端收到了 “x = 11，最后处理的请求 = #1” 的消息。客户端会将其发送输入的 #1 副本丢弃掉，但它仍然保留了 #2 的副本，因为该副本尚未得到服务器的确认。它使用服务器发送的内容更新游戏内部状态：x = 11。此时应用服务器仍未看到的所有输入，在这种情况下，输入 #2 的结果是开始向右移动，最终结果是 x = 12，这将是正确的。 继续上面的例子，在 t = 350 时刻，一个新的游戏状态从服务器到达，这次它说 “x = 12，最后处理的请求 = #2”。此时，客户端丢弃所有到 #2 的输入，并更新状态 x = 12。你可以看到，这里没有处理任何重复的输入，处理结束后，结果也是正确的。 其他上面讨论了一个简单的玩家移动的例子，但同样的原则可以应用于几乎所有的其他事物上面。例如，在回合制战斗中，当前玩家攻击另外一个角色，您可以显示攻击血液特效和表示扣血的数字，但没有在服务器返回角色的真正血量之前，你不应该直接更新角色真实的血量情况。 由于游戏状态的复杂性，并不是很容易把状态逆转回来。你可能希望避免直接预测角色的死亡状态，直到服务器告诉你角色死亡后才真正执行死亡逻辑，虽然有时候角色的血量在客户的游戏状态已经降为 0 以下了（如果另外一个角色在受到致命打击之前使用了急救箱，而此时服务器还没告诉你）。 这给我们带来了一个有趣的观点，即使游戏世界是完全确定并且没有任何作弊的客户端，客户端预测的状态和服务器发送的状态仍然可能在协调后不匹配。如上所诉，本文的描述不太可能使用在单个玩家身上，但当多个玩家连接到一个服务器上时这些问题很容易就遇到。我们将在下一篇文章继续讲解。 总结在使用权威的服务器时，你需要等待服务器实际处理的输入时提供一些模拟响应的假象，因此，客户端需要模拟输入的结果，当服务器实际的状态到达时，预测的客户端将从更新的状态中以及客户端发送的输入指令重新计算。 系列文章目录： 快节奏多人游戏（1）：客户端与服务器架构 快节奏多人游戏（2）：客户端预测与服务器协调 快节奏多人游戏（3）：实体插值 快节奏多人游戏（4）：延迟补偿 翻译原文","categories":[{"name":"多人游戏","slug":"多人游戏","permalink":"https://veinin.com/categories/多人游戏/"}],"tags":[{"name":"多人游戏","slug":"多人游戏","permalink":"https://veinin.com/tags/多人游戏/"},{"name":"多人游戏网络同步","slug":"多人游戏网络同步","permalink":"https://veinin.com/tags/多人游戏网络同步/"}]},{"title":"快节奏多人游戏（1）：客户端与服务器架构","slug":"fast-paced-multiplayer-01","date":"2019-03-02T13:13:37.000Z","updated":"2019-03-20T13:49:28.313Z","comments":true,"path":"2019/03/02/fast-paced-multiplayer-01/","link":"","permalink":"https://veinin.com/2019/03/02/fast-paced-multiplayer-01/","excerpt":"介绍这是探索使快节奏多人游戏成为可能的技术和算法的系列文章中的第一篇。下面只是一个介绍性的入门讨论，如果你已经熟悉多人游戏设计背后的理念，你可以跳到下一篇文章。 开发任何类型的游戏本身都是具有非常大的挑战性的。然而，多人游戏却增加了很多需要我们处理的新问题。有趣的是，其核心问题却是人性和物理！ 作弊问题多人游戏的一切都始于作弊。 作为一个游戏开发者，你通常并不关心一个玩家是否在一个买断制的单机游戏中作弊，你也不用关心他的行为是否会影响其他玩家。作弊的玩家可能无法完全按照你的计划去体验游戏，但是由于他们购买了游戏，所以他们有权以任何他们喜欢的方式玩游戏。 而多人游戏与单机游戏则恰恰相反。在任何有竞争性的游戏当中，玩家作弊的目的可能只是为了让自己更好，但往往这种作弊行为同时也会让其他玩家对游戏的体验变得更糟。作为开发人员，你必须避免这种情况的发生，因为只要有一个作弊玩家的存在往往会导致更多的其他玩家离去，最后你的游戏也会变得没有任何人玩。 有许许多多的防止游戏中作弊的方法，但其中最重要的一个（可能也是唯一有意义的一个）却很简单：不要相信玩家，总是假设最坏的情况–玩家会试图作弊。","text":"介绍这是探索使快节奏多人游戏成为可能的技术和算法的系列文章中的第一篇。下面只是一个介绍性的入门讨论，如果你已经熟悉多人游戏设计背后的理念，你可以跳到下一篇文章。 开发任何类型的游戏本身都是具有非常大的挑战性的。然而，多人游戏却增加了很多需要我们处理的新问题。有趣的是，其核心问题却是人性和物理！ 作弊问题多人游戏的一切都始于作弊。 作为一个游戏开发者，你通常并不关心一个玩家是否在一个买断制的单机游戏中作弊，你也不用关心他的行为是否会影响其他玩家。作弊的玩家可能无法完全按照你的计划去体验游戏，但是由于他们购买了游戏，所以他们有权以任何他们喜欢的方式玩游戏。 而多人游戏与单机游戏则恰恰相反。在任何有竞争性的游戏当中，玩家作弊的目的可能只是为了让自己更好，但往往这种作弊行为同时也会让其他玩家对游戏的体验变得更糟。作为开发人员，你必须避免这种情况的发生，因为只要有一个作弊玩家的存在往往会导致更多的其他玩家离去，最后你的游戏也会变得没有任何人玩。 有许许多多的防止游戏中作弊的方法，但其中最重要的一个（可能也是唯一有意义的一个）却很简单：不要相信玩家，总是假设最坏的情况–玩家会试图作弊。 权威的服务器和愚蠢的客户端这里有一个看似很简单的解决方案：你可以让游戏中的所有内容都发生在你控制的中央服务器中，并使客户端成为游戏的特权观众。换句话说，你的游戏客户端将输入（按键、指令）发送到服务器，而服务器运行着游戏，并处理玩家的输入，把运行的结果发送回客户端。我们叫这种服务器为“权威性服务器”，因为服务器有权触发游戏时间中发生的任何事情。 当然，你的服务器可能会被某个漏洞利用，但这超出了本系列文章的范围。但是，使用权威的服务器可以防止各种各样的黑客攻击。例如，如果你不信任游戏中客户端的玩家HP的数值状态，当被客户端被黑客攻击并修改其本地的HP数值时，告诉服务器它的HP数值增加了10000%，但服务器其实是知道玩家血量只有1%，当受到其玩家攻击时，服务器就会判断其死亡，无论黑客对客户端做了任何修改都是徒劳无功的。 另外一个简单的例子中，对于玩家在游戏时间上的坐标位置。如果你让客户端告知服务器其所处的位置，那么如果受到黑客攻击，玩家上一秒在位置 (10, 10)，一秒钟后可能就变成 (20, 10) 坐标的情况，玩家可能会很轻易就穿越一堵墙，或者跑的比其他玩家更快。相反，在一个权威的服务器中，如果让服务器知道玩家所处的位置，客户端告诉服务器“我想向右移动一个方格”，服务器用 (11, 10) 更新玩家位置的变化，并回复客户端“你现在的位置在 (11, 10)”。 总之，游戏状态仅由服务器来管理。客户端将操作发送给服务器。服务器定时更新游戏状态，然后将新游戏状态发送回客户端，客户端只是在屏幕上呈现更新后的状态。 网络传输愚蠢的客户端方案在慢节奏的回合制游戏中会工作的很正常，例如战略游戏和扑克牌。它也适用于局域网，在所有实际应用中，通信都是即时的。但是，用游戏运用于互联网进行快节奏的游戏时，这一切都会被打破。 我们来谈谈网络中物理相关的知识。假设你在旧金山，连接到纽约的服务器，那是大约 4000 公里，没有什么东西能比光传输的更快，甚至互联网上的传输的字节（在较低级别是光脉冲，电缆中的电子或电磁波），光大约以 300000 km/s 的速度行进，因此传输 4000 公里大约需要 13 毫秒。 这可能听起来非常快，但它实际上是一个非常乐观的数据，它假设数据是以直线路径的光速传播的，但实际上很少有这种情况。在现实生活中，数据经历了路由器的一系列跳转，其中大多数都不是在光速中进行的，每个路由器自身也会引入一些延迟，因为数据包往往需要拷贝、校验以及重新路由等操作。 为了论证，我们假设从客户端到服务器的数据传输需要50毫秒，这可能是最佳的情况。但是如果你在纽约连接到东京的服务器会发生了什么呢？如果由于某种原因出现网络拥塞怎么办？延迟可能会是100毫秒、200毫秒，甚至高达500毫秒。 回到我们上一个例子，你的客户端向服务器发送了一个输入：我按下了右箭头，服务器在50毫秒后获得它，假设服务器处理请求并立即发回更新的状态。您的客户端在50毫秒后获得最新的游戏状态：你现在处于位置 (1, 0)。从你的角度来看，在你按下右箭头的 1/10 秒内没有发生任何事情，然后你的角色终于向右移动了一个方格，你的输入与输出的结果的显示延迟看起来并不多，但它们是显而易见的。当然，如果你的延迟在半秒以上，你的游戏甚至会因为出现卡顿而无法继续进行下去。 总结联网的多人游戏非常有趣，但它也引入了一系列全新的挑战。权威的服务器架构非常擅长阻止大多数的作弊，但其实现可能会使游戏中的操作产生延迟，并使玩家感到反应迟钝。 在下面的文章中，我们将探讨如何构建一个权威服务器的系统，同时最大限度的减少玩家所经历的操作延迟，使其几乎与本地单人游戏无任何区别。 系列文章目录： 快节奏多人游戏（1）：客户端与服务器架构 快节奏多人游戏（2）：客户端预测与服务器协调 快节奏多人游戏（3）：实体插值 快节奏多人游戏（4）：延迟补偿 翻译原文","categories":[{"name":"多人游戏","slug":"多人游戏","permalink":"https://veinin.com/categories/多人游戏/"}],"tags":[{"name":"多人游戏","slug":"多人游戏","permalink":"https://veinin.com/tags/多人游戏/"},{"name":"多人游戏网络同步","slug":"多人游戏网络同步","permalink":"https://veinin.com/tags/多人游戏网络同步/"}]},{"title":"寻路算法揭秘（4）：实用 A* 算法","slug":"pathfinding-demystified-04","date":"2019-02-28T14:13:45.000Z","updated":"2019-03-25T16:24:07.035Z","comments":true,"path":"2019/02/28/pathfinding-demystified-04/","link":"","permalink":"https://veinin.com/2019/02/28/pathfinding-demystified-04/","excerpt":"介绍本系列的前三篇文章从寻路算法的基础知识开始，最后非常清晰明了地阐述了A *算法。这在理论上是很好的，但对于理解如何在实践中应用它却是一个不同的主题。 例如，如果你的世界不是网格怎么办？ 如果你的角色不能瞬间旋转90度怎么办？ 如果你的世界是无限的，你又该如何建立一个图表？ 如果您不关心路径上的长度，但是您依赖太阳光并且需要尽可能地在阳光下呢？ 如何找到两个目标节点中任何一个的最短路径？","text":"介绍本系列的前三篇文章从寻路算法的基础知识开始，最后非常清晰明了地阐述了A *算法。这在理论上是很好的，但对于理解如何在实践中应用它却是一个不同的主题。 例如，如果你的世界不是网格怎么办？ 如果你的角色不能瞬间旋转90度怎么办？ 如果你的世界是无限的，你又该如何建立一个图表？ 如果您不关心路径上的长度，但是您依赖太阳光并且需要尽可能地在阳光下呢？ 如何找到两个目标节点中任何一个的最短路径？ 成本（Cost）函数在最初的示例中，我们搜索了从开始节点到目标节点之间的最短路径。然而，我们没有将路径长度存储在一个变量 length 中，而是将其命名为 cost，为什么呢？ A* 搜索不仅仅能搜索到最短路径，还可以搜索到你定义的“最好”的路径，这对我们的目标是有好处的。当我们想要最短路径时，代价时路径的长度；但当我们想要最小化，比如说，燃料消耗，那就得把它当作消耗成本（cost）；如果你想最大化“阳光下的时间”，那么成本就是没有阳光的时间。诸如此类… 这通常意味着图中的每一条边都与一个特定的成本相关。在最初的例子中，因为我们在计算路径上的步长，路径的成本是隐式的，假设它总是为 1，但是你可以根据你想要的最小化的任何值来调整每条边的成本。 目标（Goal）函数假设你是一辆汽车，需要去加油站。任何加油站都可以。您想要到最短的路径的最近加油站。 一种天真的方法是依次计算到每个加油站的最短路径，然后选择最短的路径。这会奏效，但这会非常浪费。 你可以做的是用过一个方法来替换单一的目标节点（goal_node），这个方法根据给定的节点来判断是否是目标节点。这样你可以同时寻找多个目标，你还可以调整启发式算法，以返回所有可能目标的最小估计成本。 根据你的具体情况，你可能无法准确到达目标，或者这样做成本很高（如果你在一张巨大的地图中传送一个角色，你会在一哪怕一英寸的差距吗？），因此，方法 is_goal_node 可以在“足够接近”时返回 true。 不需要很明确将世界表示为离散的网格对于许多游戏来说可能不够好。例如，考虑第一人称射击游戏或赛车游戏，世界是离散的，你不能用网格来表示它。 但这还有一个更大的难题，如果世界是无限大的呢？在这种情况下，即使你可以把它表示成为一个网格，你也不能建立与网格相对应的图形，因为它是一个无限大的图像。 然而，希望并没有丧失。我们确实需要一个图表来运行图形搜索算法，但是没人说图表必须是明确的。 如果仔细查看算法，你会注意到我们对图表整体没有做任何事情。相反，我们通过正在考虑的节点中获取可以到达的节点，正如 A* 算法演示中看到的，图中的一些节点根本没有被探索过。 那么，如果我们只是在搜索时才去构建图形该怎么办？ 我们将起始节点设置为当前角色的位置。无论何时调用方法 get_adjacent_nodes，它都可以找出角色从给定节点移动的可能方向，并在运行中创建相邻节点。 超越三重维度即使您的世界是 2D 网格，也需要考虑其他因素。例如，如果你的角色不能瞬间转90度或180度，这种情况该怎么办？ 每个搜索节点所代表的状态步兵局限于某个位置，相反，它可以包括一组任意复杂的值。例如，如果旋转90度从一个方块走到另外一个方块所需的时间相同，那么角色的状态可以是： [坐标(position), 航向(heading)]。现在，每个节点不仅仅表示角色的位置，还表示角色的航向，图的每一条新边（隐式或显示）反应了这一点。 回到最初的 5x5 的网格，现在搜索的起始坐标可能是 [A, East]，相邻节点现在则是 [B, East] 和 [A, South]。如果你想到达 F 节点，首先你需要先修正你的航向，所以路径将是 [A, East] -&gt; [A, South] -&gt; [F, South]。 而第一人称射击游戏呢？你至少需要四个维度：[X, Y, Z, 航向]，设置可能是：[X, Y, Z, 航向, 血量, 弹药]。 请注意，状态越复杂，启发式函数也就会越复杂。 结论这几篇文章的目的是一劳永逸的消除 A* 算法是一种神秘的，难以理解的感觉。相反，我已经证明了它没有什么神秘之处。事实上，它可以用一种非常直接的方式从0开始推导出来。 进一步阅读阿米特·帕特尔（Amit Patel）有一篇非常好的关于 A* 算法介绍，当然他的其他主题文章也是非常棒的。 系列文章目录： 寻路算法揭秘（1）：通用搜索 寻路算法揭秘（2）：搜索策略 寻路算法揭秘（3）：A* 解密 寻路算法揭秘（4）：实用 A* 算法 翻译原文","categories":[{"name":"寻路算法","slug":"寻路算法","permalink":"https://veinin.com/categories/寻路算法/"}],"tags":[{"name":"寻路算法","slug":"寻路算法","permalink":"https://veinin.com/tags/寻路算法/"},{"name":"A*","slug":"A","permalink":"https://veinin.com/tags/A/"}]},{"title":"寻路算法揭秘（3）：A* 解密","slug":"pathfinding-demystified-03","date":"2019-02-23T12:21:00.000Z","updated":"2019-03-25T16:24:02.168Z","comments":true,"path":"2019/02/23/pathfinding-demystified-03/","link":"","permalink":"https://veinin.com/2019/02/23/pathfinding-demystified-03/","excerpt":"介绍本系列文章中的第一篇介绍了通用的寻路算法，每种不同类型的寻路算法背后都是它的一个微小变化。 第二篇文章揭示了不同搜索算法背后的秘密：这一切都要归结于 choose_node 函数。它还提供了一个相当简单的 choose_node 函数来生成一个称为统一搜索成本的算法。 这个算法非常好：它将找到从开始节点到目标节点的最短路径。然而，它也有一点点浪费：它会前往人们可以很容易察觉到的错误路径节点，这往往会让目标偏移，我们能避免这种情况的发生吗？ 魔术算法想象一下，我们在一台特殊的计算机上运行搜索算法，它拥有一个可以变魔术的芯片。有了这个很棒的芯片，我们就能用一种非常简单的方式来表达 choose_node 函数，它保证产生最短的路径，不会浪费时间去探索那些不会通向目标地方的道路: 12function choose_node (reachable): return magic(reachable, &quot;最短路径的下一个节点是什么&quot;)","text":"介绍本系列文章中的第一篇介绍了通用的寻路算法，每种不同类型的寻路算法背后都是它的一个微小变化。 第二篇文章揭示了不同搜索算法背后的秘密：这一切都要归结于 choose_node 函数。它还提供了一个相当简单的 choose_node 函数来生成一个称为统一搜索成本的算法。 这个算法非常好：它将找到从开始节点到目标节点的最短路径。然而，它也有一点点浪费：它会前往人们可以很容易察觉到的错误路径节点，这往往会让目标偏移，我们能避免这种情况的发生吗？ 魔术算法想象一下，我们在一台特殊的计算机上运行搜索算法，它拥有一个可以变魔术的芯片。有了这个很棒的芯片，我们就能用一种非常简单的方式来表达 choose_node 函数，它保证产生最短的路径，不会浪费时间去探索那些不会通向目标地方的道路: 12function choose_node (reachable): return magic(reachable, &quot;最短路径的下一个节点是什么&quot;) 虽然这很诱人，但是神奇的芯片仍然需要一些更低级别的代码，下面是一个类似的实现： 1234567891011121314function choose_node (reachable): min_cost = infinity best_node = None for node in reachable: cost_start_to_node = node.cost cost_node_to_goal = magic(node, &quot;shortest path to the goal&quot;) total_cost = cost_start_to_node + cost_node_to_goal if min_cost &gt; total_cost: min_cost = total_cost best_node = node return best_node 这是选择下一个节点的好方式：我们选择从开始节点到目标节点的最短路径，而这正是我们想要的。 我们还最大幅度的减少了魔法的使用：我们确切的知道从起始节点到目标节点（即node.cost）所需成本，并且我们只是使用魔法来预测从当前节点前往目标节点的成本。 不神奇但是非常棒的 A* 算法不幸的是，魔术芯片很新，但我们希望其支持传统的硬件。上面大多数代码都没问题，除了这一行： 12# 抛出麻瓜处理器异常cost_node_to_goal = magic(node, &quot;shortest path to the goal&quot;) 所以，我们并不能用魔法来知道我们尚未探索的道路的成本。很好，那让我们来猜猜看，我们很乐观，所以我们假设当前节点到目标节点之间没有任何东西，我们可以直接走： 1cost_node_to_goal = distance(node, goal_node) 注意，最短路径和最小距离是不同的：最小距离假定了当前节点和目标节点之间绝对没有障碍物。 这个假设当然非常简单。在我们基于网格的示例种，它是两个节点之间的曼哈顿距离，而所谓“曼哈顿距离”是指两点在在东西方向上的距离加上南北方向上的距离，即：abs(Ax - Bx) + abs(Ay - By)。如果你可以移动到对角线，则它的距离会是：sqrt( (Ax - Bx)^2 + (Ay - By)^2)。诸如此类，但最重要的是永远不要高估道路的成本。 所以，下面是一个没有魔法的 choose_node 版本： 1234567891011121314function choose_node (reachable): min_cost = infinity best_node = None for node in reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal if min_cost &gt; total_cost: min_cost = total_cost best_node = node return best_node 预估从节点到目标节点的距离的函数成为启发式算法，观众朋友们，我们称这种算法叫做 _A*_。 在线演示当你从意识到神秘的 _A*_ 算法实际上那么简单的震惊中恢复过来时，这里有一个你可以试玩的演示。与前面的示例不同，你会注意到整个搜索在错误的方向上浪费的时间非常少。 reachable = []explored = [] // Choose the node with the lowest path cost. Search.prototype.chooseNode = function() { // return this.reachable[Math.floor(Math.random() * this.reachable.length)]; var min_cost = Infinity; var best_node = undefined; for (var i in this.reachable) { var node = this.reachable[i]; // Compute Manhattan distance to goal. var idx = getNodeIndex(node, this.graph.nodes); var nr = Math.floor(idx / this.graph.cols); var nc = idx % this.graph.cols; idx = getNodeIndex(this.goal_node, this.graph.nodes); var gr = Math.floor(idx / this.graph.cols); var gc = idx % this.graph.cols; var node_to_goal_distance_estimate = Math.abs(nr - gr) + Math.abs(nc - gc); var total_cost = node.cost + node_to_goal_distance_estimate; if (total_cost < min_cost) { min_cost = total_cost; best_node = node; } } return best_node; } Search.prototype.addAdjacent = function(node, adjacent) { if (findNode(adjacent, this.explored)) { return; } if (!findNode(adjacent, this.reachable)) { this.reachable.push(adjacent); } if (adjacent.cost > node.cost + 1) { adjacent.cost = node.cost + 1; adjacent.previous = node; } } // Build the grid used in the example. // \"*\" represent a blocked square, \" \" an open one. var graph = new Graph([\" \", \" \", \" \", \" \", \" \", \" \", \" * \", \" ** \", \" ** \", \" \"]); var stepDelay = 100; var search = new Search(graph, \"BN\", \"CK\"); search.reset(); render(search); 结论我们最终得到了 _A*_ 算法，它只不过是第一篇文章中描述的通用搜索算法，在第二篇文章的描述中加入了一些改进，使用 choose_node 函数选择我们预估的节点将使我们更加接近目标，仅此而已。 参照上面的结论，我们给出了主要方法的伪代码： 123456789101112131415161718192021222324252627282930function find_path(start_node, goal_node): reachable = [start_node] explored = [] while reachable is not empty: # 选择一个我们知道如何到达的节点 node = choose_node(reachable) # 如果我们刚好到达了目标节点，则构建并返回路径。 if node == goal_node: return build_path(goal_node) # 记录已经处理的节点，防止重复处理 reachable.remove(node) explored.add(node) # 我们能从这个节点得到我们以前没有探索过的新节点 new_reachable = get_adjacent_node(node) - explored for adjacent in new_reachable: # 是不是第一次抵达这个节点 if adjacent not in reachable: reachable.add(adjacent) # 如果这是一个新路径，或者比现有的路径更短，则保留它 if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1 # 如果我们到达了这里，则路径没有找到 return None build_path 方法实现： 123456function build_path(to_node): path = [] while to_node != None: path.add(to_node) to_node = to_node.previous return path 使用 A* 算法实现的 choose_node 方法： 1234567891011121314function choose_node(reachable): min_cost = infinity best_node = None for node in reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal if min_cost &gt; total_cost: min_cost = total_cost best_node = node return best_node 经此而已。 那么为什么本系列文章还有第四部分？ 现在你已经了解了 _A*_ 算法的工作原理，我想探索一些令人难以置信的应用程序，而不仅仅是在一个正方形的网格中搜索路径。 系列文章目录： 寻路算法揭秘（1）：通用搜索 寻路算法揭秘（2）：搜索策略 寻路算法揭秘（3）：A* 解密 寻路算法揭秘（4）：实用 A* 算法 翻译原文","categories":[{"name":"寻路算法","slug":"寻路算法","permalink":"https://veinin.com/categories/寻路算法/"}],"tags":[{"name":"寻路算法","slug":"寻路算法","permalink":"https://veinin.com/tags/寻路算法/"},{"name":"A*","slug":"A","permalink":"https://veinin.com/tags/A/"}]},{"title":"寻路算法揭秘（2）：搜索策略","slug":"pathfinding-demystified-02","date":"2019-02-20T10:20:00.000Z","updated":"2019-03-25T16:23:54.419Z","comments":true,"path":"2019/02/20/pathfinding-demystified-02/","link":"","permalink":"https://veinin.com/2019/02/20/pathfinding-demystified-02/","excerpt":"介绍本系列第一篇文章介绍了通用寻路算法。如果你没有完全理解它，请返回并重新阅读，因为其对你了解后面的内容至关重要，一旦你掌握了它，A* 算法将是世界上最自然的事情。 秘制酱汁我在上一章结尾处留下了两个悬而未决的问题：如果每一种寻路算法都使用相同的代码，是什么让 A 的行为看起来像 A 呢？而为什么上一章的演示实例会找出不同的路径呢？ 这两个问题的答案是非常相关联的。尽管算法定义得很好，但有一个方面我故意含糊不清，事实证明，它是解释搜索算法行为的关键： 1node = choose_node(reachable) 那些看起来很无辜的线使得每个搜索算法都与众不同。choose_node 所作的选择会让世界看起来不同。 那么为什么上一章的演示实例会找出不同的路径呢？答案是因为 choose_node 方法随机选择了一个节点。","text":"介绍本系列第一篇文章介绍了通用寻路算法。如果你没有完全理解它，请返回并重新阅读，因为其对你了解后面的内容至关重要，一旦你掌握了它，A* 算法将是世界上最自然的事情。 秘制酱汁我在上一章结尾处留下了两个悬而未决的问题：如果每一种寻路算法都使用相同的代码，是什么让 A 的行为看起来像 A 呢？而为什么上一章的演示实例会找出不同的路径呢？ 这两个问题的答案是非常相关联的。尽管算法定义得很好，但有一个方面我故意含糊不清，事实证明，它是解释搜索算法行为的关键： 1node = choose_node(reachable) 那些看起来很无辜的线使得每个搜索算法都与众不同。choose_node 所作的选择会让世界看起来不同。 那么为什么上一章的演示实例会找出不同的路径呢？答案是因为 choose_node 方法随机选择了一个节点。 长度很重要在深入研究 choose_node 函数的不同行为之前，根据前面的解释，我们需要对算法中存在的一点疏忽进行修正。 每当我们考虑与当前节点的相邻节点是，我们忽略了那些我们已经知道如何到达的节点： 123if adjacent not in reachable: adjacent.previous = node # 记住我们是如何抵达这个节点的 reachable.add(adjacent) 这里犯了一个错误：如果我们刚好发现一个更好的到达此节点的方式呢？在这种情况下，我们应该应该调整这个节点的前驱节点来使到达此节点的路径更短。 为此，我们需要知道从起始节点到任何可达的节点之间的路径长度，我们称这种长度为 cost。现在让我们假设从一个节点移动到一个相邻节点的固定花费（cost）为 1。 在开始搜索之前，我们先设置每个节点的 cost 为值 infinity，这使得任何路径都比这个值要短。我们还需要设置到达 start_node 节点的 cost 为 0。 所以现在代码看起来是这样子： 1234567if adjacent not in reachable: reachable.add(adjacent)# 如果这是一条新路径，或者比现有的路径更断，则保留它。if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1 统一的搜索成本现在让我们关注 choose_node(选择节点) 方法。如果我们想要得到尽可能短的路径，随机选择一个节点显然不是一个很好的主意。 一个更好的方法是选择从开始节点可以到达最短路径的节点。这通常会选择较短的路径，而不是较长的路径。当然，这并不意味着不考虑较长的路径，而是优先考虑较短的路径。因为一旦找到有效路径，算法就会停止，这应该就是我们的较短路径。 这里是一种可能的 choose_node 函数实现： 12345678function choose_node (reachable): best_node = None for node in reachable: if beat_node == None or best_node &gt; node.cost: best_node = node return best_node 直观的说，该算法的搜索从开始节点“径向”展开，直到抵达结束节点。下面是这种搜索行为的Demo演示: reachable = []explored = [] // Choose the node with the lowest path cost. Search.prototype.chooseNode = function() { // return this.reachable[Math.floor(Math.random() * this.reachable.length)]; var min_cost = Infinity; var best_node = undefined; for (var i in this.reachable) { var node = this.reachable[i]; if (node.cost < min_cost) { min_cost = node.cost; best_node = node; } } return best_node; } Search.prototype.addAdjacent = function(node, adjacent) { if (findNode(adjacent, this.explored)) { return; } if (!findNode(adjacent, this.reachable)) { this.reachable.push(adjacent); } if (adjacent.cost > node.cost + 1) { adjacent.cost = node.cost + 1; adjacent.previous = node; } } // Build the grid used in the example. // \"*\" represent a blocked square, \" \" an open one. var graph = new Graph([\" \", \" \", \" \", \" \", \" \", \" \", \" * \", \" ** \", \" ** \", \" \"]); var stepDelay = 100; var search = new Search(graph, \"BN\", \"CK\"); search.reset(); render(search); 结论在选择下一个要考虑的节点方式上做一个非常简单的改变，就可以得到一个非常好的搜索算法：找到从开始节点到目标节点的最短路径。 在某种程度上，这仍然是个愚蠢的做法。算法会一直漫无目的的寻找，直到它偶然发现了目标节点。在上面的例子中，当我们在朝着 A 节点方向搜索时却距离目标节点越来越远，这有什么意义呢？ 我们能让 choose_node 方法更加智能吗？即使事先不知道正确的方向，也能让它朝着目标不断迈进。 事实证明我们是可以做到的，在下一篇文章中，我们最终会得到更加完善的 choose_node 方法，它会使常规的寻路算法变成 A*。 系列文章目录： 寻路算法揭秘（1）：通用搜索 寻路算法揭秘（2）：搜索策略 寻路算法揭秘（3）：A* 解密 寻路算法揭秘（4）：实用 A* 算法 翻译原文","categories":[{"name":"寻路算法","slug":"寻路算法","permalink":"https://veinin.com/categories/寻路算法/"}],"tags":[{"name":"寻路算法","slug":"寻路算法","permalink":"https://veinin.com/tags/寻路算法/"},{"name":"A*","slug":"A","permalink":"https://veinin.com/tags/A/"}]},{"title":"寻路算法揭秘（1）：通用搜索","slug":"pathfinding-demystified-01","date":"2019-02-18T13:13:37.000Z","updated":"2019-03-25T16:24:54.139Z","comments":true,"path":"2019/02/18/pathfinding-demystified-01/","link":"","permalink":"https://veinin.com/2019/02/18/pathfinding-demystified-01/","excerpt":"介绍寻路算法通常是游戏开发者一个比较困惑的主题。特别是 A* 算法常常令人费解，人们普遍会认为这是一种神秘的魔法。 本系列文章的目的是以一种非常清晰易懂的方式解释常规的寻路与 A* 算法，你不必误解这是一个非常困难的话题，如果解释的当，这将是非常简单明了的问题。 请注意，我们的重点将放在游戏领域的寻路，与学术化的方法不同，我们将跳过诸如深度优先（Depth-First）或广度优先（Breadth-First）搜索算法的介绍，并尽快进从0到1的介绍 A* 算法。 第一篇文章将要解释寻路的基本概念，一旦你掌握了这些基本概念，你会发现 A* 算法非常简单。 简单的第一步虽然你能够将这些概念任意复杂的 3D 环境中去，但首先我们将从一个非常简单的设置开始：一个 5x5 的方格。为了方便起见，我们用大写字母标记了每一个方块。","text":"介绍寻路算法通常是游戏开发者一个比较困惑的主题。特别是 A* 算法常常令人费解，人们普遍会认为这是一种神秘的魔法。 本系列文章的目的是以一种非常清晰易懂的方式解释常规的寻路与 A* 算法，你不必误解这是一个非常困难的话题，如果解释的当，这将是非常简单明了的问题。 请注意，我们的重点将放在游戏领域的寻路，与学术化的方法不同，我们将跳过诸如深度优先（Depth-First）或广度优先（Breadth-First）搜索算法的介绍，并尽快进从0到1的介绍 A* 算法。 第一篇文章将要解释寻路的基本概念，一旦你掌握了这些基本概念，你会发现 A* 算法非常简单。 简单的第一步虽然你能够将这些概念任意复杂的 3D 环境中去，但首先我们将从一个非常简单的设置开始：一个 5x5 的方格。为了方便起见，我们用大写字母标记了每一个方块。 我们要做的第一件事就是通过图形来表示环境。我不会详细介绍图表的内容，直观地说，它是由箭头连接的一组气泡。我们把气泡称为“节点”，箭头称为“边缘”。 每个节点代表一个角色可以的一种“状态”。在这种情况下，角色的状态就是它的位置，所以我们要为每个方块的网格创建一个节点： 现在让我们添加边缘，它代表了你可以从其他的给定状态“达到”哪些状态。在下面的例子中，除了被阻挡的方格外，你可以从任何方格走到其相邻的方格： 如果你你能从 A 节点到达 B 节点，我们可以说 B 是 A 的邻边。 注意，边缘是有方向的，我们需要一个从 A 到 B 的边，也需要一个从 B 到 A 的边。这看起来可能有点多余，但当你考虑复杂的“状态”时，就不会是这样了。例如，你可以从屋顶掉落到地面，但你不能从地面再跳到屋顶；你可以从“活着”变成“死亡”，但反过来则不行。 第一个例子当我们向从 A 节点到 T 节点时，在第一步中我们可以从两个方向进行选择：走到 B 节点或走到 F 节点。 假设我们先走到 B 节点，现在你又有了两个选择：回到 A 节点或去到 C 节点。我们记得我们已经去过了 A 节点，这是一个我们已经考虑过的选择，所以没必要再选择一次（否则我们可能整天都在走 A -&gt; B -&gt; A -&gt; B…），所以下一步我们将去到 C 节点。 现在我们到达了 C 节点，但是我们发现我们已经无路可走了，而再回到 B 节点是没有任何意义的。所以我们到了一个死胡同，当我们在 A 节点选择 B 节点时就不是一个好主意，也许我们应该尝试下 F 节点。 我们继续不断的重复这个过程，直到我们发现了 T 节点。我们只是通过回溯我们的步骤，重新构建了路径。当我们在 T 节点时，我们怎么来到这里的？那么终点的路径是 O -&gt; T 吗？那我们怎么走到 O 节点？ 请记住，我们实际上根本没有移动，所有的这些都只是一次思考练习。我们仍然站在 A 节点，在我们弄清楚整个路径之前，我们根本不会移动。当我们说“移动到B节点”，我们实际上是在说“想象我们到达了B节点”。 通用算法本章节是本系列文章最重要的部分。这是你为了寻路必须理解的部分，其他（包括A*）只是一些细节而已。一旦你了解了这一部分你将得到启蒙。 这一章节当然也很简单。 让我们将上面的例子形式化成一些伪代码。 我们需要追踪我们知道的从起点可以到达的节点。开始时，我们只有一个起始节点，但是我们可以对网格进行“探索”，并搞清楚如何到达其他节点。我们把这个列表叫做 reachable： 1reachable = [start_node] 另外，我们需要追踪我们已经到达过的节点，因为我们不想再次前往，我们把这部分节点列表叫做 explored: 1explored = [] 这里我们来到了算法的核心部分：在搜索的每一个步骤时，我们先选择一个我们已知可达但尚未探索过的节点，然后在此节点检索我们可以到达的新节点。一旦发现我们可以到达目标节点，我们就完成了！否则，继续寻找。 这听起来好像很简单？是的，但这还不是全部，让我们一步步的用伪代码写出来。 我们一直寻找，直到我们到达目标节点（在这种情况下，我们已经找到了从开始节点到目标节点的路径），或者直到没有其他节点可以继续探索（在这种情况下，没有从开始节点到达目标节点的路径）: 1while reachable is not empty: 我们选择一个我们已知的但没有探索过的节点： 1node = choose_node(reachable) 如果我们已经直到如何到达目标节点，我们就完成了！然后只需要建立一条路径，根据当前节点的前驱(previous )节点回到开始节点： 1234567if node == goal_node: path = [] while node != None: path.add(node) node = node.previous return path 我们多次的去往同一个节点是没有意义的，所以我们需要追踪那些已经去过的节点： 12reachable.remove(node)explored.add(node) 我们可以算出从当前节点可以到达的新节点。我们继续从当前节点的相邻节点开始，并删除我们已经探索过的节点： 1new_reachable = get_adjacent_nodes(node) - explored 然后取出可探索的每一个新节点： 1for adjacent in new_reachable: 如果我们已经探索过此节点，则忽略它。否则，把此节点加入到已经探索过的节点列表中，记录我们已经探索过它： 123if adjacent not in reachable: adjacent.previous = node # Remember how we got there. reachable.add(adjacent) 找到目标节点是退出循环的一种方式。另外一种则是当可探索(reachable)的节点为空时：如果我们已经没有可检查的节点，并且没有任何一个节点是我们的目标节点，这意味着没有从开始节点到达目标节点的路径： 1return None 然后…也就这样了。这已经是一个完整的流程了，我们把上面的代码提取到一个单独的方法中去： 12345678910111213141516171819202122232425function find_path (start_node, end_node): reachable = [start_node] explored = [] while reachable is not empty: # Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don&apos;t repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: if adjacent not in reachable adjacent.previous = node # Remember how we got there. reachable.add(adjacent) # If we get here, no path was found :( return None 下面这个函数通过前驱节点构建返回起始节点的路径： 123456function build_path (to_node): path = [] while to_node != None: path.add(to_node) to_node = to_node.previous return path 就这样，这是每一个寻路算法的伪代码，包括 A*。 在线演示下面是一个在线演示和上面算法的实现示例。choose_node 只是一个随机选择的节点。你可以一步步的运行它，并查看 可达(reachable) 和 已探索(explored) 节点的变化情况，以及 前驱(previous) 节点的连接情况。 reachable = []explored = [] // Choose a random node from the reachable list. Search.prototype.chooseNode = function() { return this.reachable[Math.floor(Math.random() * this.reachable.length)]; } Search.prototype.addAdjacent = function(node, adjacent) { if (findNode(adjacent, this.explored) || findNode(adjacent, this.reachable)) { return; } adjacent.previous = node; this.reachable.push(adjacent); } // Build the grid used in the example. // \"*\" represent a blocked square, \" \" an open one. var graph = new Graph([\" * \", \" *** \", \" \", \"* ** \", \"* \"]); var stepDelay = 200; var search = new Search(graph, \"A\", \"T\"); search.reset(); render(search); 总结上述算法是每一种寻路算法的通用算法。 那么，你知道是什么使得每一种寻路算法彼此都不相同吗？为什么 A* 叫做 A*。 这里有个小提示：如果你多次运行上面的演示搜索，你会发现算法每次找到的路径并不一定总是相同。它找到了一些其他路径，但其并不是最短路径，为什么？ 系列文章目录： 寻路算法揭秘（1）：通用搜索 寻路算法揭秘（2）：搜索策略 寻路算法揭秘（3）：A* 解密 寻路算法揭秘（4）：实用 A* 算法 翻译原文","categories":[{"name":"寻路算法","slug":"寻路算法","permalink":"https://veinin.com/categories/寻路算法/"}],"tags":[{"name":"寻路算法","slug":"寻路算法","permalink":"https://veinin.com/tags/寻路算法/"},{"name":"A*","slug":"A","permalink":"https://veinin.com/tags/A/"}]},{"title":"Lua入门教程：协程","slug":"programming_in_lua_15","date":"2019-01-03T15:10:10.000Z","updated":"2019-03-25T16:17:59.396Z","comments":true,"path":"2019/01/03/programming_in_lua_15/","link":"","permalink":"https://veinin.com/2019/01/03/programming_in_lua_15/","excerpt":"从多线程的角度来看，协程（coroutine）与线程（thread）类似：协程时一系列的可执行语句，拥有自己的栈、局部变量和指令指针，同时协程又与其他协程共享全局变量和其他几乎一切资源。 协程与线程的主要区别在于，一个多线程程序可以并行运行多个线程，而协程则需要彼此协作运行，即在任意时刻只能有一个协程运行，且只有当正在运行的协程要求挂起时其执行才会暂停。 协程基础与协程相关的函数都放在表 coroutine 中。没个新建立的协程都拥有一个完整的生命周期，其包含四种状态：挂起（suspended）、运行（running）、正常（normal）和死亡（dead)。 创建协程coroutine.create(f)，创建一个以执行代码的函数 f（协程体）的新协程，并返回以类型 thread 为标志的新协程。 12co = coroutine.create(function() print(\"hello\") end)print(type(co)) --&gt; thread 当协程被创建时，默认处于挂起状态，即协程不会在被创建时自动运行，我们可以通过 coroutine.status 来检查协程的状态： 1print(coroutine.status(co)) --&gt; suspended","text":"从多线程的角度来看，协程（coroutine）与线程（thread）类似：协程时一系列的可执行语句，拥有自己的栈、局部变量和指令指针，同时协程又与其他协程共享全局变量和其他几乎一切资源。 协程与线程的主要区别在于，一个多线程程序可以并行运行多个线程，而协程则需要彼此协作运行，即在任意时刻只能有一个协程运行，且只有当正在运行的协程要求挂起时其执行才会暂停。 协程基础与协程相关的函数都放在表 coroutine 中。没个新建立的协程都拥有一个完整的生命周期，其包含四种状态：挂起（suspended）、运行（running）、正常（normal）和死亡（dead)。 创建协程coroutine.create(f)，创建一个以执行代码的函数 f（协程体）的新协程，并返回以类型 thread 为标志的新协程。 12co = coroutine.create(function() print(\"hello\") end)print(type(co)) --&gt; thread 当协程被创建时，默认处于挂起状态，即协程不会在被创建时自动运行，我们可以通过 coroutine.status 来检查协程的状态： 1print(coroutine.status(co)) --&gt; suspended 运行协程要想启动或再启动一个协程，我们可以使用函数 coroutine.resume 来执行，并将去状态改为运行： 1coroutine.resume(co) --&gt; hello 上面的协程创建后运行的函数会输出 hello 然后该协程就终止了，最后协程执行完成后会变为死亡状态： 1print(coroutine.status(co)) --&gt; dead 挂起协程协程的强大之处在于函数 coroutine.yield，该函数可以让一个运行中的协程挂起自己，然后在后续执行中恢复运行： 123456co = coroutine.create(function() for i = 1, 10 do print(\"co\", i) coroutine.yield() endend) 上面协程运行着一个循环，在循环中打印输出一个数字后遇到 yield 进入挂起状态： 1coroutine.resume(co) --&gt; co 1 此时我们可以查看协程状态，会发现协程处于挂起状态： 1print(coroutine.status(co)) --&gt; suspended 我们可以继续运行，直到上面 for 循环执行结束： 12345coroutine.resume(co) --&gt; co 2coroutine.resume(co) --&gt; co 3 ...coroutine.resume(co) --&gt; co 10coroutine.resume(co) --&gt; 不输出任何数据 当最后一次调用 resume 时，协程体执行完毕并返回，不会输出任何数据，如果我们试图再次唤醒它，函数 resume 会返回 false 已经一条错误信息： 1print(coroutine.resume(co)) --&gt; false cannot resume dead coroutine 请注意，resume 函数运行在保护模式中，如果协程出错，Lua 不会显示错误信息，而是将错误信息返回给 resume 函数。 当协程 A 唤醒协程 B 时，协程 A 不是挂起状态（因为不能唤醒协程A），而不是运行状态（因为正在运行协程B），此时的状态称之为正常状态。 交换数据协程中一个非常有用的机制是通过一对 resume-yield 来交换数据。第一个 resume 函数会把所有的额外参数传递给协程的主函数： 12345co = coroutine.create(function(a, b, c) print(\"co\", a, b, c) end)coroutine.resume(co, 1, 2, 3) --&gt; co 1 2 3 函数 resume 第一个返回值为 true 时表示没有错误，之后的返回值对应函数 yield 的参数： 12345co = coroutine.create(function(a, b) coroutine.yield(a + b, a - b) end)print(coroutine.resume(co, 10, 20)) --&gt; true 30 -10 函数 yield 返回值则会对应 resume 的参数： 1234567co = coroutine.create(function(x) print(\"co1\", x) print(\"co2\", coroutine.yield()) end)coroutine.resume(co, \"hi\") --&gt; co1 hicoroutine.resume(co, 4, 5) --&gt; co2 4 5 当协程运行结束后，主函数所返回的值将变成对应函数 resume 的返回值： 12345co = coroutine.create(function() return 1, 2 end)print(coroutine.resume(co)) --&gt; true 1 2 使用协程解决生产者于消费者问题生产者-消费者设计两个函数，一个函数不断的生成值，而另外一个函数则不断的消费这些值，我们可以看以下代码实现： 12345678910111213141516171819202122232425function producer() while true do local x = io.read() -- 生产新值 send(x) -- 发送给消费者 endendfunction send(x) coroutine.yield(x)endfunction consume() while true do local x = receive() -- 接受来自生产者的值 io.write(x, \"\\n\") -- 消费 endendfunction receive() local status, value = coroutine.resume(producer) return valueendproducer = coroutine.create(producer) -- 生成者在协程里面运行consume() -- 通过消费者启动 上面这种设计中，程序通过消费者启动。当消费者需要新值时就唤醒生成者，生成者向消费者返回新值后挂起，知道消费者再次将其唤醒。因此这种设计称之为消费者驱动式设计。","categories":[{"name":"Lua入门教程","slug":"Lua入门教程","permalink":"https://veinin.com/categories/Lua入门教程/"}],"tags":[{"name":"Lua 5.3","slug":"Lua-5-3","permalink":"https://veinin.com/tags/Lua-5-3/"},{"name":"Lua编程","slug":"Lua编程","permalink":"https://veinin.com/tags/Lua编程/"},{"name":"Lua协程","slug":"Lua协程","permalink":"https://veinin.com/tags/Lua协程/"}]},{"title":"Lua入门教程：垃圾回收","slug":"programming_in_lua_14","date":"2018-12-25T15:10:10.000Z","updated":"2019-03-25T16:18:44.755Z","comments":true,"path":"2018/12/25/programming_in_lua_14/","link":"","permalink":"https://veinin.com/2018/12/25/programming_in_lua_14/","excerpt":"Lua 使用的是自动内存管理，所以我们不需要自己手动取删除创建后的对象，Lua 通过垃圾回收（garbage collection）的方式自动删除成为来及的对象，从而将程序员从内存管理的负担中解放出来。 虽然在理想的环境中，垃圾回收对我们来说是不可见的，但其却不是万能的，比如某些关键的性能点，我们可能需要停止垃圾回收，或者让它只在特定的时间点运行，这就需要额外的垃圾回收方式来辅助。 Lua 采用了弱引用表（weak table)、析构器（finalizer）和函数 collectgarbage 的机制来作为辅助垃圾回收。 弱引用表所谓弱引用（weak reference）是一种不在垃圾回收考虑范围内的对象引用。弱引用表允许收集 Lua 中还可以被程序访问的对象，它告知 Lua 语言一个引用不应该阻止对一个对象的回收机制。 一个典型的内存泄漏的场景是如果我们在数组中存储一些活跃的对象，我们只需要把对象插入到数组中去即可，一旦对象成为了数组中一部分，在数组销毁之前，该对象是永远无法回收的，虽然数组中的对象可能没有任何其他地方引用它，但其仍然被数组引用，除非我们告诉 Lua 数组中的引用不应该阻止此对象的回收。 表由键和值组成，键和值都是强引用，垃圾回收默认不会回收一个可访问的作为表中键和值的对象。而在一个弱引用表中，键和值都可以是弱引用，一旦某个键或值被回收，那么其对应的整个键值对也会被回收。 一个表是否为弱引用表由其元表中的 __mode 字段决定，其值应该是个字符串： 当字符串是 “k” 时，这个表的键是弱引用。 当字符串是 “v” 时，这个表的值时弱引用。 当字符串是 “kv” 时，表中的键和值都是弱引用。","text":"Lua 使用的是自动内存管理，所以我们不需要自己手动取删除创建后的对象，Lua 通过垃圾回收（garbage collection）的方式自动删除成为来及的对象，从而将程序员从内存管理的负担中解放出来。 虽然在理想的环境中，垃圾回收对我们来说是不可见的，但其却不是万能的，比如某些关键的性能点，我们可能需要停止垃圾回收，或者让它只在特定的时间点运行，这就需要额外的垃圾回收方式来辅助。 Lua 采用了弱引用表（weak table)、析构器（finalizer）和函数 collectgarbage 的机制来作为辅助垃圾回收。 弱引用表所谓弱引用（weak reference）是一种不在垃圾回收考虑范围内的对象引用。弱引用表允许收集 Lua 中还可以被程序访问的对象，它告知 Lua 语言一个引用不应该阻止对一个对象的回收机制。 一个典型的内存泄漏的场景是如果我们在数组中存储一些活跃的对象，我们只需要把对象插入到数组中去即可，一旦对象成为了数组中一部分，在数组销毁之前，该对象是永远无法回收的，虽然数组中的对象可能没有任何其他地方引用它，但其仍然被数组引用，除非我们告诉 Lua 数组中的引用不应该阻止此对象的回收。 表由键和值组成，键和值都是强引用，垃圾回收默认不会回收一个可访问的作为表中键和值的对象。而在一个弱引用表中，键和值都可以是弱引用，一旦某个键或值被回收，那么其对应的整个键值对也会被回收。 一个表是否为弱引用表由其元表中的 __mode 字段决定，其值应该是个字符串： 当字符串是 “k” 时，这个表的键是弱引用。 当字符串是 “v” 时，这个表的值时弱引用。 当字符串是 “kv” 时，表中的键和值都是弱引用。 123456789101112t = &#123;&#125;setmetatable(t, &#123;__mode = \"k\"&#125;)k = &#123;&#125;t[k] = 1k = &#123;&#125; -- 上一个 k 对象引用被清除t[k] = 2collectgarbage() -- 强制垃圾回收for _, v in pairs(t) do print(v) end --&gt; 2 上面例子中，第二个 k = {} 覆盖了指向了第一个键的索引，调用 collectgarbage 强制垃圾回收器进行一次完整的垃圾回收，由于第一个键没有了其他引用，所以 Lua 会回收该键对象，并从表中删除对应的元素。 最后，请注意，只有对象可以从弱表中移除，而像数字和布尔这样的“值”是不可回收的。 析构器析构器（Finalizer）是一个与对象关联的函数，当该对象即将被会收时该函数会被调用。Lua语言通过元方法 __gc 实现析构器： 1234o = &#123;x = \"hello\"&#125;setmetatable(o, &#123;__gc = function(o) print(o.x) end&#125;)o = nilcollectgarbage() --&gt; hi 上例中，对象 o 创建了一个带有 __gc 元方法的元表，然后清理对象 o 的引用，调用 collectgarbage 函数强制执行一次完整的垃圾回收，对象 o 被回收时，会调用表的析构器，也就是元方法 __gc。 逆序调用当垃圾回收期在同一个周期析构多个对象时，它会按照对象被标记为需要析构处理的顺序逆序调用这些对象的析构器： 123456789101112mt = &#123;__gc = function(o) print(o.x) end&#125;obj = nilfor i = 1, 3 do obj = setmetatable(&#123;x = i&#125;, mt)endobj = nilcollectgarbage() --&gt; 3 --&gt; 2 --&gt; 1 上面代码，创建了三个对象，分别设置了析构器，运行垃圾回收后，可以看到第一个被析构的对象是最后被标记的对象。 复苏当一个析构器被调用时，它的参数是正在被析构的对象。因此，这个对象会至少在析构期间重新变成活跃状态，我们称之为临时复苏。而在析构期间，我们无法阻止该对象被存储在某个全局变量中，使得该对象在析构器返回后任然可访问，我们称之为永久复苏。 12345a = &#123;x = \"hello\"&#125;b = &#123;f = a&#125;setmetatable(b, &#123;__gc = function(o) print(o.f.x) end&#125;)a, b = nilcollectgarbage() 上面代码中，对象 b 的析构会访问 a，所以在 a 在 b 析构前都不能被回收，Lua 会在运行析构器之前同时复苏 b 和 a。 需要注意的是，Lua 会在两个阶段回收具有析构器的对象： 第一个阶段为发现不可达的带有析构器的对象，并调用析构器开始执行，执行完成后标记为已被析构 第二个阶段的垃圾回收又发现该对象不可达时，它就会将该对象删除。 因此，如果我们想保证我们程序所有垃圾都能真正被释放，那么我们必须调用两次 collectgarbage 函数。 垃圾回收器垃圾回收（Garbage Collector, GC）算法的原理大体可以概括为：遍历系统中的所有对象，看哪些对象没有被引用，没有引用关系的就认为是可以回收的对象，对其进行删除。 对于如何找出没有“引用” 的对象有以下几种主流算法： 引用计数 GC 算法，当对象被引用时，该对象引用计数加一，反之则减一。当引用计数为 0 时则认为该对象没有被引用，可以被回收删除。该算法有点是只需要对引用计数，不需要对每个对象进行扫描遍历，但有个先天的不足就是很难处理循环引用的问题。 标记清楚 GC 算法，每次做GC扫描时，首先扫描并且标记所有对象，被扫描过并且被标记的对象认为时可达的，不能被回收；而没有被标记的对象认为是可回收的。 双色标记-清除算法Lua 5.0 使用的 GC 算法是双色标记-清除（Tow-Color Mark and Sweep）算法，其算法原理也很简单： 创建新对象，对象的颜色被标记为白色，并加入到对象链表中。 标记阶段，取出对象链表中未扫描的元素，标记为黑色，并遍历该对象关联的其他对象，也标记为黑色。 回收阶段，遍历所有对象，如果是白色，则认为该对象没有被引用，逐个回收；否则加入重新加入到对象链表等待下一轮GC检查。 这种垃圾收集器被称为“stop-the-world”（全局暂停）式的收集器，其垃圾回收过程中是不能被打断的，因为你无法在标记与清除的过程中对新加入的对象进行标记判断，无法确认新对象到底应该是白色还是黑色。假设在 GC 回收阶段，如果把新对象标记为白色，那么该对象会在没有遍历其关联对象的情况下被回收；如果被标记为黑色，那么这个对象本轮并没有被扫描就被认为不能回收。所以，在双色清除算法中，标记阶段和回收阶段必须合并在一起才能完成。 正因为双标记清除算法不能被打断，所以其每次GC操作的代价都非常大。GC 过程中，程序必须停下来，不能做任何其他操作。 三色增量标记清除算法Lua 5.1 使用了增量式的三色标记清除算法（Thi-Color-Incremental Mark and Sweep）,这种算法与前面的相比，每个对象新增加了一种颜色，这样的好处在于：它不必在要求GC阶段停止主程序的运行，这个GC过程是增量的，可以被终端再恢复并继续运行。3中颜色分类如下： 123- 白色，表示对象没有被GC标记过，任何对象创建时的默认状态，如果GC扫描结束后任然是白色，则说明该对象没有被引用，可以被回收。- 灰色，表示对象已经被GC标记过，但该对象关联的其他对象还没有没访问标记过。- 黑色，表示对象已经被GC标记过，且该对象关联的其他对象也被访问标记过。 引入灰色节点后，算法不再要去一次性完整的执行完毕，而是把已经扫描但是其引用的还未扫描的对象置为灰色。在标记过程中，只要还要元素是灰色，则算法标记过程会一直持续下去，即使中间被打断并去执行其他操作，也不会受影响。 紧急垃圾回收Lua 5.2 引入了紧急垃圾收集（emergency collection），当内存分配失败时，Lua 会强制进行一次完整的垃圾收集，然后再次尝试重新分配。这种紧急功能可以发生在程序进行内存分配的任意时刻。 控制垃圾回收Lua 提供了函数 collectgarbage ([opt [, arg]]) 来让我们可以辅助垃圾收集器进行一些额外的控制。该函数第一个参数是一个可选字符串，用来说明执行何种操作，而有些选项需要第二个参数： “collect”: 做一次完整的垃圾收集循环，如果不提供任何参数，这将是默认选项。 “isrunning”: 返回表示收集器是否在工作的布尔值。 “stop”: 停止垃圾收集器的自动运行，直到再次调用restart前，只能显示的调用垃圾收集器。 “restart”: 重启垃圾收集器到自动运行。 “count”: 以 KB 字节数为单位返回 Lua 使用的总内存数。其结果为浮点数，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数。 “step”: 单步运行垃圾收集器。 步长“大小”由 arg 控制，指定在分配了多少个字节后垃圾回收一个做什么。 “setpause”: 将 arg 设为收集器的间歇率。 “setstepmul”: 将 arg 设为收集器的 步进倍率。 任何垃圾回收器都是使用CPU时间来换内存空间的。在极端情况下，垃圾收集器可能无法运行。但是，不消耗CPU时间将会消耗大量的内存空间。而在另外一种极端情况下，垃圾回收器可能在一次赋值后就得完成一次完整的垃圾收集。程序如果想使用尽可能小的内存，是要以付出大量的CPU计算量为代价的。 collectgarbage 函数的 setpause 与 setstepmul 参数可以让我们在CPU与内存消耗之间找一个平衡点，以寻求尽可能大的运行效率。 参数 setpause 用于控制垃圾回收器在一次收集完成后需要等待多久时间再开始新一轮的收集。当其选项的值设为 0 时，表示上一次垃圾回收完成后立刻开始新一轮的收集工作；当选项值设为 200% 时，表示重启垃圾回收器前需要等待内存使用翻倍。如果想消耗更多的 CPU 时间去换取更低的内存消耗，可以把这个值设的小一点。 参数 setstepmul 控制对没分配 1KB 内存时垃圾回收器应该进行多少工作。该选项值越高则垃圾回收器使用的增量越小。其默认值为 200%，当参数值低于 100 % 时会使垃圾回收运行的很慢，以至于可能一次收集都完成不了；而当参数设置为 100000000% 这样巨大的值时，其表现将是一个非增量的垃圾回收器。 对于上面的一些参数来说，其默认值已经足够好了，而对于一些特殊应用来说，手工实验控制则可能更好，比如游戏应用中，某些关键阶段我们必须调用 collectgarbage(&quot;stop&quot;) 来停止回收，并在关键阶段执行完成后，再调用 collectgarbage(&quot;restart&quot;) 来重启垃圾收集器。","categories":[{"name":"Lua入门教程","slug":"Lua入门教程","permalink":"https://veinin.com/categories/Lua入门教程/"}],"tags":[{"name":"Lua 5.3","slug":"Lua-5-3","permalink":"https://veinin.com/tags/Lua-5-3/"},{"name":"Lua编程","slug":"Lua编程","permalink":"https://veinin.com/tags/Lua编程/"},{"name":"Lua垃圾回收","slug":"Lua垃圾回收","permalink":"https://veinin.com/tags/Lua垃圾回收/"}]},{"title":"Lua入门教程：元表与元方法","slug":"programming_in_lua_11","date":"2018-12-22T13:35:05.000Z","updated":"2019-03-25T16:17:38.447Z","comments":true,"path":"2018/12/22/programming_in_lua_11/","link":"","permalink":"https://veinin.com/2018/12/22/programming_in_lua_11/","excerpt":"Lua 语言中每中类型的值都有一套可预见的操作集合，比如可以将数字相加，将字符串连接，还可以在表中插入键值对。但我们却无法直接将两个表相加，无法对表进行直接比较，除非我们使用元表。元表可以修改一个值在面对未知操作时的行为。例如，我们对两个表 a 和 b 执行 a + b 操作，Lua 在试图将两个表相加时，会检查其中某个表是否含有元表(metatable)，且元表中是否含有 __add 字段，如果 Lua 找到该字段，则调用该字段对应的值，这就是所有的元方法(metamethod)。 在元表中每个元方法的键的命名都是一个双下划线（__）加事件名的，键关联的那些值被称为元方法。上面说的 _add 就是元方法键名称，而对应的元方法值是执行加操作的函数。 获取与设置元表在 Lua 中每个值都可以有元表，而元表只是一个普通的Lua表。每个表和用户数据类型都具有各自独立的元表，而其他类型的值则共享对于类型所属的同一个元表。我们可以使用 getmetatable 获取一个表的元表，注意，刚创建的新表是没有元表的： 12t = &#123;&#125;print(getmetatable(t)) --&gt; nil 另外，我们可以使用 setmetatable 来设置和修改任意表的元表： 123t1 = &#123;&#125;setmetatable(t, t1)print(getmetatable(t) == t1) --&gt; true 在 Lua 中我们只能为表设置元表，如果要为其他类型值设置元表，则必须通过C代码或调试库完成。另外，字符串库为所有字符串都设置了同一个元表，而其他类型默认是没有元表的： 123print(getmetatable(\"hello\")) --&gt; table: 0106F578print(getmetatable(\"world\")) --&gt; table: 0106F578print(getmetatable(true)) --&gt; nil","text":"Lua 语言中每中类型的值都有一套可预见的操作集合，比如可以将数字相加，将字符串连接，还可以在表中插入键值对。但我们却无法直接将两个表相加，无法对表进行直接比较，除非我们使用元表。元表可以修改一个值在面对未知操作时的行为。例如，我们对两个表 a 和 b 执行 a + b 操作，Lua 在试图将两个表相加时，会检查其中某个表是否含有元表(metatable)，且元表中是否含有 __add 字段，如果 Lua 找到该字段，则调用该字段对应的值，这就是所有的元方法(metamethod)。 在元表中每个元方法的键的命名都是一个双下划线（__）加事件名的，键关联的那些值被称为元方法。上面说的 _add 就是元方法键名称，而对应的元方法值是执行加操作的函数。 获取与设置元表在 Lua 中每个值都可以有元表，而元表只是一个普通的Lua表。每个表和用户数据类型都具有各自独立的元表，而其他类型的值则共享对于类型所属的同一个元表。我们可以使用 getmetatable 获取一个表的元表，注意，刚创建的新表是没有元表的： 12t = &#123;&#125;print(getmetatable(t)) --&gt; nil 另外，我们可以使用 setmetatable 来设置和修改任意表的元表： 123t1 = &#123;&#125;setmetatable(t, t1)print(getmetatable(t) == t1) --&gt; true 在 Lua 中我们只能为表设置元表，如果要为其他类型值设置元表，则必须通过C代码或调试库完成。另外，字符串库为所有字符串都设置了同一个元表，而其他类型默认是没有元表的： 123print(getmetatable(\"hello\")) --&gt; table: 0106F578print(getmetatable(\"world\")) --&gt; table: 0106F578print(getmetatable(true)) --&gt; nil 算术运算元方法对于数学运算、位运算这些算术运算符，每一个操作都有唯一对应的元方法： __add: + 操作。 如果任何不是数字的值（包括不能转换为数字的字符串）做加法， Lua 就会尝试调用该元方法。 __sub: - 操作。 行为和 “add” 操作类似。 __mul: * 操作。 行为和 “add” 操作类似。 __div: / 操作。 行为和 “add” 操作类似。 __mod: % 操作。 行为和 “add” 操作类似。 __pow: ^ （次方）操作。 行为和 “add” 操作类似。 __unm: - （取负）操作。 行为和 “add” 操作类似。 __idiv: // （向下取整除法）操作。 行为和 “add” 操作类似。 __band: &amp; （按位与）操作。 行为和 “add” 操作类似， 不同的是 Lua 会在任何一个操作数无法转换为整数时尝试取元方法。 __bor: | （按位或）操作。 行为和 “band” 操作类似。 __bxor: ~ （按位异或）操作。 行为和 “band” 操作类似。 __bnot: ~ （按位非）操作。 行为和 “band” 操作类似。 __shl: &lt;&lt; （左移）操作。 行为和 “band” 操作类似。 __shr: &gt;&gt; （右移）操作。 行为和 “band” 操作类似。 比如下面实现一个表用作集合操作，并对集合操作实现加法运算的元方法： 1234567891011121314151617local set = &#123;&#125;local set_mt = &#123;&#125;function set.new(v) local set = setmetatable(&#123;&#125;, set_mt) for _, v in ipairs(v) do set[v] = true end return setendset_mt.__add = function(a, b) local ret = &#123;&#125; for k in pairs(a) do ret[k] = true end for k in pairs(b) do ret[k] = true end return retend 然后，我们可以按以下方法对一个集合进行加法运算了： 12345678910111213local s1 = set.new&#123;10, 20, 30, 40&#125;local s2 = set.new&#123;20, 50&#125;print(getmetatable(s1)) --&gt; table: 00E7E978print(getmetatable(s2)) --&gt; table: 00E7E978local s3 = s1 + s2local t = &#123;&#125;for k in pairs(s3) do t[#t + 1] = kendprint(\"&#123;\" .. table.concat(t, \", \") .. \"&#125;\") --&gt; &#123;40, 10, 20, 30, 50&#125; 关系运算符元方法我们还可以指定关系运算符元方法，其主要包含以下几种操作： __eq: == （等于）操作。仅在两个值都是表或都是完全用户数据时，且它们不是同一个对象时才尝试该元方法，调用的结果总会被转换为布尔量。 __lt: &lt; （小于）操作。 仅在两个值不全为整数也不全为字符串时才尝试元方法，调用的结果总会被转换为布尔量。 __le: &lt;= （小于等于）操作。 和其它操作不同， 小于等于操作可能用到两个不同的事件。 首先，像 “lt” 操作的行为那样，Lua 在两个操作数中查找 __le 元方法，如果一个元方法都找不到，就会再次查找 __lt 元方法，Lua 会将 a &lt;= b 转化为 not (b &lt; a)；a ~= b 转换为 not (a == b)；a &gt; b 转换为 b &lt; a；a &gt;= b 转换为 b &lt; a。 我们可以尝试为上面集合增加一个集合相等操作： 1234567891011set_mt.__eq = function(a, b) for k in pairs(a) do if not b[k] then return false end end for k in pairs(b) do if not a[k] then return false end end return trueend 然后我们对集合进行比较： 123456local s1 = set.new&#123;2, 4&#125;local s2 = set.new&#123;2, 4, 5&#125;local s3 = set.new&#123;2, 4&#125;print(s1 == s2) --&gt; falseprint(s1 == s3) --&gt; true index 与 newindex 元方法Lua 提供了一种能改变表在访问和修改表中不存在字段时的行为方式。 __index 元方法当我们访问一个表中不存在的字段时，通常情况下会返回 nil。但实际上，这样的访问方式会引发解释器取查找一个名为 __index 的元方法。如果没有找到这个元方法，则会直接返回 nil，否则会由这个元方法来提供最终的结果。 下面代码首先定义了一个原型 prototype 用来表示窗口坐标和大小信息，然后定义了一个 new 构造函数来产生一个对象，返回的对象直接设置成了元表 mt，该元表定义了元方法 __index，访问该元方法默认是直接访问 prototype 表的熟悉： 1234567891011prototype = &#123;x = 0, y = 0, width = 100, height = 100&#125;local mt = &#123;&#125;mt.__index = function(_, key) return prototype[key]endlocal function new(o) return setmetatable(o, mt)end 然后我们可以调用函数 new 创建新对象，并指定对象的宽度和高度属性，可以预见的是，新对象并不包含坐标 x 和 y 的值，当我们访问不存在的 x 值时会触发直接访问 __index 元方法，并返回 prototype 的默认值 0： 12w = new&#123;width = 50, heigh = 50&#125;print(w.x) --&gt; 0 __index 虽然叫做元方法，但不一定非得是一个函数，它还可以是一个表。当元方法是一个函数时，Lua 会把当前表和不存在的参数名作为参数调用该函数；当元方法是一个表时，Lua 会直接访问这个表。上面例子中，我们把 __index 字段直接设置为 prototype 时，访问不存在的值时，会直接返回 prototype 对应的值： 1mt.__index = prototype __index 元方法与 rawget 函数有时候我们希望访问一个表时，不调用 __index 元方法，那么我们可以使用 rawget (table, index) 函数，该函数会在不触发任何元方法的情况下直接获取 table[index] 的值。 12w = new&#123;width = 50, heigh = 50&#125;print(rawget(w, \"x\")) --&gt; nil 可以看到上面代码使用 rawget 访问 x 属性时，并不会触发对元方法 __index 的访问，而是直接返回了 nil。 __newindex 元方法__newindex 与 __index 类似，不同之处在于 __newindex 用于表的更新操作，而 __index 用于表的查询操作。当对一个表中不存在的索引赋值时，解释器就会触发 __newindex 元方法，如果这个元方法存在则会直接调用它，而不会继续执行赋值操作。 123456mt.__newindex = function(t, key, value) error(\"attempt to update a nonexistent field\", 2)endobj = new&#123;width = 50, height = 50&#125;obj.name = \"Window\" -- 赋值不存在的键时，产生错误 上面例子中，我们可以使用 __newindex 元方法来拦截对不存在的字段的赋值操作，当不存在的 name 字段赋值时，会触发 __newindex 元方法，并抛出一个赋值错误的异常。 __newindex 元方法与 rawset 函数与函数 rawget 类似，原始函数 rawset (t, k, v) 允许我们绕过元方法，直接对某个表进行赋值操作。其中参数 t 必须时一张表，当我们调用 rawset(t, k, v) 时，其等价于 t[k] = v，但不会触发任何元方法。 123456789mt.__newindex = function(t, key, value) if key == \"name\" and type(value) ~= \"string\" then error(\"the assignment must be of type string\") end rawset(t, key, value)endobj = new&#123;width = 50, height = 50&#125;obj.name = 1 -- 非字符串类型，产生错误 上面例子中，当我们对对象的 name 字段赋值时，会触发 __newindex 元方法，该函数会检查 name 字段的值是否为字符串类型，如果不是则会抛出错误，否则执行正常赋值操作。","categories":[{"name":"Lua入门教程","slug":"Lua入门教程","permalink":"https://veinin.com/categories/Lua入门教程/"}],"tags":[{"name":"Lua 5.3","slug":"Lua-5-3","permalink":"https://veinin.com/tags/Lua-5-3/"},{"name":"Lua编程","slug":"Lua编程","permalink":"https://veinin.com/tags/Lua编程/"},{"name":"元表","slug":"元表","permalink":"https://veinin.com/tags/元表/"},{"name":"元方法","slug":"元方法","permalink":"https://veinin.com/tags/元方法/"}]},{"title":"Lua入门教程：模块与包","slug":"programming_in_lua_10","date":"2018-12-20T12:34:15.000Z","updated":"2019-03-25T16:16:50.666Z","comments":true,"path":"2018/12/20/programming_in_lua_10/","link":"","permalink":"https://veinin.com/2018/12/20/programming_in_lua_10/","excerpt":"Lua 从 5.1 版本开始为模块与包定义了一系列规则，这些规则不需要引入额外的功能特性。对用户来说，一个模块就是一些代码，这些代码可以通过 require 函数加载。 值得注意的是，从 Lua 5.2 开始编写模块的建议方式已经发生改变，而不在是 Lua 5.1 中的 module(“mymodule”, package.seall) 。现在根据推荐的是创建一个本地表，将所有模块函数放入其中并返回表，其最大的区别是不会再使用全局命名空间来注册模块。 模块的基本方法定义一个简单的模块，该模块在文件 test_module.lua 中，其模块有两个函数 foo 和 bar： 12345678910111213-- test_module.lualocal M = &#123;&#125;function M.foo() print(\"foo\")endfunction M.bar() print(\"bar\")endreturn M","text":"Lua 从 5.1 版本开始为模块与包定义了一系列规则，这些规则不需要引入额外的功能特性。对用户来说，一个模块就是一些代码，这些代码可以通过 require 函数加载。 值得注意的是，从 Lua 5.2 开始编写模块的建议方式已经发生改变，而不在是 Lua 5.1 中的 module(“mymodule”, package.seall) 。现在根据推荐的是创建一个本地表，将所有模块函数放入其中并返回表，其最大的区别是不会再使用全局命名空间来注册模块。 模块的基本方法定义一个简单的模块，该模块在文件 test_module.lua 中，其模块有两个函数 foo 和 bar： 12345678910111213-- test_module.lualocal M = &#123;&#125;function M.foo() print(\"foo\")endfunction M.bar() print(\"bar\")endreturn M 另外，还有一种编写模块的方法是把所有函数定义为局部变量，然后在最后构造模块并返回一个表： 1234567891011121314-- test_module.lualocal function foo() print(\"foo\")endlocal function bar() print(\"bar\")endreturn &#123; foo = foo, bar = bar,&#125; 这种编写模块的方式与上一种运行结果是一样的，其优点是无需在每个函数前使用表示符 M. 或类似的这种东西，最后再显示的导出相应的表。但这种方式有一个缺点就是导出表处在模块的最后，我们需要把导出的名字都写两边，会有点冗余。 当然，不管怎么，最后我们都能通过 require 函数获取到模块并使用它： 123456-- module_main.lualocal tm = require \"test_module.lua\"tm.foo() --&gt; footm.bar() --&gt; bar require 函数require 只是一个简单的加载模块的函数，我们如果需要使用某个模块，我们只需向其传入模块名作为参数，就可以获取指定的模块代码。 require 使用方式通常有两种： 12345-- 使用括号local m = require(\"test_module\")-- 不使用括号local m = require \"tet_module\" 这两种方式并没有什么差异性，它们的运行方式是一样的。但对于 require 执行方式，我们还是有必要了解以下其运行原理的： 首先 rquire 函数调用时，会去一个叫做 package.loaded 的全局表中查找模块是否已经加载，如果已经加载则返回对于的值。 如果 package.loaded 没有找到对于的模块名，则会进一步搜索具有自定模块名的 Lua 文件（搜索路径由 package.path 决定），如果找打对于文件则调用 loadfile 函数加载。 进一步，如果找不到指定模块名的 Lua 文件，那么会继续搜索对于名称的的 C 标准库文件（搜索路径由 package.cpath 决定），如果找到 C 标准库，则会使用 package.loadlib 函数进行加载。 最后，如果找到模块由返回值，那么 require 会返回这个值，并保存在表 package.loaded 中，以便下次加载时返回相同的值。如果找到的模块没有任何返回值，返回值会设置为 true。 因为由 package.loaded 的存在，除了第一次加载会执行一系列搜索模块规则外，后续的调用都会直接返回 package.loaded 中的值，如果我们希望再次强制加载一此模块，以达到比如重新更新模块的代码，我们可以这样做： 12package.loaded.modname = nillocal m = require \"modname\" require 搜索路径require 使用的路径是一组模板，其中每一项都指定了如何将模块名转换为文件名的方式，其中每一个模板都是一个包含了可选问好的文件名， require 会将传入的模块名替换每一个问号，然后再一次检查每一项是否存在该文件名，如果目标不存在，则检查下一个模板。我们可以看下面这组路径： 1D:\\Lua\\bin\\lua\\?;D:\\Lua\\bin\\lua\\?\\?.lua; 如果使用 require “test” 加载模块，则会将上面路径转换为： 12D:\\Lua\\bin\\lua\\testD:\\Lua\\bin\\lua\\test\\test.lua 前面提到了 require 用于搜索 Lua 文件路径的变量是 package.path，其默认值初始化后会设置为环境变量 LUA_PATH_5_3 的值，如果没有 LUA_PATH_5_3 这个环境变量则会尝试找到 LUA_PATH 这个变量进行设置。 对于 C 标准库的路径其用变量名叫做 package.cpath，其默认值来自环境变量 LUA_CPATH_5_3 或者 LUA_CPATH。需要注意的是，package.cpath 的值在 POSIX 系统和 Windows 系统中是由差异的，比如在 POSIX 系统中，其典型的值为： 1./?.so;/usr/local/lib/lua/5.3/?.so 可以看到 POSIX 系统中，库名称都是 .so 结尾，而在 Windows 中会变成 .dll： 1.\\?.dll;D:\\Lua\\lua53\\lib\\?dll 另外，我们还需要了解函数 package.searchpath(name, path) 函数，该函数实现了搜索库的所有规则，我们可以传入一个模块名和路径来搜索文件，该函数会返回抵押给存在的文件，如果不存在则会返回 nil 和无法加载成功的错误信息。 12345&gt; path = \".\\\\?.dll;D:\\\\lua\\\\lib\\\\?.dll\"&gt; print(package.searchpath(\"test\", path))nil no file '.\\test.dll' no file 'D:\\lua\\lib\\test.dll' 加载器加载器的作用是用来搜索 Lua 文件或者 C 标准库文件。在变量数组 package.searchers 中存放了 require 所需要使用的所有类型的加载器，当查找一个模块是，require 会按次序使用这些加载器，并传入模块名进行搜索。如果某个加载器找到模块，则停止搜索并返回，如果使用完所有加载器都没有找到模块，则 require 函数会抛出异常。 Lua 用四个查找器函数初始化 package.searchers 表： 第一个查找器就是简单的在 package.preload 表中查找加载器。 第二个查找器用于查找 Lua 库文件，它使用变量 package.path 中的路径来做查找工作。 第三个查找器用于查找 C 库文件，它使用变量 package.cpath 中的路径来做查找工作。 第四个查找器我们称之为一体化加载器，它从 C 库路径中查找指定模块的根名字，比如请求 a.b.c 时，它将查找 a 这个 C 库，如果找到，再加载函数，这个例子中则是 luaopen_a_b_c。利用这个机制，可以把若干 C 子模块打包进单个库，每个子模块都可以有原本的加载函数名。 除了上面所说的加载器之外，我们也可以为一些特殊模块定义预加载器，预加载查找器会使用要给名为 package.preload 的表来映射模块名称和加载函数，当加载指定模块时，如果检查到 package.preload 定义了预加载器函数，则会直接使用该函数作为模块加载，并使用其返回值返回。 子模块与包在一个负责的软件系统中，其一般会包含多个软件模块，每个模块又会分配多个子模块，而 Lua 是支持这种具有层次结构的模块分配的。比如，一个名为 mod.sub 的模块是模块 mod 的一个子模块 sub，我们可以看下面这样的树形结构的模块示意： 123456src mod sub mod2 sub2 sub3 当搜索一个子模块时，函数 require 会将点转换为对于操作系统中的分隔符，如 POSIX 操作系统中的斜杠或 Windows 操作系统中的反斜杠。转换完成后，再对搜索路径的问号进行替换，然后走上面介绍的的模块搜索流程。如下面路径： 1.\\?.lua;D:\\Lua\\?.lua; 当调用 require &quot;a.b&quot; 时，会生成以下搜索路径： 123.\\a\\b.luaD:\\Lua\\a\\b.lua;D:\\Lua\\a\\b\\init.lua; 这种搜索行为可以让我们很容易的把一个模块中的所有文件放置到同一个目录下，比如模块 m、m.a、m.b 对于的文件可以分别时 m/init.lua、m/a.lua、m/b.lua，而目录 m 可以放置在合适的任意位置，其他模块搜索只需要设置其搜索路径即可。 另外，C 语言中名称是不能包含点，因此在编写 C 标准库时，子模块 a.b 是无法导出函数 lua_a.b的，这时，require 函数会将点替换为下划线，即名为 lua_a_b 的 C 标准库函数。","categories":[{"name":"Lua入门教程","slug":"Lua入门教程","permalink":"https://veinin.com/categories/Lua入门教程/"}],"tags":[{"name":"Lua 5.3","slug":"Lua-5-3","permalink":"https://veinin.com/tags/Lua-5-3/"},{"name":"Lua编程","slug":"Lua编程","permalink":"https://veinin.com/tags/Lua编程/"}]},{"title":"Lua入门教程：编译、执行和错误","slug":"programming_in_lua_09","date":"2018-12-17T13:13:20.000Z","updated":"2019-03-25T16:16:47.778Z","comments":true,"path":"2018/12/17/programming_in_lua_09/","link":"","permalink":"https://veinin.com/2018/12/17/programming_in_lua_09/","excerpt":"dofile 与 loadfile 函数dofile 是一个辅助函数，函数 loadfile 才完成了真正的核心工作。 两个函数都是从文件中加载 Lua 代码，但它不会运行，只是编译代码，然后把编译后的代码作为函数返回。与 dofile 不同，loadfile 不会抛出异常，只会返回错误码。 1234function dofile(filename) local f = assert(loadfile(filename)) return f()end load 函数与 loadfile 类似，但该函数是从一个字符串中读取代码。 编写用后即弃的代码： 123i = 0s = \"i = i + 1\"load(s)() --&gt; 1","text":"dofile 与 loadfile 函数dofile 是一个辅助函数，函数 loadfile 才完成了真正的核心工作。 两个函数都是从文件中加载 Lua 代码，但它不会运行，只是编译代码，然后把编译后的代码作为函数返回。与 dofile 不同，loadfile 不会抛出异常，只会返回错误码。 1234function dofile(filename) local f = assert(loadfile(filename)) return f()end load 函数与 loadfile 类似，但该函数是从一个字符串中读取代码。 编写用后即弃的代码： 123i = 0s = \"i = i + 1\"load(s)() --&gt; 1 该函数加载的代码如果有语法错误，load 会返回 nil 和 错误信息，所以最好使用 assert： 1assert(load(s))() laod 加载编译时不会设计词法定界，该函数总是在全局环境中编译代码： 123456i = 32local i = 0f = load(\"i = i + 1; print(i)\")g = function() i = i + 1; print(i) endf() --&gt; 33g() --&gt; 1 错误Lua 会在遇到非预期的情绪时引发错误，如将非数值类型相加，对不是函数的值进行调用等。 也可以调用函数 error 并传入一个错误信息来作为参数引发一个错误： 12n = io.read(\"n\")if not n then error(\"invalid input\") end 当然上面这种情况更简单的代码结构是使用 assert 函数来完成，assert 函数检查第一个参数是否为真，如果为真则返回该参数，否则引发一个错误，并用第二个参数作为错误提示信息： 1n = assert(io.read(\"n\"), \"invalid input\") Lua 中要给函数发现某个错误是，在进行异常处理时有两种选择： 返回错误代码（nil 或是 false） 通过函数 error 引发一个错误。 通常容易避免的错误应该引发错误，否则应该返回错误码。 错误处理和异常要执行一段代码并捕获一段错误(try-catch)可以使用pcall函数，该函数以一种保护模式调用它的第一个参数，如果没有发生错误会返回true和调用函数的返回参数，否则返回false和错误信息。我们可以通过 error(throw an exception) 来抛出异常，并通过 pcall 来捕获 (catch) 异常。 1234567891011local ok, msg = pcall(function() some code if unexpected_condition then error() end some codeend)if ok then regular codeelse error-handing codeend 另外，error 函数还有第2个可选参数 level，用于只想函数调用层次中的哪层函数报告错误，以说明谁应该为错误负责。 123456function foo(str) if type(str) ~= \"string\" then error(\"string expected\", 2) end regualr codeend 最后，我们如果希望错误发生时获得更多的调试信息，比如发生错误时一个完整的函数调用栈信息。pcall 如果发生错误时，部分的调用栈已经被破坏了（从pcall到出错部分），如果希望得到一个完整的有意义的栈回溯，则必须在函数 pcall 返回前先将调用栈构好。为了实现上面的需求，我们可以使用 xpcall 函数，该函数第二个参数是一个消息处理函数，当错误发生时，Lua 会在调用栈展开前调用这个消息处理函数，我们可以使用 debug.traceback 来获取更多错误信息。 123456789local function error_handler(msg) print(debug.traceback(tostring(msg), 2))endxpcall(function() some code if unexpected_c ondition then error() end some codeend, error_handler)","categories":[{"name":"Lua入门教程","slug":"Lua入门教程","permalink":"https://veinin.com/categories/Lua入门教程/"}],"tags":[{"name":"Lua 5.3","slug":"Lua-5-3","permalink":"https://veinin.com/tags/Lua-5-3/"},{"name":"Lua编程","slug":"Lua编程","permalink":"https://veinin.com/tags/Lua编程/"}]},{"title":"Lua入门教程：数值","slug":"programming_in_lua_01","date":"2018-12-15T12:12:33.000Z","updated":"2019-03-25T16:16:45.096Z","comments":true,"path":"2018/12/15/programming_in_lua_01/","link":"","permalink":"https://veinin.com/2018/12/15/programming_in_lua_01/","excerpt":"Lua 5.2 以及之前的版本，所有数值类型都是以双精度浮点数表示，并且所有浮点型数值最大都是 2^54，但是 Lua 5.3 版本引入了整形，最大可用 64 位表示。 数值表示方式Lua 数值默认是十进制表示，除了整形之外，其他小数或者指数都会当做浮点型数值。我们可以使用函数 type 来获数值类型，他们都是使用 number 表示数值： 1234567&gt; 1 --&gt; 1&gt; 1.0 --&gt; 1.0&gt; 1.2e5 --&gt; 120000.0&gt; 0.2e4 --&gt; 2000.0&gt; 0xff --&gt; 255&gt; type(1) --&gt; number&gt; type(1.0) --&gt; number 在 Lua 5.3 中为了区分整形和浮点型数值，引入了 math.type 函数，如果是整形该函数返回 integer，浮点型则返回 float： 12&gt; math.type(1) --&gt; integer&gt; math.type(1.0) --&gt; float 同时为了方便判断是否可以把一个数转换到整数，Lua 5.3 引入了 math.tointeger 函数，如果目标可以转换为一个整数，返回该整数，否则返回 nil ： 12&gt; math.tointeger(3.0) --&gt; 3&gt; math.tointeger(3.1) --&gt; nil","text":"Lua 5.2 以及之前的版本，所有数值类型都是以双精度浮点数表示，并且所有浮点型数值最大都是 2^54，但是 Lua 5.3 版本引入了整形，最大可用 64 位表示。 数值表示方式Lua 数值默认是十进制表示，除了整形之外，其他小数或者指数都会当做浮点型数值。我们可以使用函数 type 来获数值类型，他们都是使用 number 表示数值： 1234567&gt; 1 --&gt; 1&gt; 1.0 --&gt; 1.0&gt; 1.2e5 --&gt; 120000.0&gt; 0.2e4 --&gt; 2000.0&gt; 0xff --&gt; 255&gt; type(1) --&gt; number&gt; type(1.0) --&gt; number 在 Lua 5.3 中为了区分整形和浮点型数值，引入了 math.type 函数，如果是整形该函数返回 integer，浮点型则返回 float： 12&gt; math.type(1) --&gt; integer&gt; math.type(1.0) --&gt; float 同时为了方便判断是否可以把一个数转换到整数，Lua 5.3 引入了 math.tointeger 函数，如果目标可以转换为一个整数，返回该整数，否则返回 nil ： 12&gt; math.tointeger(3.0) --&gt; 3&gt; math.tointeger(3.1) --&gt; nil 数值运算Lua 5.3 引入整形后，如果我们对两个整形进行加(+)、减(-)、乘(*)、除(/)、取负数(-)操作，其结果任然是整形。并且为了方便我们对整数进行除法运算，引入了一个新的 float 除法运算符 //，该运算符会对得到的商向负无穷取整，从而保证结果是一个整形。而如果我们忽略整形和浮点型之间的区别，那么其运算规则和其他的 5.x 版本没有任何差别： 12345678910&gt;&gt; 1 + 1 --&gt; 2&gt; 1 + 1.0 --&gt; 2.0&gt; 1.0 + 1.0 --&gt; 2.0&gt; 6 // 3 --&gt; 2&gt; -6 // -3 --&gt; 2&gt; 2.0 // 2 --&gt; 1.0&gt; 1 // 0.5 --&gt; 2.0&gt; 1 + 0.0 --&gt; 1.0&gt; 1.0 | 0 --&gt; 1 数值关系运算我们可以使用 Lua 的关系运算符大于（&gt;）、小于（&lt;）、大于且等于（&gt;=）、小于且等于（&lt;=）以及不等于（~=）对数数值进行关系运算： 1234567&gt; 1 &lt; 2 --&gt; true&gt; 1 &gt; 2 --&gt; false&gt; 2 &gt;= 2 --&gt; true&gt; 3 &lt;= 4 --&gt; true&gt; 4 ~= 4 --&gt; false&gt; 5.0 ~= 5 --&gt; false&gt; 1.0 == 1 --&gt; true 数值运算符优先级Lua 中操作符的优先级从高优先级到低优先级排序表示如下： 123456789101112^一元运算符 (not # - ~)* / // %+ -..&lt;&lt; &gt;&gt;&amp;~|&lt; &gt; &lt;= &gt;= ~= ==andor 通常，你可以用括号来改变运算次序。连接操作符 (‘..’) 和乘方操作 (‘^’) 是从右至左的。 其它所有的操作都是从左至右。 1234&gt; 1 + 2 == 2 * 3 // 2 --&gt; (1 + 2) == (2 * 3) // 2&gt; 1 and 3 or 2 --&gt; (1 and 3) or 2&gt; -1 ^ 2 --&gt; -(1^2)&gt; 1 + 2 &gt; 3 and 4 位运算Lua 5.3 版本开始提供针对数值类型的一组标准位运算符，与算术运算符不同的是，位运算只能用于整形数值。 位运算符包括： &amp;，按位与 |，按位或 ~，按位异或 &gt;&gt;，右移 &lt;&lt;，左移 ~，按位取反 下面例子中的位运算符使用了函数 string.format 来输出十六进制形式的结果： 1234&gt; string.format(\"%s\", 0xff &amp; 0xabcd) --&gt; cd&gt; string.format(\"%s\", 0xff | 0xabcd) --&gt; abcd&gt; string.format(\"%x\", 0xaaaa ~ -1) --&gt; ffffffffffff5555&gt; string.format(\"%x\", ~0) --&gt; ffffffffffffffff 数学库除了前面提到 Lua 5.3 新增的 math.type、math.tointeger 函数外，Lua 还提供了其他一系列基础的数学操作函数库给我们，基本能满足我们日常编程的大部分需求。 基本数值运算函数 math.abs(x)，返回 x 的绝对值。 math.acos(x)，返回 x 的反余弦值（用弧度表示）。 math.asin(x)，返回 x 的反正弦值（用弧度表示）。 math.atan(x)，返回 y/x 的反正切值（用弧度表示）。 math.ceil(x)，返回不小于 x 的最小整数值。 math.cos(x)，返回 x 的余弦（假定参数是弧度）。 math.deg(x)，将角 x 从弧度转换为角度。 math.exp(x)，返回 ex 的值 （e 为自然对数的底）。 math.floor(x)，返回不大于 x 的最大整数值。 math.fmod(x)，返回 x 除以 y，将商向零圆整后的余数。 (integer/float) math.log(x)，返回以指定底的 x 的对数。 默认的 base 是 e （因此此函数返回 x 的自然对数）。 math.modf(x)，返回 x 的整数部分和小数部分。 第二个结果一定是浮点数。 math.rad(x)，将角 x 从角度转换为弧度。 math.sin(x)，返回 x 的正弦值（假定参数是弧度）。 math.sqrt(x)，返回 x 的平方根。 math.tan(x)，返回 x 的正切值。 math.ult(x)，如果整数 m 和 n 以无符号整数形式比较， m 在 n 之下，返回布尔真否则返回假。 math.min(x, …)，返回参数中最小的值， 大小由 Lua 操作 &lt; 决定。 math.max(x, …)，返回参数中最大的值， 大小由 Lua 操作 &lt; 决定。 1234567&gt; math.abs(-10) --&gt; 10&gt; math.floor(2.33) --&gt; 2&gt; math.floor(-2.33) --&gt; -3&gt; math.ceil(2.33) --&gt; 3&gt; math.ceil(-2.33) --&gt; -2&gt; math.modf(2.3) --&gt; 2 0.3&gt; math.modf(-2.3) --&gt; -2 -0.3 数值返回表示前面说过，Lua 5.3 使用 64 位来存储整数值，其最大值为 2^63 - 1，数学库中可以使用 math.maxinteger 与 math.mininteger 来表示整数的最大值和最小值。另外 Lua 使用 math.huge 这个值来表示最大的数，这个值比我们能用到的所有数值都要大。 1234567&gt; math.pi --&gt; 3.1415926535898 (π 的值)&gt; math.huge --&gt; inf&gt; math.maxinteger --&gt; 9223372036854775807&gt; math.mininteger --&gt; -9223372036854775808&gt; math.maxinteger + 1 --&gt; -9223372036854775808&gt; math.mininteger - 1 --&gt; 9223372036854775807&gt; math.maxinteger &lt; math.huge --&gt; true 再次强调，Lua 中所有双精度浮点型的值最大只能用 2^53 - 1 表示，如果超过这个数值，进行数值运算则会造成精度损失： 12&gt; 9007199254740992 + 0.0 == 9007199254740992 --&gt; true&gt; 9007199254740993 + 0.0 == 9007199254740993 --&gt; false 随机数Lua 使用 math.random ([m [, n]]) 来产生伪随机数，其有 3 种随机数产生方式： 不带任何参数时，返回一个 [0, 1) 区间内一致分布的浮点伪随机数。 两个整数 m 与 n 调用时， math.random 返回一个 [m, n] 区间 内一致分布的整数伪随机数。值 n-m 不能是负数，且必须在 Lua 整数的表示范围内。） 当调用 math.random(n) 时，其等价于 math.random(1, n)。 123&gt; math.random() --&gt; 0.56356811523438&gt; math.random(1, 4) --&gt; 1&gt; math.random(4) --&gt; 4 作为伪随机数函数，我们每次重新启动 Lua 虚拟机时，其产生随机数都会与上次启动时一模一样，比如在游戏中，我们每次重启游戏后，其产生的随机数都会和上一次启动时一模一样，这其实不是我们所想要的，为了使程序每次启动时都会有不同的随机数产生，我们就需要使用 math.randomseed (x) 函数来初始化随机数生成器。当我们调用次函数后，后面的所有随机数都是基于此函数设置的种子生成的。 通常来说，对于随机数种子，如果没有特殊需求，那么我们直接使用 os.time() 获取当前系统时间来当做随机数种子： 1234&gt; math.randomseed(os.time())&gt; math.random() --&gt; 0.84405517578125&gt; math.randomseed(os.time())&gt; math.random() --&gt; 0.79620361328125 但是有时候，我们必须设置特殊的随机数种子来让随机数表现出一致性，比如 Moba 游戏中，通常很多数值都是客户端进行运算，如果我们希望一局游戏中所有客户端产生的随机数都是一致的，那么我们可以让所有客户端在开始战斗前都统一设置一个随机数种子，那么不同的玩家客户端在同一局游戏中产生的所有随机数都会是一致的： 游戏客户端A: 12&gt; math.randomseed(111231254123)&gt; math.random() --&gt; 0.63229370117188 游戏客户端B： 12&gt; math.randomseed(111231254123)&gt; math.random() --&gt; 0.63229370117188","categories":[{"name":"Lua入门教程","slug":"Lua入门教程","permalink":"https://veinin.com/categories/Lua入门教程/"}],"tags":[{"name":"Lua 5.3","slug":"Lua-5-3","permalink":"https://veinin.com/tags/Lua-5-3/"},{"name":"Lua编程","slug":"Lua编程","permalink":"https://veinin.com/tags/Lua编程/"}]},{"title":"玩转终端软件 Hyper","slug":"hyper-windows-tutorial","date":"2018-11-29T17:20:00.000Z","updated":"2018-11-29T17:21:40.171Z","comments":true,"path":"2018/11/30/hyper-windows-tutorial/","link":"","permalink":"https://veinin.com/2018/11/30/hyper-windows-tutorial/","excerpt":"相信有很多人开发环境是我 Windows 上面，有时候又不得不面临在 Windows 上面开发 Linux 环境的程序。还好 Windows 10 系统为我们提供了一个叫 WSL（Windows Subsystem for Linux） 的子系统。但是，尽管微软已经很努力得在改善 Windows 开发环境了，但我们却始终得不到一个比较简单易用得终端软件，最起码你用 Window 自带得终端来操作 Linux 系统还是会觉得缺了点什么。 目前市面上很多终端软件都比 Windows 自带终端好太多，比如这篇文章就介绍了 20 个比较好用终端软件： THE BEST 1 OF 20 OPTIONS 之前用过一个不错得软件叫做 Cmder，但它不是今天得主角，我们今天要介绍得是另一款更符合我口味得终端软件 Hyper。 获取并安装 Hyper你可以在一下几个地方获取到 Hyper： 官方网站：入口 Github：入口 下载到二进制安装包后，直接安装就可以运行，本文运行环境是 Windows。 基础插件安装Hyper 本身是支持插件系统的，在安装扩展插件时，你需要先安装 Hyper 命令行程序，你可以点击菜单，选择 Plugin 选项，点击 Install Hyper CLI command in PATH。 其官方在首页推荐了4个比较易用的插件，推荐直接全部安装。安装地址请点击 链接。其中4款插件分别为： hypercwd，它可以让你的终端在新建标签页时，保持上一个终端的目录地址。安装命令： hyper i hypercwd。 hyper-search，它可以让你搜索整个终端的所有文本内容。安装命令： hyper i hyper-search。 hyper-pane，增强窗口导航，对于支持多个页签的软件来说这是个利器。安装命令： hyper i hyper-pane。 hyperpower，这是一个让你的终端变得更加绚丽的插件，当然这么炫酷的效果是不是会影响你的工作呢，还是要视个人情而定。安装命令： hyper i hyperpower。","text":"相信有很多人开发环境是我 Windows 上面，有时候又不得不面临在 Windows 上面开发 Linux 环境的程序。还好 Windows 10 系统为我们提供了一个叫 WSL（Windows Subsystem for Linux） 的子系统。但是，尽管微软已经很努力得在改善 Windows 开发环境了，但我们却始终得不到一个比较简单易用得终端软件，最起码你用 Window 自带得终端来操作 Linux 系统还是会觉得缺了点什么。 目前市面上很多终端软件都比 Windows 自带终端好太多，比如这篇文章就介绍了 20 个比较好用终端软件： THE BEST 1 OF 20 OPTIONS 之前用过一个不错得软件叫做 Cmder，但它不是今天得主角，我们今天要介绍得是另一款更符合我口味得终端软件 Hyper。 获取并安装 Hyper你可以在一下几个地方获取到 Hyper： 官方网站：入口 Github：入口 下载到二进制安装包后，直接安装就可以运行，本文运行环境是 Windows。 基础插件安装Hyper 本身是支持插件系统的，在安装扩展插件时，你需要先安装 Hyper 命令行程序，你可以点击菜单，选择 Plugin 选项，点击 Install Hyper CLI command in PATH。 其官方在首页推荐了4个比较易用的插件，推荐直接全部安装。安装地址请点击 链接。其中4款插件分别为： hypercwd，它可以让你的终端在新建标签页时，保持上一个终端的目录地址。安装命令： hyper i hypercwd。 hyper-search，它可以让你搜索整个终端的所有文本内容。安装命令： hyper i hyper-search。 hyper-pane，增强窗口导航，对于支持多个页签的软件来说这是个利器。安装命令： hyper i hyper-pane。 hyperpower，这是一个让你的终端变得更加绚丽的插件，当然这么炫酷的效果是不是会影响你的工作呢，还是要视个人情而定。安装命令： hyper i hyperpower。 主题插件安装Hyper 支持插件系统，自然就少不了主题了，官方首页推荐了4种同颜色的主题，你可以直接在主题地址查看并安装。 当然，上面的满足不了你，你也可以去在上面的主题地址中的页签 NEWEST 找到更多主题，或者你也可以直接去 GitHub 搜索，抑或是你自己写一个主题插件。总之，你最终会找到一款符合你的主题皮肤。 其他插件GitHub 有一个项目叫做 awesome-hyper，其列出了 Hyper 社区中精选的软件包、主题和相关有趣的资源列表，比如下面这款当你输入 git push 成功执行后，终端会出现火箭动画： Hyper 集成 WSL通常我们在使用 WSL 工作时，希望启动终端时就进入 WSL bash 内部，Windows 中有一个 base.exe 程序可以让我们在启动终端后输入 bash 后进入 WSL 终端。但这一步实在太繁琐了，有了 Hyper，我们只需要改动一下配置文件，上面这步就可以直接省略。 现在，你只需打开 Hyper 设置页面文件，这一步需要从菜单 Edit -&gt; Preferences 进入，然后编辑 shell 和 shellArgs 参数： 12shell: 'C:\\\\Windows\\\\System32\\\\wsl.exe',shellArgs: [], 再次从新打开 Hyper，你会发现默认已经进入了 base 终端页面。 使用 zsh 代替 bash通常 Linux 服务器上面默认使用的命令模式是 bash，除了 bash 之外，还有很多其他诸如 zsh、csh、fish等，这其中，我认为 zsh 增强功能（标签完成和拼写错误修正）会很吸引人。 安装 zsh 和 oh-my-zsh虽然 zsh 配置很繁琐，但这一步已经有人帮你完成了，GitHub 上面有一个项目叫做 oh-my-zsh 就是专门用来管理配置 zsh 的一个框架。 在使用 oh-my-zsh 之前，你需要安装 zsh，各个平台安装的方式可能不一样，你可以通过这个 链接 查看 zsh 安装方式。 有了 zsh 后，要安装 oh-my-zsh，你还需要用 wget 或者 curl 来辅助安装： 通过 curl 安装，sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 通过 wget 安装，sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 安装完成后，你可以通过命令 chsh -s /bin/zsh 设置 zsh 为默认的 shell。 安装自动补全功能使用 zsh 我认为第一个吸引我的重要插件就是 zsh-autosuggestions。它会自动为你的终端命令提供补全建议，让你能更加快速的完成命令输入，有了它，你再也不用一遍遍的按 tab 来加快你的命令输入了。 zsh-autosuggestions 安装文档你可以点击这个链接 进入查看，比如使用 Git 安装步骤如下： 使用 Git 把项目从仓库 Clone 下来： 1git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions 将以下内容添加到 .zshrc 文件内： 1source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh 重新开启终端会话，你就可以享受 zsh-autosuggestions 给你带来的便利了。 配置主题Oh My Zsh 附带了大量的插件和主题，你可以利用它们可以进一步增强和美化你的终端功能。要想配置主题和插件，你可以直接修改 ~/.zshrc 文件。 对于插件启用，你可以编辑 plugins 输入你想要加载的插件： 123456789plugins =（ git bundler dotenv osx rake rbenv ruby） 对于主题，你也可以编辑文件 ~/.zshrc，在 ZSH_THEME 修改主题名称即可，链接 External themes 提供了大部分主题的样式，你可以直接修改参数后即可看到主题效果，比如 agnoster 主题： 1ZSH_THEME=\"agnoster\" 修改完成后，你的终端会变成这个样子： 请注意，很多主题如果你无法显示预期效果，那是因为响应的主题系统字体没有安装，你需要正确的安装了 Powerline字体 字体才会显示出来。 总结本文详细阐述了如何安装 Hyper 终端软件，其中包括配置 Hyper 插件和主题设置，并讲述了如何使用 Hyper 完全代替 Windows 的默认终端软件 CMD。最后，介绍了一种使用 zsh 来代替 bash 的方法，你可以让你的终端功能更加强大易用。用一句时髦的话来总结：Hyper 长得很漂亮哦。","categories":[{"name":"Hyper","slug":"Hyper","permalink":"https://veinin.com/categories/Hyper/"}],"tags":[{"name":"Hyper","slug":"Hyper","permalink":"https://veinin.com/tags/Hyper/"},{"name":"Shell","slug":"Shell","permalink":"https://veinin.com/tags/Shell/"},{"name":"Zsh","slug":"Zsh","permalink":"https://veinin.com/tags/Zsh/"},{"name":"CMD","slug":"CMD","permalink":"https://veinin.com/tags/CMD/"}]},{"title":"AI 行为树设计与实现-实现篇","slug":"ai_behavior_tree_design_and_implementation_02","date":"2018-08-08T13:15:00.000Z","updated":"2018-08-11T14:34:14.682Z","comments":true,"path":"2018/08/08/ai_behavior_tree_design_and_implementation_02/","link":"","permalink":"https://veinin.com/2018/08/08/ai_behavior_tree_design_and_implementation_02/","excerpt":"上一篇文章中，我们主要介绍了有限状态机和行为树的各自特点以及他们之间的优劣势，本文着重讲解如何实现一个可用的行为树，手动实现一个行为树的库，这个库代码不到200行，代码库采用面向对象方式实现，语言采用的是 Lua，当然你也可以翻译成其他任何你顺手的语言。 节点行为树时一个树形结构，我们AI系统要做的是执行每个节点，所以我们最开始必须先抽象一个节点出来，该节点作为所有其他类型节点的父节点： 12345678910local Node = class('Node')function Node:ctor(opts) self.blackboard = opts.blackboardendfunction Node:doAction()endreturn Node 我们可以看到，节点拥有一个可选的成员变量 blackboard，我们称它为黑板，你可以搜索查看设计模式关于 黑板模式 的详细介绍。 引入黑板，是因为很多节点在处理AI逻辑时是需要对数据进行处理，黑板中包含了整个行为树可以操作的数据结构。比如上一节我们提到的关于一个NPC守夜巡逻的实现中，整个行为树要处理的对象其实是NPC，NPC打伞、NPC巡逻动作其实是NPC自身的一个行为，而行为树各个节点要处理的目标就是存放在黑板中的这个NPC。 我们实现的行为树节点对外部来说只有一个入口 doAction 函数，下面实现的所有其他类型的行为树节点都继承自 Node 节点。","text":"上一篇文章中，我们主要介绍了有限状态机和行为树的各自特点以及他们之间的优劣势，本文着重讲解如何实现一个可用的行为树，手动实现一个行为树的库，这个库代码不到200行，代码库采用面向对象方式实现，语言采用的是 Lua，当然你也可以翻译成其他任何你顺手的语言。 节点行为树时一个树形结构，我们AI系统要做的是执行每个节点，所以我们最开始必须先抽象一个节点出来，该节点作为所有其他类型节点的父节点： 12345678910local Node = class('Node')function Node:ctor(opts) self.blackboard = opts.blackboardendfunction Node:doAction()endreturn Node 我们可以看到，节点拥有一个可选的成员变量 blackboard，我们称它为黑板，你可以搜索查看设计模式关于 黑板模式 的详细介绍。 引入黑板，是因为很多节点在处理AI逻辑时是需要对数据进行处理，黑板中包含了整个行为树可以操作的数据结构。比如上一节我们提到的关于一个NPC守夜巡逻的实现中，整个行为树要处理的对象其实是NPC，NPC打伞、NPC巡逻动作其实是NPC自身的一个行为，而行为树各个节点要处理的目标就是存放在黑板中的这个NPC。 我们实现的行为树节点对外部来说只有一个入口 doAction 函数，下面实现的所有其他类型的行为树节点都继承自 Node 节点。 节点执行状态上一章我们解释了行为树包含两大类子节点：控制节点与行为节点。 控制节点，这类节点没有任何游戏内的具体逻辑实现，只是为了控制行为节点的执行； 行为节点，这是涉及我们游戏内的具体游戏逻辑的节点，行为节点通常会在执行完成后，返回执行成功与否，拥有行为节点的父节点，也就是控制节点，会根据行为节点的返回值，做出相应的控制。 为了更加明白的阐述，我们举个例子，例如上一节提到的NPC夜晚巡逻的AI，我们把“是否晚上”、“巡逻”这种节点称为行为节点，行为节点需要返回一些执行结果，如“是否晚上”节点返回为真，则控制节点再运行“巡逻”行为。 所以，在进入详细代码设计之前，所有节点的执行，都是需要定义一些返回状态常量值的： 1234567local BTConst = &#123;&#125;BTConst.SUCCESS = 0BTConst.FAIL = 1BTConst.WAIT = 2return BTConst 行为树的节点，通常需要以上三种执行状态，执行节点成功、失败以及等待，对于等待状态，是因为一些节点单次执行并没有成功，需要等待下一次的执行时间到来以继续执行。 控制节点实现对于一个行为树系统，其核心部分主要是其提供的控制节点，通过控制节点，我们可根据自己的游戏需求拓展出一套相对应的条件与行为节点。我们必须再度强调控制节点是与具体的游戏逻辑是无关的，它只负责整个行为树的逻辑控制。 本文的代码采用面向对象开发，实现语言采用 Lua。在实现控制节点前，我们先看看控制节点的类结构： 从图中我们可以看到，控制节点核心包含选择节点（Selector）、序列节点（Sequence）和平行节点（Parallel），它们都继承自一个组合节点（Composite）。 组合节点(Coposite)组合节点可以看作是一个节点的集合，可以组合多个子节点。行为树的控制节点都是组合各类行为节点的父节点，然后按一定的规则执行它们。我们先实现一个组合节点： 1234567891011local Composite = class('Composite', Node)function Conposite:ctor() self.children = &#123;&#125;endfunction Composite:addChild(node) table.insert(self.children, node)endreturn Composite 组合节点成员只有一个，那就是一个孩子节点的集合，我们可以往组合节点上面添加任意数量的孩子节点。 选择节点选择节点，顾名思义，就是需要从众多的子节点中选择一个可以执行成功的节点，如果子节点执行成功，则跳出执行，并且下次执行时继续从头开始。选择在行为树中运用的频率比其他两个控制节点来说要更多，因为游戏AI系统中充斥着各种不同情况，我们的AI系统需要从中选择一个合理的路径执行。比如下图某个NPC的AI是选择巡逻还是休息： 选择节点代码来实现： 1234567891011121314151617181920212223242526272829303132333435363738local Selector = Class('Selector', Composite)function Selector:ctor() self.index = 1endlocal function reset(self) self.index = 1endfunction Selector:doAction() local size = #self.children if size == 0 then return BTConst.SUCCESS end if self.index &gt; size then reset(self) end for i = self.index, size do local ret = self.children[i]:doAction() self.index = self.index + 1 if ret == BTConst.SUCCESS then reset(self) return ret elseif ret == BTConst.WAIT then return ret end end reset(self) return BTConst.FAILendreturn Selector 上面代码中，选择节点的策略是先从第一个子节点开始执行，如果遇到某个节点执行成功，则重置执行节点的位置，并直接返回，那么下次再进入该节点后，会直接从第一个子节点开始执行。如果执行某个节点是等待状态，则直接返回，下次重新进入该节点执行时，会直接从等待的那个节点继续执行。如果所有节点都未成功或没有等待，则返回失败，并重置执行位置，下次将会从头开始执行。 序列节点序列节点执行是有序的，它会从从到尾依次执行其子节点，当碰到一个子节点失败是会被打断，并且立刻返回，剩下的节点将不会继续执行。序列节点的特性适合于执行一系列连续的操作，如果某个操作执行失败，则后续的操作会被打断。如NPC在选择巡逻还是休息的AI中，在判断巡逻时，需要判断是白天还是晚上，如果满足条件，则巡逻，否则休息： 序列节点代码来实现： 1234567891011121314151617181920212223242526272829303132333435363738local Sequence = class('Sequence', Composite)function Sequence:ctor() self.index = 1endlocal function reset(self) self.index = 1endfunction Sequence:doAction() local size = #self.children if size == 0 then return BTConst.SUCCESS end if self.index &gt; size then reset(self) end for i = self.index size do local ret = self.children[i]:doAction() self.index = self.index + 1 if ret == BTConst.WAIT then return ret elseif ret == BTConst.FAIL then reset(self) return ret end end reset(self) return BTConst.SUCCESSendreturn Sequence 上面代码选择从头开始执行各个子节点，遇到某个节点等待，则跳出，下次继续执行剩余节点。如果某个节点执行失败，则重置执行位置，并返回，下次执行时，会从头开始。最后，在所有节点都执行成功后，重置执行位置，并返回执行成功，下次执行时，从头继续开始。 平行节点平行节点与序列节点类似，但平行节点，每次执行时都会把所有子节点执行一边，然后统计其执行结果，根据平行节点执行策略，返回相应的结果。平行节点影响执行结果返回会有好几种策略： FAIL_ON_ONE，只要有一个子节点执行返回失败，则执行结果就会返回失败状态。 FAIL_ON_ALL，所有子节点执行失败了，执行结果才会返回失败，否则算做成功。 平行节点运用于执行一系列不被其他节点影响还的操作，如NPC巡逻AI中，在平行节点中有两个子节点，一个是选择天气，一个是选择守夜巡逻，天气系统中只会影响NPC是否需要打伞，而守夜巡逻分支影响NPC是否需要巡逻，着两个节点会独立的运行，它们之间不会相互影响的， 平行节点代码来实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758local FAIL_ON_ONE = 1local FAIL_ON_ALL = 2local Parallel = class('Parallel', Composite)function Parallel:ctor(opts) self.policy = opts and opts.policy or FAIL_ON_ONE self.waits = &#123;&#125; self.succ = 0 self.fail = 0endlocal function reset(self) self.waits = &#123;&#125; self.succ = 0 self.fail = 0endlocal function checkPolicy(self) if self.policy == FAIL_ON_ONE then return self.fail &gt; 0 and BTConst.FAIL or BTConst.SUCCESS elseif self.policy == FAIL_ON_ALL then return self.succ &gt; 0 and BTConst.SUCCESS or BTConst.FAIL endendfunction Parallel:doAction() local size = #self.children if size == 0 then return BTConst.SUCCESS end local ret local rest = &#123;&#125; local origin = #self.waits &gt; 0 and self.waits or self.children for i = 1, #origin do ret = origin[i]:doAction() if ret == BTConst.SUCCESS then self.succ = self.succ + 1 elseif ret == BTConst.WAIT then table.insert(rest, origin[i]) elseif ret == BTConst.FAIL then self.fail = self.fail + 1 end end if #rest &gt; 0 then self.waits = rest return BTConst.WAIT end ret = checkPolicy(self) reset(self) return retend 上面代码中，首先声明了平行节点执行策略 FAIL_ON_ONE 与 FAIL_ON_ALL。平行节点定义了3个类成员 waits 表示执行等待的节点，succ 表示执行成功的节点数量，fail 表示执行失败的节点数量。节点开始执行前先获取执行起点，如果有等待执行的节点，有优先执行等待节点；如果没有等待的节点，则从头开始执行各个子节点。子节点执行成功、失败，则记录，如果是带状态则记录到等待列表 rest 中，并在执行完成后，检查 rest，如果存在等待节点，则直接返回，下次继续执行等待节点。如果所有节点执行都返回成功或失败，则根据记录从节点策略中获取返回状态码，并重置所有执行记录，等待下一次重新开始执行。 装饰节点装饰节点可以作为额外的附加条件，例如，时间间隔控制、频率控制、触发概率、结果取反、错误处理等待。比如我一个怪物使用某个技能，我们实现了使用技能的行为节点，但我们需要对这个使用技能的行为节点增加节点触发概率，这种情况下，我们就可以使用装饰节点来扩充原有的行为节点。 1234567891011local Decorator = class('Decorator', Node)function Decorator:ctor(opts) self.child = opts.childendfunction Decorator:setChild(node) self.child = nodeendreturn Decorator 上面装饰节点中，存储了一个装饰子节点，这个子节点将作为被装饰的对象。 循环节点循环节点根据条件不停循环执行子节点，直到子节点返回成功，然后检查循环条件，判断自己是否继续循环。比如巡逻AI中，根节点就是一个循环节点，默认情况下，循环节点会移植运行下去，直到循环节点运行成功，比如我们需求在NPC进行巡逻后，就结束AI的运行等等。 我们看下代码： 1234567891011121314151617181920local Loop = Class('Loop', Decorator)function Loop:ctor(opts) self.loopCond = data.loopCondendfunction Loop:doAction() local ret = self.child:doAction() if ret ~= BTConst.SUCCESS then return ret end if self.loopCond and self.loopCond(self.blackboard) then return BTConst.WAIT end return BTConst.SUCCESSendreturn Loop 循环节点也是一个装饰节点，其有一个循环检查条件节点用于在子节点执行成功后检查， 行为节点实现有了控制节点后，我们剩下的就是实现行为节点了，行为节点可能每个游戏都会不一样，这主要是因为每个游戏AI可能都不同，具体需求到来时，才针对性的实现，所以行为节点通常依托于控制节点，其只会作为叶子节点使用。 条件节点条件节点的作用是判定，如NPC巡逻AI中，天气判定、打伞判定、时间判定都是一个条件节点。先看条件节点实现： 123456789101112131415local Condition = class('Condition', Node)function Condition:ctor(opts) self.umpire = opts.umpireendfunction Condition:doAction() if self.umpire and self.umpire(self.blackboard) then return BTConst.SUCCESS end return BTConst.FAILendreturn Condition 条件节点有一个成员变量 umpire ，我们把他视为一个“裁判员”，用来判定某个条件是否成立。这个变量在 Lua 中实现为一个函数，我们可以自定义一个函数，然后根据上面的接口创建一个条件，比如创建判定天气为晴天的条件节点： 123456local isSunny = function(blackboard) return blackboard.world.weather == \"Sunny\"endlocal isSunnyCondition = Condition.new(isSunny)isSunnyCondition.doAction() 可以看到上面创建一个判定天晴的条件节点是分成简单的，判定条件参数传入的是一个“黑板”成员，里面保存着AI需要的数据对象，比如上面代码中，我们可以直接通过黑板获取到世界world对象，来获取当前天气。 动作节点动作节点人如其名，只会执行相应的动作，具体执行什么动作，也是根据游戏 AI 需求去重新实现的，比如我们的巡逻AI中，NPC 执行打伞、收伞、巡逻等一系列的动作。动作节点只需要继承自 Node 节点，然后实现 doAction 内容即可，如一个 NPC 的巡逻动作： 12345678local PatrolAction = class('PatrolAction', Node)function PatrolAction:doAction() local npc = self.blackboard.npc npc:GoPatrol()endreturn PatrolAction 上面巡逻动作节点实现很简单，只需要执行时，从黑板中获取到NPC对象，然后调用NPC巡逻函数 GoPatrol，NPC就开始进行巡逻了。 总结本章节，我们的行为树核心代码基本全部实现，对于AI不太复杂的游戏，这些代码基本可用了，当然我们也可以根据上面代码在项目需求满足不了的情况下，继续拓展不同类型、不同功能的节点，比如可以支持权值的选择节点等等。下一节，我们将根据这些代码来实现一个具体的 NPC 巡逻 AI。","categories":[{"name":"AI","slug":"AI","permalink":"https://veinin.com/categories/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://veinin.com/tags/AI/"},{"name":"行为树","slug":"行为树","permalink":"https://veinin.com/tags/行为树/"},{"name":"状态机","slug":"状态机","permalink":"https://veinin.com/tags/状态机/"}]},{"title":"AI 行为树设计与实现-理论篇","slug":"ai_behavior_tree_design_and_implementation_01","date":"2018-08-07T10:36:00.000Z","updated":"2018-08-11T11:05:08.175Z","comments":true,"path":"2018/08/07/ai_behavior_tree_design_and_implementation_01/","link":"","permalink":"https://veinin.com/2018/08/07/ai_behavior_tree_design_and_implementation_01/","excerpt":"一个典型的 AI 系统通常包含：感知、导航和决策三个子系统。对于游戏来说，感知系统是可以“作弊”的，不需要NPC真的去“感知”世界，系统可以告诉NPC世界是怎么的。所以，对于导航系统，不再属于本文的讨论范畴。而决策系统才是让NPC看起来可以有自己的意图和信念的，所以本文讨论的是决策系统。 一个 AI 决策系统模型看起来是这样的： 最开始，游戏 AI 的决策系统往往会这样写： 1234567891011switch(自己) case '血量充足': 攻击(); break; case '快死了': 加血(); break; case ‘死了’: 游戏结束(); break;&#125;","text":"一个典型的 AI 系统通常包含：感知、导航和决策三个子系统。对于游戏来说，感知系统是可以“作弊”的，不需要NPC真的去“感知”世界，系统可以告诉NPC世界是怎么的。所以，对于导航系统，不再属于本文的讨论范畴。而决策系统才是让NPC看起来可以有自己的意图和信念的，所以本文讨论的是决策系统。 一个 AI 决策系统模型看起来是这样的： 最开始，游戏 AI 的决策系统往往会这样写： 1234567891011switch(自己) case '血量充足': 攻击(); break; case '快死了': 加血(); break; case ‘死了’: 游戏结束(); break;&#125; 随机计算机硬件的不断提升，可以分配给 AI 运算的 CPU 时间越来越长，我们对游戏 AI 的要求也自然提高了，比如我们可以相处这样的策略：有多个敌人时，使用群体技能；只有单个敌人时，使用强力的单体攻击；魔法低于50时，吃药补魔法；血量低于100时，吃个大的血瓶回血。 于是，AI 程序员在上面的需求到来的时候，不得不继续扩充上的 swtich 条件，然后在 case 里面增加自己的逻辑。可以想象，如果一个 Moba 类游戏中，一个地狱难度的电脑的 AI 需要根据场上的情况使用各种策略。当策划的需求越来越多，很快，一个带有上万行的代码函数就横空出世啦。如果这时候遇到了一个 Bug ，不要说修复，仅仅是阅读这个函数的代码都恐怕让人觉得畏惧了。 毫无疑问，当一个函数遇到大量的状态转换判断的时候，很容易让整个程序崩溃，不过经过后辈们前赴后继的努力，目前市面上关于游戏的 AI 有了更加精简的代码手段。比如常见 的 AI 模型：FSM（有限状态机）和 Behavior Tree（行为树）。 有限状态机（FMS）相对于 switch - case 来说， FSM 编程与人类的思维相似，更易于梳理，更加灵活。当每种状态封装后，就不在会有一个“中央”函数来控制所有的逻辑，每个状态只要管好自己的业务就行。这样，一个复杂的决策系统就被切割成了两子系统，不同的状态以及状态之间的转换。切割后的子系统与原有的系统被大大简化，从而使得代码变得可以维护。FSM 在相当多的游戏中已经被应用，甚至 Unreal Engine 的脚本语言是直接支持状态编程的。 当游戏中的NPC决策并不太复杂时候，FSM是非常有效的。比如 Half-Life 这款游戏，里面的AI被业界称赞了很久，而其中的AI就是通过FSM来实现的。 有限状态机举例我们接下来通过一个简单的例子来认识一下FSM。比如一个AI文字表述如下： 1.平时的状态是巡逻 如果遇到敌人之后打量一下敌人 如果敌人比自己弱小，那就打攻击 如果敌人比自己强大，那就跑逃跑 那么这个可以很自然的转换成 FSM，然后进行编程实现，我们可以看看整个 AI 流程图： 有限状态机缺点虽然FSM简洁，和人的直觉思维相近，但是FSM也是有缺点的： 由于我们所能做的仅是编辑从一状态到另一状态的转换，而无法做出更高层次的模式功能，所以会导致我们发现自己总是在构建相似的行为，这会花费我们大部分时间。 使用 FSM 实现目标导向的行为需要做很多工作。这是一个大问题，因为大部分有针对性的AI 需要处理长远目标。 FSM 难以并发。当并行运行多个状态机，要么死锁，要么我们通过手工编辑来确保它们在某个程度上能够兼容。 大规模支持较差，即使是分层的有限状态机，也难以大规模扩展。它们往往是在其中夹杂一大块逻辑代码，而非行为编辑模块化。 用 FSM 实现任何设计都需要做大量工作，需要花费设计师的大量时间(并非编程时间)，甚至最终这还会成行为中的 bugs 的来源。 行为树（Behavior Tree）行为树是在Next-Gen AI中提出的模型，虽说是Next-Gen AI，但距其原型提出已有约10年时间。其中Spore(孢子)，Crysis(孤岛危机)2，Red Dead Redemption(荒野大镖客：救赎)等就是用行为树作为它们的AI模型。而越来越多的引擎也都开始直接支持行为树，比如 Cry Engine, Havok等。 对于用行为树定模型构造的AI系统来说，每次执行AI时 ，系统都会从根节点遍历整个树，父节点执行子节点，子节点执行完后将结果返回父节点，然后父节点根据子节点的结果来决定接下来怎么做。 所谓树，那么其就存在很多节点，而对于行为树来说，它把基本节点类型分为两大类： 控制节点在行为树中我们所看到的所有父节点都被称为控制节点。控制节点是行为树的核心部分，它与具体的游戏是无关的，它只负责整个行为树的逻辑控制。其包含以下几种类型： 选择节点(Selector)：属于组合节点，顺序执行子节点，只要碰到一个子节点返回true，则停止继续执行，并返回true，否则返回false，类似于程序中的逻辑或。 顺序节点(Sequence)：属于组合节点，顺序执行子节点，只要碰到一个子节点返回false，则停止继续执行，并返回false，否则返回true，类似于程序中的逻辑与。 平行节点(Parallel)：提供了平行的概念，无论子节点返回值是什么都会遍历所有子节点。所以不需要像 Selector/Sequence 那样预判哪个 Child Node 应摆前，哪个应摆后。Parallel Node增加方便性的同时，也增加实现和维护复杂度。 组合节点(Coposite)：可以组合多个子节点。 装饰节点(Decoraor)：可以作为某种节点的一种额外的附加条件，如允许次数限制，时间限制，错误处理等。 循环节点(Loop)：循环执行相应的动作，并返回结果。 行为节点行为树的行为定义都在行为节点中，也就是我们说的叶子节点。行为节点是与我们的具体需求相关的，不同的需求定义会有不同的行为节点。 条件节点(Condition)：属于叶子节点，判断条件是否成立。 动作节点(Action)：属于叶子节点，执行动作，一般返回true。 当然，如果有更多需求，也可以自己继续拓展，通过控制与行为节点的组合，最终，会产生一颗行为树，它看起来会是这样的： 行为树举例我们可以来看一个行为树构造 AI 的例子，这个AI的逻辑文字表述为： 1.一个NPC在晚上需要执行守夜巡逻的任务。2.如果到了白天，那么NPC需要休息。3.如果天下雨的话，则需要打伞。4.如果天气变晴，处在打伞状态下的人需要把伞收起。 通过以上条件，我们可以转换成一颗行为树： 行为树优缺点行为树模型看似简单，但是以下几个优点让行为树目前变成了复杂AI的主流模型： 静态性。越复杂的功能越需要简单的基础，否则最后连自己都玩不过来。即使系统需要某些”动态”性，也应该尽量使用静态的行为树来表示。静态性直接带来的好处就是整棵树的规划无需再运行时动态调整，大大方便设计人员和编程人员，并且大大减少诡异的bug，同时这也为很多优化和预编辑都带来方便。 直观性。行为树可以方便地把复杂的AI知识条目组织得非常直观。默认的组合节点处理子节点的迭代方式就像是处理一个预设优先策略队列，也非常符合人类的正常思考模式：先最优再次优。此外，行为树编辑器对优秀的程序员来说也是唾手可得。 复用性。各种节点，包括叶子节点，可复用性都极高。 扩展性。可以容易地为项目量身定做新的组合节点或修饰节点。还可以积累一个项目相关的节点库，长远来说非常有价值。","categories":[{"name":"AI","slug":"AI","permalink":"https://veinin.com/categories/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://veinin.com/tags/AI/"},{"name":"行为树","slug":"行为树","permalink":"https://veinin.com/tags/行为树/"},{"name":"状态机","slug":"状态机","permalink":"https://veinin.com/tags/状态机/"}]},{"title":"开发笔记：游戏 UI 半自动化开发流程","slug":"dev_notes-game-UI-semi-automated-development","date":"2018-07-31T12:10:00.000Z","updated":"2018-08-01T14:39:59.893Z","comments":true,"path":"2018/07/31/dev_notes-game-UI-semi-automated-development/","link":"","permalink":"https://veinin.com/2018/07/31/dev_notes-game-UI-semi-automated-development/","excerpt":"最近着手试了下我们客户端 UI 开发，发现整个流程对于开发人员来说并不是很友好，我们游戏客户端代码基本使用 Lua 语言进行，引擎则采用 Unity。对于 UI 模块目前有一套基本的 MVC 模式的开发流程，但这个开发模式的边界并没有处理很好，导致开发过程中异常艰难。编写代码的人员有时也会很懵逼，因为实现的方式可以有多种多样。 在了解了整个旧有的开发流程后，我发现个问题，其中由UI编辑到代码编写，这个流程中，大部分过程都是重复行工作，而针对这一部分重复行工作通过一些小工具可以让UI开发流程实现半自动化。 所谓半自动化，无非就是，开发人员不需要编写基本的UI代码，基础UI代码可以自动生成，包括整个开发流程中使用的各个UI窗口的组件都可以自动生成代码。 另外，因为UI编写过程中进程资源修改、代码修改，我希望都可以在修改完后立刻可以看到效果，而不是重启游戏。 下面是我对于一个半自动化的UI开发流程整理笔记。","text":"最近着手试了下我们客户端 UI 开发，发现整个流程对于开发人员来说并不是很友好，我们游戏客户端代码基本使用 Lua 语言进行，引擎则采用 Unity。对于 UI 模块目前有一套基本的 MVC 模式的开发流程，但这个开发模式的边界并没有处理很好，导致开发过程中异常艰难。编写代码的人员有时也会很懵逼，因为实现的方式可以有多种多样。 在了解了整个旧有的开发流程后，我发现个问题，其中由UI编辑到代码编写，这个流程中，大部分过程都是重复行工作，而针对这一部分重复行工作通过一些小工具可以让UI开发流程实现半自动化。 所谓半自动化，无非就是，开发人员不需要编写基本的UI代码，基础UI代码可以自动生成，包括整个开发流程中使用的各个UI窗口的组件都可以自动生成代码。 另外，因为UI编写过程中进程资源修改、代码修改，我希望都可以在修改完后立刻可以看到效果，而不是重启游戏。 下面是我对于一个半自动化的UI开发流程整理笔记。 UI 编辑流程我们的 UI 编辑是一个独立的项目工程，通常一个功能的 UI 编辑会由策划完成一部分工作，程序人员拿过来，按需求再整理 UI 资源、编写代码即可。 编辑器项目结构 在UI编辑器中，其文件结构看起来是这样的： 1234567891011121314151617181920UIProject -&gt; Assert -&gt; PublicPrefabs - 公共UI -&gt; PulibcResources - 公共资源 -&gt; Texture - 纹理 -&gt; UI -&gt; LoginWindow - 登陆窗口UI -&gt; Prefabs -&gt; EquipWinodw - 装备窗口UI -&gt; Prefabs -&gt; TeamWindow - 组队窗口UI -&gt; Prefabs -&gt; TeamCreateView - 队伍创建窗口 -&gt; TeamMemberView - 队员窗口 -&gt; TeamMemberItem - 队员窗口队伍信息 -&gt; ... -&gt; UI资源1.png -&gt; UI资源2.png -&gt; ... -&gt; ... 比如在一个组队功能UI里面，其他包含一个文件夹（TeamWindow），该文件夹下包含了多个UI用到的私有美术资源图片、纹理等。Window 文件夹下，有一个 Prefabs 文件夹，用来保存该功能所用到的所有子UI。 比如上面队伍窗口（TeamWindow）在UI设计中看起来是这样的： 其包含3个View文件，两个主要窗口，CreateView用来创建队伍窗口，MemberView用来显示队伍成员窗口，而MemberItem用来显示队伍成员窗口下的队员详细。 2.UI文件打包 编辑好的UI会统一打包成一个文件，方便使用代码做资源一次性加载。比如上面TeamWindow，打包后一个统一的资源包文件，包含了上面所示的队伍UI下面的所有子窗口。 MVC 设计模式原有的UI开发流程是使用 MVC 设计模式的，采用这个模式，如果能处理好，开发起来也是会很顺畅的。 对于 MVC，我们先用一张图来展示： 在 Unity UI 开发中引入 MVC 设计模式，它看起来是这样的： Model 其只是用来保存数据用的，其不能访问 View 或 Controller。 它可以被 Controller 和 View 直接访问。 View 其只是游戏中能用户看到的 UI 布局。 View 可以处理 UI 点击逻辑、处理外面传进来的数据，可以访问和修改 Model。 在 Unity 中，每个 UI 资源的 Prefab 文件都会生成一个与之对应的 View 源代码文件。 Conroller 负责控制单个模块内所有 View 资源的加载、显示、关闭、数据更新、分组、层级控制等。 其持有所有 View 和 Model 对象。 其销毁后，所有View 和 Model 都会自动销毁。 MVC 实现对于上面所示的MVC模式，我们结合相关MVC特性，用实际代码来展示，下面实例统一采用 Lua 语言，并使用面向对象概念来设计。 实现一个 Controller 接口Controller 是一个UI功能的控制中心，其控制当前Window下的所有UI的加载、显示、隐藏，以及数据保存、清理、传递工作。默认情况下所有子UI（UIView子类）都是会自动被其销毁的，其资源、数据都会在最后一个窗口关闭后自动清理掉。 Controller 接口完整生命周期示例图如下： 实现的 Controller 接口代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143local UIController = Class('UIController')function UIController:Ctor(opts) self.isInit = false self.isPersistent = opts.isPersistent -- 是否持久化 model 数据，如果为 true，不会销毁 model 数据 self.prefabsName = opts.prefabsName -- UI 打包后的资源名称 self.assets = &#123;&#125; -- 已经加载的资源 self.model = &#123;&#125; -- model 数据 self.viewClasses = &#123;&#125; -- view 资源对应的子类，未实例化 self.openViews = &#123;&#125; -- 已经打开的 view self.openViewCount = &#123;&#125; -- 已经打开的 view 数量 self.lastOpenData = nil -- 上次打开 view 时的数据（未初始化时需要先保存打开时数据，初始化完成后再打开）endfunction UIController:IsInit() return self.isInitendlocal function OnLoad(self, assets) for _, asset in ipairs(assets) do self.assets[asset.name] = asset end self.isInit = true if not next(self.viewClasses) then self:OnInitView() end if self.lastOpenData then self.Open(unpack(self.lastOpenData)) self.lastOpenData = nil else self:OnDefaultOpen() endendfunction UIController:Init() if self:IsInit() then return end LoadManager:LoadPrefab(self.prefabsName, function(assets) OnLoad(self, assets) end)endfunction UIController:OnInitView()endfunction UIController:RegisterView(class) assert(self.viewClasses[class.name] == nil) self.viewClasses[class.name] = classendlocal function CreateView(self, name) local class = self.viewClasses[name] if not class then return end local view = class.New() view.controller = self view.model = self.model self.openViews[name] = view self.openViewCount = self.openViewCount + 1 return viewendlocal function GetView(self, name) local view = self.openViews[name] if not view then view = CreateView(self, name) end if not view then return end if view:IsState(UIConst.LIFESTATE.NONE) then UIHelper.InitView(self, view) end return viewendfunction UIController:Open(name, ...) if not self:IsInit() then self.lastOpenData = &#123;name, ...&#125; self:Init() return end local view = GetView(self, name) if not view then return end if view:IsState(UIConst.LIFESTATE.SHOW) then view:Update(...) else view:Open(...) endendfunction UIController:Close(view) if not view then return end GameObject.Destroy(view.gameObject) self.openViews[name] = nil self.openViewCount = self.openViewCount - 1 if self.openViewCount == 0 then self:Dispose() endendfunction UIController:Dispose() self.isInit = false self.assets = &#123;&#125; LoadManager:RemovePrefab(self.prefabsName) if not self.isPersistent then self.model = &#123;&#125; end self:OnDispose()endfunction UIController:OnDispose()endreturn UIController 根据上面生命周期实例图和代码实现，我们可以看到 Contoller 入口有两个，一个是外部打开指定 View，一个是外部关闭指定 View。 当外部需要打开指定 View 时，我们先检查当前 Controller 是否初始化完成，如果未初始化，则先临时保存打开时的数据，然后再走初始化 Controller 逻辑，加载 UI 资源。 当加载 UI 资源完成后，我们通过 View 的名称，调用 GetView() 函数获取一个 View 对象，如果 View 对象未创建，则走创建对象逻辑 CreateView()，并调用 View 初始化逻辑（下一节详解）。 获取到 View 对象后，如果 View 是打开状态则调用 UIView.Update(...) 函数更新，关闭状态则调用 UIView:Open(...) 函数打开。 UIController 对外暴露一个公共接口： UIController.Open(name, ...)，用于外部打开指定 View 。 UIController.RegisterView(class)，用于注册一个 View 子类，通过其来实例化相应的 UI 窗口。 UIController.Close(view)，用于关闭一个 View，这个接口用于 View 为了关闭自己而调用。 UIController 作为一个父类，需要子类重写以下接口： UIController.OnInitView()，初始化所有View，调用 RegisterView 注册指定 View。 UIController.OnDispose()，销毁整个 Controller 的后续处理。 实现一个 View 接口View 接口是所有UI资源窗口的父类，子类通过继承方式实现一个UI子窗口显示。View 子类可以直接访问和修改 model 数据，另外，我希望在 View 中能间接调用 Controller 打开其他窗口。 View 接口完整生命周期示例图如下： 根据上面生命周期实例图，我们可以看出整个 View 对象从初始化到关闭的完整生命周期流程。我们把 View 生命周期状态分为3部分： NONE，未初始化状态 HIDE，隐藏状态 SHOW，打开状态 根据上面的状态图，我们先实现 View 接口代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576local UIView = Class('UIView')function UIView:Ctor() self.controller = nil -- 持有 View 的 UIController 对象 self.model = nil -- View 持有的 Model 数据，与 UIController 共享 self.gameObject = nil -- 引擎对象，该对象保存着UI资源 self.isAutoDestroy = false -- 是否自动销毁，默认关闭时直接销毁对象，如果不自动销毁，关闭动作时隐藏 self.layer = UIConst.LAYER.MIDDLE -- UI 层级（高、中、低） self.lifeState = UIConst.LIFESTATE.NONE -- UI 生命周期状态endfunction UIView:IsState(state) return self.lifeState == stateendfunction UIView:Init() self.gameObject:SetActive(false) self.lifeState = UIConst.LIFESTATE.HIDE self:OnInit()endfunction UIView:OpenView(name, ...) self.controller:Open(name, ...)endfunction UIView:Open(...) if not self:IsState(UIConst.LIFESTATE.HIDE) then return end self.lifeState = UIConst.LIFESTATE.SHOW self.gameObject:SetActive(true) self:OnShow(...)endfunction UIView:Update(...) if not self:IsState(UIConst.LIFESTATE.SHOW) then return end self:OnUpdate(...)endfunction UIView:Close() if not self:IsState(UIConst.LIFESTATE.SHOW) then return end self:OnHide() if self.isAutoDestroy then self.controller:Close(self) else self.gameObject:SetActive(false) self.lifeState = UIConst.LIFE_STATE.HIDE endendfunction UIView:OnInit()endfunction UIView:OnShow(...)endfunction UIView:OnUpdate(...)endfunction UIView:OnHide()endreturn UIView View 初始化时，会从引擎底层加载 UI 编辑器指定的 UI 组件到 View 对象，这一步是 Contoller 在创建 View 时执行的，我们可以看到 UIContoller.GetView() 函数调用时，判断当前 View 对象如果是未初始化状态则调用帮助函数 UIHelper.InitView() 加载所有 UI 组件对象，其加载代码看起来时这样的： 12345678910111213141516171819202122232425262728293031323334353637local UIHelper = &#123;&#125;-- Lua 封装的 UI 组件对象local UI_TYPES = &#123; ['UIButton'] = require(\"game.ui.component.UIButton\"), ['UILabel'] = require(\"game.ui.component.UILabel\"), ['UIInputField'] = require(\"game.ui.component.UIInputField\"), -- 其他 UI 组件...&#125;-- 创建引擎 UI 对象local function CreateCSObject() -- TODO 创建引擎UI对象，设置其层级关系end-- 初始化所以 UI 组件Lua对象local function InitComponents(view) local components = view.gameObject.components for _, component in ipairs(components) do local uiLuaClass = UI_TYPES[component.typeName] if uiLuaClass then view[component.key] = uiLuaClass.New(component.value) end endend-- 初始化 UIView 对象function UIHelper.InitView(view) view.gameObject = CreateCSObject(view) InitComponents(view) view:Init()endreturn UIHelper 在我们可以看到所有 UI 组件都在 Lua 层有一个简单的封装对象，我们在 UI 编辑器指定 UI 组件名称和类型后，在加载完 View 对象后，其 UI 组件就被赋予给了 View 对象。下面给出了一个按钮组件的简单封装实例： 1234567891011121314151617local UIButton = Class('UIButton', UIBehaviour)function UIButton:SetText(name) self.core.text = nameendfunction UIButton:SetEnable(isEnable) self.core:SetEnable(isEnable)endfunction UIButton:AddListener(callback, delayTime) delayTime = delayTime or 0.3 self.event.onClickLua = callback self.event.clickDelayTime = delayTimeendreturn UIButton View 初始化完成后，每次打开时，都会传入打开时需要的数据，我们根据状态，把数据传给不同的处理函数。当前 UI 处于打开状态时调用 UIView.Open()；处于显示状态，则调用 UIView.Update()。最后可以使用 UIView.Close() 关闭 View。 UIView 对外暴露一个公共接口： UIView.Init()，初始化 View，初始化完成后调用一次 UIView.OnInit()。 UIView.Open(...)，当 View 处于隐藏状态时，打开 View，最终会调用 UIView.OnShow() 处理。 UIView.Update(...)，当 View 处于打开状态时，更新 View 数据，最终会调用 UIView.OnUpdate() 处理。 UIView.Close(...)，用于关闭当前 UI，并调用 UIView.OnHide() 处理 View 隐藏后逻辑，其资源清理逻辑最终会交给 Controller 执行。 UIView.OpenView(name)，用于打开其他 View，其打开逻辑会交给 Controller 执行。 UIView 作为一个父类，需要子类重写以下接口： UIView.OnInit()，初始化View，我们需要做一些 UI 组件事件注册逻辑处理，如果某个按钮点击后的逻辑，因为这些逻辑固定不变的，整个 View 生命周期只会调用过一次。 UIView.OnShow()，如果 View 隐藏状态，在打开 View 时，会调用此函数，并传入打开 UI 时需要处理的数据。 UIView.OnUpdate()，如果 View 打开状态，在打开 View 时，会调用此函数，并传入打开 UI 时需要处理的数据。 UIView.OnHide()，当 View 被调用 UIView.Close(…) 时，在销毁前，会被调用，需要在此函数内处理关闭 View 时的逻辑。 View 分组在复杂的游戏 UI 功能开发时，常常遇到这些的问题： 同一个 UI 窗口内，我们希望某一组 UI 是互斥的，即同一时间内，Controller 只能打开该组内的某一个 View，如果同组有其他 View 打开则先关闭一打开的 View。 有一些 UI 分组，在某个指定 UI 关闭后，其分组内的任何 UI 只要打开都会自动关闭。 看到这些需求后，我们很快想到使用一颗树来管理这些 UI View 分组。其分组示例图如下： 从图中我们可以看到，这是一个树形结构的 UI 分组，有一个根节点，子节点之间是分层的，每一层节点之间可以设置未互斥状态，即同一时间内，只能被打开一个。有了这个树形结构，当某个节点被关闭后，我们可以很快获取到这个节点的所有子节点，并关闭它们。 于是可以设计一个 UI 分组代码： 123456789101112131415161718192021local Tree = require \"game.foundation.Tree\"local UIGroupTree = Class('UIGroupTree', Tree)function UIGroupTree:Ctor() self.isExclusion = true -- 子节点是否互斥，默认未互斥endfunction UIGroupTree:SetExclusion(isExclusion) self.isExclusion = isExclusionendfunction UIGroupTree:IsExclusion() return self.isExclusionendfunction UIGroupTree:AddChildUI(view) return self.NewChild(view.name)endreturn UIGroupTree 代码中树形结构 Tree 实现请参考外部 链接。 然后我们拓展 Contoller 接口实现： 加入新的成员变量 group (UIGroupTree类型) 加入创建 UI 分组对象函数，UIController.NewGroup(view)，用于创建一个分组。 加入新的抽象函数 UIController.OnInitGroup()，子类如需要UI分组，则重写该函数，该函数在 Controller 初始化时被调用。 打开某个 UI 时检查 View 对象是否分组、分组是否互斥、是否有互斥 View 已打开，如果打开则关闭互斥 View。 关闭某个 UI 时检查 View 对象是否分组，当前节点是否存在子节点，子节点是否有打开情况，如果打开则关闭 View。 扩展 Controller 的代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102local UIGroupTree = require \"game.ui.group.UIGroupTree\"local UIController:Ctor() -- 上面已实现代码省略...endlocal function OnLoad(self, assets) -- 上面已实现代码省略... if not next(self.viewClasses) then -- ... self:OnInitGroup() end -- ...endfunction UIController:OnInitGroup() -- 子类实现end-- 创建一个UI分组function UIController:NewGroup(view) assert(self.group == nil, \"不允许创建多个分组\") self.group = UIGroupTree.New(view.name) return self.groupend-- 检查互斥local function CheckExclusion(self, view) if not self.group or self.openViewCount == 1 then return end local name = view.name local node = self.group:FindChild(name) if not node then return end local parent = node:GetParent() if #parent == 0 or not parent:IsExclusion() then return end local childName local childView for _, child in ipairs(parent) do childName = child.name childView = self.openViews[childName] if childName ~= name and childView then -- 如果打开则关闭 self:Close(childView) end endendfunction UIController:Open(name, ...) -- ... -- 打开前检查分组互斥 CheckExclusion(self, view) if view:IsState(UIConst.LIFESTATE.SHOW) then view:Update(...) else view:Open(...) endend-- 检查子节点关闭local function CheckCloseChild(self, view) if not self.group then return end local name = view.name local node = self.group:FindChild(name) if not node then return end local childView node:IterativeChildren(function(child) childView = self.openViews[child.value] if childView then -- 如果子节点打开则关闭 self:Close(childView) end end)endfunction UIController:Close(view) -- ... if self.openViewCount == 0 then self:Dispose() else -- 还有打开的 View，检查是否其子节点，并关闭 CheckCloseChild(self, view) endendreturn UIController 有了上面扩展实现的代码，我们就实现分组示例图中展示的分组结构： 123456789function MyTestController:OnInitGroup() local root = self:NewGroup(UIView1) root:AddChild(UIView2) root:AddChild(UIView3) local child = root:AddChild(UIView4) child:AddChild(UIView5) child:AddChild(UIView6)end UI 开发半自动化我们知道，游戏 UI 开发，很多固定的流程其实是可以省略的： UI 编辑完成后，开始写业务代码时，可以将所有基础代码全部生成，比如上面的 Controller 子类和每个窗口的 View 子类。 每个 View 类型，我们设计时其会对应 UI 编辑器的一个界面，且 UI 编辑器里面的所有组件，都是可以读取到的，在 Unity 中，我们保存为 Prefab 文件，而这个文件可以帮助我们设计一个自动生成代码的工具。 每次修改 UI 增加了新的组件后，我们希望原有的已经编辑的代码可以保留，在编辑器中刷新一下代码，能将新增加的控件基础代码直接加入到相应的代码文件里面。 每次修改完 UI 资源后，然后对应改完代码后，不希望在游戏中重启客户端才能看到效果，所以，我们加入了热更机制，任何代码都是可以热更新的，那么 UI 开发人员编码阶段将会非常方便。 综上考虑，因为我们项目很多人使用 IntelliJ IDEA 配合一个不错的 Lua 插件 EmmyLua， 相对来说使用 Lua 开发还是比较顺畅的。所以决定在 IntelliJ IDEA 平台上开发一个为项目定制的 UI 开发插件（当然现在一些主流的代码编辑器都支持插件编写，你可以很容易在其他编辑器中实现这些内容）。 在UI编辑完成后，开发人员，建立 UI 功能开发文件夹后，右键菜单点击生成代码，插件自动生成 UIController 和 UIView 对应子类。 比如一个组队功能包含以下 UI 文件: 12345-&gt; TeamWindow -&gt; Prefabs -&gt; CreateView.prefab -&gt; MemberView.prefab -&gt; MemberItem.prefab 生成的代码文件夹： 12345678-&gt; team -&gt; contoller -&gt; TeamController.lua -&gt; views -&gt; CreateView.lua -&gt; MemberView.lua -&gt; protocol -&gt; TeamProtocol.lua -- 协议文件，项目定制 下面是 Contoller 实例 TeamController.lua 文件内容，该文件自动生成了很多基础的代码，需要填写的地方只剩下分组（如需要）： 12345678910111213141516local UIController = require \"game.ui.core.UIController\"local CreateView = require \"game.ui.team.views.CreateView\"local MemberView = require \"game.ui.team.views.MemberView\"local TeamController = Class('TeamController', UIController)function TeamController:OnInitView() self:RegisterView(CreateView) self:RegisterView(MemberView)endfunciton TeamController:OnInitGroup()endreturn TeamController 下面是一个 View 实例 CreateView.lua 文件内容，其基本的组件代码全部通过编辑器UI文件自动生成，开发人员只需要在对应的 UI 组件填入相对于的业务逻辑即可： 123456789101112131415161718192021222324252627282930313233local UIView = require \"game.ui.core.UIView\"local CreateView = Class('CreateView', UIView)function CreateView:Ctor()endfunction CreateView:OnInit() self.closeButton:AddListener(function() self:Close() end) self.cofirmButton:AddListener(function() -- 开发人员实现创建队伍逻辑 end)endfunction CreateView:OnShow(...) self.nameInputField:SetText() self.fightINputField:SetText() self.levelInputField:SetText()endfunction CreateView:OnUpdate(...)endfunction CreateView:OnHide()endreturn CreateView 为了对比，下面展示以下 CreateView.lua 对应 CreateView.prefab 文件结构： 可以看出这个 UI 有5个需要处理的组件，两个按钮（关闭、确定），3个输入文本框（队伍名称、队伍战力、最低等级）。我们可以很容易从编辑的 prefab 文件中提取到里面的 UI 组件，然后通过插件直接生成代码文件。 有了上面的这些自动生成的代码，剩下的工作，其实就是填写一些基础的业务逻辑，那些重复性的工作工具已经可以帮你很好的完成了。 总结本文阐述了一个半自动化工作的游戏 UI 编写流程，并给出了实现步骤。游戏 UI 开发流程存在大部分重复工作，我们稍微花点时间，其实是可以把这些重复工作自动化的，剩下的工作，无非就是填写下业务逻辑代码。可以预见的是，开发这么一套半自动化的工具其实不到一周时间，其实是可以很容易搞定的，并且后续的 UI 开发效率其实是提升了一个档次。","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://veinin.com/categories/开发笔记/"}],"tags":[{"name":"半自动化，游戏UI开发，Unity","slug":"半自动化，游戏UI开发，Unity","permalink":"https://veinin.com/tags/半自动化，游戏UI开发，Unity/"},{"name":"MVC","slug":"MVC","permalink":"https://veinin.com/tags/MVC/"}]},{"title":"POSIX 多线程程序设计-线程同步精要","slug":"programming_with_posix_pthreads_08","date":"2018-06-25T06:11:13.000Z","updated":"2018-07-12T14:44:50.554Z","comments":true,"path":"2018/06/25/programming_with_posix_pthreads_08/","link":"","permalink":"https://veinin.com/2018/06/25/programming_with_posix_pthreads_08/","excerpt":"本章节摘录自陈硕 《Linux多线程服务端编程:使用muduoC++网络库》 第二章关于线程同步笔记。 线程同步四项原则线程同步的四项原则，按重要性排列： 首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑 immutable 对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。 其次是使用高级的并发编程构件，如 TaskQueue、Producer-ConsumerQueue、CountDownLatch 等等。 最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。 除了使用 atomic 整数之外，不自己编写 lock-free 代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如spin lock vs mutex。","text":"本章节摘录自陈硕 《Linux多线程服务端编程:使用muduoC++网络库》 第二章关于线程同步笔记。 线程同步四项原则线程同步的四项原则，按重要性排列： 首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑 immutable 对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。 其次是使用高级的并发编程构件，如 TaskQueue、Producer-ConsumerQueue、CountDownLatch 等等。 最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。 除了使用 atomic 整数之外，不自己编写 lock-free 代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如spin lock vs mutex。 互斥器（mutex）互斥器（mutex）是使用得最多的同步原语，粗略地说，它保护了临界区，任何一个时刻最多只能有一个线程在此 mutex 划出的临界区内活动。单独使用 mutex 时，我们主要为了保护共享数据。 主要原则： 在C++中，应该使用用RAII手法封装mutex的创建、销毁、加锁、解锁这四个操作。Java里的 synchronized 语句和C#的 using 语句也有类似的效果，即保证锁的生效期间等于一个作用域（scope），不会因异常而忘记解锁。 只用非递归的 mutex（即不可重入的mutex）。 不手工调用 lock() 和 unlock() 函数， 在每次构造 Guard 对象的时候，思考一路上（调用栈上）已经持有的锁，防止因加锁顺序不同而导致死锁（deadlock）。 次要原则： 不使用跨进程的 mutex，进程间通信只用 TCPsockets。 加锁、解锁在同一个线程，线程a不能去 unlock 线程b已经锁住的 mutex（RAII自动保证）。 别忘了解锁（RAII自动保证）。 不重复解锁（RAII自动保证）。 必要的时候可以考虑用 PTHREAD_MUTEX_ERRORCHECK 来排错。 条件变量互斥器（mutex）是加锁原语，用来排他性地访问共享数据，它不是等待原语。在使用 mutex 的时候，我们一般都会期望加锁不要阻塞，总是能立刻拿到锁。然后尽快访问数据，用完之后尽快解锁，这样才能不影响并发性和性能。 如果需要等待某个条件成立，我们应该使用条件变量（conditionvariable）。条件变量顾名思义是一个或多个线程等待某个布尔表达式为真，即等待别的线程“唤醒”它。条件变量只有一种正确使用的方式，几乎不可能用错。 对于wait端： 必须与 mutex 一起使用，该布尔表达式的读写需受此mutex保护。 在 mutex 已上锁的时候才能调用 wait()。 把判断布尔条件和 wait() 放到 while 循环中。 对于 signal/broadcast 端： 不一定要在 mutex 已上锁的情况下调用 signal（理论上）。 在 signal 之前一般要修改布尔表达式。 修改布尔表达式通常要用 mutex 保护（至少用作fullmemorybarrier）。 注意区分 signal 与 broadcast： broadcast 通常用于表明状态变化，signal 通常用于表示资源。 条件变量是非常底层的同步原语，很少直接使用，一般都是用它来实现高层的同步措施，如 BlockingQueue&lt;T&gt; 或 CountDownLatch。 倒计时（CountDownLatch）是一种常用且易用的同步手段。它主要有两种用途： 主线程发起多个子线程，等这些子线程各自都完成一定的任务之后，主线程才继续执行。通常用于主线程等待多个子线程完成初始化。 主线程发起多个子线程，子线程都等待主线程，主线程完成其他一些任务之后通知所有子线程开始执行。通常用于多个子线程等待主线程发出“起跑”命令。 不要使用读写锁和信号量读写锁（Readers-Writerlock，简写为rwlock）是个看上去很美的抽象，它明确区分了 read 和 write 两种行为。 初学者常干的一件事情是，一见到某个共享数据结构频繁读而很少写，就把 mutex 替换为 rwlock。甚至首选 rwlock 来保护共享状态，这不见得是正确的。 从正确性方面来说，一种典型的易犯错误是在持有 readlock 的时候修改了共享数据。这通常发生在程序的维护阶段，为了新增功能，程序员不小心在原来 readlock 保护的函数中调用了会修改状态的函数。这种错误的后果跟无保护并发读写共享数据是一样的。 从性能方面来说，读写锁不见得比普通 mutex 更高效。无论如何 readerlock 加锁的开销不会比 mutexlock 小，因为它要更新当前 reader 的数目。如果临界区很小，锁竞争不激烈，那么 mutex 往往会更快。 readerlock 可能允许提升为 writerlock，也可能不允许提升。如果处理不好容易导致程序崩溃和死锁。 通常 readerlock 是可重入的，writerlock 是不可重入的。但是为了防止 writer 饥饿，writerlock通常会阻塞后来的readerlock，因此 readerlock 在重入的时候可能死锁。另外，在追求低延迟读取的场合也不适用读写锁。 对于信号量（Semaphore），陈硕认为信号量不是必备的同步原语，因为条件变量配合互斥器可以完全替代其功能，而且更不易用错。信号量的另一个问题在于它有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能。 归纳与总结作者认为，应该先把程序写正确（并尽量保持清晰和简单），然后再考虑性能优化，如果确实还有必要优化的话。这在多线程下仍然成立。让一个正确的程序变快，远比“让一个快的程序变正确”容易得多。 “效率”并不是我的主要考虑点，我提倡正确加锁而不是自己编写 lock-free算法（使用原子整数除外），更不要想当然地自己发明同步设施。在没有实测数据支持的情况下，妄谈哪种做法效率更高是靠不住的，不能听信传言或凭感觉“优化”。很多人误认为用锁会让程序变慢，其实真正影响性能的不是锁，而是锁争用（lockcontention）。 系列文章目录： 概述 线程 同步 使用线程方式 线程高级编程 POSIX 针对线程的调整 线程扩展 线程同步精要 Github 示例源码","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://veinin.com/categories/并发编程/"}],"tags":[{"name":"Phtreads","slug":"Phtreads","permalink":"https://veinin.com/tags/Phtreads/"},{"name":"POSIX Pthreads","slug":"POSIX-Pthreads","permalink":"https://veinin.com/tags/POSIX-Pthreads/"}]},{"title":"POSIX 多线程程序设计-线程扩展","slug":"programming_with_posix_pthreads_07","date":"2018-06-20T14:12:24.000Z","updated":"2018-07-12T14:44:39.879Z","comments":true,"path":"2018/06/20/programming_with_posix_pthreads_07/","link":"","permalink":"https://veinin.com/2018/06/20/programming_with_posix_pthreads_07/","excerpt":"栅栏（Barriers）barrier 字面意思时栅栏，barrier 是将一组成员保持在一起的一种方式，它可以实现让一组线程等待至某个状之后再全部同时执行。一个 barrier 通常被用来确保某些井行算法中的所有合作线程在任何线程可以继续运行之前到达算法中的一个特定点。 barrier 的核心是一个计数器，我们可以称之为“阈值”，即在一个 barrier 上必须等待的线程数。计时器计算着当前线程的返回数量，如果数量未达到指定点，那么之前返回的线程都必须继续等待，直到最后一个线程返回，才能开始下一步。","text":"栅栏（Barriers）barrier 字面意思时栅栏，barrier 是将一组成员保持在一起的一种方式，它可以实现让一组线程等待至某个状之后再全部同时执行。一个 barrier 通常被用来确保某些井行算法中的所有合作线程在任何线程可以继续运行之前到达算法中的一个特定点。 barrier 的核心是一个计数器，我们可以称之为“阈值”，即在一个 barrier 上必须等待的线程数。计时器计算着当前线程的返回数量，如果数量未达到指定点，那么之前返回的线程都必须继续等待，直到最后一个线程返回，才能开始下一步。 你可以查看源文件 barrier.h 、barrier.c、barrier_main.c，这是一个比较容易理解的实现。 另外 Pthreads 在 POSIX.14 草案标准（一个 “POSIX 标准子集”）中新增加了 Barriers 变量，其 API 如下： 12345678#include &lt;pthread.h&gt;int pthread_barrier_init(pthread_barrier_t * restrict barrier, const pthread_barrierattr_t * restrict attr, unsigned int count);int pthread_barrier_destroy(pthread_barrier_t *barrier);int pthread_barrier_wait(pthread_barrier_t *barrier); 源文件 pthread_barrier.c 是一个 Pthreads barrier 的简单实例。 读/写锁（Read-Write Lock）读/写锁很像一个互斥量，它是阻止多个线程同时修改共享数据的另外一种方。但是不同于互斥量的是它区分读数据和写数据。一个互斥量排除所有的其他线程，而一个读/写锁如果线程不需要改变数据，则允许多个线程同时读数据。当一个线程需要更新缓存数据是，则必须以独占的方式进行，其他只读线程都不能继续占有锁。 读/写锁被用来保护经常需要读但是通常不需要修改的信息（读多写少）。当写锁被释放时，如果读数据者和写数据者同时正在等待存取，则读数据者被优先给予访问权。因为潜在地允许许多线程同时完成工作，读访问优先有利于并发。 文件 rwlock.h 、rwlock.c、rwlock_main.c 演示了如何使用标准的 Pthreads 互斥量和状况变量实现读写锁， 这是相对容易理解的可移植的实现。 另外，在最新版本的 X/Open XSH5 [UNIX98] 标准中，Pthreads 增加了读写锁的支持，读写锁的数据类型为 pthread_rwlock_t，如果需要静态分配该类型数据，那么可通过PTHREAD_RWLOCK_INITIALIZER 宏来初始化它。Pthreads 读写锁 API 如下： 12345678910111213141516#include &lt;pthread.h&gt;pthread_rwlock_t lock = PTHREAD_RWLOCK_INITIALIZER;int pthread_rwlock_init(pthread_rwlock_t * restrict lock, const pthread_rwlockattr_t * restrict attr);int pthread_rwlock_destroy(pthread_rwlock_t *lock);int pthread_rwlock_rdlock(pthread_rwlock_t *lock);int pthread_rwlock_timedrdlock(pthread_rwlock_t * restrict lock, const struct timespec * restrict abstime);int pthread_rwlock_tryrdlock(pthread_rwlock_t *lock);int pthread_rwlock_wrlock(pthread_rwlock_t *lock);int pthread_rwlock_timedwrlock(pthread_rwlock_t * restrict lock, const struct timespec * restrict abstime);int pthread_rwlock_trywrlock(pthread_rwlock_t *lock);int pthread_rwlock_unlock(pthread_rwlock_t *lock); 你可以查看源文件 pthread_rwlock.c，这是简单的 Pthread 读写锁的使用实例。 自旋锁（Spin Locks）自旋锁（Spinlock）也是一种锁，自旋锁在线程尝试获取它时，会在一个循环中不停等待（旋转），同时反复检查锁是否可用。由于线程始终保持活动状态且并没有执行有用的任务，因此使用这种锁时将产生一种忙碌的等待情况。 因为在一些多线程场景中我们需要避免操作系统进程的重新调度或者上下文的切换开销，所以如果线程仅仅只是短时间内被阻塞，那么使用自旋锁将是一种非常有效的方式。但是，如果你的程序需要比较长的时间保持锁的使用，那么自旋锁将会变的浪费，因为它会阻止其他线程运行。线程持有锁的时间越长，操作系统调度程序在保持锁定时中断线程的风险就越大。在这种情况下，其他线程将会不停“旋转”（反复尝试获取锁定），而持有锁的线程没有进行释放。结果将是无限期推迟，直到持有锁的线程完成并释放它。 下面是一个自旋锁的实现方式，该实现中使用了 GCC 提供的原子操作的相关函数： 12345678910111213141516171819202122232425262728typedef struct spinlock_type &#123; int lock;&#125; spinlock_t;static inline void spinlock_init(spinlock_t *sl)&#123; sl-&gt;lock = 0;&#125;static inline void spinlock_lock(spinlock_t *sl)&#123; while(__sync_lock_test_and_set(&amp;sl-&gt;lock, 1)) &#123;&#125;&#125;static inline int spinlock_trylock(spinlock_t *sl)&#123; return __sync_lock_test_and_set(&amp;sl-&gt;lock, 1) == 0;&#125;static inline void spinlock_unlock(spinlock_t *sl)&#123; __sync_lock_release(&amp;sl-&gt;lock);&#125;static inline void spinlock_destroy(spinlock_t *sl)&#123; (void) sl;&#125; 你可以查看源文件 spinlock.h 和 spinlock_main.c，这是一个自旋锁的简单使用实例，演示了10个线程并发使用自旋锁修改单一数据流程。 另外，Pthreads 也提供了自旋锁的实现，其 API 定义如下： 1234567#include &lt;pthread.h&gt;int pthread_spin_init(pthread_spinlock_t *lock, int pshared);int pthread_spin_lock(pthread_spinlock_t *lock);int pthread_spin_trylock(pthread_spinlock_t *lock);int pthread_spin_unlock(pthread_spinlock_t *lock);int pthread_spin_destroy(pthread_spinlock_t *lock); 你可以在源文件 pthread_spinlock.c 中查看对自旋锁的使用实例。 信号量（Semaphore）信号量是由 EW Dijkstra 在20世纪60年代后期设计的编程结构。Dijkstra 的模型是铁路运营。考虑一段铁路，其中存在单个轨道，在该轨道上一次只允许一列火车。 信号量同步此轨道上的行程。火车必须在进入单轨之前等待，直到信号量处于允许旅行的状态。当火车进入轨道时，信号量改变状态以防止其他列车进入轨道。离开这段赛道的火车必须再次改变信号量的状态，以允许另一列火车进入。 在计算机版本中，信号量似乎是一个简单的整数。线程等待许可继续，然后通过对信号量执行P操作来发出线程已经继续的信号。 线程必须等到信号量的值为正，然后通过从值中减去1来更改信号量的值。完成此操作后，线程执行V操作，通过向该值加1来更改信号量的值。这些操作必须以原子方式进行。在P操作中，信号量的值必须在值递减之前为正，从而产生一个值，该值保证为非负值，并且比递减之前的值小1。 信号量 API1234567#include &lt;semaphore.h&gt;int sem_init(sem_t *sem, int pshared, unsigned int value);int sem_post(sem_t *sem);int sem_wait(sem_t *sem);int sem_trywait(sem_t *sem);int sem_destroy(sem_t *sem); 信号量初始化函数中，pshared的值为零，则不能在进程之间共享信号量。如果pshared的值非零，则可以在进程之间共享信号量。值 value 之名，其中，sem_post 以原子方式递增sem指向的信号量。调用后，当信号量上的任何线程被阻塞时，其中一个线程被解除阻塞。使用 sem_wait 来阻塞调用线程，直到sem指向的信号量计数变为大于零，然后原子地减少计数。 信号量解决生产者与消费者问题生产者和消费者问题是并发编程中标准的，众所周知的一个小问题。在一个缓冲区中，分为将项目放入缓冲区生产者，从缓冲区中取出项目的消费者。 在缓冲区有可用空间之前，生产者不能在缓冲区中放置东西。在生产者写入缓冲区之前，消费者不能从缓冲区中取出东西。 你可以查看源文件 pthread-semaphore.c，这是一个使用信号量解决生产者、消费者问题的实例。 工作队列工作队列是一组线程间分派工作的方法，创建工作队列时，可以指定需要的最大并发级别（最大线程数量）。 依据工作量的要求，线程将被开始或停止。没有发现任何请求的一个线程将等待一段时间后终止。最优的时间段取决于在你的系统上创建一个新线程的开销、维护一个不做任何工作的线程的系统资源的开销，以及你将再次需要线程的可能性。 源文件 workq.h 、workq.c 和 workq_main.c 显示了一个工作队列管理器的实现。 系列文章目录： 概述 线程 同步 使用线程方式 线程高级编程 POSIX 针对线程的调整 线程扩展 线程同步精要 Github 示例源码","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://veinin.com/categories/并发编程/"}],"tags":[{"name":"Phtreads","slug":"Phtreads","permalink":"https://veinin.com/tags/Phtreads/"},{"name":"POSIX Pthreads","slug":"POSIX-Pthreads","permalink":"https://veinin.com/tags/POSIX-Pthreads/"}]},{"title":"POSIX 多线程程序设计-POSIX 针对线程的调整","slug":"programming_with_posix_pthreads_06","date":"2018-06-17T11:38:12.000Z","updated":"2018-07-12T14:44:36.943Z","comments":true,"path":"2018/06/17/programming_with_posix_pthreads_06/","link":"","permalink":"https://veinin.com/2018/06/17/programming_with_posix_pthreads_06/","excerpt":"多线程与fork多线程进程调用 fork 创造的子进程，只有调用 fork 的线程在子进程内存在，除了当前调用的线程，其他线程在子进程中都会消失，但消失的线程状态仍然保留为调用 fork 时的相同状态，线程会拥有与在父进程内当前调用线程的相同状态，拥有相同的互斥量，同样的线程私有数据键值等。 在 forked 的进程中只有一个线程，消失的其他线程并不会调用诸如 pthread_exit 退出，线程也不会再运用线程私有数据 destructors 或清除处理函数。这里就存在一个很危险的局面，其他线程可能正好位于临界区之内，持有了某个锁，而它突然死亡，也就再也没有机会去解锁了。而如果子进程试图去对某个 mutex 加锁，那么马上就会造成死锁的局面。 综上所述，除非你打算很快地在子进程中调用 exec 执行一个新程序， 否则应避免在一个多线程的程序中使用 fork。","text":"多线程与fork多线程进程调用 fork 创造的子进程，只有调用 fork 的线程在子进程内存在，除了当前调用的线程，其他线程在子进程中都会消失，但消失的线程状态仍然保留为调用 fork 时的相同状态，线程会拥有与在父进程内当前调用线程的相同状态，拥有相同的互斥量，同样的线程私有数据键值等。 在 forked 的进程中只有一个线程，消失的其他线程并不会调用诸如 pthread_exit 退出，线程也不会再运用线程私有数据 destructors 或清除处理函数。这里就存在一个很危险的局面，其他线程可能正好位于临界区之内，持有了某个锁，而它突然死亡，也就再也没有机会去解锁了。而如果子进程试图去对某个 mutex 加锁，那么马上就会造成死锁的局面。 综上所述，除非你打算很快地在子进程中调用 exec 执行一个新程序， 否则应避免在一个多线程的程序中使用 fork。 如果你不能避免，那么你应该注意在子进程中不能调用以下这些函数（参考《Linux多线程服务端编程》）： malloc,会访问全局状态，肯定会加锁。 任何分配和释放内存的函数，诸如new、delete…… 任何 Pthreads 函数。 printf 系列函数。其他线程可能持有了stdout/stderr的锁。 sigle 中除了“sigle安全”之外的任何函数，应避免在信号处理函数内使用 fork。 另外，Pthreads 增加了 pthread_atfork “fork 处理器” 机制以允许你的代码越过 fork 调用保护数据和不变量。 1int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void)); 该函数中，prepare fork 处理器以正确的顺序锁住所有的由相关代码使用的互斥量以阻止死锁的发生。parent fork 处理器只需要开锁所有互斥量即可，以允许父进程和所有线程继续正常工作。child fork 处理器经常可以与 parent fork 处评器一样； 但是有时需要重置程序或库的状态。 在程序 atfork.c 中展示了如何使用 fork 处理器。 多线程与execexec 函数功能是消除当前程序的环境并且用一个新程序代替它，所以并没有受线程的影响。 多线程与signal在多线程程序中，使用 signal 的第一原则就是 不要使用 signal。 尽管修改进程信号行为本身是线程安全的，但是不能防止其他线程随后很快地设置一个新的信号行为。任何印象线程的信号同样也会影响整个进程，这意味着向进程或进程内的任何线程传送一个 SIGKILL 信号，将终止进程。传送一个 SIGSTOP 停止命令时，将导致所有的线程停止直到收到 SIGCOUNT 信号。 多线程与stdioPthreads 要求 ANSI C 标准 I/O (stdio) 函数是线程安全的。因为 stdio 包需要为输出缓冲区和文件状态指定静态存储区，stdio 实现将使用互斥量或信号灯等同步机制。 flockfile 和 funlockfile在一些情况里，一系列 stdio 操作以不被中断的顺序执行是重要的。例如，一个提示符后面跟着一个从终端的读操作。为了不让其他线程在两个操作之间读 stdin 或者写stdout，你应该在两个调用前后锁住 stdin 和 stdou。你可以使用使用 flockfile 和 funlockfile 以及 ftrylockfile 函数来确保一系列写操作不会被从其他线程的文件存取打断。 123void flock file(FILE *file);int ftrylockfile(FILE *file)void funlockfile(FILE *file)； 你可以参考程序 flock.c 实例。 getchar_unlocked 和 putchar_unlocked函数 getchar 和 putchar 分别操作 stdin 和 stdout，而 getc 和 putc 能在任何stdio 文件流上被使用。Pthreads 要求这些函数锁住 stdio 流数据来防止代码对 stdio 缓冲区的偶然破坏。 Phtread 提供了函数 getc_unlocked、putc_unlocked、 getchar_unlocked 和 putchar_unlocked，但它们不执行任何锁操作，因此你必须在这些操作附近使用 flockfile 和 fimlockfili。 1234int getc_unlocked(FILE *stream);int getchar_unlocked(void);int putc_unlocked(int c, FILE *stream);int putchar_unlocked (int c); 程序 putchar.c 显示了使用 putchar 和在一个文件锁内调用一系列 putchar_unlocked之间的差异。 进程结束在一个多线程程序中，主函数是”进程主线程的启动函数”，从主函数返回将终止整个进程。与进程相关的所有内存（和线程）将消失。线程也不会执行清除处理器或线程私有数据 destructors 函数。调用 exit 具有同样的效果，你可以调用 exit 来很快地停止所有的线程。 当你不想使用起始线程或让它等待其他线程结束时，可以通过调用 pthread_exit 而非返回或调用 exit 退出主函数。从主函数中调用 pthread_exit 将在不影响进程内其他线程的前提下终止起始线程，允许其他线程继续运作，直到正常完成。 线程安全函数Pthreads 定义了现存函数的线程安全的变体，它们在相应函数名结尾处添加后缀 _r： 用户和终端ID，getlogin_r、ctermid、ttyname_r。 目录搜索，readdir_r。 字符串 token，strtok_r。 时间表示，asctime_r、ctime_r、gmtime_r、localtime_r。 随机数产生，read_r。 组和用户数据库，getgrgid_r、getgrnam_r、getpwuid_r、getpwnam_r。 程序 getlogin.c 是一个如何调用获取用户和终端ID的实例。 系列文章目录： 概述 线程 同步 使用线程方式 线程高级编程 POSIX 针对线程的调整 线程扩展 线程同步精要 Github 示例源码","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://veinin.com/categories/并发编程/"}],"tags":[{"name":"Phtreads","slug":"Phtreads","permalink":"https://veinin.com/tags/Phtreads/"},{"name":"POSIX Pthreads","slug":"POSIX-Pthreads","permalink":"https://veinin.com/tags/POSIX-Pthreads/"}]},{"title":"POSIX 多线程程序设计-线程高级编程","slug":"programming_with_posix_pthreads_05","date":"2018-06-12T15:12:32.000Z","updated":"2018-07-12T14:44:32.855Z","comments":true,"path":"2018/06/12/programming_with_posix_pthreads_05/","link":"","permalink":"https://veinin.com/2018/06/12/programming_with_posix_pthreads_05/","excerpt":"一次性初始化一些事情仅仅需要做一次，不管是什么。在主函数中并且在调用任何其他依赖于初始化的事物之前，这时初始化应用最容易，特别是在创造任何线程之前初始化它需要的数据，如互斥量、线程特定数据键等。 在传统的顺序编程中，一次性初始化经常通过使用布尔变量来管理。控制变量被静态地初始化为 0,而任何依赖于初始化的代码都能测试该变量。如果变量值仍然为 0, 则它能实行初始化，然后将变量置为 1，以后检查的代码将跳过初始化。如下面代码示例： 12345678910bool initialized = false;void init()&#123; if (initialized) return; // TODO initialized = true&#125;","text":"一次性初始化一些事情仅仅需要做一次，不管是什么。在主函数中并且在调用任何其他依赖于初始化的事物之前，这时初始化应用最容易，特别是在创造任何线程之前初始化它需要的数据，如互斥量、线程特定数据键等。 在传统的顺序编程中，一次性初始化经常通过使用布尔变量来管理。控制变量被静态地初始化为 0,而任何依赖于初始化的代码都能测试该变量。如果变量值仍然为 0, 则它能实行初始化，然后将变量置为 1，以后检查的代码将跳过初始化。如下面代码示例： 12345678910bool initialized = false;void init()&#123; if (initialized) return; // TODO initialized = true&#125; 但在使用多线程时，上述操作就不是那么容易了。如果多个线程并发地执行初始化序列代码， 2 个线程可能都发现 initialized 为0，并且都执行初始化，而且该过程本该仅仅执行一次，那么上面代码就会立马发生不可预估的错误。 对于多线程环境下初始化的状态有两种方式： 使用一个静态初始化的互斥量来编写一次性初始化代码。 无法静态初始化一个互斥量时，使用 pthread_once。 对于 pthread_once 初始化，需要声明类型为 pthread_once_t 的一个控制变量，且该控制变量必须使用 PTHREAD_ONCE_INIT 宏进行静态初始化。pthread_once 首先检查控制变量，以判断是否已经完成初始化，如果完成，则什么都不做并立刻返回；否则，pthread_once 会调用初始化函数，并且记录初始化完成。如果在一个线程初始化时，另外一个线程也调用了pthread_once，则调用线程会阻塞等待，直到正在初始化的线程返回，这样就确保了所以状态一定会正确初始化完成。 下面是一个使用 pthread_once 来初始化的实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;pthread.h&gt;#include \"errors.h\"pthread_once_t once_block = PTHREAD_ONCE_INIT;pthread_mutex_t mutex;void once_init_routine(void)&#123; int status; status = pthread_mutex_init(&amp;mutex, NULL); if (status != 0) err_abort(status, \"Init mutex\");&#125;void *thread_routine(void *arg)&#123; int status; status = pthread_once(&amp;once_block, once_init_routine); if (status != 0) err_abort(status, \"Once init\"); status = pthread_mutex_lock(&amp;mutex); if (status != 0) err_abort(status, \"Init mutex\"); printf(\"thread_toutine has locked the mutex.\\n\"); status = pthread_mutex_unlock(&amp;mutex); if (status != 0) err_abort(status, \"Destroy mutex\"); return NULL;&#125;int main()&#123; int status; pthread_t thread_id; status = pthread_create(&amp;thread_id, NULL, thread_routine, NULL); if (status != 0) err_abort(status, \"Create thread\"); status = pthread_once(&amp;once_block, once_init_routine); if (status != 0) err_abort(status, \"Once init\"); status = pthread_mutex_lock(&amp;mutex); if (status != 0) err_abort(status, \"Init mutex\"); printf(\"Main has locked the mutex.\\n\"); status = pthread_mutex_unlock(&amp;mutex); if (status != 0) err_abort(status, \"Destroy mutex\"); status = pthread_join(thread_id, NULL); if (status != 0) err_abort(status, \"Join thread\"); return 0;&#125; 上面程序，唯一的临界共享数据实际是 once_block，主线程和线程 thread_routine 都会调用 pthread_once 进行初始化，但只会有一个线程会执行初始化函数。 属性当我们创建线程或动态初始化互斥量和条件变量时，通常使用空指针作为第二个参数，这个参数实际上是指向一个属性对象的指针。空指针表明，Pthreads 应该为所有属性假定默认值，就像静态初始化互斥量或条件变量时一样。 一个属性对象是当初始化一个对象时提供的一个扩展参数表，可以提供更加高级的功能。类型 pthread_attr_t 代表一个属性对象，线程、 互斥置和条件变量都有自己特殊的属性对象类型， 分别是 pthread_attr_t、 pthread_mutexattr_t 和 pthread_condattr_t。 互斥量属性Pthreads 为互斥量创建定义下列属性：pshared、pratocol 和 prioceiling。通过调用 pthread_mutexattr_init 初始化互斥量属性，指定一个指向类型 pthread_mutexattr_t 变量的指针。 12345pthread_mutexattr_t mutex_attr;int pthread_mutexattr_init(pthread_mutexattr_t *attr);int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);int pthread_mutexattr_getpshared(pthread_mutexattr_t *attr, int *pshared)int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared); 下面程序显示了如何设置属性对象来创建使用 pshared 属性的互斥量，并且获取 pshared 值，打印输出 1： 12345678910111213141516171819202122232425262728293031#include &lt;pthread.h&gt;#include \"errors.h\"pthread_mutex_t mutex;int main()&#123; int status; int pshared; pthread_mutexattr_t mutex_attr; status = pthread_mutexattr_init(&amp;mutex_attr); if (status != 0) err_abort(status, \"Init mutex attr\"); status = pthread_mutexattr_setpshared(&amp;mutex_attr, PTHREAD_PROCESS_SHARED); if (status != 0) err_abort(status, \"Set pshared\"); status = pthread_mutex_init(&amp;mutex, &amp;mutex_attr); if (status != 0) err_abort(status, \"Init mutex\"); status = pthread_mutexattr_getpshared(&amp;mutex_attr, &amp;pshared); if (status != 0) err_abort(status, \"Get pshared\"); printf(\"pshared: %d\\n\", pshared); return 0;&#125; 条件变量属性Pthreads 为条件变量的创建仅定义了一个属性 pshared。使用 pthread_condattr_init 初始化条件变量属性对象，设置一个指向类型 pthread_condattr_t 变量的指针。可以通过调用 pthread_condattr_setpshared 设置 pshared。 该属性默认值时 PTHREAD_PROCESS_PRIVATE，如果条件变量属性需要被多个线程使用，可以设置值为 PTHREAD_PROCESS_SHAREAD。 下面程序演示了如何使用条件变量的 pshared 属性来创建设置一个条件变量: 123456789101112131415161718192021222324#include &lt;pthread.h&gt;#include \"errors.h\"pthread_cond_t cond;int main()&#123; int status; pthread_condattr_t cond_attr; status = pthread_condattr_init(&amp;cond_attr); if (status != 0) err_abort(status, \"Create attr\"); status = pthread_condattr_setpshared(&amp;cond_attr, PTHREAD_PROCESS_PRIVATE); if (status != 0) err_abort(status, \"Set pshared\"); status = pthread_cond_init(&amp;cond, &amp;cond_attr); if (status != 0) err_abort(status, \"Init cond\"); return 0;&#125; 线程属性POSIX 为线程创建定义下列属性：detachstate、stacksize、stackaddr、scope、inheritsched、schedpolicy 和 schedparam。并不是所有系统都支持以上所有的属性，因此需要在使用前检查系统文档。 所有的 Pthreads 系统都支持 detachstate 属性 ，该属性的值可以是 PTHREAD_CREATE_JOINABLE 或 PTHREAD_CREATE_DETACHED。默认的线程被创建为可连接的(joinable)，即意味着由 pthread_create 创建的该线程ID 能被用来与线程连接并获得它的返回值，或取消它。如果设置为 PTHREAD_CREATE_DETACHED，则该属性对象创建的线程 ID 不能被使用，线程终止时，线程的所有资源都会被系统立刻回收。所以，在创建已经知道不需要取消或连接的线程时，应该以可分离的方式创建它们。 12345pthread_attr_t attr;int pthread_attr_init(pthread_attr_t *attr);int pthread_attr_destroy(pthread_attr_t *attr);int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);int pthread_attr_setdetachstate(pthread_attr_t *attr, int *detachstate); 如果系统定义了标志 _POSIX_THREAD_ATTR_STACKSIZE，就可以设置 stacksize 属性，指定使用属性对象创建的线程栈的最小值。但栈大小不是可移植的，你应该小心使用它。如果系统定义了标志 _POSIX_THREAD_ATTR_STACKADDR，就可以设置 stackaddr 属性，为指定线程指定一个存储器区域来作为堆栈使用。 下面程序演示了实际中的某些属性对象的使用实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;limits.h&gt;#include &lt;pthread.h&gt;#include \"errors.h\"void *thread_routine(void *arg)&#123; printf(\"The thread is here\\n\"); return NULL;&#125;int main()&#123; pthread_t thread_id; pthread_attr_t thread_attr; struct sched_param thread_param; size_t stack_size; int status; status = pthread_attr_init(&amp;thread_attr); if (status != 0) err_abort(status, \"Create attr\"); status = pthread_attr_setdetachstate(&amp;thread_attr, PTHREAD_CREATE_DETACHED); if (status != 0) err_abort(status, \"Set detach\");#ifdef _POSIX_THREAD_ATTR_STACKSIZE status = pthread_attr_getstacksize(&amp;thread_attr, &amp;stack_size); if (status != 0) err_abort(status, \"Get stack size\"); printf(\"Default stack size is %d; minimum is %d\\n\", stack_size, PTHREAD_STACK_MIN); status = pthread_attr_setstacksize(&amp;thread_attr, PTHREAD_STACK_MIN*2); if (status != 0) err_abort(status, \"Set stack size\");#endif status = pthread_create(&amp;thread_id, &amp;thread_attr, thread_routine, NULL); if (status != 0) err_abort(status, \"Create thread\"); printf(\"Main exiting\\n\"); pthread_exit(NULL); return 0;&#125; 取消大部分时间每个线程独立地运行着，完成一个特定的工作，并且自己退出。但是有时一个线程被创建并不需要一定完成某件事情。例如用户可以单击按钮取消停止长时间的搜索操作。取消一个线程就像告诉一个人停止他正在做的工作一样。Pthreads 允许每个线程控制自己的结束，它能恢复程序不变量并解锁互斥量。当线程完成一些重要的操作时它甚至能推迟取消。 以下是常用的线程取消函数： 123456int pthread_cancel(pthread_t thread);int pthread_setcancelstate(int state, int *oldstate);int pthread_setcanceltype(int type, int *oldtype);void pthread_testcancel(void);void pthread_cleanup_push(void (*routine)(void *), void *arg);void pthread_cleanup_pop(int execute); Pthread 支持三种取消模式，模式为两位二进制编码，称为“取消状态”和“取消类型”。每种模式实质上包括开、关两种状态。取消状态可以是“启用”（ enable)或“禁用”（disable)，取消类型可以是被“推迟” 或 “异步。如果取消状态被禁用，那么其他取消模式都会失效，相反则可以执行“推迟”或“异步”模式。 模式 状态 类型 含义 Off（关） 禁用 二者之一 取消被推迟，直到启动取消模式 Deferred（推迟） 启用 推迟 在下一个取消点执行取消 Asynchronous（异步） 启用 异步 可以随时执行取消 为取消一个线程， 你需要线程的标识符 ID， 即由 pthread_create 返回给创建者或由 pthread_self 返回给线程自己的 pthread_t 值。如果没有一个线程的标识符 TD， 就不能取消线程。 取消一个线程是异步的， 当 pthread_cancel 调用返回时， 线程未必已经被取消，可能仅仅被通知有一个针对它的未解决的取消请求。如果需要知道线程在何时实际终止，就必须在取消它之后调用 pthread_join 与它连接。 也有被称为 pthread_testcancel 的特殊函数， 该函数仅仅是一个推迟的取消点。如果线程没被要求终止，它将很快返回，这允许你将任何函数转变为取消点。 下面是一个在循环内调用 pthread_testcancel 来对一个延迟取消反应的线程实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;pthread.h&gt;#include \"errors.h\"static int counter;void *thread_routine(void *arg)&#123; printf(\"thread_routine starting\\n\"); for (counter == 0; ; counter++) &#123; if ((counter % 1000) == 0) &#123; printf(\"calling testcancel\\n\"); pthread_testcancel(); &#125; &#125;&#125;int main()&#123; pthread_t thread_id; void *result; int status; status = pthread_create(&amp;thread_id, NULL, thread_routine, NULL); if (status != 0) err_abort(status, \"Create thread\"); sleep(2); printf(\"callling cancel\\n\"); status = pthread_cancel(thread_id); if (status != 0) err_abort(status, \"Cancel thread\"); printf(\"calling join\\n\"); status = pthread_join(thread_id, &amp;result); if (status != 0) err_abort(status, \"Join thread\"); if (result == PTHREAD_CANCELED) printf(\"Thread canceled at iteration %d\\n\", counter); else printf(\"Thread was not canceled\\n\"); return 0;&#125; 推迟取消“推迟取消”意味着线程的取消类型被设置为 PTHREAD_DEFERRED，线程的取消使能属性被设置为 PTHREAD_CANCEL_ENABLE，线程将仅仅在到达取消点时才响应取消请求。 大多数取消点包含可以“无限”时间阻塞线程的 I/O 操作，它们是可取消的，以便等待能被打断，比如 wait、read 这样的函数函数。你可以在下面这个链接中查找到所有可能的取消点：Pthreads-Cancellation-points 如果需要保证取消不能在一个特别的取消点或取消点的一些顺序期间发生，可以暂时在代码的那个区域停用取消。下面程序是一个实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;pthread.h&gt;#include \"errors.h\"static int counter;void *thread_routine(void *arg)&#123; int state; int status; printf(\"thread_routine starting\\n\"); for (counter == 0;; counter++) &#123; if ((counter % 755) == 0) &#123; status = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &amp;state); if (status != 0) err_abort(status, \"Disable cancel\"); sleep(1); status = pthread_setcancelstate(state, &amp;state); if (status != 0) err_abort(status, \"Restore cancel\"); &#125; else if ((counter % 1000) == 0) &#123; printf(\"calling testcancel\\n\"); pthread_testcancel(); &#125; &#125;&#125;int main()&#123; pthread_t thread_id; void *result; int status; status = pthread_create(&amp;thread_id, NULL, thread_routine, NULL); if (status != 0) err_abort(status, \"Create thread\"); sleep(2); printf(\"callling cancel\\n\"); status = pthread_cancel(thread_id); if (status != 0) err_abort(status, \"Cancel thread\"); printf(\"calling join\\n\"); status = pthread_join(thread_id, &amp;result); if (status != 0) err_abort(status, \"Join thread\"); if (result == PTHREAD_CANCELED) printf(\"Thread canceled at iteration %d\\n\", counter); else printf(\"Thread was not canceled\\n\"); return 0;&#125; 异步取消如果目标线程不需要使用取消点来査询取消请求。对于运行一个紧密计算循环的线程（例如，在找一个素数因素）而言是非常珍贵的，因为那种情况下调用 pthread_testcancel 的开销在可能是严重的。 异步取消线程很难确保目标线程安全的执行取消，例如当你调用 malloc 时，系统为你分配一些堆内存，但 malloc 可能在很多地方被异步取消打断，可能在分配内存前，或可能在分配内存后、也可能在保存地址返回前被打断。无论哪种情况，你的代码保存的内存地址变量将是未初始化的，这就很可能造成内存泄漏。 所以，在你的任何代码里面应该 避免异步的取消 ！我们很难正确使用异步取消，并且很少有用。 除非当函数被记录为“异步取消安全”的，否则当异步取消被启用时你不该调用任何函数。Pthreads 建议所有的库函数应该记录它们是否是异步取消安全的。如果函数的描述没有具体的说明，则你应该总是假定它不是异步取消安全的。 下面是一个计算密集的循环中异步取消的使用实例，但是如果在循环内有任何函数调用，程序将变得不可靠，而推迟取消的版本将能继续正确工作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;pthread.h&gt;#include \"errors.h\"#define SIZE 10static int matrixa[SIZE][SIZE];static int matrixb[SIZE][SIZE];static int matrixc[SIZE][SIZE];void *thread_routine(void *arg)&#123; int cancel_type, status; int i, j, k, value = 1; for (i = 0; i &lt; SIZE; i++) for (j = 0; j &lt; SIZE; j++) &#123; matrixa[i][j] = i; matrixb[i][j] = j; &#125; while (1) &#123; status = pthread_setcancelstate(PTHREAD_CANCEL_ASYNCHRONOUS, &amp;cancel_type); if (status != 0) err_abort(status, \"Set cancel type\"); for (i = 0; i &lt; SIZE; i++) &#123; for (j = 0; j &lt; SIZE; j++) &#123; matrixc[i][j]= 0; for (k = 0; k &lt; SIZE; k++) matrixc[i][j] += matrixa[i][k] * matrixb[k][j]; &#125; &#125; status = pthread_setcancelstate(cancel_type, &amp;cancel_type); if (status != 0) err_abort(status, \"Set cancel type\"); for (i = 0; i &lt; SIZE; i++) for (j = 0; j &lt; SIZE; j++) matrixa[i][j] = matrixc[i][j]; &#125;&#125;int main()&#123; pthread_t thread_id; void *result; int status; status = pthread_create(&amp;thread_id, NULL, thread_routine, NULL); if (status != 0) err_abort(status, \"Create thread\"); sleep(1); printf(\"callling cancel\\n\"); status = pthread_cancel(thread_id); if (status != 0) err_abort(status, \"Cancel thread\"); printf(\"calling join\\n\"); status = pthread_join(thread_id, &amp;result); if (status != 0) err_abort(status, \"Join thread\"); if (result == PTHREAD_CANCELED) printf(\"Thread canceled\\n\"); else printf(\"Thread was not canceled\\n\"); return 0;&#125; 清除当一个代码段被取消时，需要恢复一些状态，必须使用清除处理器。例如当线程在等待一个条件变量时被取消，它将被唤醒，并保持互斥量加锁状态。在线程终止前，通常需要恢复不变量，且它总是需要释放互斥量。 可以把每个线程考虑为有一个活动的清除处理函数的栈。 调用 pthread_cleanup_push 将清除处理函数加到栈中， 调用 pthread_cleanup_pop 删除最近增加的处理函数。当线程被取消时或当它调用 pthread_exit 退出时，Pthreads 从最近增加的清除处理函数幵始，依次调用各个活动的清除处理函数，当所有活动的清除处理函数返回时，线程被终止。 下面程序演示了当一个条件变量等待被取消时，使用清除处理函数来释放互斥量： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;pthread.h&gt;#include \"errors.h\"#define THREADS 5typedef struct control_tag&#123; int counter, bysy; pthread_mutex_t mutex; pthread_cond_t cv;&#125; control_t;control_t control = &#123;0, 1, PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER&#125;;void cleanup_handler(void *arg)&#123; control_t *st = (control_t *)arg; int status; st-&gt;counter--; printf(\"cleaup_handler: counter == %d\\n\", st-&gt;counter); status = pthread_mutex_unlock(&amp;st-&gt;mutex); if (status != 0) err_abort(status, \"Unlock in cleanup handler\");&#125;void *thread_routine(void *arg)&#123; int status; pthread_cleanup_push(cleanup_handler, (void *)&amp;control); status = pthread_mutex_lock(&amp;control.mutex); if (status != 0) err_abort(status, \"Mutex lock\"); control.counter++; while (control.bysy) &#123; status = pthread_cond_wait(&amp;control.cv, &amp;control.mutex); if (status != 0) err_abort(status, \"Wait on condition\"); &#125; pthread_cleanup_pop(1); return NULL;&#125;int main()&#123; pthread_t thread_id[THREADS]; int count; void *result; int status; for (count = 0; count &lt; THREADS; count++) &#123; status = pthread_create(&amp;thread_id[count], NULL, thread_routine, NULL); if (status != 0) err_abort(status, \"Create thread\"); &#125; sleep(2); for (count = 0; count &lt; THREADS; count++) &#123; status = pthread_cancel(thread_id[count]); if (status != 0) err_abort(status, \"Cancel thread\"); status = pthread_join(thread_id[count], &amp;result); if (status != 0) err_abort(status, \"Join thread\"); if (result == PTHREAD_CANCELED) printf(\"Thread %d canceled\\n\", count); else printf(\"Thread %d was not canceled\\n\", count); &#125;&#125; 如果你的一个线程创建了一套线程来“转包”一些功能（如并行算术运算），并且当分包线程在进行中时“承包线程”被取消，你可能不希望留着分包线程继续运行。相反，可以把取消操作“传递”到每个“分包线程”，让它们独立地处理自己的终止过程。当“承包线程”取消它们时，不应该连接分包线程来推迟取消，相反，可以取消每个线程并且使用 pthread_detach 很快地分离它。当它们完成时，分包线程的资源就能够很快被重用， 而“承包线程” 同时能独立地完成一些事情。 以下程序演示了同时独立取消“分包线程”的一个方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;pthread.h&gt;#include \"errors.h\"#define THREADS 5typedef struct team_tag &#123; int join_i; pthread_t workers[THREADS];&#125; team_t;void *worker_routine(void *arg)&#123; int counter; for(counter = 0; ; counter++) if ((counter % 1000) == 0) pthread_testcancel();&#125;void cleanup(void *arg)&#123; team_t *team = (team_t *)arg; int count, status; for (count = team-&gt;join_i; count &lt; THREADS; count++) &#123; status = pthread_cancel(team-&gt;workers[count]); if (status != 0) err_abort(status, \"Cancel worker\"); status = pthread_detach(team-&gt;workers[count]); if (status != 0) err_abort(status, \"Detach worker\"); printf(\"Cleanup: canceled %d\\n\", count); &#125;&#125;void *thread_routine(void *arg)&#123; team_t team; int count; void *result; int status; for (count = 0; count &lt; THREADS; count++) &#123; status = pthread_create(&amp;team.workers[count], NULL, worker_routine, NULL); if (status != 0) err_abort(status, \"Create worker\"); &#125; pthread_cleanup_push(cleanup, (void *)&amp;team); for (team.join_i = 0; team.join_i &lt; THREADS; team.join_i++) &#123; status = pthread_join(team.workers[team.join_i], &amp;result); if (status != 0) err_abort(status, \"Join worker\"); &#125; pthread_cleanup_pop(1); return NULL;&#125;int main()&#123; pthread_t thread_id; int status; status = pthread_create(&amp;thread_id, NULL, thread_routine, NULL); if (status != 0) err_abort(status, \"Create team\"); sleep(5); status = pthread_cancel(thread_id); if (status != 0) err_abort(status, \"Cancel team\"); status = pthread_join(thread_id, NULL); if (status != 0) err_abort(status, \"Join team\"); return 0;&#125; 线程私有数据在进程内的所有线程共享相同的地址空间，即意味着任何声明为静态或外部的变量，或在进程堆声明的变量，都可以被进程内所有的线程读写。 当线程需要一个私有变量时，必须首先决定所有的线程是否共享相同的值，或者线程是否应该有它自己的值。如果它们共享变量，则可以使用静态或外部数据，就像你能在一个单线程程序做的那样；然而，必须同步跨越多线程对共享数据的存取， 运通常通过增加一个或多个互斤量来完成。 如果每个线程都需要一个私有变量值，则必须在某处存储所有的值。线程私有数据允许每个线程保有一份变量的拷贝，好像每个线程有一连串通过公共的“键”值索引的私有数据值。 建立和使用线程私有数据线程私有数据键在程序中是由类型 pthread_key_t 来表示的。 在任何线程试图使用键以前，创建线程私有数据键最容易的方法是调用 pthread_key_create，但必须保证 pthread_key_create 对于每个 pthread_key_t 变童仅仅调用一次。如果将一个键创建两次，其实是在创建两个不同的键。第二个键将覆盖第一个，第一个键与任何线程为其设置的值一起将永远地丢失。所以，最容易一次性创建一个键的方法是使用 pthread_once。 当程序不再需要时，你可以调用 pthread_key_delete 释放一个线程私有数据键。 在私有数据创建后，你可以使用 pthread_getspecific 函数来获得线程当前的键值，或调用 pthread_setspecific 来改变当前的键值。 12345pthread_key_t key;int pthread_key_create(pthread_key_t *key, void (*destructor)(void *));int pthread_key_delete(pthread_key_t key);void pthread_setspecific(pthread_key_t key, const void *value);void *pthread_getspecific(pthread_key_t); 下面是一个建立和使用线程私有数据的实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;pthread.h&gt;#include \"errors.h\"typedef struct tsd_tag &#123; pthread_t thread_id; char *string;&#125; tsd_t;pthread_key_t tsd_key;pthread_once_t key_one = PTHREAD_ONCE_INIT;void once_routine(void)&#123; int status; printf(\"initializing key\\n\"); status = pthread_key_create(&amp;tsd_key, NULL); if (status != 0) err_abort(status, \"Create key\");&#125;void *thread_routine(void *arg)&#123; tsd_t *value; int status; status = pthread_once(&amp;key_one, once_routine); if (status != 0) err_abort(status, \"Once init\"); value = (tsd_t*)malloc(sizeof(tsd_t)); if (value == NULL) errno_abort(\"Allocate key value\"); status = pthread_setspecific(tsd_key, value); if (status != 0) err_abort(status, \"Set tsd\"); printf(\"%s set tsd value %p\\n\", (char*)arg, value); value-&gt;thread_id = pthread_self(); value-&gt;string = (char*)arg; value = (tsd_t*)pthread_getspecific(tsd_key); printf(\"%s starting...\\n\", value-&gt;string); sleep(2); value = (tsd_t*)pthread_getspecific(tsd_key); printf(\"%s done...\\n\", value-&gt;string); return NULL;&#125;int main()&#123; int status; pthread_t thread1, thread2; status = pthread_create(&amp;thread1, NULL, thread_routine, \"thread 1\"); if (status != 0) err_abort(status, \"Create thread 1\"); status = pthread_create(&amp;thread2, NULL, thread_routine, \"thread 2\"); if (status != 0) err_abort(status, \"Create thread 2\"); pthread_exit(NULL);&#125; 使用 destructor 函数当一个线程退出时，它有一些为线程私有数据键定义的值，通常需要处理它们。当你创建一个线程私有数据键时，Pthreads 允许你定义 destructor 函数。当具有非空的私有数据键值的一个线程终止时，键的 destructor (如果存在） 将以键的当前值为参数被调用。 下列程序表明了当一个线程终止时使用线程私有数据的 destructors 释放存储器。 它还跟踪有多少线程正在使用线程私有数据， 并且当最后线程的 destructor 被调用时， 删除线程私有数据键。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;pthread.h&gt;#include \"errors.h\"typedef struct private_tag &#123; pthread_t thread_id; char *string;&#125; private_t;pthread_key_t identity_key;pthread_mutex_t identity_key_mutex = PTHREAD_MUTEX_INITIALIZER;long identity_key_counter = 0;void identity_key_destructor(void *value)&#123; private_t *private = (private_t*)value; int status; printf(\"thread \\\"%s\\\" exiting...\\n\", private-&gt;string); free(value); status = pthread_mutex_lock(&amp;identity_key_mutex); if (status != 0) err_abort(status, \"Lock key mutex\"); identity_key_counter--; if (identity_key_counter &lt;= 0) &#123; status = pthread_key_delete(identity_key); if (status != 0) err_abort(status, \"Delete key\"); printf(\"key delete...\\n\"); &#125; status = pthread_mutex_unlock(&amp;identity_key_mutex); if (status != 0) err_abort(status, \"Unlock key mutex\");&#125;void *identity_key_get(void)&#123; void *value; int status; value = pthread_getspecific(identity_key); if (value == NULL) &#123; value = malloc(sizeof(private_t)); if (value == NULL) errno_abort(\"Allocate key value\"); status = pthread_setspecific(identity_key, value); if (status != 0) err_abort(status, \"Set TSD\"); &#125; return value;&#125;void *thread_routine(void *arg)&#123; private_t *value; value = (private_t*) identity_key_get(); value-&gt;thread_id = pthread_self(); value-&gt;string = (char*)arg; printf(\"thread \\\"%s\\\" starting...\\n\", value-&gt;string); sleep(2); return NULL;&#125;int main()&#123; pthread_t thread_1, thread_2; private_t *value; int status; status = pthread_key_create(&amp;identity_key, identity_key_destructor); if (status != 0) err_abort(status, \"Create key\"); identity_key_counter = 3; value = (private_t*)identity_key_get(); value-&gt;thread_id = pthread_self(); value-&gt;string = \"Main thread\"; status = pthread_create(&amp;thread_1, NULL, thread_routine, \"thread 1\"); if (status != 0) err_abort(status, \"Create thread 1\"); status = pthread_create(&amp;thread_2, NULL, thread_routine, \"thread 2\"); if (status != 0) err_abort(status, \"Create thread 2\"); pthread_exit(NULL);&#125; 线程实时调度“受限制”的响应时间不一定是“快”的反应，而是确实意味着“可预知”的响应速度。必须有一些方法来定义一个时间跨度，在该时间段内一系列操作保证被完成。例如控制一个核反应堆的系统比你将写的大多数程序有更严格的响应要求，并且没能满足反应堆要求的后果是更严重的。 很多代码将需要在“确定的反应时间”内提供一些“达到要求水平的服务”，我们称为实时编程。 实时编程分为“硬实时”和“软实时”。“硬实时”是不可原谅的，如燃料干的调整被推迟几微妙，你的核反应堆将会很危险；“软实时”意味着你大部分时间需要满足调度要求，但是如果不能能满足，后果也不是很严重。 POSIX 实时选项优先级调度允许程序员给系统提供了任何两个线程间相。无论何时当多个线程准备好执行时，系统将选择最高优先级的线程。 调度策略和优先级。调度策略允许设置各个调度策略的最小和最大优先级。POXIS 标准提供两种调度策略（SCHED_FIFO 和 SCHED_RR)。 SCHED_FIFO(先入先出）策略允许一个线程运行直到有更高优先级的线程准备好，或者直到它自愿阻塞自己。 SCHED_RR(轮循），和先入先出策略是基本相同的，不同之处在于：如果有一个 SCHED_RR策略的线程执行了超过一个固定的时期（时间片间隔）没有阻塞，而另外的SCHED_RR 或 SCHED_FIFO 策略的相同优先级的线程准备好时，运行的线程将被抢占以使准备好的线程可以执行。 程序 sched_attr.c 显示了如何使用属性对象来创建一个具有显式的调度策略和优先级的线程。程序 sched_thread.c 显示了如何为一个正在运行的线程修改实时调度策略和参数。 竞争范围和分配域。如果你正在写一个实时的应用程序，应该知道系统对这些控制量设置的支持，否则它们可能没有什么关系。 竞争范围，它描述了线程为处理器资源而竞争的方式。系统竞争范围意味着线程与进程之外的线程竞争处理器资源。一个进程内的髙优先级系统竞争范围线程能阻止其他进程内的系统竞争范围线程运行。进程竞争范围指线程仅仅在同一进程内相互竞争。可以使用 pthread_attr_setscope 设置竞争范围。 分配域，分配域是系统内线程可以为其竞争的处理器的集合。一个系统叫以有一个以上的分配领域，每个包含一个以上的处理器。在一个单处理机系统内，分配域将只包含一个处理器，但是你仍然可以有多个分配域。在一台多处理机上，各个分配领域可以包含从一个处理器到系统中所有的处理器。 系列文章目录： 概述 线程 同步 使用线程方式 线程高级编程 POSIX 针对线程的调整 线程扩展 线程同步精要 Github 示例源码","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://veinin.com/categories/并发编程/"}],"tags":[{"name":"Phtreads","slug":"Phtreads","permalink":"https://veinin.com/tags/Phtreads/"},{"name":"POSIX Pthreads","slug":"POSIX-Pthreads","permalink":"https://veinin.com/tags/POSIX-Pthreads/"}]},{"title":"POSIX 多线程程序设计-使用线程方式","slug":"programming_with_posix_pthreads_04","date":"2018-06-09T13:15:44.000Z","updated":"2018-07-12T14:44:26.398Z","comments":true,"path":"2018/06/09/programming_with_posix_pthreads_04/","link":"","permalink":"https://veinin.com/2018/06/09/programming_with_posix_pthreads_04/","excerpt":"线程编程模型线程变成模型主要有以下3种： 流水线。每个线程反复地在数据系列集上执行冋一种操作，并把操作结果传递给下一步驟的其他线程。 工作组。每个线程在自己的数据上执行操作，工作组中的线程可能执行同样的操作，也可能执行不同的操作，但是它们一定独立地执行。 客户端/服务器。一个客户为每一件工作与一个独立的服务器“订契约”。通常“订契约”是匿名的，即一个请求通过某种接提交。","text":"线程编程模型线程变成模型主要有以下3种： 流水线。每个线程反复地在数据系列集上执行冋一种操作，并把操作结果传递给下一步驟的其他线程。 工作组。每个线程在自己的数据上执行操作，工作组中的线程可能执行同样的操作，也可能执行不同的操作，但是它们一定独立地执行。 客户端/服务器。一个客户为每一件工作与一个独立的服务器“订契约”。通常“订契约”是匿名的，即一个请求通过某种接提交。 流水线在流水线（pipeline) 方式中，“数据元素”流串行地被一组线程顺序处理。每个线程依次在每个元素上执行一个特定的操作，并将结果传递给流水线中的下一个线程。 例如， 数据可能是扫描的图像，线程 A 可能处理一个图像数组，线程 B 可能在处理的数据中搜索某个特定的属性集，而线程 C 可能控制从线程 B 中收集连续的搜索结果流井做出报告。或者每个线程可能执行某个数据修改序列中的一步。 工作组在工作组模式中，数据由一组线程分别独立地处理。循环的“并行分解” 通常就是属于这种模式。 例如，可能建立一组线程，每个线程负责处理数组的某些行或列。单一数据集合在线程间分离成不同部分，且结果是一个数据集。由于所有的工作线程在不同的数据部分上执行相同的操作，这种模式通常被称为 SIMD (single instruction, multiple data, 单指令多数据流）并行处理。 客户/服务器在客户服务器系统中，客户请求服务器对一组数据执行某个操作。服务器独立地执行操作——客户端或者等待服务器执行，或者并行地执行并在后面需要时査找结果。尽管让客户等待是最简单的，但这种方式很少有用，因为它不会为客户带来性能上的提高。另一方面，这又是一种对某些公共资源同步管理的简单方式。 系列文章目录： 概述 线程 同步 使用线程方式 线程高级编程 POSIX 针对线程的调整 线程扩展 线程同步精要 Github 示例源码","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://veinin.com/categories/并发编程/"}],"tags":[{"name":"Phtreads","slug":"Phtreads","permalink":"https://veinin.com/tags/Phtreads/"},{"name":"POSIX Pthreads","slug":"POSIX-Pthreads","permalink":"https://veinin.com/tags/POSIX-Pthreads/"}]},{"title":"POSIX 多线程程序设计-同步","slug":"programming_with_posix_pthreads_03","date":"2018-06-07T12:16:55.000Z","updated":"2018-07-12T14:44:21.968Z","comments":true,"path":"2018/06/07/programming_with_posix_pthreads_03/","link":"","permalink":"https://veinin.com/2018/06/07/programming_with_posix_pthreads_03/","excerpt":"不变量、临界区和谓词不变量（invariant) 是由程序作出的假设， 特别是有关变量组间关系的假设。不变量可能会被破坏， 而且会经常被独立的代码段破坏。临界区（critical section）有时称为“串行区域”，是指影响共享数据的代码段，临界区总能够对应到一个数据不变量。例如，你从队列中删除数据时， 你可以将删除数据的代码视为临界区。谓词（Predicate) 是描述代码所需不变量的状态的语句。在英语中，谓词可以是如“队列为空”、 “资源可用” 之类的陈述。 互斥量大部分多线程程序需要在线程间共享数据。如果两个线程同时访问共享数据就可能会有问，因为一个线程可能在另一个线程修改共享数据的过程中使用该数据，并认为共享数据保持末变。使线程同步最通用和常用的方法就是确保对相同数据的内存访问“互斥地”进行，即一次只能允许一个线程写数据，其他线程必须等待。同步不仅仅在修改数据时重要， 当线程需要读取其他线程写入的数据时，而且数据写入的顺序也有影响时，同样需要同步。","text":"不变量、临界区和谓词不变量（invariant) 是由程序作出的假设， 特别是有关变量组间关系的假设。不变量可能会被破坏， 而且会经常被独立的代码段破坏。临界区（critical section）有时称为“串行区域”，是指影响共享数据的代码段，临界区总能够对应到一个数据不变量。例如，你从队列中删除数据时， 你可以将删除数据的代码视为临界区。谓词（Predicate) 是描述代码所需不变量的状态的语句。在英语中，谓词可以是如“队列为空”、 “资源可用” 之类的陈述。 互斥量大部分多线程程序需要在线程间共享数据。如果两个线程同时访问共享数据就可能会有问，因为一个线程可能在另一个线程修改共享数据的过程中使用该数据，并认为共享数据保持末变。使线程同步最通用和常用的方法就是确保对相同数据的内存访问“互斥地”进行，即一次只能允许一个线程写数据，其他线程必须等待。同步不仅仅在修改数据时重要， 当线程需要读取其他线程写入的数据时，而且数据写入的顺序也有影响时，同样需要同步。 创建和销毁互斥量Pthreads 的互斥量用 pthread_mutex_t 类型的变量来表示。不能拷贝互斥量，拷贝的互斥量是不确定的，但可以拷贝指向互斥量的指针。 大部分时间互斥量在函数体外，如果有其他文件使用互斥量，声明为外部类型，如果仅在本文将内使用，则将其声明为静态类型。可以使用宏 PTHREAD_WTEX_INZTIALIZER 来声明具有默认属性的静态互斥量，静态初始化的互斥量不需要主动释放。 下面程序演示了一个静态创建互斥量的程序，该程序 main 函数为空，不会产生任何结果。 1234567891011121314#include &lt;pthread.h&gt;#include \"errors.h\"typedef struct my_struct_tag &#123; pthread_mutex_t mutex; int value;&#125; my_struct_t;my_struct_t data = &#123;PTHREAD_MUTEX_INITIALIZER, 0&#125;;int main()&#123; return 0;&#125; 如果要初始化一个非缺省属性的互斥量， 必须使用动态初始化。如当使用 malloc 动态分配一个包含互斥量的数据结构时，应该使用 pthread_nutex_init 调用来动态的初始化互斥量。当不需要互斥量时，应该调用 pthread_mutex_destory 来释放它。另外，如果想保证每个互斥量在使用前被初始化，而且只被初始化一次。可以在创建任何线程之前初始化它，如通过调用 pthread_once。 12int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);int pthread_mutex_destroy(pthread_mutex_t *mutex); 下面程序演示了动态地初始化一个互斥量： 1234567891011121314151617181920212223242526272829#include &lt;pthread.h&gt;#include \"errors.h\"typedef struct my_struct_tag &#123; pthread_mutex_t mutex; int value;&#125; my_struct_t;int main()&#123; my_struct_t *data; int status; data = malloc(sizeof(my_struct_t)); if (data == NULL) errno_abort(\"Allocate structure\"); status = pthread_mutex_init(&amp;data-&gt;mutex, NULL); if (status != 0) err_abort(status, \"Init mutex\"); status = pthread_mutex_destroy(&amp;data-&gt;mutex); if (status != 0) err_abort(status, \"Destroy mutex\"); free(data); return status;&#125; 加锁和解锁互斥量最简单的情况下使用互斥量通过调用 pthread_mutex_lock 或 pthread_mutex_trylock 锁住互斥量，处理共享数据，然后调用 pthread_mutex_unlock 解锁互斥量。为确保线程能够读取一组变量的一致的值，需要在任何读写这些变量的代码段周围锁住互斥量。当调用线程己经锁住互斥量之后，就不能再加锁一个线程己经锁住互斥量之后，试图这样做的结果可能是返回错误(EDEADLK)，或者可能陷入“自死锁”，使线程永远等待下去。同样，你也不能解锁一个已经解锁的互斥量，不能解锁一个由其他线程锁住的互斥量。 123int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex); 下面程序 alarm_mutex.c 是 alarm_thread.c 的一个改进版本，该程序效果如下： 所有的闹钟按时间顺序存储在一个链表结构 alarm_list 中。 互斥量 alarm_mutex 负责协调对闹铃请求列表 alarm_list 的头节点的访问。 主线程，获取闹钟请求，将去按时间顺序插入到 alarm_list 中。 子线程，检查最新的闹铃列表，如果列表为空，则并阻塞住一段时间（1秒），解锁互斥量，以便主线程添加新的闹铃请求。否则获取下一个请求的差值，阻塞指定时间后，产生闹铃。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;pthread.h&gt;#include &lt;time.h&gt;#include \"errors.h\"typedef struct alarm_tag &#123; struct alarm_tag *link; int seconds; time_t time; char message[64];&#125; alarm_t;pthread_mutex_t alarm_mutex = PTHREAD_MUTEX_INITIALIZER;alarm_t *alarm_list = NULL;void *alarm_thread(void *arg)&#123; alarm_t *alarm; int sleep_time; time_t now; int status; while(1) &#123; status = pthread_mutex_lock(&amp;alarm_mutex); if (status != 0) err_abort(status, \"Lock mutex\"); alarm = alarm_list; if (alarm == NULL) sleep_time = 1; else &#123; alarm_list = alarm_list-&gt;link; now = time(NULL); if (alarm-&gt;time &lt;= now) sleep_time = 0; else sleep_time = alarm-&gt;time - now; status = pthread_mutex_unlock(&amp;alarm_mutex); if (status != 0) err_abort(status, \"Unlock mutex\"); if (sleep_time &gt; 0) sleep(sleep_time); else sched_yield(); if (alarm != NULL) &#123; printf(\"(%d) %s\\n\", alarm-&gt;seconds, alarm-&gt;message); free(alarm); &#125; &#125;&#125;int main()&#123; int status; char line[128]; alarm_t *alarm, **last, *next; pthread_t thread; status = pthread_create(&amp;thread, NULL, alarm_thread, NULL); if (status != 0) err_abort(status, \"Create alarm thread\"); while (1) &#123; printf(\"Alarm&gt; \"); if (fgets(line, sizeof(line), stdin) == NULL) exit(0); if (strlen(line) &lt;= 1) continue; alarm = (alarm_t*)malloc(sizeof(alarm_t)); if (alarm == NULL) errno_abort(\"Allocate alarm\"); if (sscanf(line, \"%d %64[^\\n]\", &amp;alarm-&gt;seconds, alarm-&gt;message) &lt; 2) &#123; fprintf(stderr, \"Bad command\\n\"); free(alarm); &#125; else &#123; status = pthread_mutex_lock(&amp;alarm_mutex); if (status != 0) err_abort(status, \"Lock mutex\"); alarm-&gt;time = time(NULL) + alarm-&gt;seconds; last = &amp;alarm_list; next = *last; while (next != NULL) &#123; if (next-&gt;time &gt;= alarm-&gt;time) &#123; alarm-&gt;link = next; *last = alarm; break; &#125; last = &amp;next-&gt;link; next = next-&gt;link; &#125; if (next == NULL) &#123; *last = alarm; alarm-&gt;link = NULL; &#125; status = pthread_mutex_unlock(&amp;alarm_mutex); if (status != 0) err_abort(status, \"Unlock mutex\"); &#125; &#125;&#125; 该实例具有占用更少资源的优势，但它的响应性能不够。一旦 alarm_thread 线程从列表中接收了一个闹铃请求，它就进入睡眠直到闹铃到期。当它发现列表中没有闹铃请求时，也会睡眠 1 秒，以允许主线程接收新的用户请求。 当 alarm_thread 线程睡眠时，直到它从睡眠中返回，它都不能注意到由主线程添加到请求列表中的任何闹铃请求。这种情况下最好的办法是使用条件变量来通知共享数据的状态变化（后面章节内容）。 非阻塞式互斥量锁当调用 pthread_mutex_lock 加锁互斥量时，如果此时互斥量己经被锁住，则调用线程将被阻塞。通常这是你希望的结果，但有时你可能希望如果互斥量己被锁住，则执行另外的代码路线，你的程序可能做其他一些有益的工作而不仅仅是等待。为此，Pthreads 提供了 pthread_mutex_trylock 函数，当调用互斥量己被锁住时调用该函数将返回错误代码 EBUSY。 下列实例程序 trylock.c 使用 pthread_mutex_trylock 函数来间歇性地报告计数器的值， 不过仅当它对计数器的访问与计数线程没有发生冲突时才报告： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;pthread.h&gt;#include \"errors.h\"#define SPIN 10000000pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;long counter;time_t end_time;void *counter_thread(void *arg)&#123; int status; int spin; while (time(NULL) &lt; end_time) &#123; status = pthread_mutex_lock(&amp;mutex); if (status != 0) err_abort(status, \"Lock mutex\"); for (spin = 0; spin &lt; SPIN; spin++) counter++; status = pthread_mutex_unlock(&amp;mutex); if (status != 0) err_abort(status, \"Unlock mutex\"); sleep(1); &#125; printf(\"Counter is %ld\\n\", counter); return NULL;&#125;void *monitor_thread(void *arg)&#123; int status; int misses = 0; while (time(NULL) &lt; end_time) &#123; sleep(3); status = pthread_mutex_trylock(&amp;mutex); if (status != EBUSY) &#123; if (status != 0) err_abort(status, \"Trylock mutex\"); printf(\"Counter is %ld\\n\", counter/SPIN); status = pthread_mutex_unlock(&amp;mutex); if (status != 0) err_abort(status, \"Unlock mutex\"); &#125; else misses++; &#125; printf(\"Monitor thread missed update %d times.\\n\", misses); return NULL;&#125;int main()&#123; int status; pthread_t counter_thread_id; pthread_t monitor_thread_id; end_time = time(NULL) + 60; status = pthread_create(&amp;counter_thread_id, NULL, counter_thread, NULL); if (status != 0) err_abort(status, \"Create counter thread\"); status = pthread_create(&amp;monitor_thread_id, NULL, monitor_thread, NULL); if (status != 0) err_abort(status, \"Create monitor thread\"); status = pthread_join(counter_thread_id, NULL); if (status != 0) err_abort(status, \"Join counter thread\"); status = pthread_join(monitor_thread_id, NULL); if (status != 0) err_abort(status, \"Join monitor thread\"); return 0;&#125; 多个互斥量与死锁有时，一个互斥量是不够的，特别是当你的代码需要跨越软件体系内部的界限时。例如，当多个线程同时访问一个队列结构时，你需要两个互斥量，一个用来保护队列头，一个用来保护队列元素内的数据。当为多线程建立一个树型结构时，你可能需要为每个节点设置一个互斥量。 使用多个互斥量会导致复杂度的增加。最坏的情况就是死锁的发生，即两个线程分别锁住了一个互斥量而等待对方的互斥量。一个线程锁住了互斥量 A 后，加锁互斥量 B；同时另一个线程锁住了 B 而等待互斥量 A，则你的代码就产生了经典的死锁现象。 第一个线程 第二个线程 pthread_mutex_lock(&amp;mutex_a) pthread_mutex_lock(&amp;mutex_b) pthread_mutex_lock(&amp;mutex_b) pthread_mutex_lock(&amp;mutex_a) 针对死锁，考虑以下两种通用的解决方法： 固定加锁顺序。所有需要同时加锁互斥量A和互斥量B的代码，必须首先加锁互斥量A，然后锁互斥量B。 试加锁和回退。在锁住某个集合中的第一个互斥量后，使用以 pthread_mutex_trylock 来加锁集合中的其他互斥量，如果失败则将集合中所有己加锁互斥量释放，并重新锁。 如果代码不变量允许先释放互斥量 1,然后再加锁互斥量 2,就可以避免同时拥有两个互斥量的需要。但是，如果存在被破坏的不变置需要锁住不变量 1，则互斥量 1 就不能被释放，直到不变量被恢复为止。在这种情况下， 你应该考虑使用回退（或者试锁-回退 ）算法。 以下程序 backoff.c 演示了如何使用回退算法避免互斥量死锁。程序建立了两个线程线程，一个运行函数 lock_forward,一个个运行函数 lock_backward。程序每次循环都会试图锁住三个互斥量，lock_forward 依次锁住互斥量1、2、3，lock_backward则按相反顺序加锁互斥量： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;pthread.h&gt;#include \"errors.h\"#define ITERATIONS 10pthread_mutex_t mutex[3] = &#123; PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_INITIALIZER&#125;;int backoff = 1;int yield_flag = 0;void *lock_forward(void *arg)&#123; int i, iterate, backoffs; int status; for (iterate = 0; iterate &lt; ITERATIONS; iterate++) &#123; backoffs = 0; for (i = 0; i &lt; 3; i++) &#123; if (i == 0) &#123; status = pthread_mutex_lock(&amp;mutex[i]); if (status != 0) err_abort(status, \"First lock\"); printf(\"forward lock got %d\\n\", i); &#125; else &#123; if (backoff) status = pthread_mutex_trylock(&amp;mutex[i]); else status = pthread_mutex_lock(&amp;mutex[i]); if (status == EBUSY) &#123; backoffs++; printf(\"forward locker backing of at %d\\n\", i); for (; i &gt;= 0; i--) &#123; status = pthread_mutex_unlock(&amp;mutex[i]); if (status != 0) err_abort(status, \"Backoff\"); &#125; &#125; else &#123; if (status != 0) err_abort(status, \"Lock mutex\"); printf(\"forward locker got %d\\n\", i); &#125; &#125; if (yield_flag) &#123; if (yield_flag &gt; 0) sched_yield(); else sleep(1); &#125; &#125; printf(\"lock forward got all locks, %d backoffs\\n\", backoffs); pthread_mutex_unlock(&amp;mutex[0]); pthread_mutex_unlock(&amp;mutex[1]); pthread_mutex_unlock(&amp;mutex[2]); sched_yield(); &#125; return NULL;&#125;void *lock_backward(void *arg)&#123; int i, iterate, backoffs; int status; for (iterate = 0; iterate &lt; ITERATIONS; iterate++) &#123; backoffs = 0; for (i = 2; i &gt;= 0; i--) &#123; if (i == 2) &#123; status = pthread_mutex_lock(&amp;mutex[i]); if (status != 0) err_abort(status, \"First lock\"); printf(\"backward lock got %d\\n\", i); &#125; else &#123; if (backoff) status = pthread_mutex_trylock(&amp;mutex[i]); else status = pthread_mutex_lock(&amp;mutex[i]); if (status == EBUSY) &#123; backoffs++; printf(\"backward locker backing of at %d\\n\", i); for (; i &lt; 3; i++) &#123; status = pthread_mutex_unlock(&amp;mutex[i]); if (status != 0) err_abort(status, \"Backoff\"); &#125; &#125; else &#123; if (status != 0) err_abort(status, \"Lock mutex\"); printf(\"backward locker got %d\\n\", i); &#125; &#125; if (yield_flag) &#123; if (yield_flag &gt; 0) sched_yield(); else sleep(1); &#125; &#125; printf(\"lock backward got all locks, %d backoffs\\n\", backoffs); pthread_mutex_unlock(&amp;mutex[2]); pthread_mutex_unlock(&amp;mutex[1]); pthread_mutex_unlock(&amp;mutex[0]); sched_yield(); &#125; return NULL;&#125;int main(int argc, char *argv[])&#123; pthread_t forward, backward; int status; if (argc &gt; 1) backoff = atoi(argv[1]); if (argc &gt; 2) yield_flag = atoi(argv[2]); status = pthread_create(&amp;forward, NULL, lock_forward, NULL); if (status != 0) err_abort(status, \"Create forward\"); status = pthread_create(&amp;backward, NULL, lock_backward, NULL); if (status != 0) err_abort(status, \"Create backward\"); pthread_exit(NULL);&#125; 如果没有特殊防范机制，这个程序很快就会死锁，如果上面程序运行 backoff 0，就会看到死锁现象： 1234$ ./bin/backoff 0backward lock got 2backward locker got 1forward lock got 0 上面两个线程都调用 pthread_mutex_lock 来加锁每个互斥量，由于线程从不同的端开始，所以它们在中间遇到时就会死锁。而使用回退算法的程序，不管运行多少次循环，上面的程序都会正常执行，而不会发生死锁现象。 条件变量条件变量是用来通知共享数据状态信息的。可以使用条件变量来通知队列已空、或队列非空、或任何其他需要由线程处理的共享数据状态。 当一个线程互斥地访问其享状态时，它可能发现在其他线程改变状态之前它什么也做不了。即没有破坏不变量，但是线程就是对当前状态不感兴趣。例如，一个处理队列的线程发现队列为空时，它只能等恃，直到有一个节点被添加进队列中。 条件变置不提供互斥，需要一个互斥量来同步对共享数据的访问。 一个条件变量应该与一个谓词相关，如果试图将一个条件变量与多个谓词相关，或者将多个条件变量与一个谓词相关，就有陷入死锁或者竞争问题的危险。 创建和释放条件变量程序中由 pthread_cond_t 类型的变量来表示条件变量。如果声明了一个使用默认属性值的静态条件变量，则需要要使用 PTHREAD_COND_TNTTIALIZER 宏初始化，这样初始化的条件变量不必主动释放。 1pthread_cond_tcond = PTHREAD_COND_INITIALIZER; 下面时一个静态初始化条件变量的实例： 12345678910111213141516#include &lt;pthread.h&gt;#include \"errors.h\"typedef struct my_struct_tag&#123; pthread_mutex_t mutex; pthread_cond_t cond; int value;&#125; my_struct_t;my_struct_t data = &#123;PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0&#125;;int main(int argc, char const *argv[])&#123; return 0;&#125; 有时无法静态地初始化一个条件变量，例如，当使用 malloc 分配一个包含条件变量的结构时，这时，你需要调用 pthread_cond_init 来动态地初始化条件变量。当动态初始化条件变量时，应该在不需要它时调用 pthread_cond_destory 来释放它。 12int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *condattr);int pthread_cond_destroy(pthread_cond_t *cond); 下面是一个动态初始化条件变量的实例: 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;pthread.h&gt;#include \"errors.h\"typedef struct my_struct_tag&#123; pthread_mutex_t mutex; pthread_cond_t cond; int value;&#125; my_struct_t;int main(int argc, char const *argv[])&#123; my_struct_t *data; int status; data = malloc(sizeof(my_struct_t)); if (data == NULL) errno_abort(\"Allocate structure\"); status = pthread_mutex_init(&amp;data-&gt;mutex, NULL); if (status != 0) err_abort(status, \"Init mutex\"); status = pthread_cond_init(&amp;data-&gt;cond, NULL); if (status != 0) err_abort(status, \"Init condition\"); status = pthread_cond_destroy(&amp;data-&gt;cond); if (status != 0) err_abort(status, \"Destroy condition\"); status = pthread_mutex_destroy(&amp;data-&gt;mutex); if (status != 0) err_abort(status, \"Destroy mutex\"); free(data); return status;&#125; 等待条件变量和唤醒等待线程每个条件变量必须与一个特定的互斥量、一个谓词条件相关联。当线程等待条件变量时，它必须轉相关互斥量锁住。记住，在阻寒线程之前，条件变量等待操作将解锁互斥量；而在重新返回线程之前，会再次锁住互斥量。 所有并发地（同时）等待同一个条件变量的线程心须指定同一个相关互斥量。例如，Pthreads不允许线程1使用互斥量 A 等待条件变量 A，而线程2使用互斥量 B 等待条件变量 A。不过，以下情况是十分合理的：线程1使用互斥量 A 等待条件变量 A，而线程2使用互斥量 A 等待条件变量 B。即，任何条件变量在特定时刻只能与一个互斥量相关联，而互斥量则可以同时与多个条件变过关联。 12int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);int pthread_cond_timedwait(pthread_cond *cond, pthread_mutex_t *mutex, struct timespec *expiration); 一旦有线程为某个谓词在等待一个条件变量，你可能需要唤醒它。Pthreads 提供了两种方式唤醒等待的线程：一个是“发信号”，一个是“广播”。发信号只唤醒一个等待该条件变量的线程，而广播将唤醒所有等待该条件变量的线程。 广播与发信号真正的区别是效率：广播将唤醒额外的等待线程，而这些线程会检测自己的谓词然后继续等待，通常，不能用发信号代替广播。“当有什么疑惑的时候，就使用广播”。 12int pthread_cond_signal(pthread_cond_t *cond);int pthread_cond_broadcast(pthread_cond_t *cond); 下面实例展示了如何等待条件变量，唤醒正在睡眠的等待线程。线程 wait_thread 等待指定时间后，设置 value 值后，发送信号给条件变量。主线程调用 pthread_cond_timedwait 函数等待最多2秒，如果 hibernation 大于2秒则条件变量等待将会超时，返回 ETIMEOUT;如果 hibernation 设置为2秒，则主线程与 wait_thread 线程发生竞争，每次运行结果可能不同；如果 hibertnation 设置少于2秒，则条件变量等待永远不会超时。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;pthread.h&gt;#include &lt;time.h&gt;#include \"errors.h\"typedef struct my_struct_tag&#123; pthread_mutex_t mutex; pthread_cond_t cond; int value;&#125; my_struct_t;my_struct_t data = &#123;PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0&#125;;int hibernation = 1;void *wait_thread(void *arg)&#123; int status; sleep(hibernation); status = pthread_mutex_lock(&amp;data.mutex); if (status != 0) err_abort(status, \"Lock mutex\"); data.value = 1; status = pthread_cond_signal(&amp;data.cond); if (status != 0) err_abort(status, \"Signal condition\"); status = pthread_mutex_unlock(&amp;data.mutex); if (status != 0) err_abort(status, \"Unlock mutex\"); return NULL;&#125;int main(int argc, char *argv[])&#123; int status; pthread_t wait_thread_id; struct timespec timeout; if (argc &gt; 1) hibernation = atoi(argv[1]); status = pthread_create(&amp;wait_thread_id, NULL, wait_thread, NULL); if (status != 0) err_abort(status, \"Create wait thread\"); timeout.tv_sec = time(NULL) + 2; timeout.tv_nsec = 0; status = pthread_mutex_lock(&amp;data.mutex); if (status != 0) err_abort(status, \"Lock mutex\"); while (data.value == 0) &#123; status = pthread_cond_timedwait(&amp;data.cond, &amp;data.mutex, &amp;timeout); if (status == ETIMEDOUT) &#123; printf(\"Condition wait time out.\\n\"); break; &#125; else if (status != 0) err_abort(status, \"Wait on condition\"); &#125; status = pthread_mutex_unlock(&amp;data.mutex); if (status != 0) err_abort(status, \"Unlock mutex\"); return 0;&#125; 闹钟实例最终版本之前采用 mutex 实现的闹钟版本并不完美，它必须在处理完当前闹铃后，才能检测其他闹铃请求是否已经被加入了列表，即使新的请求的到期时间比当前请求早。例如， 首先输入命令行 10 message1， 然后输入 5 message2，那么程序是无法预知后面5秒的闹钟加入到列表中来了，只能先处理完10秒的闹钟，才能继续处理后面的内容。 我们可以增加条件变量的使用来解决这个问题，新的版本使用一个超时条件变量操作代替睡眠操作，以等待闹钟到时。当主线程在列表中添加了一个新的请求时，将发信号给条件变量，立刻唤醒 alarm_thread 线程。alarm_thread 线程可以重排等待的闹铃请求，然后重新等待。 你可以在 alarm_cond.c 获取源代码实现。 系列文章目录： 概述 线程 同步 使用线程方式 线程高级编程 POSIX 针对线程的调整 线程扩展 线程同步精要 Github 示例源码","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://veinin.com/categories/并发编程/"}],"tags":[{"name":"Phtreads","slug":"Phtreads","permalink":"https://veinin.com/tags/Phtreads/"},{"name":"POSIX Pthreads","slug":"POSIX-Pthreads","permalink":"https://veinin.com/tags/POSIX-Pthreads/"}]},{"title":"POSIX 多线程程序设计-线程","slug":"programming_with_posix_pthreads_02","date":"2018-06-05T14:22:01.000Z","updated":"2018-07-12T14:44:14.938Z","comments":true,"path":"2018/06/05/programming_with_posix_pthreads_02/","link":"","permalink":"https://veinin.com/2018/06/05/programming_with_posix_pthreads_02/","excerpt":"建立和使用线程线程标识符程序中使用线程标识符 ID 来表示线程。线程 ID 属于封装的 pthreadLt 类型。为建立线程，你需要在程序中声明一个 pthread_t 类型的变量。 如果只需在某个函数中使用线程 ID，或者函数直到线程终止时才返回，则可以将线程 ID 声明为自动存储变量，不过大部分时间内， 线程 ID 保存在共享变量中（静态或外部）， 或者保存在堆空间的结构体中。 1pthread_t thread;","text":"建立和使用线程线程标识符程序中使用线程标识符 ID 来表示线程。线程 ID 属于封装的 pthreadLt 类型。为建立线程，你需要在程序中声明一个 pthread_t 类型的变量。 如果只需在某个函数中使用线程 ID，或者函数直到线程终止时才返回，则可以将线程 ID 声明为自动存储变量，不过大部分时间内， 线程 ID 保存在共享变量中（静态或外部）， 或者保存在堆空间的结构体中。 1pthread_t thread; 创建线程通过向 pthread_create 函数传送线程函数地址和线程函数调用的参数来创建线程。线程函数应该只有一个 void * 类型参数，并返回相同的类型值。当创建线程时，pthread_create 函数返回一个 pthread_t 类型的线程 ID, 并保存在 thread 参数中。 通过这个线程 ID， 程序可以引用该线程。 1int pthread_create(pthread_t *thread, const pthreae_attr_t *attr, void *(*start)(void *), void *arg); 获得自己的线程ID线程可以通过调用 pthread_self 来获得自身的 ID。除非线程的创建者或者线程本身将线程 ID 保存于某处，否则不可能获得一个线程的 ID。要对线程进行任何操作都必须通过线程 ID。 1pthread_t pthread_self(void); 比较线程可以使用 pthread_equal 函数来比较两个线程 ID,只能比较二者是否相同。比较两个线程 ID 谁大谁小是没有任何意义的，因为线程 ID 之间不存在顺序。如果两个线程 ID 表示同一个线程，则 pthread_equal 函数返回非零值，否则返回零值。 1int pthread_equal(pthread_t tl, pthread_t t2); // 相等返回非0值 分离线程如果要创建一个从不需要控制的线程，可以是用属性（attribute）来建立线程以使它可分离的。如果不想等待创建的某个线程，而且知道不再需要控制它，可以使用 pthread_detach 函数来分离它。分离一个正在运行的线程不会对线程带来任何影响，仅仅是通知系统当该线程结束时，其所属资源可以被回收。 1int pthread_detach(pthread_t thread); 退出线程当 C 程序运行时，首先运行 main 函数。在线程代码中， 这个特殊的执行流被称为 “初始线程” 或 “主线程”。 你可以在初始线程中做任何你能在普通线程中做的事情。也可以调用 pthread_exit 来终止自己。 1int pthread_exit(void *value_ptr); 取消线程外部发送终止信号给指定线程，如果成功则返回0，否则返回非0。发送成功并不意味着线程会终止。另外，如果一个线程被回收，终止线程的 ID 可能被分配给其他新的线程，使用该 ID 调用 pthread_cancel 可能就会取消一个不同的线程， 而不是返回 ESRCH 错误。 1int pthread_cancel(pthread_t thread); 等待线程结束如果需要获取线程的返回值，或者需要获知其何时结束，应该调用 pthread_join 函数。 pthread_join 函数将阻塞其调用者直到指定线程终止。然后，可以选择地保存线程的返回值。调用 pthread_join 函数将自动分离指定的线程。线程会在返回时被回收，回收将释放所有在线程终止时未释放的系统和进程资源，包栝保存线程返回值的内存空间、堆栈、保存寄存器状态的内存空间等。所以，在线程终止后上述资源就不该被访问了。 1int pthread_join(pthread_t thread, void **value_ptr); 线程生命周期线程有四种基本状态： 就绪（Ready）状态。线程能够运行，但在等待可用的处理器，可能刚刚启动，或刚刚从阻塞中恢复，或者被其他线程抢占。 运行（Running）状态。线程正在运行，在多处器系统中，可能有多个线程处于运行态线程由于等待处理器外的其他条件无法运行，如条件变量的改变、加锁互斥量或 I/O 操作结束。 阻塞（Blocked）状态。线程由于等待处理器外的其他条件无法运行，如条件变量的改变、加锁互斥量或 I/O 操作结束。 终止（Terminated）状态。线程从起始函数中返回，或调用 pthread_exit，或者被取消，终止自己并完成所有资源清理。不是被分离，也不是被连接，一且线程被分离或者连接，它就可以被收回。 下面是线程的状态转换图： 下面程序展示了一个线程使用的完整生命周期实例： 12345678910111213141516171819202122232425#include &lt;pthread.h&gt;#include \"errors.h\"void *thread_routine(void *arg) &#123; return arg;&#125;int main(void) &#123; pthread_t thread_id; void *thread_result; int status; status = pthread_create(&amp;thread_id, NULL, thread_routine, NULL); if (status != 0) err_abort(status, \"Create thread\"); status = pthread_join(thread_id, &amp;thread_result); if (status != 0) err_abort(status, \"Join thread\"); if (thread_result == NULL) return 0; else return 1;&#125; 上面程序中 pthread_create 创建线程后，线程处于就绪状态。受调度机制的限制，新线程可能在就绪状态下停留一段时间才被执行。当处理器选中一个就绪线程执行它时，该线程进入运行态。通常这意味着某个其他线程被阻塞或者被时间片机制抢占，处理器会保存被阻塞（或抢占）线程的环境并恢复下二个就绪线程的环境。主线程在调用 pthread_join 进入阻塞状态，等待它创建的线程运行结束。当调用 pthread_exit 退出线程或调用 pthread_cancel 取消线程时， 线程在调用完清理过程后也将进入终止态。而主线程等到创建的线程终止后重新运行直到结束。 系列文章目录： 概述 线程 同步 使用线程方式 线程高级编程 POSIX 针对线程的调整 线程扩展 线程同步精要 Github 示例源码","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://veinin.com/categories/并发编程/"}],"tags":[{"name":"Phtreads","slug":"Phtreads","permalink":"https://veinin.com/tags/Phtreads/"},{"name":"POSIX Pthreads","slug":"POSIX-Pthreads","permalink":"https://veinin.com/tags/POSIX-Pthreads/"}]},{"title":"POSIX 多线程程序设计-概述","slug":"programming_with_posix_pthreads_01","date":"2018-06-01T11:32:05.000Z","updated":"2018-07-12T14:43:46.241Z","comments":true,"path":"2018/06/01/programming_with_posix_pthreads_01/","link":"","permalink":"https://veinin.com/2018/06/01/programming_with_posix_pthreads_01/","excerpt":"术语定义同步与异步同步（synchronous）意味着同时在一起工作。例如聊天室和在线会议就是同步的好例子，在聊天室中，人们对彼此的对话会立即得到反应。同步相对来说比较简单，但开销相对较大。 异步（asynchronous) 表明事情相互独立地发生， 异步双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送。例如论坛和电子邮件就是采用异步通信的一个好例子，这样沟通的双方都会有足够的时间去思考。异步增加了复杂性以及更加麻烦的调试过程。如果你没有同时执行多个活动， 那么异步就没有什么优势。 如果你开始了一个异步活动， 然后什么也不做等待它结束， 则你并没有从异步那儿获得太多好处。","text":"术语定义同步与异步同步（synchronous）意味着同时在一起工作。例如聊天室和在线会议就是同步的好例子，在聊天室中，人们对彼此的对话会立即得到反应。同步相对来说比较简单，但开销相对较大。 异步（asynchronous) 表明事情相互独立地发生， 异步双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送。例如论坛和电子邮件就是采用异步通信的一个好例子，这样沟通的双方都会有足够的时间去思考。异步增加了复杂性以及更加麻烦的调试过程。如果你没有同时执行多个活动， 那么异步就没有什么优势。 如果你开始了一个异步活动， 然后什么也不做等待它结束， 则你并没有从异步那儿获得太多好处。 并发与并行并发（concurrency ) 的意思是指事情同时发生。 也是指让实际上可能串行发生的事情好像同时发生一样。 并发描述了单处理器系统中线程或进程的行为特点。在 POSIX 中，并发的定义要求“延迟调用线程的函数不应该导致其他线程的无限期延迟。 并行（parallelism) 指并发序列同时执行， 换言之，软件中的“并行”语言中的“并发”是相同的意思， 而区別于软件中的“并发”。指事情在相同的方向上独立进行（没有交错）。 真正的并行只能在多处理器系统中存在， 但是并发可以在单处理器系统和多处理器系统中都存在。并发能够在单处理器系统中存在是因为并发实际上是并行的假象。 并行要求程序能够同时执行多个操作，而并发只要求程序能够假装同时执行多个操作。 单处理器和多处理器单处理器是指一台计算机只有一个编程人员可见的执行单元（处理器）。对于拥有超标量体系结构、向量或者其他数学或 I/O 协处理器的单一通用处理器，我们仍然把它当成单处理器。 多处理器是指一台计算机拥有多个处理器，它们共享同一个指令集和相同的物理内存。虽然处理器不必同等地访问所有物理内存，但是每一个应该都能访问大部分内存。 线程安全和可重入线程安全是指代码能够被多个线程调用而不会产生灾难性的结果。它补要求代码在多个线程中高效的运行，只要求能够安全的运行。人部分现行函数可以利用 Pthreads 提供的互斥量、 条件变量和线程私有数据来实现线程的安全。比如，在进入函数时加锁，在退出函数时解锁。这样的函数可以被多个线程调用，但一次只能有一个线程调用它。 “可重入”有时用来表示”有效的线程安全”。意味着函数不在连续的调用中保存静态数据，也不返回指向静态数据的指针。所有的数据都是由函数的调用程序提供的。重入函数不得调用非重入函数。 线程的好处多线程编程模型具有以下优点： 在多处理器系统中开发程序的并行性，除了并行性这一优点是需要特殊硬件支持外， 其他优点对硬件不做要求。 在等待慢速外设 I/O 操作结束的同时， 程序可以执行其他计算， 为程序的并发提供更有效、 更自然的开发方式。 一种模块化编程模型， 能清晰地表达程序中独立事件间的相互关系。 线程的代价任何事情都有代价，线程也不例外。在很多情形下好处超过了代价，在其他情形下则相反。 计算负荷。比如线程间同步会直接影响运行时间，对于两个总是同时使用的变量分别加以保护，这意味着你在同步上花费太多的时间而损失了并发。 编程规则。尽管线程编程模型的基本思想简单，但是编写实际的代码不是件容易的事。编写能够在多个线程中良好工作的代码需要认真的思考和计划。你需要明白同步协议和程序中的不变量（invariant), 你不得不避免死锁、竞争和优先级倒置。 更难以调试。调试不可避免地要改变事件的时序。在调试串行代码时不会有什么大问题，但是在调试异步代码时却是致命的。如果一个线程因调试陷阱而运行得稍微慢了，则你要跟踪的问题就可能不会出现。每个程序员都会遇到此类在调试时无法再现的错误，这在线程编程中会更加普遍。 选择线程还是不用线程线程并非总是容易使用，而且并非总是可达到最好的性能。一些问题本身就是非并发的，添加线程线程只能降低程序的性能并使程序复杂。如果程序中的每一步都需要上一步的结果，则使用线程不会有任何帮助。每个线程不得不等待其他线程的结束。 最适合使用线程的应用包括以下这些： 计算密集型应用，为了能在多处理器系统上运行，将这些计算分解到多个线程中实现。 I/O 密集型应用，为提高性能，将 I/O 操作重叠。很多线程可以同时等待不同的 I/O 操作。分布式服务器应用就是很好的实例，它们必须响应多个客户的请求，必须为通过慢速网络的连接主动提供 I/O 准备。 POSIX线程概念POSIX 线程线程 API 遵循国际正式标准 POSIX 1003.1c-1995, 我们将使用非正式的术语 “Pthreads” 代表 “POSIX 1003.1c-1995”。 线程系统包含三个基本要素： 执行环境，是并发实体的状态。 并发系统必须提供建立、 删除执行环境和独立维护它们状态的方式。 调度，决定在某个给定时刻该执行哪个环境（或环境组）， 并在不同的环境中切换。 同步，为并发执行的环境提供了协调访问共享资源的一种机制。 下表列出了上述三方面的几个不同的实例： 环境 执行环境 调度 同步 交通 汽车 红绿灯 转变信号和刹车灯 UNIX ( 无线程 ) 进程 优先级 等待和管道 Pthreads 线程 策略、 优先级 条件变量和互斥量 结构概述使用 Pthreads, 通过调用 pthread_create 来创建执行环境（线程）。 创建一个线程同样也调度了该线程的执行，这将通过调用指定的 “线程启动” 函数开始。Pthreads 允许在创建线程时指定调度参数，或者在线程运行时设定。当线程调用 pthread_exit 时退出，或者也可以从线程启动函数中返回时退出。 基本的 Pthreads 同步模型使用 互斥量 来保护共享数据，使用 条件变量 来通信，还可以使用其他的同步机制，如 信号量、管道 和 消息队列。互斥量允许线程在访问共享数据时锁定它，以避免其他线程的干扰。条件变量允许线程等待共享数据到达某个期望的状态（例如队列非空或者资源可用）。 类型和接口POSIX 线程数据类型： 类型 描述 pthread_t 线程标识符 pthreae_mutex_t 互斥量 pthread_code_t 条件变量 pthread_key_t 线程私有权握访问键 pthread_attr_t 线程属性对象 pthread_mutexattr_t 互斥量属性对 pthread_condattr_t 条件变属性对象 pthread_once_t “一次性初始化”控制变量 错误检查在传统的UNIX系统和原来的标准中．errno 是一个外部整型变量。由于该变量一次只能有一个值，所以只能支持进程中的单一执行流程。传统的报错机制有许多问题，包括很难创建在报错的同时返回一个有用的 -1 值的函数。当引入多线程时会有更严重的问题。Pthreads 修订版是 POSIX 中第一个与传统的 UNIX 和 C 语言报错机制相分离的部分。Pthreads 中的新函数通过返回值来表示错误状态，而不是用变量。当成功时，Pthreads 函数返回 0, 并包含一个额外的输出参数来指向存有“有用结果”的地址。当发生错误时，函数返回一个包含在 errno 变量以支持其他使用 &lt;errao.h&gt; 文件中的错误代码。 下面程序是一个典型的线程错误检查代码，因为 pthread_t 变量拥有一个无效的值，所以在使用 pthread_join 在遇到无效线程ID时会返回错误代码 ESRCH。运行下面程序将显示错误消息：error 3: No such process。 12345678910111213141516#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;int main()&#123; pthread_t thread; int status; status = pthread_join(thread, NULL); if (status != 0) fprintf(stderr, \"error %d: %s\\n\", status, strerror(status)); return status;&#125; 为了避免在实例代码的每个函数调用中都增加报错和退出的代码段，我们需要写两个报错宏使用 err_abort 检测标准的 Pthreads 错误， 使用 errno_abort 检测传统的 errno 错误变量方式。 12345678910111213#define err_abort(code, text) \\ do &#123;\\ fprintf(stderr, \"%s at \\\"%s\\\":%d: %s\\n\",\\ text, __FILE__, __LINE__, strerror(code));\\ abort();\\ &#125; while(0)#define errno_abort(text) \\ do &#123;\\ fprintf(stderr, \"%s at \\\"%s\\\":%d: %s\\n\",\\ text, __FILE__, __LINE__, strerror(errno));\\ abort();\\ &#125; while(0) 异步编程举例下面使用一个简单的闹钟实例程序来演示基本的异歩编程方法。该程序循环接受用户输入信息，直到出错或者输入完毕，用户输入的每行信息中，第一部分是闹钟等待的时间（ 以秒为单位），第二部分是闹钟时间到迖时显示的文本消息。 同步版本一直同步等待 fgets 产生输入，然后根据输入的秒数进行等待指定时间，最后输出闹钟响起的消息。该程序的问题是一次只能处理一个闹钟请求，如果你的程序设置了一个10分钟闹钟，就不能再继续让它在5分钟时响起另外一个闹钟。 1234567891011121314151617181920212223#include \"errors.h\"int main(void) &#123; int seconds; char line[128]; char message[64]; while(1) &#123; printf(\"Alarm&gt; \"); if (fgets(line, sizeof(line), stdin) == NULL) exit(0); if (strlen(line) == 0) continue; if (sscanf(line, \"%d %64[^\\n]\", &amp;seconds, message) &lt; 2) &#123; fprintf(stderr, \"Bad command\\n\"); &#125; else &#123; sleep(seconds); printf(\"(%d) %s\\n\", seconds, message); &#125; &#125;&#125; 多进程版本为每个命令使用 fork 调用生成一个独立的子进程来处理闹钟。fork 版本是异步方式的的一种实现，该程序可以随时输入命令行，它们被彼此独立地执行。 新版本并不比同步版本复杂多少。该版本的主要难点在于对所有己终止子进程的 reap。如果程序不做这个工作，则要等到程序退出的时候由系统回收，通常回收子进程的方法是调用某个 wait 系列函数。在本例中，我们调用 waitpid 函数，并设置 WNOHANG（父进程不必挂等待子进程的结束）。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;sys/types.h&gt;#include &lt;wait.h&gt;#include \"errors.h\"int main(void) &#123; pid_t pid; int seconds; char line[128]; char message[64]; while(1) &#123; printf(\"Alarm&gt; \"); if (fgets(line, sizeof(line), stdin) == NULL) exit(0); if (strlen(line) &lt;= 1) continue; if (sscanf(line, \"%d %64[^\\n]\", &amp;seconds, message) &lt; 2) &#123; fprintf(stderr, \"Bad command\\n\"); &#125; else &#123; pid = fork(); if (pid == -1) errno_abort(\"Fork\"); if (pid == (pid_t)0) &#123; sleep(seconds); printf(\"(%d) %s\\n\", seconds, message); exit(0); &#125; else &#123; do &#123; pid = waitpid((pid_t)-1, NULL, WNOHANG); if (pid == (pid_t) -1) errno_abort(\"Wait for child\"); &#125; while(pid != (pid_t)0); &#125; &#125; &#125;&#125; 多线程版本多线程版本与多进程十分相似，只是使用线程而非子进程来实现异步闹钟。本例中用到了以下三个Pthread函数： pthread_create 函数建立一个线程， 运行由第三个参数 alarm_thread 指定的例程，并返回线程标识符 ID (保存在 thread 引用的变量中） pthread_self 获取当前线程标识符 ID。 pthread_detach 函数允许在当线程终止时立刻回收线程资源。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include \"errors.h\"#include &lt;pthread.h&gt;typedef struct alarm_tag &#123; int seconds; char message[64];&#125; alarm_t;void *alarm_thread(void *arg) &#123; alarm_t *alarm = (alarm_t*)arg; int status; status = pthread_detach(pthread_self()); if (status != 0) err_abort(status, \"Detach thread\"); sleep(alarm-&gt;seconds); printf(\"(%d) %s\\n\", alarm-&gt;seconds, alarm-&gt;message); free(alarm); return NULL;&#125;int main(void) &#123; int status; int seconds; char line[128]; alarm_t *alarm; pthread_t thread; while(1) &#123; printf(\"Alarm&gt; \"); if (fgets(line, sizeof(line), stdin) == NULL) exit(0); if (strlen(line) &lt;= 1) continue; alarm = (alarm_t*)malloc(sizeof(alarm_t)); if (alarm == NULL) errno_abort(\"Allocate alarm\"); if (sscanf(line, \"%d %64[^\\n]\", &amp;alarm-&gt;seconds, alarm-&gt;message) &lt; 2) &#123; fprintf(stderr, \"Bad command\\n\"); free(alarm); &#125; else &#123; status = pthread_create(&amp;thread, NULL, alarm_thread, alarm); if (status != 0) err_abort(status, \"Create alarm thread\"); &#125; &#125;&#125; 系列文章目录： 概述 线程 同步 使用线程方式 线程高级编程 POSIX 针对线程的调整 线程扩展 线程同步精要 Github 示例源码","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://veinin.com/categories/并发编程/"}],"tags":[{"name":"Phtreads","slug":"Phtreads","permalink":"https://veinin.com/tags/Phtreads/"},{"name":"POSIX Pthreads","slug":"POSIX-Pthreads","permalink":"https://veinin.com/tags/POSIX-Pthreads/"}]},{"title":"Windows 10 子系统安装指南","slug":"windows-10-bash-linux-subsystem-setup","date":"2018-05-09T14:50:00.000Z","updated":"2018-05-09T16:03:07.306Z","comments":true,"path":"2018/05/09/windows-10-bash-linux-subsystem-setup/","link":"","permalink":"https://veinin.com/2018/05/09/windows-10-bash-linux-subsystem-setup/","excerpt":"安装 Windows 的 Linux 子系统步骤1 开启开发者模式菜单栏搜索 -&gt; 设置 -&gt; 针对开发人员 -&gt; 开发者模式 -&gt; 等待下载相关软件","text":"安装 Windows 的 Linux 子系统步骤1 开启开发者模式菜单栏搜索 -&gt; 设置 -&gt; 针对开发人员 -&gt; 开发者模式 -&gt; 等待下载相关软件 步骤2 开启 Windows 子系统功能菜单栏搜索 -&gt; 控制面板 -&gt; 程序 -&gt; 勾选 “启动或关闭 Windows 功能” -&gt; 确定 -&gt; 重启电脑 步骤3 查看 Bash 程序菜单栏搜索 -&gt; Bash -&gt; 打开后提示可以通过 Windows 应用商店来安装分发版 步骤4 安装 ubuntu 子系统打开 Windows 应用商店 -&gt; 搜索 ubuntu -&gt; 点击进入并选择安装 -&gt; 等待安装完成 步骤5 设置用户名、密码从 Windows 商店或菜单栏搜索 Ubuntu 程序启动 -&gt; 等待几分钟后 -&gt; 输入子系统的用户名和密码 -&gt; 完成安装 升级到最新版本子系统终端输入：12sudo apt updatesudo apt upgrade Hyper 整合 Bash在终端你可以使用 bash 命令直接进入ubuntu子系统，但是 Windows 终端对于开发人员来说还是很难用的，更加推荐第三方的终端软件，比如以下两个软件： hyper cmder 这里推荐的是 hyper 终端软件，它是一个非常漂亮且实用的终端软件，并且提供了一大堆漂亮的插件和主题。 Hyper 设置直接启动 bash 终端步骤：设置按钮 -&gt; Editor -&gt; Preferences -&gt; 设置文本中找到 shell 一栏 -&gt; 填入 bash.exe 路径 设置完毕后，重新打开 hyper，会自动执行 bash 命令进入 Linux 子系统。 VS Code 集成 BashVS Code 终端默认使用的终端是 PowwerShell，你可以设置终端使用 Bash，这样你就可以在 VS Code 编辑代码后，直接在 Bash 终端里面编译、运行查看结果了。 VS Code 设置默认终端步骤：文件菜单 -&gt; 首选项 -&gt; 设置 -&gt; 将 &quot;terminal.integrated.shell.windows&quot;: &quot;C:\\\\Windows\\\\System32\\\\bash.exe&quot;, 加入到用户设置 -&gt; 保存 设置完毕后，重新打开终端，可以看到默认打开的是 bash 终端了。","categories":[{"name":"System","slug":"System","permalink":"https://veinin.com/categories/System/"}],"tags":[{"name":"Windows 10 Bash","slug":"Windows-10-Bash","permalink":"https://veinin.com/tags/Windows-10-Bash/"},{"name":"Linux Subsystem Setup","slug":"Linux-Subsystem-Setup","permalink":"https://veinin.com/tags/Linux-Subsystem-Setup/"}]},{"title":"Python 快速上手 - 文件","slug":"python-practice-files","date":"2018-04-19T13:35:00.000Z","updated":"2018-04-19T14:51:39.588Z","comments":true,"path":"2018/04/19/python-practice-files/","link":"","permalink":"https://veinin.com/2018/04/19/python-practice-files/","excerpt":"os.path 模块os.path 模块包含了许多与文件名和文件路径相关的有用函数。例如， 你已经使用了 os.path.join()来构建所有操作系统上都有效的路径。因为 os.path 是 os 模块中的模块， 所以只要执行 import os 就可以导入它。 1import os 文件与文件路径在 Windows 上， 路径书写使用倒斜杠作为文件夹之间的分隔符。但在 OS X 和Linux 上， 使用正斜杠作为它们的路径分隔符。如果想要程序运行在所有操作系统上，在编写 Python 脚本时， 就必须处理这两种情况。Python 使用 os.path.join() 函数来做这件事很简单。如果将单个文件和路径上的文件夹名称的字符串传递给它， os.path.join() 就会返回一个文件路径的字符串","text":"os.path 模块os.path 模块包含了许多与文件名和文件路径相关的有用函数。例如， 你已经使用了 os.path.join()来构建所有操作系统上都有效的路径。因为 os.path 是 os 模块中的模块， 所以只要执行 import os 就可以导入它。 1import os 文件与文件路径在 Windows 上， 路径书写使用倒斜杠作为文件夹之间的分隔符。但在 OS X 和Linux 上， 使用正斜杠作为它们的路径分隔符。如果想要程序运行在所有操作系统上，在编写 Python 脚本时， 就必须处理这两种情况。Python 使用 os.path.join() 函数来做这件事很简单。如果将单个文件和路径上的文件夹名称的字符串传递给它， os.path.join() 就会返回一个文件路径的字符串 1234567891011&gt;&gt;&gt; import os&gt;&gt;&gt; os.path.join(&apos;usr&apos;, &apos;bin&apos;, &apos;spam&apos;)&apos;usr\\\\bin\\\\spam&apos;&gt;&gt;&gt;&gt;&gt;&gt; myFiles = [&apos;a.txt&apos;, &apos;b.txt&apos;, &apos;c.txt&apos;]&gt;&gt;&gt; for fileName in myFiles: print(os.path.join(&apos;C:\\\\Users\\\\App&apos;, fileName))C:\\Users\\App\\a.txtC:\\Users\\App\\b.txtC:\\Users\\App\\c.txt 当前工作目录每个运行在计算机上的程序， 都有一个“ 当前工作目录”， 或 cwd。利用 os.getcwd() 函数，可以取得当前工作路径的字符串， 并可以利用 os.chdir() 改变它。 12345&gt;&gt;&gt; os.getcwd()&apos;C:\\\\Users\\\\Ansh&apos;&gt;&gt;&gt; os.chdir(&apos;C:\\\\App&apos;)&gt;&gt;&gt; os.getcwd()&apos;C:\\\\App&apos; 创建新文件夹可以用 os.makedirs() 函数创建新文件夹（ 目录）。1os.makedirs(&apos;C:\\\\Users\\\\Ansh\\\\Desktop\\\\Test&apos;) 处理绝对路径和相对路径有两种方法指定一个文件路径。 “绝对路径”， 总是从根文件夹开始。 “相对路径”，它相对于程序的当前工作目录。还有点（ .）和点点（ ..）文件夹。它们不是真正的文件夹，而是可以在路径中使用的特殊名称。 os.path 模块提供了一些函数， 返回一个相对路径的绝对路径， 以及检查给定的路径是否为绝对路径。 调用 os.path.abspath(path) 将返回参数的绝对路径的字符串。 调用 os.path.isabs(path) ，如果参数是一个绝对路径，就返回 True，如果参数是一个相对路径，就返回 False。 调用 os.path.relpath(path, start) 将返回从 start 路径到 path 的相对路径的字符串。如果没有提供 start，就使用当前工作目录作为开始路径。 调用 os.path.dirname(path) 将返回一个字符串，它包含 path 参数中最后一个斜杠之前的所有内容。 调用 os.path.basename(path) 将返回一个字符串，它包含 path 参数中最后一个斜杠之后的所有内容。 调用 os.path.split() 获得一个路径的目录名称和基本名称， 会返回两个字符串的元组 12345678910111213141516171819202122&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)&apos;C:\\\\App&apos;&gt;&gt;&gt; os.path.abspath(&apos;.\\\\Scripts&apos;)&apos;C:\\\\App\\\\Scripts&apos;&gt;&gt;&gt; os.path.isabs(&apos;.&apos;)False&gt;&gt;&gt; os.path.isabs(os.path.abspath(&apos;.&apos;))True&gt;&gt;&gt; os.path.relpath(&apos;C:\\\\Windows&apos;, &apos;C:\\\\&apos;)&apos;Windows&apos;&gt;&gt;&gt; os.path.relpath(&apos;C:\\\\Windows&apos;, &apos;C:\\\\spam\\\\eggs&apos;)&apos;..\\\\..\\\\Windows&apos;&gt;&gt;&gt;&gt;&gt;&gt; path = &apos;C:\\\\Windows\\\\System32\\\\calc.exe&apos;&gt;&gt;&gt; os.path.basename(path)&apos;calc.exe&apos;&gt;&gt;&gt; os.path.dirname(path)&apos;C:\\\\Windows\\\\System32&apos;&gt;&gt;&gt; os.path.split(path)(&apos;C:\\\\Windows\\\\System32&apos;, &apos;calc.exe&apos;)&gt;&gt;&gt; path.split(os.path.sep)[&apos;C:&apos;, &apos;Windows&apos;, &apos;System32&apos;, &apos;calc.exe&apos;] 文件大小和文件夹内容一旦有办法处理文件路径， 就可以开始搜集特定文件和文件夹的信息。 调用 os.path.getsize(path) 将返回 path 参数中文件的字节数。 调用 os.listdir(path) 将返回文件名字符串的列表，包含 path 参数中的每个文件。 1234&gt;&gt;&gt; os.path.getsize(&apos;C:\\\\Windows\\\\System32\\\\calc.exe&apos;)26112L&gt;&gt;&gt; os.listdir(&apos;C:\\\\App\\\\Python27&apos;)[&apos;DLLs&apos;, &apos;Doc&apos;, &apos;include&apos;, &apos;Lib&apos;, &apos;libs&apos;, &apos;LICENSE.txt&apos;, &apos;NEWS.txt&apos;, &apos;python.exe&apos;, &apos;pythonw.exe&apos;, &apos;README.txt&apos;, &apos;Scripts&apos;, &apos;tcl&apos;, &apos;Tools&apos;, &apos;w9xpopen.exe&apos;] 检查路径有效性如果你提供的路径不存在， 许多 Python 函数就会崩溃并报错。 os.path 模块提供了一些函数，用于检测给定的路径是否存在，以及它是文件还是文件夹。 调用 os.path.exists(path) ，返回所指的文件或文件夹是否存在。 调用 os.path.isfile(path) ，返回目标是否一个文件。 调用 os.path.isdir(path) ，返回目标是否一个文件夹。 打开并读写文件在 Python 中， 读写文件有 3 个步骤： 调用 open() 函数， 返回一个 File 对象。 调用 File 对象的 read() 或 write() 方法。 调用 File 对象的 close() 方法，关闭该文件。 打开文件 open() 方法，“读模式”、“ 写模式” 和 “添加模式”。如果打开文件时用读模式，就不能写入文件。而写模式将覆写原有的文件。添加模式将在已有文件的末尾添加文本。open 方法有第二个可选参数，如果不传则是读模式打开， 参数 ‘w’ 将使用写模式打开，而参数 ‘a’ 将以添加模式打开。 对于读取文件，还可以使用 readlines() 方法， 从该文件取得一个字符串的列表。 123456789101112131415161718192021222324252627&gt;&gt;&gt; helloFile = open(&apos;C:\\\\Users\\\\Ansh\\\\Desktop\\\\hello.txt&apos;)&gt;&gt;&gt; helloContent = helloFile.read()&gt;&gt;&gt; helloContent&apos;Hello, World!&apos;&gt;&gt;&gt;&gt;&gt;&gt; textFile = open(&apos;C:\\\\Users\\\\Ansh\\\\Desktop\\\\text.txt&apos;)&gt;&gt;&gt; for line in textFile.readlines(): print(line.strip())When, in disgrace with fortune and men&apos;s eyes,I all alone beweep my outcast state,And trouble deaf heaven with my bootless cries,And look upon myself and curse my fate,&gt;&gt;&gt;&gt;&gt;&gt; baconFile = open(&apos;bacon.txt&apos;, &apos;w&apos;)&gt;&gt;&gt; baconFile.write(&apos;Hello world!\\n&apos;)&gt;&gt;&gt; baconFile.close()&gt;&gt;&gt;&gt;&gt;&gt; baconFile = open(&apos;bacon.txt&apos;, &apos;a&apos;)&gt;&gt;&gt; baconFile.write(&apos;Bacon is not a vegetable.&apos;)&gt;&gt;&gt; baconFile.close()&gt;&gt;&gt;&gt;&gt;&gt; baconFile = open(&apos;bacon.txt&apos;)&gt;&gt;&gt; print(baconFile.read())Hello world!Bacon is not a vegetable.&gt;&gt;&gt; baconFile.close() 使用 shelve 模块保存变量你可以将 Python 程序中的变量保存到二进制的 shelf 文件中。这样， 程序就可以从硬盘中恢复变量的数据。 shelve 模块让你在程序中添加“ 保存”和“ 打开” 功能。 要利用 shelve 模块读写数据，首先要导入它。调用函数 shelve.open() 并传入一个文件名，然后将返回的值保存在一个变量中。可以对这个变量的 shelf 值进行修改，就像它是一个字典一样。当你完成时，在这个值上调用 close()。最后，在当前的工作目录下会生成一个对应的二进制文件。 1234shelfFile = shelve.open(&apos;mydata&apos;)cats = [&apos;Zophie&apos;, &apos;Pooka&apos;, &apos;Simon&apos;]shelfFile[&apos;cats&apos;] = catsshelfFile.close() 然后，可以使用 shelve 模块， 重新打开这些文件并取出数据。shelf 值不必用读模式或写模式打开，因为它们在打开后，既能读又能写。 123shelfFile = shelve.open(&apos;mydata&apos;)print(shelfFile[&apos;cats&apos;]) # [&apos;Zophie&apos;, &apos;Pooka&apos;, &apos;Simon&apos;]shelfFile.close() shutil 模块shutil（或称为 shell 工具）模块中包含一些函数，让你在 Python 程序中复制、移动、改名和删除文件。要使用 shutil 的函数，首先需要 import shutil。 复制文件和文件夹调用 shutil.copy(source, destination)，将路径 source 处的文件复制到路径 destination处的文件夹。如果 destination 是一个文件名，它将作为被复制文件的新名字。该函数返回一个字符串，表示被复制文件的路径。另外，可以使用 shutil.copytree() 复制整个文件夹里面包含的文件夹和文件。 1234567import shutil, osos.chdir(&apos;C:\\\\&apos;)shutil.copy(&apos;C:\\\\Users\\\\Ansh\\\\Desktop\\\\hello.txt&apos;, &apos;C:\\\\temp&apos;)shutil.copy(&apos;C:\\\\temp\\\\hello.txt&apos;, &apos;C:\\\\temp\\\\hello2.txt&apos;)shutil.copytree(&apos;C:\\\\temp&apos;, &apos;C:\\\\Users\\\\Ansh\\\\Desktop\\\\temp_backup&apos;) 移动或改名文件和文件夹调用 shutil.move(source, destination)， 将路径 source 处的文件夹移动到路径 destination。 12shutil.move(&apos;C:\\\\temp&apos;, &apos;C:\\\\Users\\\\Ansh\\\\Desktop&apos;)shutil.move(&apos;C:\\\\text.txt&apos;, &apos;C:\\\\Users\\\\Ansh\\\\Desktop\\\\temp&apos;) 永久删除文件和文件夹利用 os 模块中的函数，可以删除一个文件或一个空文件夹。但利用 shutil 模块，可以删除一个文件夹及其所有的内容。 调用 os.unlink(path) 将删除 path 处的文件。 调用 os.rmdir(path) 将删除 path 处的文件夹。 调用 shutil.rmtree(path) 将删除 path 处的文件夹，它包含的所有文件和文件夹都会被删除。 12345678for filename in os.listdir(&apos;C:\\\\Users\\\\Ansh\\\\Desktop&apos;): if filename.endswith(&apos;.txt&apos;): os.unlink(filename)os.makedirs(&apos;Test&apos;)os.rmdir(&apos;Test&apos;)shutil.rmtree(&apos;temp_back&apos;) 遍历目录树如果你需要对某个文件夹中的所有文件改名， 包括该文件夹中所有子文件夹中的所有文件。也就是说， 你希望遍历目录树， 处理遇到的每个文件。写程序完成这件事，可能需要一些技巧。 好在， Python 提供了一个 os.walk() 函数， 替你处理这个过程。os.walk() 函数被传入一个字符串值，即一个文件夹的路径。你可以在一个 for循环语句中使用 os.walk()函数，遍历目录树。 os.walk() 在循环的每次迭代中，返回 3 个值： 当前文件夹名称的字符串。 当前文件夹中子文件夹的字符串的列表。 当前文件夹中文件的字符串的列表。 123456789101112import ospath = &apos;C:\\\\Users\\\\Ansh\\\\Desktop\\\\Source\\\\lua-5.3.4&apos;for folderName, subFolders, fileNames in os.walk(path): print(&apos;The current folder is &apos; + folderName) for subFolder in subFolders: print(&apos;Sub folder of &apos; + folderName + &apos; : &apos; + subFolder) for fileName in fileNames: print(&apos;File inside &apos; + folderName + &quot; : &quot; + fileName) 使用 zipfile 模块压缩文件我们经常需要对一组文件进行压缩，减少它的大小，然后在网络上进行传输。ZIP 文件（ 带有.zip 文件扩展名）， 它可以包含许多其他文件的压缩内容。在 Python 程序可以利用 zipfile 模块中的函数创建和打开（或解压） ZIP 文件。 创建和添加到 ZIP 文件要创建你自己的压缩 ZIP 文件， 必须以“写模式”打开 ZipFile 对象，即传入’w’作为第二个参数。如果向 ZipFile 对象的 write() 方法传入一个路径， Python 就会压缩该路径所指的文件， 将它加到 ZIP 文件中。write() 方法的第一个参数是一个字符串， 代表要添加的文件名。第二个参数是“压缩类型”参数，它告诉计算机使用怎样的算法来压缩文件。 12345import zipfilenewZip = zipfile.ZipFile(&apos;new.zip&apos;, &quot;w&quot;)newZip.write(&apos;myCats.py&apos;, compress_type=zipfile.ZIP_DEFLATED)newZip.close() 读取 ZIP 文件可以使用 zipfile.ZipFile() 函数读取要给 ZIP 文件， 向它传入一个字符串， 表示.zip 文件的文件名。ZipFile 对象有一个 namelist() 方法，返回 ZIP 文件中包含的所有文件和文件夹的字符串的列表。可以把文件或文件夹名称传递给 ZipFile 对象的 getinfo() 方法来返回一个关于特定文件的 ZipInfo 对象。通过 ZipInfo 对象可以读取到保存的归档文件的有用信息。 12345678readZip = zipfile.ZipFile(&apos;new.zip&apos;)print(readZip.namelist())catsFileInfo = readZip.getinfo(&apos;myCats.py&apos;)print(catsFileInfo.file_size)print(catsFileInfo.compress_size)readZip.close() 加压缩 ZIP 文件ZipFile 对象的 extractall() 方法从 ZIP 文件中解压缩所有文件和文件夹， 放到当前工作目录中。可以使用 extractall() 方法从 ZIP 文件中解压缩所有文件。也可以使用 extract() 方法从 ZIP 文件中解压缩单个文件。 1234extractZip = zipfile.ZipFile(&apos;new.zip&apos;)extractZip.extractall()extractZip.extract(&apos;myCats.py&apos;, &apos;.\\\\temp&apos;)extractZip.close()","categories":[{"name":"Python","slug":"Python","permalink":"https://veinin.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://veinin.com/tags/Python/"},{"name":"编程","slug":"编程","permalink":"https://veinin.com/tags/编程/"},{"name":"Python 文件","slug":"Python-文件","permalink":"https://veinin.com/tags/Python-文件/"}]},{"title":"Git 教程 - 分支","slug":"git-tutorial-branching","date":"2018-04-01T06:26:00.000Z","updated":"2018-04-01T13:18:44.374Z","comments":true,"path":"2018/04/01/git-tutorial-branching/","link":"","permalink":"https://veinin.com/2018/04/01/git-tutorial-branching/","excerpt":"有人把 Git 的分支模型称为它的”必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。 分支简介前面提过，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。在进行提交操作时，Git 会保存一个提交对象（commit object）。 该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。 Git 的分支，其实本质上仅仅是指向提交对象的可变指针。Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。它会在每次的提交操作中自动向前移动。","text":"有人把 Git 的分支模型称为它的”必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。 分支简介前面提过，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。在进行提交操作时，Git 会保存一个提交对象（commit object）。 该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。 Git 的分支，其实本质上仅仅是指向提交对象的可变指针。Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。它会在每次的提交操作中自动向前移动。 分支创建Git 使用命令 git branch 创建一个新分支，创建新分支后，会在当前所在的提交对象上创建一个新指针： 1$ git branch testing 如图，分支会有一个名为 HEAD 的特殊指针，用来标明当前所处的分支。 可以使用 git log 查看各个分支当前所指的对象： 12git log --oneline --decorate2f2ff67 (HEAD -&gt; master, origin/master, testing) modify the theme 分支切换git branch 命令仅仅是创建一个新分支，并不会自动切换到新分支中去。如果要切换到一个已存在的分支，你需要使用 git checkout 命令： 12345$git checkout testingSwitched to branch &apos;testing&apos;$ git log --oneline --decorate2f2ff67 (HEAD -&gt; testing, origin/master, master) modify the theme 通过 git log 再次查看后，我们可以看到 HEAD 指针已经指向了刚刚创建的新分支 testing。 如果我们在当前所处分支进行提交，那么 HEAD 分支随着提交操作自动向前移动，HEAD 仍然指向运行 git checkout 时所指的对象。 12$ vim README.md$ git commit -a -m &apos;made a change&apos; 这是如果我们再切换回 master 分支，并且更改后提交，那么在 master 分支也会产生新的提交对象： 1234$ git checkout masterSwitched to branch &apos;master&apos;$ vim README.md$ git commit -a -m &apos;made other changes&apos; 以上各个分支切换工作，你只需要熟悉 branch、checkout 和 commit 命令，就可以在不同分支间来回切换和工作，并在时机成熟后合并它们。 最后，你可以通过 git log 来查看分叉历史，他会输出你提交的历史、各个分支指向的分支分叉情况： 12345λ git log --oneline --decorate --graph --all* 92cd086 (HEAD -&gt; master) made other changes| * b5c6792 (testing) made a change|/* 2f2ff67 (origin/master) modify the theme 分支的新建与合并Git 在当前所处分支中使用 git merge 命令来合并其他分支。 实际工作中你可能会用到类似的工作流。 你将经历如下步骤： 开发某个网站。为实现某个新的需求，创建一个分支。 12$ git checkout -b iss53Switched to a new branch &quot;iss53&quot; 在这个分支上开展工作。 12$ vim index.html$ git commit -a -m &apos;added a new footer [issue 53]&apos; 正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理： 切换到你的线上分支（production branch）。 12$ git checkout masterSwitched to branch &apos;master&apos; 为这个紧急任务新建一个分支，并在其中修复它。 1234$ git checkout -b hotfixSwitched to a new branch &apos;hotfix&apos;$ vim index.html$ git commit -a -m &apos;fixed the broken email address&apos; 在测试通过之后，切换回线上分支，然后合并这个修补分支，并将改动推送到线上分支,最后删除 hotfix 分支。 12345678$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+)$ git branch -d hotfixDeleted branch hotfix (3a0874c). 切换回你最初工作的分支上，继续工作。 12$ git checkout iss53Switched to branch &quot;iss53&quot; 在上面这个典型的使用 Git 分支的工作流中，我们使用了一个带有 -b 参数的 git checkout 命令来创建一个新分支，它等价于执行了git branch 和 git checkout 两个命令。 分支合并冲突解决在分支合并的适合，如果涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：1234$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result. 此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：123456789$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: index.html Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html 冲突的地方使用=======来区分，你所处的 HEAD 指向的版本在这个区段的上半部分，合并过来的分支在这个区段的下半部分。 你可以修改冲突的地方，保留你认为何时的内容，并且删除冲突的其余部分，如上面例子，我们需要保留下半部分提交内容：123&lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com&lt;/div&gt; 在所有冲突解决完成后，你可以再次输入 git commit 来完成这次合并提交。 分支管理git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表，其中 master 分支前的 * 号代表当前 HEAD 所指向的分支：123$ git branch* master testing 如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令：123$ git branch -v* master 92cd086 made other changes testing b5c6792 made a change 使用 -merged 与 –no-merged 这两个选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支，。123456$ git branch --no-merged testing$ git merge testing$ git branch --merged* master testing 包含未合并的分支时，尝试使用 git branch -d 命令删除它时会失败，如果你确定要删除并丢弃那些工作，你可以使用 -D 选项强制删除。","categories":[{"name":"Git","slug":"Git","permalink":"https://veinin.com/categories/Git/"}],"tags":[{"name":"Git 教程","slug":"Git-教程","permalink":"https://veinin.com/tags/Git-教程/"},{"name":"Git 安装","slug":"Git-安装","permalink":"https://veinin.com/tags/Git-安装/"},{"name":"Git 分支","slug":"Git-分支","permalink":"https://veinin.com/tags/Git-分支/"}]},{"title":"Git 教程 - 基础操作","slug":"git-tutorial-basics","date":"2018-04-01T02:25:00.000Z","updated":"2018-04-02T16:45:24.344Z","comments":true,"path":"2018/04/01/git-tutorial-basics/","link":"","permalink":"https://veinin.com/2018/04/01/git-tutorial-basics/","excerpt":"在获得 Git 后你需要学会使用 Git 完成各种工作中将要使用的各种基本命令。例如配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改。更进一步，你应该学会如何配置 Git 来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。 获取 Git 仓库取得 Git 项目仓库有两种方法。 在现有项目或目录下导入所有文件到 Git 中。 从一个服务器克隆一个现有的 Git 仓库。 在现有目录中初始化仓库如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入： 1git init","text":"在获得 Git 后你需要学会使用 Git 完成各种工作中将要使用的各种基本命令。例如配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改。更进一步，你应该学会如何配置 Git 来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。 获取 Git 仓库取得 Git 项目仓库有两种方法。 在现有项目或目录下导入所有文件到 Git 中。 从一个服务器克隆一个现有的 Git 仓库。 在现有目录中初始化仓库如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入： 1git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。但你的项目里的文件还没有被跟踪。 如果你已经有一些文件需要让 Git 仓库来进行版本控制的话，你可使用 git add 命令来追踪指定文件，然后用 git commit 提交： 123$ git add *.c$ git add LICENSE$ git commit -m &apos;initial project version&apos; 如果你需要追踪指定某一类型的文件，git add 是支持通配符的，例如所有 .c 的文件：git add *.c；当然你也可以指定添加某些文件。 克隆现有的仓库如果你想获得一份已经存在了的 Git 仓库的拷贝，你可以使用到 git clone 命令。与其他 VCS 系统（如 Subversion）的 checkout 不同，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。当 git clone 执行完后，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 克隆仓库的命令格式是 git clone [url]，比如克隆一个 blog 项目： 1$ git clone git@github.com:Veinin/blog.git 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令： 1$ git clone git@github.com:Veinin/blog.git myblog 克隆命令除了支持 https:// 协议外，你还可以使用 git:// 协议或者使用 SSH 传输协议 user@host:path/to/repo.git 记录每次更新到仓库你工作目录下的每一个文件都不外乎这两种状态： 已跟踪，是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 未跟踪，已跟踪文件以外的所有其它文件都属于未跟踪文件。 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下： 检查当前文件状态可以用 git status 命令来查看当前文件状态。刚克隆下来的项目，你的工作目录是相当干净的。如果你使用该命令，会得到如下结果： 123$ git statusOn branch masternothing to commit, working directory clean 此时，你的所有追踪文件都是未修改的，该明显显示了当前所在分支，分支名为 master。 随后，你可能想创建新文件，比如 README 文件，创建完后，如果你使用 git status，你讲看到一个未跟踪的文件： 123456789$ echo &apos;My Project&apos; &gt; README$ git statusOn branch masterUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) READMEnothing added to commit but untracked files present (use &quot;git add&quot; to track) 上面的 Untracked files 为未跟踪文件列表，未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件。 跟踪新文件使用命令 git add 开始跟踪一个文件。 所以，要跟踪 README 文件，运行： 1$ git add README 然后使用 git status 命令，你会看到 README 文件已被追踪，且处于暂存状态。 123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README 只要在 Changes to be committed 这行下面的文件，就说明是已暂存状态。 暂存已修改文件如果你修改了一个名为 CONTRIBUTING.md 的已被跟踪的文件，然后运行 git status 命令，会看到下面内容： 123456789101112$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 文件 CONTRIBUTING.md 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 git add 命令。这是个多功能命令： 可以用它开始跟踪新文件。 把已跟踪的文件放到暂存区。 用于合并时把有冲突的文件标记为已解决状态等。 我们运行 git add 将”CONTRIBUTING.md”放到暂存区，文件又会变成已暂存状态，然后再看看 git status 的输出： 12345678$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: CONTRIBUTING.md 假设此时，你想要在 CONTRIBUTING.md 里再加条注释， 重新编辑存盘后，准备好提交。 不过且慢，再运行 git status 看看： 1234567891011121314$ vim CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: CONTRIBUTING.mdChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 现在 CONTRIBUTING.md 文件同时出现在暂存区和非暂存区。实际上 Git 只不过暂存了你运行 git add 命令时的版本。如果你现在提交，CONTRIBUTING.md 的版本是你最后一次运行 git add 命令时的那个版本，而不是你运行 git commit 时，在工作目录中的当前版本。所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来： 12345678$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: CONTRIBUTING.md 状态简览git status 命令的输出十分详细，但其用语有些繁琐。你可以使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出。 123456$ git status -s M READMEM lib/simplegit.rbMM RakefileA lib/git.rb?? LICENSE.txt 简介标识分为 5 种： M，出现在右边表示该文件被修改了但是还没放入暂存区。 M，出现在靠左边表示该文件被修改了并放入了暂存区。 MM，表示被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。 ??，新增未追踪文件。 A ，新添加到暂存区的文件。 查看已暂存和未暂存的修改git status 命令显示可能还过于模块，但你可以用 git diff 命令来查看你具体修改了什么地方。 查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff： 12345$ git diffdiff --git a/README.md b/README.mdindex 4464ea4..83bfa15 100644--- a/README.md+++ b/README.md 若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --cached 命令： 123456$ git add README.md$ git diff --cacheddiff --git a/README.md b/README.mdindex 4464ea4..83bfa15 100644--- a/README.md+++ b/README.md 如果对上面暂存 README.md 文件再编辑，运行 git status 会看到暂存前后的两个版本。运行 git diff 将看到暂存前后的变化，而用 git diff --cached 将查看已经暂存起来的变化。 忽略文件一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。 文件 .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob（shell 正则表达式） 模式匹配。例如星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符等等。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 1234567$ cat .gitignore*.a!lib.a/TODObuild/doc/*.txtdoc/**/*.pdf 提交更新如果暂存区域已经准备妥当可以提交了。准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit： 1git commit 这种方式会启动文本编辑器以便输入本次提交的说明。 123456789# Please enter the commit message for your changes. Lines starting# with &apos;#&apos; will be ignored, and an empty message aborts the commit.# On branch master# Changes to be committed:# new file: README# modified: CONTRIBUTING.md#~&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C 默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示： 1234$ git commit -m &quot;modify the README file&quot;[master 463dc4f] modify the README file 2 files changed, 2 insertions(+) create mode 100644 README 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤： 移除文件要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后再提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分： 123456789$ rm PROJECTS.md$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: PROJECTS.md 然后再运行 git rm 记录此次移除文件的操作。注意，如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f： 12345678$ git rm PROJECTS.mdrm &apos;PROJECTS.md&apos;$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: PROJECTS.md 另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。为达到这一目的，使用 –cached 选项： 1$ git rm --cached README git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。 比方说： 1$ git rm log/\\*.log 移动文件Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么。 要在 Git 中对文件改名，可以使用 git mv 命令： 1234567$ git mv README.md README$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) renamed: README.md -&gt; README 它会恰如预期般正常工作。但实际上运行 git mv 相当于运行了以下 3 条命令： 123$ mv README.md README$ git rm README.md$ git add README Git 查看提交历史你也许想回顾下提交历史，可以使用 git log 命令来查看。默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 1234567891011121314$ git logcommit 2f2ff67cb4e8731dad9bb1b8ec4f0963c0368870Author: Veinin Guo &lt;Veinin@users.noreply.github.com&gt;Date: Fri Mar 30 00:46:23 2018 +0800 modify the themecommit 633e5f7e0cbf87fba2e922956667c9cb627bd4a0Author: Veinin Guo &lt;Veinin@users.noreply.github.com&gt;Date: Fri Mar 30 00:39:54 2018 +0800 initialize commit... git log 有许多选项可以帮助你搜寻你所要找的提交： 使用选项 -p，用来显示每次提交的内容差异。 可以加上 -2 来仅显示最近两次提交。 使用 --stat 选项查看每次提交的简略的统计信息。 使用 --pretty 这个选项可以指定使用不同于默认格式的方式展示提交历史。 比如用 --pretty=oneline 将每个提交放在一行显示。另外还有 short，full 和 fuller 可以用 使用 --pretty=format 来定制要显示的记录格式，具体格式可以参考 Git 帮助文档。 按照时间作限制的选项 --since 和 --until，比如列出最近两周内的提交记录：$ git log --since=2.weeks；或具体到某一天：git log --since=2008-03-30。 撤销操作在任何一个阶段，你都有可能想要撤消某些操作。 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令尝试重新提交：在上次提交后马上执行了此命令，那么快照会保持不变，而你所修改的只是提交信息。例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作： 123$ git commit -m &apos;initial commit&apos;$ git add forgotten_file$ git commit --amend 取消暂存的文件你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如果你想取消暂存的指定文件，可以使用 git reset HEAD &lt;file&gt;... 来操作。 123456789$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: README.md$ git reset HEAD README.md 撤消对文件的修改如果你并不想保留对某个文件的修改，可以使用 git checkout -- &lt;file&gt;... 将文件还原成上次提交时的样子。请注意，这个命令是非常危险，除非你确实不想修改那个文件，否则不要使用这个命令。 12345678910$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: README.md$ git checkout -- README.md 远程仓库的使用远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 查看远程仓库如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字： 12$ git remoteorigin 指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。如果你的远程仓库不止一个，该命令会将它们全部列出。123$ git remote -vorigin https://github.com/Veinin/blog.git (fetch)origin https://github.com/Veinin/blog.git (push) 添加远程仓库运行 git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写： 12345678$ git remoteorigin$ git remote add pb https://github.com/paulboone/ticgit$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push)pb https://github.com/paulboone/ticgit (fetch)pb https://github.com/paulboone/ticgit (push) 现在你可以在命令行中使用字符串 pb 来代替整个 URL。例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb。 从远程仓库中抓取与拉取从远程仓库中获得数据，可以执行： 1$ git fetch [remote-name] 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。 推送到远程仓库当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push [remote-name] [branch-name]。 当你想要将 master 分支推送到 origin 服务器时，那么运行这个命令就可以将你所做的备份到服务器： 1$ git push origin master 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。否则，你的推送就会毫无疑问地被拒绝。 查看远程仓库如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。 123456789101112131415161718λ git remote show origin* remote origin Fetch URL: https://github.com/chenshuo/muduo.git Push URL: https://github.com/chenshuo/muduo.git HEAD branch: master Remote branches: backport new (next fetch will store in remotes/origin) cpp11 new (next fetch will store in remotes/origin) cpp17 tracked cpp98 tracked experiment stale (use &apos;git remote prune&apos; to remove) gh-pages tracked mac tracked master tracked Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (up to date) 这条命令会列出你执行 git push、git pull 会推送到哪个分支。也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 git pull 时哪些分支会自动合并。 远程仓库的移除与重命名如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 1234$ git remote rename pb paul$ git remoteoriginpaul 如果因为一些原因想要移除一个远程仓库， 可以使用 git remote rm ： 123$ git remote rm paul$ git remoteorigin 打标签像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 列出标签在 Git 中列出已有的标签是非常简单直观的。 只需要输入 git tag： 1234567891011λ git tag v0.1.0 v0.1.1 v0.1.2 ...v0.9.7 v0.9.8 v1.0.0 v1.0.1 ...v2.0.0-beta 你也可以使用特定的模式查找标签。 123456λ git tag -l v1.0.*v1.0.0v1.0.0-rc1v1.0.0-rc2v1.0.1v1.0.2 创建标签Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。 附注标签附注标签是存储在 Git 数据库中的一个完整对象。其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。通常建议创建附注标签，这样你可以拥有以上所有信息。创建附注标签，只需在在运行 tag 命令时指定 -a 选项： 123$ git tag -a v0.1.0 -m &quot;new version&quot; $ git tagv0.1.0 使用 git show 命令可以看到标签信息与对应的提交信息： 123456789101112λ git show v0.1.0tag v0.1.0Tagger: veinin &lt;veininguo@gmail.com&gt;Date: Fri Mar 30 18:14:44 2018 +0800new versioncommit 2f2ff67cb4e8731dad9bb1b8ec4f0963c0368870Author: Veinin Guo &lt;Veinin@users.noreply.github.com&gt;Date: Fri Mar 30 00:46:23 2018 +0800 modify the theme 轻量标签轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。 创建轻量标签，不需要使用任何选项，只需要提供标签名字：如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，可以使用轻量标签。 1234$ git tag v0.0.1$ git tagv0.0.1v0.1.0 如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息： 123456$ git show v0.0.1commit 2f2ff67cb4e8731dad9bb1b8ec4f0963c0368870Author: Veinin Guo &lt;Veinin@users.noreply.github.com&gt;Date: Fri Mar 30 00:46:23 2018 +0800 modify the theme 后期标签可以对过去的某个提交记录打标签，当你忘记给某个时间点的提交打标签时，你可以使用提交记录的校验和（或部分）来重新打上标签。 12345678910111213$ git log --pretty=oneline2f2ff67cb4e8731dad9bb1b8ec4f0963c0368870 modify the theme6d434e8c571342290ffa15d8852a9487db63b7e1 modify the theme633e5f7e0cbf87fba2e922956667c9cb627bd4a0 initialize commitba67864882e13b588bb5061f334d8a23b7dc29b3 initialize commitd5a38f1858b5af96f3338060b8f13071a878b17b first commit$ git tag -a v0.0.2 633e5f7 -m &quot;initial version&quot;$ git tagv0.0.1v0.0.2v0.1.0 共享标签默认情况下，git push 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样，你可以运行 git push origin [tagname] 命令推送一个标签。 123456$ git push origin v0.1.0Counting objects: 1, done.Writing objects: 100% (1/1), 166 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To https://github.com/Veinin/blog.git * [new tag] v0.1.0 -&gt; v0.1.0 如果想要一次性推送很多标签，也可以使用带有 --tags 选项，这将会把所有不在远程仓库服务器上的标签全部传送到那里。 1234567λ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1/1), 161 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To https://github.com/Veinin/blog.git * [new tag] v0.0.1 -&gt; v0.0.1 * [new tag] v0.0.2 -&gt; v0.0.2 检出标签在 Git 中你并不能真的检出一个标签，但你可以指定某个新标签来创建新的分支。 12$ git checkout -b version2 v0.0.2Switched to a new branch &apos;version2&apos; 删除标签删除一个标签分两种： 删除本地标签：git tag -d 标签名 删除远程仓库标签：git push origin :ref/tag/标签名 123456$ git tag -d v0.1.0Deleted tag &apos;v0.1.0&apos; (was 729a196)$ git push origin :refs/tags/v0.0.1To https://github.com/Veinin/blog.git - [deleted] v0.0.1 别名使用别名小技巧可以使你的 Git 体验更简单、容易、熟悉。如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 123456$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status$ git config --global alias.unstage &apos;reset HEAD --&apos;$ git config --global alias.last &apos;log -1 HEAD&apos; 有了这些别名后，当你输入 git co 时，它就对应了 git checkout 命令，所以，如果你把你常用的一些命令设置为别名，那将对你很有帮助。 总结现在，你可以完成所有基本的 Git 本地操作：创建或者克隆一个仓库、做更改、暂存并提交这些更改、浏览你的仓库从创建到现在的所有更改的历史。下一步，本书将介绍 Git 的杀手级特性：分支模型。","categories":[{"name":"Git","slug":"Git","permalink":"https://veinin.com/categories/Git/"}],"tags":[{"name":"Git 教程","slug":"Git-教程","permalink":"https://veinin.com/tags/Git-教程/"},{"name":"Git 安装","slug":"Git-安装","permalink":"https://veinin.com/tags/Git-安装/"},{"name":"Git 基础","slug":"Git-基础","permalink":"https://veinin.com/tags/Git-基础/"}]},{"title":"Git 教程 - 起步","slug":"git-tutorial-started","date":"2018-04-01T02:10:00.000Z","updated":"2018-04-01T03:01:23.352Z","comments":true,"path":"2018/04/01/git-tutorial-started/","link":"","permalink":"https://veinin.com/2018/04/01/git-tutorial-started/","excerpt":"Linux 内核开源项目有着为数众广的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许成千上万个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。","text":"Linux 内核开源项目有着为数众广的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许成千上万个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。 安装在你开始使用 Git 前，需要将它安装在你的计算机上。 即便已经安装，最好将它升级到最新的版本。 Linux使用 yum：sudo yum install git使用 apt-get：sudo apt-get install git Mac 上安装可以使用二进制安装程序。 官方维护的 OSX Git 安装程序可以在 Git 官方网站下载，网址为 http://git-scm.com/download/mac。 Windows 上安装官方版本可以在 Git 官方网站下载。 地址为 http://git-scm.com/download/win简单的方法是安装 GitHub for Windows。 地址为 https://desktop.github.com/ Git 基础在开始学习 Git 的时候，请努力分清你对其它版本管理系统的已有认识，如 Subversion 和 Perforce 等；这么做能帮助你使用工具时避免发生混淆。 Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。 直接记录快照，而非差异比较相比传统的版本管理系统（CVS、Subversion、Perforce、Bazaar 等等），它们将保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。反之，Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个快照流。 近乎所有操作都是本地执行因为你在本地磁盘上就有项目的完整历史，所以在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。例如： 你可以不需外连到服务器去获取历史，浏览项目的历史。 离线或者没有 VPN 时，几乎可以进行任何操作。 Git 保证完整性Git 中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。 Git 一般只添加数据你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。一旦你提交快照到 Git 中，就难以再丢失数据。 三种状态Git 有三种状态，你的文件可能处于其中之一： 已提交（committed），表示数据已经安全的保存在本地数据库中。 已修改（modified），表示修改了文件，但还没保存到数据库中。 已暂存（staged），表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 Git 项目的三个工作区域的概念： Git 仓库，是 Git 用来保存项目的元数据和对象数据库的地方。 工作目录，工作目录是对项目的某个版本独立提取出来的内容。 暂存区域，是一个文件，保存了下次将提交的文件列表信息。 工作目录中保存着的特定版本文件，就属于已提交状态。如果作了修改并颐和园已放入暂存区域，就属于已暂存状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 环境初始化Git 有多种使用方式。 你可以使用原生的命令行模式，也可以使用 GUI 模式。 但只有在命令行模式下你才能执行 Git 的 所有 命令。 获得帮助使用 Git 命令行时有三种方法可以找到 Git 命令的使用手册： 123$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt; 例如，如果想要获得 config 命令的手册，可以: $ git help config 初次运行配置初次安装 Git 的系统上，首先需要做几件事来定制你的 Git 环境。 每台计算机上只需要配置一次。 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： /etc/gitconfig 文件，包含系统上每一个用户及他们仓库的通用配置。 ~/.gitconfig 或 ~/.config/git/config 文件，只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config），针对该仓库的配置。 每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。 用户信息当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 12$ git config --global user.name &quot;Veinin Guo&quot;$ git config --global user.email veininguo@gmail.com 检查配置信息可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。 123456$ git config --listrebase.autosquash=truecredential.helper=manageruser.name=veininuser.email=veininguo@gmail.com... 你也可以通过输入 git config &lt;key&gt; 来检查 Git 的某一项配置。 12$ git config user.nameveinin","categories":[{"name":"Git","slug":"Git","permalink":"https://veinin.com/categories/Git/"}],"tags":[{"name":"Git 教程","slug":"Git-教程","permalink":"https://veinin.com/tags/Git-教程/"},{"name":"Git 安装","slug":"Git-安装","permalink":"https://veinin.com/tags/Git-安装/"},{"name":"Git 基础","slug":"Git-基础","permalink":"https://veinin.com/tags/Git-基础/"}]},{"title":"开发笔记：游戏中属性定义、策划公式处理方案","slug":"dev-notes-designer-formula-processing-solution-in-game","date":"2018-03-24T13:28:00.000Z","updated":"2018-08-08T15:28:12.197Z","comments":true,"path":"2018/03/24/dev-notes-designer-formula-processing-solution-in-game/","link":"","permalink":"https://veinin.com/2018/03/24/dev-notes-designer-formula-processing-solution-in-game/","excerpt":"在游戏设计中，策划喜欢通过表格来制定自己的数值方案，通常一个游戏制作会有几十上百张不同功能的表格，这些表格通常采用Excel制定。大部分时候，策划更想要的是自己来操作所有数值，而不需要程序为其各种需求去正对性的通过代码来实现。 这样做有几个好处： 1.策划可以独立拓展自己的业务，而不依赖于程序。 2.程序可以更加专心于自己的逻辑功能，而不用去特意维护策划的数值变动需求。 3.工作内容分离，减少沟通成本，更加提升工作效率，让各部门更加专注于自己所处的领域。 在游戏日常开发中，有两个典型的应用场景，一个是角色的属性，一个是计算这些属性的公式，最后还需要通过这些属性在战斗中通过公式生成伤害数值。如果涉及复杂的战斗系统，通常一个角色的战斗属性可能会有上百种，而计算这些属性的公式，也可能成百上千。这里就会产生几个问题：属性、公式由程序去定义，还是策划自己去主导？属性、公式通过某种方式定义出来了，程序如何去使用？","text":"在游戏设计中，策划喜欢通过表格来制定自己的数值方案，通常一个游戏制作会有几十上百张不同功能的表格，这些表格通常采用Excel制定。大部分时候，策划更想要的是自己来操作所有数值，而不需要程序为其各种需求去正对性的通过代码来实现。 这样做有几个好处： 1.策划可以独立拓展自己的业务，而不依赖于程序。 2.程序可以更加专心于自己的逻辑功能，而不用去特意维护策划的数值变动需求。 3.工作内容分离，减少沟通成本，更加提升工作效率，让各部门更加专注于自己所处的领域。 在游戏日常开发中，有两个典型的应用场景，一个是角色的属性，一个是计算这些属性的公式，最后还需要通过这些属性在战斗中通过公式生成伤害数值。如果涉及复杂的战斗系统，通常一个角色的战斗属性可能会有上百种，而计算这些属性的公式，也可能成百上千。这里就会产生几个问题：属性、公式由程序去定义，还是策划自己去主导？属性、公式通过某种方式定义出来了，程序如何去使用？ 最近和策划一起讨论了下，最终给出了解决方案，属性、公式都有策划去配置，但公式需要简化，于是我们先给出了两张表格。 属性表一个属性字典，对于程序来说，特别设计属性服务器、客户端传输的过程，我们可以通过一个唯一ID、类型进行，只要客户端、服务器都拥有这么一张属性字典，那么将很容易对属性进行传输： 属性ID 名称 类型 初值 描述 成长公式 1 strength int 5 力量 2 pdCorrect float 1.2 物理伤害修正系数 3 physicalDamage int 20 物理基础伤害 公式1 4 physicalCritical int 15 物理暴击率 5 physicalCriticalDec int 10 物理暴击抵抗率 公式表一张公式表，由策划去配置，但程序得把策划的公式翻译成程序能读懂的代码。 公式ID 公式名称 公式内容 1 physicalDamage 40 (level pdCorrect + 1) * rand(1, 1.5) 1 physicalCriticalRate max(min(a.physicalCritical / 10 - t.physicalCriticalDec), 20), 0) 函数支持另外，对于策划来说，要通过公式来操作属性数据，特别是战斗中产生的伤害数据，就要求我们有一些简单函数支持，比如在Lua中，一些数学公式：math.min、math.ceil、math.random 等等。而对策划来说，大部分其实是不懂编程的，因此我们需要更加简化函数名称的设计。最终，我们得出需要以下函数的支持： min(…) ，返回参数中的最小值，如 min(1, 5, 2) ，会得到数值 1 max(…)，返回参数中的最大值，如 max(4, 10, 3)，会得到数值 10 rand(m, n)，当不带参数时，返回 [0,1] 区间内的浮点伪随机数，当以两个整数 m 与 n 调用时，返回一个 [m, n] 区间内的一致分布的伪随机数。如 rand(1, 10)，产生1-10区间内的一个随机数。 ceil(x)，返回不等于 x 的最小整数。如 ceil(1.55)，会得到数值 2 float(x)，返回不大于 x 的最大整数值，如 flooat(1.55)，会得到数值 1 实现有了上面这些，程序就可以编写工具，把策划配置的公式，导出成程序能够识别的公式函数了，比如：怪物的随等级增长物理伤害公式：40 (等级 物理伤害修正系数 + 1) * rand(1, 1.5)怪物的物理暴击计算：max(min(怪物暴击率 / 10 - 目标暴击抵抗率 / 10, 25), 0) 那么其最终需要转换成代码公式函数： 12345678910111213141516171819202122local formula = &#123;&#125;-- 怪物物理伤害公式function formula.physicalDamage(a) return 40 * (a.level * a.pdCorrect + 1) * math.random(1, 1.5)end-- 怪物暴击几率公式function formula.physicalCriticalRate(a, t) return math.max(math.min(a.physicalCritical / 10 - t.physicalCriticalDec), 20), 0)endlocal formulas = &#123; [1] = formula.physicalDamage, [2] = formula.physicalCriticalRate,&#125;function formula.exec(id, ...) return formula[id](...)endreturn formula 有了上面的表格，外加生成的公式，我们很容易计算出一个怪物的基础属性或战斗中产生的伤害数值： 12345678910111213141516171819202122232425local formula = require \"formula\"local monster = &#123; level = 3, strength = 5, pdCorrect = 1.3, physicalDamage = 15, physicalCritical = 35, physicalCriticalDec = 10,&#125;local target = &#123; level = 2, strength = 5, pdCorrect = 1.3, physicalDamage = 20, physicalCritical = 35, physicalCriticalDec = 10,&#125;-- 得出怪物物理伤害local damage = formula.exec(1, monster)-- 得出怪物物理暴击率local criticalRate = formula.exec(2, monster, target) 最终，通过这套方案的实现，程序不用再去代码里维护各种各样的公式，策划也不在需要程序来帮忙维护公式，如果需求变动，只需要更改下表格，然后重新生成一份新公式就行；如果有新属性增加，只需要在表格中创建以个新的属性值，然后不管是角色，还是战斗中都能应用到新增加的变化。","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://veinin.com/categories/开发笔记/"}],"tags":[{"name":"游戏角色属性设计","slug":"游戏角色属性设计","permalink":"https://veinin.com/tags/游戏角色属性设计/"},{"name":"游戏策划公式设计","slug":"游戏策划公式设计","permalink":"https://veinin.com/tags/游戏策划公式设计/"}]},{"title":"开发笔记：MMORPG场景同步AOI解决方案","slug":"dev-notes-mmorpg-aoi-algorithm","date":"2018-03-23T11:20:00.000Z","updated":"2018-08-08T15:29:28.255Z","comments":true,"path":"2018/03/23/dev-notes-mmorpg-aoi-algorithm/","link":"","permalink":"https://veinin.com/2018/03/23/dev-notes-mmorpg-aoi-algorithm/","excerpt":"MMO 游戏，需要解决的最重要的问题之一，就是如何把游戏世界中各种状态的改变通知给需要知道这条信息的玩家。为此，需要为每个玩家设定一个AOI（Area Of Interest），当一个对象状态发生改变时，需要将信息广播出去，那些AOI覆盖到这条消息的玩家都会收到这条广播消息。 AOI 主要作用有两：第一，服务器上的玩家或 NPC 状态发生改变时，将消息广播到附近的玩家。第二，当玩家接近NPC时，进入NPC警戒区域，AOI 模块将消息发送给NPC，NPC再做出相应的AI反应。 目前游戏中 AOI 实现主要有3种：第一种，最容易也是最笨的一种，玩家定期同步自己状态给服务器，服务器定期比较所有对象间的关系，发现可以触发 AOI 事件就发送消息。写法简单，不容易出错，但如果处理不好，效率往往是最低的。","text":"MMO 游戏，需要解决的最重要的问题之一，就是如何把游戏世界中各种状态的改变通知给需要知道这条信息的玩家。为此，需要为每个玩家设定一个AOI（Area Of Interest），当一个对象状态发生改变时，需要将信息广播出去，那些AOI覆盖到这条消息的玩家都会收到这条广播消息。 AOI 主要作用有两：第一，服务器上的玩家或 NPC 状态发生改变时，将消息广播到附近的玩家。第二，当玩家接近NPC时，进入NPC警戒区域，AOI 模块将消息发送给NPC，NPC再做出相应的AI反应。 目前游戏中 AOI 实现主要有3种：第一种，最容易也是最笨的一种，玩家定期同步自己状态给服务器，服务器定期比较所有对象间的关系，发现可以触发 AOI 事件就发送消息。写法简单，不容易出错，但如果处理不好，效率往往是最低的。 空间切割网格算法把整个场景用等分大的格子划分成一个个小区域，对象进入、退出、移动时都需要更新相应的格子对象列表。这种算法插入、删除对象都非常快，时间复杂度为O（1）。缺点是当对象在格子直接移动时，需要消耗大量计算时间。目前《幻想西游》采用的是这种算法。 场景划分场景大小：200 200格子大小：50 50场景中需要划分等分大小的格子数： 200 / 50 200 50 = 16 个 效果如下图所示： 世界坐标与格子坐标每个格子有对于的格子坐标，每个世界坐标可以轻易的转换成格子坐标。世界坐标 (x, y) 转换成格子坐标公式为：(math.floor(x/gridWeidth), math.floor(y/gridHeight))如世界坐标为 (80, 50)，转换后对应格子坐标为 (2, 1)。 划分九宫格每个格子都需要维护该格子内的对象信息，同时也需要维护关心该格子的观察者信息。当对象处于场景某个格子时，该对象会有 9 个自己所关心的格子，对象可以观察并收到自己关心区域的 AOI 事件。当然，对象所处的格子也会被其他格子的对象所关心。也就是说一个格子里面的对象可以作为观察者，观察周围格子内对象；同时也是被观察者，被其他格子内的对象所观察。 如图所示，当对象所进入格子 (2, 2) 时（红色区域），那么其关心的周围 9 个格子（浅蓝色区域）中任何一个发生 AOI 事件时，它都会收到相应的 AOI 事件消息。 对象进入场景通知对象所处周围9个格子的其他对象 进入 AOI 事件。 对象离开场景与进入相反，通知对象所处九宫格的其他对象 离开 AOI 事件。 对象移动如果对象格子变更时，如图所示，对象纵向移动由(2, 2) 移动到 (3, 2)，45度角移动由 (2, 2) 移动到 (3, 3）： 会产生3种格子： 对象离开视野的格子（灰色格子），通知对象离开 AOI 事件。 对象进入视野的格子（橙色格子），通知对象进入 AOI 事件。 取所有需要操作的格子的交集（浅蓝色格子），通知对象移动 AOI 事件。 十字链表算法场景维护着两个双向链表（如果3D空间，则增加第3条），分别对应着 X 轴 和 Y 轴。每个链表对象的坐标按从小到大排列，也就是 X 坐标值越小，排在越前面，Y轴同理。此算法对象短距离移动时，很节省计算量，但涉及长距离移动时，计算量会非常大。 对象进入场景遍历 X 轴 和 Y 轴两个链表，找出新增对象在两个轴中所处的位置，将新对象加入到指定位置，并根据新对象的通知范围（可动态设定）获得需要通知对象集合，发送 进入 AOI 事件。 对象离开场景对象进入场景后，在 X 轴 和 Y 轴各保存了两个节点位置，可以通过这个位置，获取指定范围的的对象集合，发送 离开 AOI 事件。 对象移动与格字算法类似，对象移动后也会会产生3种对象集合： 更新位置前的集合，通知 离开 AOI 事件。 更新位置后的集合，通知 进入 AOI 事件。 取上面两个集合的交集，通知对象 移动 AOI 事件。 处理上面产生事件顺序与格字算法相同。 分层 AOI有了AOI算法，并不意味着能有满意的效果，假设场景里面放入10000人，那么按分布情况来说，即使有AOI算法，也会很糟糕，你会看到满屏幕的人，密密麻麻，卡的要死。这种情况下，玩家体验会很糟糕，所以可能需要进一步优化。目前市面上见得比较多的解决方案有几种，一种是对单个场景分线，复制多个相同的场景副本，玩家随机进入某个场景的副本，以此来达到分流的目的。另外一种方案，是从梦幻西游手游服务器AOI设计方案中看到的，设计一个分层AOI概念，也就是单个场景创建多个AOI对象。把玩家分通过某个规则，分在不同的层次。当人数增多时，可以动态进行分层，人数少的时候可以把层数合并回来，然后就是让玩家在人少的时候也能看到几个人，人多的时候还是看到几个人。这种优化放过来后，这是同一台服务器，效果大概是这样的，你在同一层里看到的都是你关心的人。这个感受就很好了。","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://veinin.com/categories/开发笔记/"}],"tags":[{"name":"MMORPG","slug":"MMORPG","permalink":"https://veinin.com/tags/MMORPG/"},{"name":"AOI","slug":"AOI","permalink":"https://veinin.com/tags/AOI/"}]},{"title":"Python 快速上手 - 字符串","slug":"python-practice-strings","date":"2018-03-18T08:46:00.000Z","updated":"2018-03-24T15:00:56.181Z","comments":true,"path":"2018/03/18/python-practice-strings/","link":"","permalink":"https://veinin.com/2018/03/18/python-practice-strings/","excerpt":"文本是程序需要处理的最常见的数据形式。涉及字符串的操作不仅仅是使用+操作符连接两个字符串，你还可以从字符串中提取部分字符串， 添加或删除空白字符， 将字母转换成小写或大写， 检查字符串的格式是否正确。你甚至可以编写 Python 代码访问剪贴板， 复制或粘贴文本。 处理字符串双引号在Python中构建一个字符串相当简单：以单引号开始和结束。如果字符串里面也使用单引号的话，则需要使用双引号开始和结束来表示一个字符串。 1&gt;&gt;&gt; s = \"I found hi's very selfish.\"","text":"文本是程序需要处理的最常见的数据形式。涉及字符串的操作不仅仅是使用+操作符连接两个字符串，你还可以从字符串中提取部分字符串， 添加或删除空白字符， 将字母转换成小写或大写， 检查字符串的格式是否正确。你甚至可以编写 Python 代码访问剪贴板， 复制或粘贴文本。 处理字符串双引号在Python中构建一个字符串相当简单：以单引号开始和结束。如果字符串里面也使用单引号的话，则需要使用双引号开始和结束来表示一个字符串。 1&gt;&gt;&gt; s = \"I found hi's very selfish.\" 转义字符“转义字符” 让你输入一些字符，它们用其他方式是不可能放在字符串里的。转义字符包含一个倒斜杠（\\）， 紧跟着是想要添加到字符串中的字符。常用的转移字符包括:\\’(单引号)、 \\”(双引号)、 \\t(制表符)、 \\(倒斜杠) 123&gt;&gt;&gt; s = 'I found hi\\'s very selfish.'&gt;&gt;&gt; s\"I found hi's very selfish.\" 原始字符串在字符串开始的引号之前加上 r， 那么它就成为了一个原始字符串。“原始字符串” 会完全忽略所有的转义字符， 打印出字符串中所有的倒斜杠。 1print(r'That is Carol\\'s cat.') 用三重引号的多行字符串虽然可以用\\n转义字符将换行放入一个字符串，但使用多行字符串通常更容易。在 Python 中，多行字符串的起止是 3 个单引号或 3 个双引号。“三重引号” 之间的所有引号、 制表符或换行， 都被认为是字符串的一部分。 Python 的代码块缩进规则不适用于多行字符串。 123456print('''Dear Alice,Eve's cat has been arrested for catnapping.Sincerely,Bob''') 多行注释虽然井号字符（#） 表示这一行是注释， 但多行字符串常常用作多行注释。 12345678910\"\"\"This is a test Python program.Written by Al Sweigart al@inventwithpython.comThis program was designed for Python 3, not Python 2.\"\"\"def spam(): \"\"\"This is a multiline comment to help explain what the spam() function does.\"\"\" print('Hello!') 字符串下标和切片字符串像列表一样，可以使用下标和切片。字符串切片并不能修改原来的字符串。但可以从一个变量中获取切片，记录在另一个变量中。 12345678910111213&gt;&gt;&gt; text = 'Hello world!'&gt;&gt;&gt; text[1]'e'&gt;&gt;&gt; text[-2]'d'&gt;&gt;&gt; text[0:4]'Hell'&gt;&gt;&gt; text[:5]'Hello'&gt;&gt;&gt; text[4:]'o world!'&gt;&gt;&gt; text2 = text[0:5]'Hello' 字符串使用 in 和 not in 操作符像列表一样， in 和 not in 操作符也可以用于字符串。用 in 或 not in 连接两个字符串得到的表达式， 将求值为布尔值 True 或 False。 123456&gt;&gt;&gt; 'Veinin' in 'Veinin Guo'True&gt;&gt;&gt; 'Veinin' not in 'Veinin Guo'False&gt;&gt;&gt; '' in 'Veinin Guo'True 字符串操作方法某些字符串需要转换、分析然后产生新的字符串，字符串内置了一些常用的方法。注意：Python 中所有字符串操作方法并不会改变字符串本身的属性，而是返回一个操作后的新字符串。 upper()、 lower()、 isupper()和 islower()upper()和 lower() 方法会返回一个新字符串，所有字母都被相应地转换为大写或小写。 12345&gt;&gt;&gt; text = &apos;Hello World!&apos;&gt;&gt;&gt; print(text.upper())HELLO WORLD!&gt;&gt;&gt; print(text.lower())hello world! isupper()和islower()方法用来判断字符串是否至少有要给字母，并且所有字母都是大写或小写，相应地如果成立就会返回布尔值 True，否则返回 False。 12345678&gt;&gt;&gt; 'Hello world'.isupper()False&gt;&gt;&gt; 'HELLO WORLD'.isupper()True&gt;&gt;&gt; 'Hello'.islower()False&gt;&gt;&gt; 'hello'.islower()True isX 方法为了能判断字符串的特点，提供了一些常用的以 is 开头的方法。 isalpha() 如果字符串非空，且只包含字母，则返回 True isalnum() 如果字符串非空，且只包含字母和数字，则返回 True isdecimal() 如果字符串非空，且只包含数字，则返回 True isspace() 如果字符串非空，且只包含空格、换行和制表符，则返回 True istitle() 如果字符串包含以大写字母开头且后面字母都是小写字母的单词，则返回 True 1234567891011121314151617181920&gt;&gt;&gt; 'abc'.isalpha()True&gt;&gt;&gt; 'abc123'.isalpha()False&gt;&gt;&gt;&gt;&gt;&gt; 'abc123'.isalnum()True&gt;&gt;&gt;&gt;&gt;&gt; 'abc123'.isdecimal()False&gt;&gt;&gt; '10088'.isdecimal()True&gt;&gt;&gt;&gt;&gt;&gt; ' '.isspace()True&gt;&gt;&gt;&gt;&gt;&gt; 'I Am From China'.istitle()True&gt;&gt;&gt; 'I am from China'.istitle()False startswith() 和 endswith()startswith() 和 endswith() 用来判断某个字符串以某个字符串开始或结束，成立则返回 True。 123456&gt;&gt;&gt; 'Hello World'.startswith('Hello')True&gt;&gt;&gt; 'Hello World'.startswith('nihao')False&gt;&gt;&gt; 'Hello World'.endswith('World')True join() 和 split()join() 方法用来将一个字符串列表中的每个字符串连接成一个新的字符串。而 split() 方法与 join() 方法刚好相反，它会将一个字符串按制定分隔符进行分割，返回一个分割后的列表。 12345678&gt;&gt;&gt; ', '.join(['java', 'python', 'golang'])'java, python, golang'&gt;&gt;&gt;&gt;&gt;&gt; 'I am from China'.split()['I', 'am', 'from', 'China']&gt;&gt;&gt;&gt;&gt;&gt; 'ABCDEFGEFGEFG'.split('E')['ABCD', 'FG', 'FG', 'FG'] 使用 rjust()、 ljust() 和 center() 方法对齐文本rjust() 和 ljust() 方法使用向左或向右插入空格的方式返回一个字符串的填充版本。而 center() 方法则是让字符串文本居中。上面三个方法都接受两个参数，第一个参数指定填充数量。第二个参数，指定填充的字符，默认是填充空格。 12345678&gt;&gt;&gt; 'Veinin'.ljust(20, '-')'Veinin--------------'&gt;&gt;&gt; 'Veinin'.rjust(20, '-')'--------------Veinin'&gt;&gt;&gt; 'Veinin'.center(20)' Veinin '&gt;&gt;&gt; 'Veinin'.center(20, '#')'#######Veinin#######' 使用 strip()、 rstrip() 和 lstrip() 方法删除空白字符strip()、 rstrip() 和 lstrip() 三个方法分别对一个字符串的两边、右边和左边的空白字符进行删除操作。 1234567&gt;&gt;&gt; name = ' Veinin Guo '&gt;&gt;&gt; name.strip()'Veinin Guo'&gt;&gt;&gt; name.rstrip()' Veinin Guo'&gt;&gt;&gt; name.lstrip()'Veinin Guo '","categories":[{"name":"Python","slug":"Python","permalink":"https://veinin.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://veinin.com/tags/Python/"},{"name":"编程","slug":"编程","permalink":"https://veinin.com/tags/编程/"}]},{"title":"Python 快速上手 - 字典","slug":"python-practice-dictionaries","date":"2018-03-18T08:10:00.000Z","updated":"2018-03-24T14:09:51.148Z","comments":true,"path":"2018/03/18/python-practice-dictionaries/","link":"","permalink":"https://veinin.com/2018/03/18/python-practice-dictionaries/","excerpt":"字典数据类型提供了一种灵活的访问和组织数据的方式。像列表一样，“字典”是许多值的集合。但不像列表的下标， 字典的索引可以使用许多不同数据类型， 不只是整数。 字典的索引被称为“键”，键及其关联的值称为“键-值”对。字典仍然可以用整数值作为键， 就像列表使用整数值作为下标一样， 但它们不必从 0 开始， 可以是任何数字。 1234567891011&gt;&gt;&gt; myCat = &#123;'size': 'fat', 'color': 'gray', 'disposition': 'loud'&#125;&gt;&gt;&gt; myCat['size']'fat'&gt;&gt;&gt; 'My cat has ' + myCat['color'] + ' fur.''My cat has gray fur.'&gt;&gt;&gt;&gt;&gt;&gt; ticket = &#123;12306: 'websites', 123456: 'phone number'&#125;&gt;&gt;&gt; ticket[12306]'websites'&gt;&gt;&gt; ticket[123456]'phone number'","text":"字典数据类型提供了一种灵活的访问和组织数据的方式。像列表一样，“字典”是许多值的集合。但不像列表的下标， 字典的索引可以使用许多不同数据类型， 不只是整数。 字典的索引被称为“键”，键及其关联的值称为“键-值”对。字典仍然可以用整数值作为键， 就像列表使用整数值作为下标一样， 但它们不必从 0 开始， 可以是任何数字。 1234567891011&gt;&gt;&gt; myCat = &#123;'size': 'fat', 'color': 'gray', 'disposition': 'loud'&#125;&gt;&gt;&gt; myCat['size']'fat'&gt;&gt;&gt; 'My cat has ' + myCat['color'] + ' fur.''My cat has gray fur.'&gt;&gt;&gt;&gt;&gt;&gt; ticket = &#123;12306: 'websites', 123456: 'phone number'&#125;&gt;&gt;&gt; ticket[12306]'websites'&gt;&gt;&gt; ticket[123456]'phone number' 字典与列表确定两个列表是否相同时， 表项的顺序很重要。字典不像列表，字典中的表项是不排序的，键-值对输入的顺序并不重要。因为字典是不排序的， 所以不能像列表那样切片。尽管字典是不排序的，但可以用任意值作为键，这一点让你能够用强大的方式来组织数据。尝试访问字典中不存在的键， 将导致 KeyError 出错信息。 1234567891011121314&gt;&gt;&gt; a = ['cats', 'dogs']&gt;&gt;&gt; b = ['dogs', 'cats']&gt;&gt;&gt; a == bFalse&gt;&gt;&gt;&gt;&gt;&gt; c = &#123;'firstName': 'Veinin', 'age': 25&#125;&gt;&gt;&gt; d = &#123;'age': 25, 'firstName': 'Veinin'&#125;&gt;&gt;&gt; c == dTrue&gt;&gt;&gt;&gt;&gt;&gt; d['lastName']Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;KeyError: 'lastName' keys()、 values()和 items()方法有 3 个字典方法，它们将返回类似列表的值，分别对应于字典的键、值和键-值对：keys()、 values()和 items()。这些方法返回的值不是真正的列表，它们不能被修改，没有append()方法。但这些数据类型（分别是 dict_keys、 dict_values 和 dict_items）可以用于for 循环。 123456789101112131415161718192021&gt;&gt;&gt; person = &#123;'firstName': 'Veinin', 'lastName': 'Guo', 'age': 18&#125;&gt;&gt;&gt; for k in person.keys(): print(k)firstNamelastNameage&gt;&gt;&gt;&gt;&gt;&gt; for v in person.values(): print(v)VeininGuo18&gt;&gt;&gt;&gt;&gt;&gt; for k, v in person.items(): print(k, v)firstName VeininlastName Guoage 18 检查字典中是否存在键或值in 和 not in 操作符可以检查值是否存在于列表中。也可以利用这些操作符，检查某个键或值是否存在于字典中。 12345&gt;&gt;&gt; person = &#123;'firstName': 'Veinin', 'lastName': 'Guo', 'age': 18&#125;&gt;&gt;&gt; 'name' in personFalse&gt;&gt;&gt; 'sex' not in personTrue get()方法在访问一个键的值之前，检查该键是否存在于字典中，这很麻烦。好在，字典有一个 get()方法，它有两个参数：要取得其值的键，以及如果该键不存在时，返回的备用值。 123456&gt;&gt;&gt; person = &#123;'firstName': 'Veinin', 'lastName': 'Guo', 'age': 18&#125;&gt;&gt;&gt; \"I'm \" + str(person.get('age', 0)) + '.'\"I'm 18.\"&gt;&gt;&gt;&gt;&gt;&gt; 'His height is ' + str(person.get('height', 188)) + 'cm.''His height is 188cm.' setdefault()方法你常常需要为字典中某个键设置一个默认值，当该键没有任何值时使用它。setdefault()方法的第一个参数，是要检查的键。第二个参数，是如果该键不存在时要设置的值。 12345&gt;&gt;&gt; person = &#123;'firstName': 'Veinin', 'lastName': 'Guo', 'age': 18&#125;&gt;&gt;&gt; person.setdefault('height', 180)180&gt;&gt;&gt; print('His height is ' + str(person.get('height', 188)) + 'cm.')His height is 180cm.","categories":[{"name":"Python","slug":"Python","permalink":"https://veinin.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://veinin.com/tags/Python/"},{"name":"编程","slug":"编程","permalink":"https://veinin.com/tags/编程/"}]},{"title":"Python 快速上手 - 列表","slug":"python-practice-list","date":"2018-03-18T07:50:00.000Z","updated":"2018-03-24T14:10:00.527Z","comments":true,"path":"2018/03/18/python-practice-list/","link":"","permalink":"https://veinin.com/2018/03/18/python-practice-list/","excerpt":"列表和元组可以包含多个值，这样编写程序来处理大量数据就变得更容易。而且，由于列表本身又可以包含其他列表，所以可以用它们将数据安排成层次结构。 列表数据类型“列表” 是一个值， 它包含多个字构成的序列。列表用左方括号开始， 右方括号结束，即[]。12colors = ['red', 'green', 'blue']nums = [1, 2, 3]","text":"列表和元组可以包含多个值，这样编写程序来处理大量数据就变得更容易。而且，由于列表本身又可以包含其他列表，所以可以用它们将数据安排成层次结构。 列表数据类型“列表” 是一个值， 它包含多个字构成的序列。列表用左方括号开始， 右方括号结束，即[]。12colors = ['red', 'green', 'blue']nums = [1, 2, 3] 用下标取得列表中的单个值列表后面方括号内的整数被称为“下标”。列表中第一个值的下标是 0，第二个值的下标是 1，第三个值的下标是 2，依此类推。如果使用的下标超出了列表中值的个数， Python 将给出 IndexError 出错信息。列表也可以包含其他列表值。这些列表的列表中的值， 可以通过多重下标来访问。123456789101112131415&gt;&gt;&gt; colors = ['red', 'green', 'blue', ['red and blue', 'red and green']]&gt;&gt;&gt; colors[0]red&gt;&gt;&gt; colors[1]green&gt;&gt;&gt; colors[2]blue&gt;&gt;&gt; colors[1] + colors[2]greenblue&gt;&gt;&gt;&gt;&gt;&gt; pcolors[4][1]red and green&gt;&gt;&gt;&gt;&gt;&gt; colors[5]IndexError: list index out of range 负数下标虽然下标从 0 开始并向上增长，但也可以用负整数作为下标。整数值−1 指的是列表中的最后一个下标， −2 指的是列表中倒数第二个下标，以此类推。1234567&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; colors[-1]blue&gt;&gt;&gt; colors[-3]red&gt;&gt;&gt; colors[-1] + colors[-3]bluered 用 len()取得列表的长度len()函数将返回传递给它的列表中值的个数， 就像它能计算字符串中字符的个数一样。123&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; len(colors)3 用下标改变列表中的值可以使用列表的下标来改变下标处的值。例如， spam[1] = &#39;aardvark&#39; 意味着“将列表 spam 下标 1 处的值赋值为字符串’aardvark’。12345678&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; colors[1] = 'red and blue'&gt;&gt;&gt; colors[1]'red and blue'&gt;&gt;&gt;&gt;&gt;&gt; colors[-1] = 'blue and red'&gt;&gt;&gt; print(colors[-1])blue and red 列表连接和列表复制操作符可以连接两个列表， 得到一个新列表， 就像它将两个字符串合并成一个新字符串一样。 *操作符可以用于一个列表和一个整数，实现列表的复制。 1234567&gt;&gt;&gt; a = [1, 2, 3] + ['a', 'b', 'c']&gt;&gt;&gt; a[1, 2, 3, 'a', 'b', 'c']&gt;&gt;&gt;&gt;&gt;&gt; a = a * 2&gt;&gt;&gt; a[1, 2, 3, 'a', 'b', 'c', 1, 2, 3, 'a', 'b', 'c'] 用 del 语句从列表中删除值del 语句将删除列表中下标处的值， 表中被删除值后面的所有值， 都将向前移动一个下标。12345678&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; del colors[2]&gt;&gt;&gt; colors['red', 'green']&gt;&gt;&gt;&gt;&gt;&gt; del colors[1]&gt;&gt;&gt; colors['red'] 列表用于循环在 for 循环中可以使用 range(len(someList))， 来迭代列表的每一个下标。1234567&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; for i in range(len(colors)): print('Index : ' + str(i) + \" in color is: \" + colors[i])Index : 0 in color is: redIndex : 1 in color is: greenIndex : 2 in color is: blue in 和 not in 操作符利用 in 和 not in 操作符， 可以确定一个值否在列表中。 像其他操作符一样， in和 not in 用在表达式中， 连接两个值： 一个要在列表中查找的值， 以及待查找的列表。这些表达式将求值为布尔值。12345&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; 'red' in colorsTrue&gt;&gt;&gt; 'black' not in colorsTrue 多重赋值技巧多重赋值技巧是一种快捷方式， 让你在一行代码中， 用列表中的值为多个变量赋值。所以不必像这样：1234colors = ['red', 'green', 'blue']red = colors[0]green = colors[1]blue = colors[2] 可有使用如下技巧：12colors = ['red', 'green', 'blue']red, green, blue = colors 最后要注意变量的数目和列表的长度必须严格相等， 否则 Python 将给出 ValueError。 增强赋值针对+、 -、 *、 /和%操作符， 都有增强的赋值操作符。123456789a = 10a += 1a -= 2a *= 2a /= 2a %= 5print(a) # 9.0 方法方法和函数是一回事，只是它是调用在一个值上。方法部分跟在这个值后面，以一个句点分隔。每种数据类型都有它自己的一组方法。例如， 列表数据类型有一些有用的方法，用来查找、 添加、 删除或操作列表中的值。 用 index()方法在列表中查找值列表值有一个 index()方法， 可以传入一个值， 如果该值存在于列表中， 就返回它的下标。如果该值不在列表中， Python 就报 ValueError。1234567&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; colors.index('red')0&gt;&gt;&gt; colors.index('black')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ValueError: 'black' is not in list 用 append()和 insert()方法在列表中添加值使用append()方法调用， 可以将参数添加到列表末尾。insert()方法可以在列表任意下标处插入一个值。 insert()方法的第一个参数是新值的下标， 第二个参数是要插入的新值。1234567&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; colors.append('black')&gt;&gt;&gt; colors['red', 'green', 'blue', 'black']&gt;&gt;&gt; colors.insert(1, 'orange')&gt;&gt;&gt; colors['red', 'orange', 'green', 'blue', 'black'] 用 remove()方法从列表中删除值给 remove()方法传入一个值，它将从被调用的列表中删除。12345&gt;&gt;&gt; colors = ['red', 'orange', 'green', 'blue', 'black']&gt;&gt;&gt; colors.remove('black')&gt;&gt;&gt; colors.remove('orange')&gt;&gt;&gt; colors['red', 'green', 'blue'] 用 sort()方法将列表中的值排序数值的列表或字符串的列表， 能用 sort()方法排序。123456789&gt;&gt;&gt; colors = ['red', 'green', 'blue']&gt;&gt;&gt; colors.sort()&gt;&gt;&gt; colors['blue', 'green', 'red']&gt;&gt;&gt;&gt;&gt;&gt; a = [5, 3, 2, 1]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1, 2, 3, 5] 也可以指定 reverse 关键字参数为 True， 让 sort()按逆序排序。123&gt;&gt;&gt; a.sort(reverse=True)&gt;&gt;&gt; a[5, 3, 2, 1] 排序注意事项： 首先， sort()方法当场对列表排序。不要写出 colors = colors.sort()这样的代码。 其次， 不能对既有数字又有字符串值的列表排序，因为 Python 不知道如何比较它们。 第三， sort()方法对字符串排序时， 使用“ASCII 字符顺序”， 而不是实际的字典顺序。这意味着大写字母排在小写字母之前。因此在排序时， 小写的 a 在大写的 Z 之后。 类似列表的类型：字符串和元组列表并不是唯一表示序列值的数据类型。例如， 字符串和列表实际上很相似，只要你认为字符串是单个文本字符的列表。对列表的许多操作， 也可以作用于字符串：按下标取值、 切片、 用于 for 循环、 用于 len()， 以及用于 in 和 not in 操作符。需要注意的是：字符串是“不可变的”， 它不能被更改。尝试对字符串中的一个字符重新赋值， 将导致 TypeError 错误。12345678910111213&gt;&gt;&gt; name = 'Veinin' &gt;&gt;&gt; name[0] 'V' &gt;&gt;&gt; name[-1] 'n' &gt;&gt;&gt; 'in' in name True &gt;&gt;&gt; 'p' not in name True&gt;&gt;&gt; name[0] = 'A'Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'str' object does not support item assignment 字符串是“不可变的”， 它不能被更改。“改变” 一个字符串的正确方式， 是使用切片和连接。构造一个“新的” 字符串， 从老的字符串那里复制一些部分。1234567&gt;&gt;&gt; name = 'Veinin'&gt;&gt;&gt; newName = 'Jali' + name[4:6]&gt;&gt;&gt; name'Veinin'&gt;&gt;&gt; newName'Jaliin'&gt;&gt;&gt; 元组数据类型除了两个方面，“元组” 数据类型几乎与列表数据类型一样。首先， 元组输入时用圆括号()， 而不是用方括号[]。其次，元组像字符串一样， 是不可变的。 元组不能让它们的值被修改、 添加或删除。1234567891011&gt;&gt;&gt; colors = ('red', 'green', 'blue')&gt;&gt;&gt; colors[0]'red'&gt;&gt;&gt; colors[-2]'green'&gt;&gt;&gt; colors[1:3]('green', 'blue')&gt;&gt;&gt; colors[2] = 'black'Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment 如果需要元组值的一个可变版本， 使用函数函数 list() 将元组转换成列表就很方便。 相反也可以使用 tuple() 函数将列表转换成元组。 引用对于字符串和整数值赋值操作，将执行拷贝操作，赋值后二者是不同的变量，保存了不同的值。但列表不是这样的。 当你将列表赋给一个变量时，实际上是将列表的“引用”赋给了该变量。引用是一个值，指向某些数据。列表引用是指向一个列表的值。12345678910111213141516&gt;&gt;&gt; a = 40&gt;&gt;&gt; b = a&gt;&gt;&gt; a = 50&gt;&gt;&gt; a50&gt;&gt;&gt; b40&gt;&gt;&gt;&gt;&gt;&gt; foo = [1, 2, 3]&gt;&gt;&gt; bar = foo&gt;&gt;&gt; foo[0] = 120&gt;&gt;&gt; foo[120, 2, 3]&gt;&gt;&gt; bar[120, 2, 3]&gt;&gt;&gt; 传递引用当函数被调用时， 参数的值被复制给变元。对于列表以及字典， 这意味着变元得到的是引用的拷贝。1234567&gt;&gt;&gt; def something(arr):... arr.append(4)...&gt;&gt;&gt; arr = [1, 2, 3]&gt;&gt;&gt; something(arr)&gt;&gt;&gt; arr[1, 2, 3, 4] copy()和 deepcopy() 函数在处理列表和字典时，尽管传递引用常常是最方便的方法， 但如果函数修改了传入的列表或字典， 你可能不希望这些变动影响原来的列表或字典。要做到这一点，Python 提供了名为 copy 的模块， 其中包含 copy()和 deepcopy()函数。第一个函数copy.copy()， 可以用来复制列表或字典这样的可变值， 而不只是复制引用。如果要复制的列表中包含了列表， 那就使用 copy.deepcopy()函数来代替。deepcopy()函数将同时复制它们内部的列表。1234567891011121314import copya = [1, 2, 3, [4, 5, 6]]b = copy.copy(a)a[0] = 110a[3][0] = 120print(a) # [110, 2, 3, [120, 5, 6]]print(b) # [1, 2, 3, [120, 5, 6]]c = copy.deepcopy(a)c[3][0] = 4print(a) # [110, 2, 3, [120, 5, 6]]print(c) # [110, 2, 3, [4, 5, 6]]","categories":[{"name":"Python","slug":"Python","permalink":"https://veinin.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://veinin.com/tags/Python/"},{"name":"编程","slug":"编程","permalink":"https://veinin.com/tags/编程/"}]},{"title":"Python 快速上手 - 函数","slug":"python-practice-functions","date":"2018-03-18T07:29:00.000Z","updated":"2018-03-24T14:09:57.972Z","comments":true,"path":"2018/03/18/python-practice-functions/","link":"","permalink":"https://veinin.com/2018/03/18/python-practice-functions/","excerpt":"Python 提供了这样一些内建函数，但你也可以编写自己的函数。“函数”就像一个程序内的小程序。 使用 def 语句定义一个函数12345678def hello(): print('Veinin') print('Veinin Guo') print('Hello trere.')for i in range(3): hello() print('')","text":"Python 提供了这样一些内建函数，但你也可以编写自己的函数。“函数”就像一个程序内的小程序。 使用 def 语句定义一个函数12345678def hello(): print('Veinin') print('Veinin Guo') print('Hello trere.')for i in range(3): hello() print('') 函数参数定义一个函数时可以自己定义接收参数，传入的参数值，放在函数的括号之间。12345def hello(name): print('Hello ' + name)hello('Veinin')hello('Jalin') 返回值和 return 语句函数调用求值的结果， 称为函数的“返回值”。用 def 语句创建函数时， 可以用 return 语句指定应该返回什么值。 return 语句包含以下部分： return 关键字； 函数应该返回的值或表达式。12345678910111213141516import randomdef getAnswer(answerNumber): if answerNumber == 1: return 'It is certain' elif answerNumber == 2: return 'It is decidedly so' elif answerNumber == 3: return 'Yes' else: return 'No'r = random.randint(1, 4)fortune = getAnswer(r)print(fortune) None 值在 Python 中有一个值称为 None，它表示没有值。 None 是 NoneType 数据类型的唯一值。像布尔值 True和 False 一样， None 必须大写首字母 N。12345spam = Noneprint(None == spam)spam = 'Hello'print(None == spam) 关键字参数和 print()print()函数有可选的变元 end 和 sep， 分别指定在参数末尾打印什么，以及在参数之间打印什么来隔开它们。默认情况下，print()函数自动在传入的字符串末尾添加了换行符。可以设置 end 关键字参数，将它变成另一个字符串。例如，如果程序像这样：12print('Hello', end='')print('World') print()传入多个字符串值时，该函数就会自动用一个空格分隔它们。可以传入 sep 关键字参数， 替换掉默认的分隔字符串。1234567&gt;&gt;&gt; print('cats', 'dogs', 'mice')cats dogs mice&gt;&gt;&gt; print('Red', 'Green', 'Blue')Red Green Blue&gt;&gt;&gt; print('Red', 'Green', 'Blue', sep=',')Red,Green,Blue 局部和全局作用域在被调用函数内赋值的变元和变量，处于该函数的“局部作用域”。在所有函数之外赋值的变量，属于“全局作用域”。处于局部作用域的变量，被称为“局部变量”。处于全局作用域的变量，被称为“全局变量”。 作用域很重要， 理由如下： 全局作用域中的代码不能使用任何局部变量 12345def spam(): eggs = 31337spam()print(eggs) # NameError: name 'eggs' is not defined 局部作用域可以访问全局变量 12345name = 'Veinin'def hello(): print('Hello, ' + name)hello() 一个函数的局部作用域中的代码，不能使用其他局部作用域中的变量 12345678910def spam(): eggs = 99 bacon() print(eggs)def bacon(): ham = 101 print(eggs) # NameError: name 'eggs' is not definedspam() 如果在不同的作用域中，你可以用相同的名字命名不同的变量。也就是说，可以有一个名为 spam 的局部变量，和一个名为 spam 的全局变量。 1234567def spam(): eggs = 'spam local' print(eggs) # prints 'spam local'eggs = 'global'spam()print(eggs) # prints 'global' global 语句如果需要在一个函数内修改全局变量， 就使用 global 语句。它就告诉 Python，在这个函数中， 某个值指的是全局变量， 所以不要用这个名字创建一个局部变量。1234567def spam(): global eggs eggs = 'spam'eggs = 'global'spam()print(eggs) 有 4 条法则， 来区分一个变量是处于局部作用域还是全局作用域： 1．如果变量在全局作用域中使用（即在所有函数之外），它就总是全局变量。 2．如果在一个函数中，有针对该变量的 global 语句，它就是全局变量。 3．否则，如果该变量用于函数中的赋值语句，它就是局部变量。 4．但是，如果该变量没有用在赋值语句中，它就是全局变量。12345678910111213def spam(): global eggs eggs = 'spam' # this is the global def bacon(): eggs = 'bacon' # this is the local def ham(): print(eggs) # this is the globaleggs = 42 # this is the globalspam()print(eggs) 异常处理在 Python 程序中遇到错误， 或“异常”， 如果不处理，意味着整个程序崩溃。而我们希望程序能检测错误， 处理它们，然后继续运行。 以下代码，当试图用一个数除以零时，就会发生 ZeroDivisionError: division by zero 错误提示。从而导致后面代码中断运行。123456def devide(divideBy): return 42 / divideByprint(devide(2))print(devide(0))print(devide(22)) 我们可以使用 try 和 except 语句来处理错误。那些可能出错的语句被放在 try 子句中。如果错误发生，程序执行就转到接下来的 except 子句开始处。123456789def devide(divideBy): try: return 42 / divideBy except ZeroDivisionError: print('Error: Invalid argument.')print(devide(2))print(devide(0))print(devide(22))","categories":[{"name":"Python","slug":"Python","permalink":"https://veinin.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://veinin.com/tags/Python/"},{"name":"编程","slug":"编程","permalink":"https://veinin.com/tags/编程/"}]},{"title":"Python 快速上手 - 控制流","slug":"python-practice-flow-control","date":"2018-03-18T07:22:00.000Z","updated":"2018-04-19T13:36:01.225Z","comments":true,"path":"2018/03/18/python-practice-flow-control/","link":"","permalink":"https://veinin.com/2018/03/18/python-practice-flow-control/","excerpt":"程序就是一系列指令。但编程真正的力量不仅在于运行（或“执行”） 一条接一条的指令， 就像周末的任务清单那样。根据表达式求值的结果，程序可以决定跳过指令， 重复指令， 或从几条指令中选择一条运行。实际上， 你几乎永远不希望程序从第一行代码开始， 简单地执行每行代码， 直到最后一行。“控制流语句” 可以决定在什么条件下执行哪些 Python 语句。 布尔值“布尔” 数据类型只有两种值： True 和 False。 Boolean（布尔） 的首字母大写， 因为这个数据类型是根据数学家 George Boole 命名的。12345678910&gt;&gt;&gt; spam = True&gt;&gt;&gt; spamTrue&gt;&gt;&gt; trueTraceback (most recent call last):File \"&lt;pyshell#2&gt;\", line 1, in &lt;module&gt;trueNameError: name 'true' is not defined&gt;&gt;&gt; True = 2 + 2SyntaxError: assignment to keyword","text":"程序就是一系列指令。但编程真正的力量不仅在于运行（或“执行”） 一条接一条的指令， 就像周末的任务清单那样。根据表达式求值的结果，程序可以决定跳过指令， 重复指令， 或从几条指令中选择一条运行。实际上， 你几乎永远不希望程序从第一行代码开始， 简单地执行每行代码， 直到最后一行。“控制流语句” 可以决定在什么条件下执行哪些 Python 语句。 布尔值“布尔” 数据类型只有两种值： True 和 False。 Boolean（布尔） 的首字母大写， 因为这个数据类型是根据数学家 George Boole 命名的。12345678910&gt;&gt;&gt; spam = True&gt;&gt;&gt; spamTrue&gt;&gt;&gt; trueTraceback (most recent call last):File \"&lt;pyshell#2&gt;\", line 1, in &lt;module&gt;trueNameError: name 'true' is not defined&gt;&gt;&gt; True = 2 + 2SyntaxError: assignment to keyword 比较操作符“比较操作符” 比较两个值，求值为一个布尔值。12345678&gt;&gt;&gt; 42 == 42True&gt;&gt;&gt; 42 == 99False&gt;&gt;&gt; 2 != 3True&gt;&gt;&gt; 2 != 2False 布尔操作符3 个布尔操作符（and、 or 和 not） 用于比较布尔值。12345678&gt;&gt;&gt; True and TrueTrueFalse or TrueTrue&gt;&gt;&gt; not TrueFalse(4 &lt; 5) and (5 &lt; 6)True 控制流语句if 语句if 语句的子句（也就是紧跟 if 语句的语句块），将在语句的条件为 True 时执行。如果条件为 False，子句将跳过。if 语句包含以下部分： if 关键字； 条件（即求值为 True 或 False 的表达式）； 冒号； 在下一行开始，缩进的代码块（称为 if 子句）。12if name == 'Alice': print('Hi, Alice.') else 语句if 子句后面有时候也可以跟着 else 语句。只有 if 语句的条件为 False 时， else子句才会执行。lse 语句中包含下面部分： else 关键字； 冒号； 在下一行开始，缩进的代码块（称为 else 子句）。1234if name == 'Alice': print('Hi, Alice.')else: print('Hello, stranger.') elif 语句有时候可能你希望，“许多” 可能的子句中有一个被执行。 elif 语句是“否则如果”，总是跟在 if 或另一条 elif 语句后面。在代码中， elif 语句总是包含以下部分： elif 关键字； 条件（即求值为 True 或 False 的表达式）； 冒号； 在下一行开始，缩进的代码块（称为 elif 子句）。 while 循环语句while 语句总是包含下面几部分： 关键字； 条件（求值为 True 或 False 的表达式）； 冒号； 从新行开始，缩进的代码块（称为 while 子句）。1234spam = 0while spam &lt; 5: print('Hello, world.') spam = spam + 1 break 语句如果执行遇到 break 语句，就会马上退出 while 循环子句。在代码中， break 语句仅包含 break 关键字。123456while True: print('Please type your name.') name = input() if name == 'Veinin': breakprint('Thank you!') continue 语句像 break 语句一样， continue 语句用于循环内部。如果程序执行遇到 continue语句，就会马上跳回到循环开始处，重新对循环条件求值12345678910while True: print('Who are your?') name = input() if name != 'Veinin': continue print('Hello, Veinin. What is the password?') password = input() if password == '123': breakprint('Access granted.') for 循环和 range()函数通过 for 循环语句和 range()函数来实现一个代码块执行固定次数。for 语句看起来像 for i in range(5):这样， 总是包含以下部分： for 关键字； 一个变量名； in 关键字； 调用 range()方法，最多传入 3 个参数； 冒号； 从下一行开始，缩退的代码块（称为 for 子句）。12345678print('My name is')for i in range(5): print('Jimmy Five Time (' + str(i) + ')') total = 0for num in range(100): total = total + numprint(total) range()的开始、 停止和步长参数下列代码 range 函数中，第一个参数是 for 循环变量开始的值， 第二个参数是上限， 但不包含它， 也就是循环停止的数字。第三个参数是“步长”。 步长是每次迭代后循环变量增加的值。12for i in range(0, 10, 2): print(i) 导入模块Python 程序可以调用一组基本的函数， 这称为“内建函数”， 包括你见到过的print()、 input()和 len()函数。 Python 也包括一组模块，称为“标准库”。每个模块都是一个 Python 程序， 包含一组相关的函数， 可以嵌入你的程序之中。例如， math模块有数学运算相关的函数， random 模块有随机数相关的函数， 等等。在代码中， import 语句包含以下部分： import 关键字； 模块的名称； 可选的更多模块名称，之间用逗号隔开。123import randomfor i in range(5): print(random.randint(1, 10)) 使用逗号分隔符来导入多个模块1import random, sys, os, math from import 语句import 语句的另一种形式包括 from 关键字，之后是模块名称， import 关键字和一个星号， 例如 from random import * 。使用这种形式的 import 语句，调用 random模块中的函数时不需要 random.前缀。但是， 使用完整的名称会让代码更可读， 所以最好是使用普通形式的 import 语句。 用 sys.exit()提前结束程序通过调用 sys.exit()函数， 可以让程序终止或退出。因为这个函数在 sys 模块中，所以必须先导入 sys， 才能使用它。12345678import syswhile True: print('Type exit to exit.') response = input() if response == 'exit': sys.exit() print('You typed ' + response + '.')","categories":[{"name":"Python","slug":"Python","permalink":"https://veinin.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://veinin.com/tags/Python/"},{"name":"编程","slug":"编程","permalink":"https://veinin.com/tags/编程/"}]},{"title":"《小狗钱钱》读书笔记","slug":"reading-notes-money-oder-das","date":"2018-03-04T12:12:00.000Z","updated":"2018-03-04T12:21:15.600Z","comments":true,"path":"2018/03/04/reading-notes-money-oder-das/","link":"","permalink":"https://veinin.com/2018/03/04/reading-notes-money-oder-das/","excerpt":"《小狗钱钱》讲述的是一个童话故事，一个普通小女孩吉娅发现一只受伤的拉布拉多犬，并把它带回了家，取名叫钱钱。可是，有谁会想到，这只普通的四脚动物却是一个真正的理财天才呢？吉娅和小狗成为了朋友，通过小狗钱钱的指导，最后吉娅成功实现了自己的梦想，它彻底改变了吉娅一家人的财富命运。这是一本老少皆宜的理财入门书籍。作者是被誉为欧洲首席金钱教练博多·舍费尔。这本书会教你如何从小学会支配金钱，而不是受金钱的支配；如何像富人那样思考，正确地认识和使用金钱；如何进行理财投资，找到积累资产的方法，早日实现财务自由！","text":"《小狗钱钱》讲述的是一个童话故事，一个普通小女孩吉娅发现一只受伤的拉布拉多犬，并把它带回了家，取名叫钱钱。可是，有谁会想到，这只普通的四脚动物却是一个真正的理财天才呢？吉娅和小狗成为了朋友，通过小狗钱钱的指导，最后吉娅成功实现了自己的梦想，它彻底改变了吉娅一家人的财富命运。这是一本老少皆宜的理财入门书籍。作者是被誉为欧洲首席金钱教练博多·舍费尔。这本书会教你如何从小学会支配金钱，而不是受金钱的支配；如何像富人那样思考，正确地认识和使用金钱；如何进行理财投资，找到积累资产的方法，早日实现财务自由！ 梳理理财目标中国的智者老子说过：“天下难事，必作于易；天下大事，必作于细”。你自己必须真的有“想要变得富有”这个愿望，所以你必须找到10个“想要变得富有”的梦想。然后找出3项你觉得最重要的梦想出来，并作为目标，然后拿一本相册作为你的梦想相册。收集一些与自己的愿望有关的照片，把它们贴在相册里。我们要通过图片来思考。最后为自己的每一个梦想各准备一个储蓄罐，比如银行卡子账户。一旦储蓄罐准备好，你就应当把省下的每一分钱放进去。 撰写成功日记你是否能挣到钱，最关键的并不是你有没有好点子，也不是你有多聪明，而是你的自信程度。你的自信程度决定了你是否相信自己的能力，是否相信你自己。假如你根本不相信你能做到的话，那么你就根本不会动手去做，而假如你不开始去做，那么你就什么也得不到。自信是很容易梳理的，你只需要准备一个本子，给它取名叫‘成功日记’，然后每天都把当天所有做成功的事情记录进去。每次都写至少5条你的个人成果，任何小事都可以。 坚持你的梦想不论在什么情况下，每天都坚持自己所做所想。不间断地设想我的未来。当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。 快速摆脱负债毁掉所有的信用卡。在许可范围内按最低的分期付款数目标准支付。应当尽可能少地偿还贷款。分期付款额越高，每个月剩下的生活费就越少。许多人和银行约定的分期付款数额刚好在他们承受能力的上限，因此他们手里的钱一直很紧张。将扣除生活费后剩下的钱的一半存起来，剩下的一半用于支付消费贷款。最好根本不申请消费贷款。债务人都应该在自己的钱包里贴一张纸条，上面写着“这真的有必要吗”。这样的话，当他站在收银台前的时候，就会想到不应该花太多的钱。 合理分配你挣到的钱如果你想变得富有，你同时还要存钱，这笔钱是你绝不会再花的，只用利息进行消费，让你能依靠本金来生活。拥有一只自己的“鹅”。鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。把50％的收入变的“鹅”，用来让鹅长大；40％放入梦想储蓄罐，用来帮助实现自己的目标；剩下的10％用来零花。 进行明确的投资应该把钱投资在安全的地方。我的钱应该下很多“金蛋”。我们要足够了解你的投资对象，投资应该简单明了，而且易于操作。用72除以通货膨胀率，得出的数字就是你的钱在多少年后只值现在的一半。聪明的商人可不会让自己的钱只躺在银行里睡大觉，这样做根本没有什么利息。即使有，通货膨胀也会完全吞掉你的利息。用72除以年收益率的百分比，得出的数字就是这笔钱翻一番的年数。如果你们投资的收益率是15％，差不多5年以后，钱就会翻一倍。 如何挑选基金基金应该至少有10年历史。假如它在这么长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。 语录 不是试试看，而是去切实行动！如果你只是抱着试试看的心态，那么你只会以失败告终，你会一事无成。“尝试”纯粹是一种借口，你还没有做，就已经给自己想好了退路。不能试验，你只有两个选择——做或者不做。 学习就是认识新观念和新想法的过程。假如人们始终以同一种思维方式来考虑问题的话，那么始终只会得到同样的结果。因为我对你讲述的许多内容是你以前从未接触过的，所以我建议你，在你还没有做之前，不要轻易下结论。没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。 必须学会量入为出，否则有了更多的钱只会给他们带来更大的麻烦，因为支出往往会和收入一同增长，除非我们学会合理分配我们的财产。 要想过更幸福、更满意的生活，人就得改变自身。这和钱无关，金钱本身既不会使人幸福，也不会带来不幸。金钱是中性的，既不好，也不坏。只有当钱属于某一个人的时候，它才会对这个人产生好的影响或者坏的影响。钱可以被用于好的用途，也可以被用于坏的用途。一个幸福的人有了钱会更幸福；而一个悲观忧虑的人，钱越多，烦恼就越多。” 没有人能强迫你做你不愿意做的事情。只有你自己才能强迫自己去做。 最珍贵的礼物是我们自己争取来的。克服了丢面子的恐惧，世界就会向你敞开大门！ 成功会使人骄傲。如果你骄傲自大，你就会停止学习。不学习，人就不会再进步。 对股票，每个人都知道一点点，可是很少有人清楚它到底是什么东西。 金融家有时候还真是一群奇怪的人。也许当他们随意地说出一串除了他们自己谁也听不懂的名词时，他们会觉得自己比较重要。但遗憾的是，许多人因此感到自己不懂投资。不懂的东西，人们是不相信的。而其实这些东西就是这么简单。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://veinin.com/categories/读书笔记/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://veinin.com/tags/投资/"},{"name":"理财","slug":"理财","permalink":"https://veinin.com/tags/理财/"}]},{"title":"《富爸爸，穷爸爸》读书笔记","slug":"reading-notes-rich-dad-poor-dad","date":"2018-02-25T14:42:00.000Z","updated":"2018-03-04T12:13:53.003Z","comments":true,"path":"2018/02/25/reading-notes-rich-dad-poor-dad/","link":"","permalink":"https://veinin.com/2018/02/25/reading-notes-rich-dad-poor-dad/","excerpt":"我们从小就听父母说，好好读书，好好上课，毕业了找一份好的工作。那好好上学真的可以找到好的工作吗？找到好的工作肯定会变富有吗？我想这些问题的答案都是否定的，谁能够一直坐在教室里听着那些枯燥乏味的教学内容，那些内容让我们只会运用于考试中，在生活中往往被我们给忽略了。我们如何才能让我们的生活不在为了金钱而忙碌，我们为什么不能让金钱为我们而工作呢！ 因此，要学会管理风险，要学会投资，不要让我们的生活只留下房贷、车贷。不要生活在一种虚假的忙碌中，那样的生活没有意义，只会让我们在往后的生活中教育自己的后代：好好上学，好好读书，找个好工作。这样的生活在当今社会已经不实用了，没有谁会认为只有读书才有出路。 《富爸爸，穷爸爸》是一个真实的故事，作者罗伯特·清崎从人的个体出发分析富人之所以成为富人，穷人之所以成为穷人的自身因素，提出了一个全新的“财商”的概念。并向传统的学校教育提出挑战。","text":"我们从小就听父母说，好好读书，好好上课，毕业了找一份好的工作。那好好上学真的可以找到好的工作吗？找到好的工作肯定会变富有吗？我想这些问题的答案都是否定的，谁能够一直坐在教室里听着那些枯燥乏味的教学内容，那些内容让我们只会运用于考试中，在生活中往往被我们给忽略了。我们如何才能让我们的生活不在为了金钱而忙碌，我们为什么不能让金钱为我们而工作呢！ 因此，要学会管理风险，要学会投资，不要让我们的生活只留下房贷、车贷。不要生活在一种虚假的忙碌中，那样的生活没有意义，只会让我们在往后的生活中教育自己的后代：好好上学，好好读书，找个好工作。这样的生活在当今社会已经不实用了，没有谁会认为只有读书才有出路。 《富爸爸，穷爸爸》是一个真实的故事，作者罗伯特·清崎从人的个体出发分析富人之所以成为富人，穷人之所以成为穷人的自身因素，提出了一个全新的“财商”的概念。并向传统的学校教育提出挑战。 清崎有两个爸爸，其中一个有博士学位的是他的亲生爸爸，也是本书中的穷爸爸；另外一个初中都没有读完是他好友的爸爸，即本书中的富爸爸。两位爸爸都有非常高的收入，但是穷爸爸却常常为钱而烦恼，而富爸爸最后成为了夏威夷最富有的人。 富爸爸过世后给家里留下了很多的财产，而穷爸爸则为家人留下了很多没有还清的债务。之所以会出现这样的情况，是因为穷爸爸缺乏基本的财务知识。 而关于财务教育最大的问题是学校没有教过这门学科，所以我们对于财务的教育都来自家庭，而问题就在于除非你的父母是属于收入很高的1%的那一部分人，不然我们普通的家庭并不知道如何教自己的孩子财务方面的知识。而且他们也不会阅读像《富爸爸穷爸爸》这类的书籍。如果我们没有出身在那1%的家庭，那么我们可以向清崎来学习，学习“富爸爸”的观念，即不要做金钱的奴隶，要让金钱为我们工作。 第一课：富人不为钱工作穷人和中产阶级为钱而工作。起床，上班，付账，再起床，再上班，再付账……他们的生活从此被这两种感觉所控制：恐惧和贪婪。给他们更多的钱，他们就会以更高的开支重复这种循环。这就是所谓的的‘老鼠赛跑’。人们自身的恐惧和无知使他们困在陷阱里，正是出于恐惧的心理，人们才想找一份安稳的工作。这些恐惧有：害怕付不起账单，害怕被解雇，害怕没有足够的钱，害怕重新开始。为了寻求保障，他们会学习某种专业，或是做生意，拼命为钱而工作。大多数人成了钱的奴隶，然后就把怒气发泄在他们老板身上。他们不明白自己为什么老缺钱，于是以为多挣点钱就能解决问题，但几乎没有人意识到缺乏财商教育才是问题的关键。 第二课：为什么要教授财务知识一个受过高等教育且事业有成的人，同时也可能是财务上的文盲。这种人往往太过努力地工作，因为他们只知道努力工作，却不知道如何让钱为他们工作。如果人们认为钱能解决一切问题，恐怕他们的日子就不会太好过。只有知识才能解决问题并创造财富，那些不是靠财务知识挣来的钱也不会长久。你必须明白资产和负债的区别，并且购买资产。如果你想致富，这一点你必须知道。富人获得资产，而穷人和中产阶级获得负债，只不过他们以为那些负债就是资产。资产是能把钱放进你口袋里的东西。负债是把钱从你口袋里取走的东西。富人：增加收入，减少支出和负债，买入更多资产。穷人：增加收入，增加支出和负债。中产阶级：购买自以为是资产的负债。 第三课：关注自己的事业职业不等于你的事业。大多数人工作其实是为其他人，而非他们自己。首先他们要为公司的老板工作，其次是通过纳税为政府工作，最后是为向他们提供住房按揭贷款的银行工作。多关注自己的事业。存在财务问题的人经常耗费一生为别人工作，其中许多人在他们不能工作时就变得一无所有。富人与穷人一个重要的区别就是：富人最后才买奢侈品，而穷人和中产阶级会先买下诸如大房子、珠宝、皮衣、宝石、游艇等奢侈品，因为他们想让自己看上去很富有。他们看上去的确很富有，但实际上他们已深陷贷款的陷阱之中。那些能给子孙留下遗产的人和那些能长期富有的人，就是先构筑资产项，然后才用资产所产生的收入购买奢侈品的，而穷人和中产阶级则用他们的血汗钱和本应该留给子孙的遗产来购买奢侈品。 真正的资产可以分为以下几类： 1．不需我到场就可以正常运作的业务。我拥有它们，但由别人经营和管理。如果我必须在那儿工作，那它就不是我的事业而是我的职业了； 2．股票； 3．债券； 4．共同基金； 5．能够产生收入的房地产； 6．票据（借据）； 7．版税，如音乐、手稿、专利； 8．其他任何有价值、可产生收入或有增值潜力并且有很好销路的东西。 第四课：税收的历史和公司的力量公司的避税优势： 1.公司的某些收入可以用于税前收入支出 2.企业所得税率低于个人所得税率 知识就是力量，而且钱越多，就越需要知识管理它，使它继续增加。没有这种知识，世界就会牵着你走。 财商是由4个方面的专门知识构成的： 第一是会计，也就是我说的财务知识。 第二是投资，我把它称为钱生钱的科学。投资涉及策略和方案，这要右脑来做，是属于创造的部分。 第三是了解市场，它是供给与需求的科学。这要求了解受感情驱动的市场的“技术面”。 第四是法律。利用一个具有会计、投资和市场运营的企业会使你的财富实现爆炸性地增长。了解减税优惠政策和公司法的人会比雇员和小业主更快致富。拥有公司的富人：挣钱、支出、缴税为公司工作的人：挣钱、缴税、支出 第五课：富人的投资我们都拥有巨大的潜能，然而，我们都拥有或多或少的自我怀疑的心理。过分的害怕和自我怀疑是毁掉我们才能的最大因素。成为财务上的天才既需要专业知识，又需要足够的勇气。投资者分为两类：第一类也是最普遍的一类，即进行一揽子投资的人。他们联系一家从事经营个人投资业务的中介机构，例如房地产公司、股票经纪人或财务规划师等，然后买下某些产品。这些产品可能是共同基金、房地产投资信托、股票或债券等。 第二类是自己创造投资机会的投资者。这种投资者通常会自行组织一项交易，好比一个人买来电脑零部件，然后自己组装，这有点像量身定做。这类投资者，除了提高财商的4项基本技能，还必须具备3种主要技能， 1．如何寻找其他人都忽视的机会。 2．如何增加资金。 3．怎样把精明的人组织起来。聪明的人往往会雇用比自己更聪明的人或与他们一起工作。当你需要建议的时候，你一定要确定你选择的是明智的顾问。 第六课：学会不为钱工作大部分人需要学习和掌握不止一项技能，只有这样他们的收入才能获得显著增长。财商是会计、投资、市场和法律等各方面知识和能力的综合。将上述4种技能结合起来，以钱生钱就会容易得多。当涉及钱的时候，只有一项技能的人不得不努力工作。找一份稳定的工作。大部分人是为短期的工资和福利工作的，但从长期来看这种做法常常是具有灾难性的。劝告年轻人在找工作时要看能从中学到什么，而不是只看能挣多少钱。在选择某种职业或陷入“老鼠赛跑”的陷阱之前，要仔细看看脚下的路，弄清楚自己到底想获得什么技能。是建议他们要有长远的眼光。我承认为了金钱和生活安稳而工作是很重要，但我仍主张要再找一份工作，以便从中学到另一种技能。我受过良好教育的爸爸工作越努力，就越具有竞争力，但同时他也更深地陷入专业特长的陷阱之中。虽然他的工资增长了，可他的选择机会却少了。直到失去了在政府中的工作，他才发现自己在职业选择上是多么被动。这就好比职业运动员因为突然受伤或是年龄太大而无法继续参加比赛一样，他们会失去曾经拥有的高收入工作，而有限的技能又使他们无法另辟蹊径。我想， 克服困难掌握财务知识的人有时候还是不能积累丰厚的资产项，其主要原因有5个： 1．恐惧心理。 2．愤世嫉俗。 3．懒惰。 4．不良习惯。 5．自负。 开始行动 1．我需要一个超现实的理由——精神的力量。 2．每天作出自己的选择——选择的力量。从理财的角度来说，我们每挣到一美元，就得到了一次选择自己是成为富人、穷人还是中产阶级的机会。我们花钱的习惯反映了我们是什么样的人，穷人之所以贫穷是因为他们有着不良的消费习惯。 3．慎重地选择朋友——关系的力量。首先，我不会把理财状况作为挑选朋友的标准。 4．掌握一种模式，然后再学习一种新的模式——快速学习的力量。面包师要按照一定的配方做面包，即使配方只是记在脑子里。挣钱也是一样的道理，这也是金钱有时被称做“面包圈”的原因。 5．首先支付自己——自律的力量。如果你控制不了自己，就别想着致富。不要背上数额过大的债务包袱。要保持低支出。首先增加自己的资产，然后，再用资产项产生的现金流来买大房子或好车子。陷在“老鼠赛跑”中不是明智的选择。当你资金短缺时，让压力去发挥作用，而不要动用你的储蓄或资本。利用这种压力来激发你的理财天赋，想出新办法挣到更多的钱，然后再支付账单。这样做，不但能让你赚到钱，还能提高你的财商。 6．给你的经纪人以优厚的报酬——好建议的力量。 7．做一个“印第安给予者”——无私的力量。 8．用资产来购买奢侈品——专注的力量。 9．对英雄的崇拜——神话的力量。 10．先予后取——给予的力量。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://veinin.com/categories/读书笔记/"}],"tags":[{"name":"理财","slug":"理财","permalink":"https://veinin.com/tags/理财/"},{"name":"富爸爸","slug":"富爸爸","permalink":"https://veinin.com/tags/富爸爸/"},{"name":"穷爸爸","slug":"穷爸爸","permalink":"https://veinin.com/tags/穷爸爸/"}]},{"title":"《程序员跳槽全攻略》读书笔记","slug":"reading-notes-programmer-job-hopping-strategy","date":"2018-01-15T11:20:00.000Z","updated":"2018-07-24T14:25:35.393Z","comments":true,"path":"2018/01/15/reading-notes-programmer-job-hopping-strategy/","link":"","permalink":"https://veinin.com/2018/01/15/reading-notes-programmer-job-hopping-strategy/","excerpt":"原理篇跳槽不是什么跳槽不是为了追求价值最⼤化虽然前边我们从纯商业的⾓度讨论了跳槽这件事， 但实际上我们并不推荐求职者单纯地通过薪资的⾼低来选择雇主。 原因有两个。 ⼯作是⽣活的⼀部分你每天有24⼩时， 上班8⼩时， 它是你三分之⼀的⽣命。 如果你只是因为⾼薪选择了⼀家上班不开⼼的公司， 那么接下来三分之⼀的⽇ ⼦你都会在痛苦中渡过。 ⽽你得到的， 只是多出来的那么每⽉⼏千块钱⽽已。 职业的不可逆性别的事情错了我们可以重来， ⽽职业选择上， 每⼀步都是好⼏年的时光。 ⼀旦⾛下去， 就很难回头， 因为⼀旦换职业⽅向、 哪怕换个开发语⾔， 都意味着你之前的积累很可能前功尽弃。 所以眼光放⻓远点， 不要只看眼前的⾼薪， 更要看好未来的发展， ⽅向错了， 跑得越猛输得越狠。 跳槽不是找⼯作跳槽不是找⼯作， ⽽是换⼯作。 所以它和你刚毕业时找⼯作不⼀样， 它是有成本的。到⼀家新的公司， 需要放弃原来公司的期权， 需要重新熟悉业务， 重新和同事搞好⼈际关系， 上班路上需要花更多的时间， 甚⾄需要离开⾃⼰熟悉的城市。你并不是⼀⽆所有， 虽然往往只有在你失去后才发现。 所以跳槽之前要考虑好⾃ ⼰的付出和收益， 衡量好得失， 没事别裸辞。 跳槽不是加薪的砝码不要以跳槽为砝码去谈加薪， 这种迫胁性的谈薪资⽅式会使主管对你丧失信任。 不管涨薪成不成功， 他都不得不为你的离职做好准备， ⽽当准备完成后， 你就可以⾛⼈了。类似的， 当你提跳槽时， 如果你的主管通过加薪来挽留你， 最好也不要同意。","text":"原理篇跳槽不是什么跳槽不是为了追求价值最⼤化虽然前边我们从纯商业的⾓度讨论了跳槽这件事， 但实际上我们并不推荐求职者单纯地通过薪资的⾼低来选择雇主。 原因有两个。 ⼯作是⽣活的⼀部分你每天有24⼩时， 上班8⼩时， 它是你三分之⼀的⽣命。 如果你只是因为⾼薪选择了⼀家上班不开⼼的公司， 那么接下来三分之⼀的⽇ ⼦你都会在痛苦中渡过。 ⽽你得到的， 只是多出来的那么每⽉⼏千块钱⽽已。 职业的不可逆性别的事情错了我们可以重来， ⽽职业选择上， 每⼀步都是好⼏年的时光。 ⼀旦⾛下去， 就很难回头， 因为⼀旦换职业⽅向、 哪怕换个开发语⾔， 都意味着你之前的积累很可能前功尽弃。 所以眼光放⻓远点， 不要只看眼前的⾼薪， 更要看好未来的发展， ⽅向错了， 跑得越猛输得越狠。 跳槽不是找⼯作跳槽不是找⼯作， ⽽是换⼯作。 所以它和你刚毕业时找⼯作不⼀样， 它是有成本的。到⼀家新的公司， 需要放弃原来公司的期权， 需要重新熟悉业务， 重新和同事搞好⼈际关系， 上班路上需要花更多的时间， 甚⾄需要离开⾃⼰熟悉的城市。你并不是⼀⽆所有， 虽然往往只有在你失去后才发现。 所以跳槽之前要考虑好⾃ ⼰的付出和收益， 衡量好得失， 没事别裸辞。 跳槽不是加薪的砝码不要以跳槽为砝码去谈加薪， 这种迫胁性的谈薪资⽅式会使主管对你丧失信任。 不管涨薪成不成功， 他都不得不为你的离职做好准备， ⽽当准备完成后， 你就可以⾛⼈了。类似的， 当你提跳槽时， 如果你的主管通过加薪来挽留你， 最好也不要同意。 程序员如何谈薪资如果你对现在公司很满意， 只是觉得薪资太低， 那么可以先和你的主管聊聊。 我⼀般这么谈加薪的： ⾸先， 讲⼀讲⾃ ⼰最近在⼯作上的成⻓， 看主管是否认同； 然后， 从能⼒提升⾓度， 向主管要⼀个更⼤的发展空间和更⼤的业务挑战； 最后， 问问当你的能⼒达到这个新的⽔平时， 薪资是否可以同步提升起来。 这样谈有⼏个好处： 它建⽴了⼀个谈话基础， 那就是薪资应该和能⼒相匹配； 它不谈现在的薪资， ⽽是谈未来， ⼀⽅⾯表明你对现在的薪资还算满意（以减少主管顾虑） ， 另⼀⽅⾯对主管来讲， 他没有⽴刻给你涨薪的压⼒； 它体现了你对⾃ ⼰能⼒提升的渴求， ⽽如果在谈话中出现任何不顺利， 你可以把中途把对话结束， 根本不提加薪的事情。 当然， 坏处就是你得隔段时间才能加薪了。 跳槽的意义跳槽其实是打⼯这种挣钱形态下， 我们进⾏自我调节的⽅式， 通过合理地跳槽， 我们可以寻找到市场需求和⾃ 我实现的最佳匹配， 从⽽在⾦钱和成⻓上双丰收。 跳槽的原则永远不要因为「现在很差」 ⽽跳槽， 要因为「未来更好」 ⽽跳槽。 只有这样才能保证你⼀直往上⾛。 跳槽的节奏和路线图当我们还是⼀个应届毕业⽣的时候， 我们是不可能直接变成CTO的。 所以我们从CTO往下⼀层层画出节点来， ⼤概这个样⼦：应届⽣ → 初级程序员 → ⼩组主管 → 部⻔经理 → 总监 → CTO 我们也会根据具体情况对职业线做出调整， ⽐如当你⼩组主管做的很出⾊， 但部⻔经理这个节点却很难达到时， 我们可以这么⾛：应届⽣ → 初级程序员 → ⼩组主管 → 初创公司CTO → B轮公司CTO → 上市公司CTO 准备篇如何构架价值我是谁，我有什么资源这部分是对自己能力和资历的一个梳理。 我的竞争优势这部分是基于自己的能力和资历，我们认为自己比别的求职者更有优势的地方。注意除了写上你已经有的优势外，还可以写上你可以有的优势。然后我们可以在准备期把这些暂时还没有的优势变成现实。这就是为什么我们建议大家提前1~3个月来准备下一次的跳槽。 谁可以帮助我这部分是指可以帮助你构建价值的人。我们把内部推荐放到这个地方的原因是，推荐你的人会为你做背书，从而证明你的高价值。推荐你的人是否认识和了解你，是否愿意赌上自己名声为你做背书，这很重要。某些网站提供的内部员工推荐并不能为你的价值加分，因为推荐人根本不认识你，这时内部推荐就降格成一种渠道了。 构建个人品牌对于技术人员，下边这个列表我是建议你要有的： Github账号，不解释。 技术博客，可以直接放到Github上，Big更高。 微博，最好能加V，用于业内交流。 技术社区账号，比如stackoverflow。 有了这些账号还不行，还得有持续更新的优质内容。平时遇到的大小问题可以零星记录到微博上；相对大块的东西，可以写成文章放到博客，通过微信推送给订阅的朋友；成系统的东西，可以在文章基础上整理成迷你书。 学会沟通和写作条理性其实我们技术人员工作中大部分的写作，都是应用文写作，并不需要你有丰富的想象力、风趣幽默的文风、小清新的玻璃心或者历经沧桑的过去，只需要你把事情讲清楚就好了，所以只要内容条理性够好，听众就会很OK。 逻辑性虽然缺乏逻辑性是产品经理的而不是程序员的通病，这里也提一下吧。我们写文章或者做汇报时，前后文之间是应该有明确关系的，后一句对于前一句，或者是后续、或者是或者是论据、或者是总结、或者是并列。不要搞跳跃性思维，不能前边一句说你去了洗手间，后一句说你吃得很饱，这会出人命的。 走完分享的最后一公里下边给⼀些常⻅的渠道， 如果是技术⽂章： ⾸先可以发布到你⾃⼰的技术博客 然后同步到微博（可以⽤ifttt） 如果反响不错， 可以再通过微信公众号推送给订阅读者 提交到 startup news 和 cdsn的极客头条 针对⽂章的受欢迎程度，我们还可以进⾏⼆次加⼯： 根据⽂章内容制作PPT， 通过slideshare和微盘分享 定期精选系列⽂章， 更新到最新后整理成PDF， 通过微盘分享 对于特别受欢迎的教程类⽂章， 可以做screencast， 通过在线教育网站（⽐如优才网、 慕课网等） 进⾏传播 如果是开源项目， 当然就是GitHub了。 提升架构能力DRYDRY是Don’tRepeatYourself的缩写，翻译过来就是「不做重复事」。这正是一个逼近软件本质的原则，它指导我们把经常使用的功能抽象成库，把重复出现的代码重构为可重用的框架模块。如果你用DRY来要求自己，很快你就会发现自己抽象和架构能力的飙升。 半自动化除了手动和自动，我们还可以半自动化——让机器做完所有繁杂的常规操作，人类来处理需要智慧的那一点点工作就好，这也能极大的提升工作效率。 正交性正交性的意思是，功能和功能之间应该尽可能不互相干扰。只有这样，我们才能有效地控制每个部分的行为。所以功能之间的依赖尽可能少，如果有，规则一定要明确，不要试图去做一些自作聪明的事情。 操作篇求职材料简历的本质是⼈⽣履历， 不是项目清单， 也不是技能⼤放送。简历的存在只有⼀个目的 —— 帮你约到⾯试。 只要能达到这个目的， 简历可以是⼀段视频， ⼀个开源项目， ⼀张照⽚， 甚⾄是⼀⾏字。绝⼤部分简历的形式， 就是我们所熟知的， 是⼀篇⽂章。 简历要说什么⼀份好的简历， 要低调的告诉招聘⽅， 爷很NB。 通过FAB法则来增强其说服⼒： Feature： 是什么 Advantage： ⽐别⼈好在哪些地⽅ Benefit： 如果雇佣你， 招聘⽅会得到什么好处 给论据别给论题论据要具体， 最基本的是要数字化， 再好点的论据要让⼈印象深刻。 每天PV8个亿， 这是数字化； 访问量超越Google App Engine， 这是让⼈印象深刻。 对⽐体现成⻓我在项目⾥边没有那么显赫的成绩可以说怎么办？讲不出成绩时， 就讲你的成⻓。 因为学习能⼒也是每家公司都看中的东⻄。 你可以写你在这个项目⾥边遇到了⼀个什么样的问题， 之前怎么解决的， 之后解决的， 新⽅案好在什么地⽅， 你是寻找到这个新⽅案的， 最终这个⽅案的效果如何。具体、 量化、 有说服⼒， 是技术简历特别需要注重的地⽅。 求职邮件求职邮件只需要简单的写上在什么地⽅看到招聘启事， 应聘什么职位即可。最好在正⽂中写上完整的⽂本简历， 然后在附件⾥附上PDF版本。 这样招聘⽅更容易查找到你。如果你要使⽤QQ邮箱， 请确保你的⽤户名看起来像个程序员。 建议使⽤Gmail或者⾃⼰的域名邮箱。作为附件的PDF不要起名为「个⼈简历.PDF」 ， ⽽应该是「 XXX简历.PHP开发⼯程师.PDF 」 ， 这样当HR分拣简历⽂件时能第⼀时间看到你。 求职渠道⼈脉： 最优途径在求职过程中， 信任是⾮常重要的， 原本冗⻓复杂的⼈才筛选和鉴定流程， 因为信任， 可以简单。 竞拍： 遍历潜在机会⼤部分程序员都⽐较内向， 更喜欢和机器打交道， 所以在找⼯作的时候， 能帮忙的朋友并不多。 这个时候，竞拍就变成了最靠谱的渠道了。 猎头： 求职中的隐私保护猎头渠道已经变得很乱了，⽐如卖简历。最好不要在简历中留自己的常⽤电话号码，可以买⼀个号专⻔求职⽤，比如阿里同学“亲⼼⼩号”。 常规渠道技术社区的招聘版： V2ex ChinaUnix OSchina ThinkPHP 前端乱炖 ⾏业招聘网站： 内推网 拉勾网 直投： 绕过HRHR本⾝是不懂技术的， 所以他们也很难准确的进⾏简历筛选。对技术主管进⾏直投是很好地补充⼿段。微博， 要找这些技术主管其实并不难， 只需要在微博搜索⻚⾯， 按公司搜⼈就可以得到该公司的员⼯列表， 然后发私信或评论给他们， 问问他们公司是否招⼈， 是否可以帮忙推荐简历。 面试准备 遍历简历知识点。⾯试时， 很多问题都由简历引申出来。 技能树。 常⻅⾯试问题。为什么要离职？遇到过的最⼤的挑战以及解决的办法？你希望三年后， 成为⼀个什么样的⼈？你还有什么要问我们的？… 知⼰知彼。如果你知道⾯试⼈是谁， 那么在⾯试之前记得仔细读⼀读他的博客和微博。 准时和礼。和招聘⽅约定好的时间应该尽量准时， 晚到的话， 应该发短信告知。 如果你已经确定了offer， 不想再⾯试了， 应该给之前承诺参加⾯试的招聘⽅群发短信或邮件告知。 离职离职访谈可以对具体的规定吐吐苦⽔， 但尽量避免对同事， 尤其是上级， 尤其是上级的⼈品发表评论。说什么？ ⽼规矩， 要讲因为新的机遇⽐较好， 所以才离职； 原来公司同事都很好， 有些舍不得， 所以现在才⾛；给公司的建议挑两个⽆关痛痒的提就好了， 没必要当真。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://veinin.com/categories/读书笔记/"}],"tags":[{"name":"职业规划","slug":"职业规划","permalink":"https://veinin.com/tags/职业规划/"}]},{"title":"《人类简史》读书笔记","slug":"reading-notes-a-brief-history-of-humankind","date":"2017-12-31T11:59:10.000Z","updated":"2017-12-31T03:03:03.098Z","comments":true,"path":"2017/12/31/reading-notes-a-brief-history-of-humankind/","link":"","permalink":"https://veinin.com/2017/12/31/reading-notes-a-brief-history-of-humankind/","excerpt":"十万年前，地球上至少有六种不同的人。但今日，世界舞台为什么只剩下了我们自己？从只能啃食虎狼吃剩的残骨的猿人，到跃居食物链顶端的智人，从雪维洞穴壁上的原始人手印，到阿姆斯壮踩上月球的脚印，从认知革命、农业革命，到科学革命、生物科技革命，我们如何登上世界舞台成为万物之灵的？ 这是以色列历史学家尤瓦尔·赫拉利成名作，这本书以不到500页的篇幅，从10万年前一直讲到了21世纪，为我们理清人类的发展脉络提供了一个充满哲思的全局视角。","text":"十万年前，地球上至少有六种不同的人。但今日，世界舞台为什么只剩下了我们自己？从只能啃食虎狼吃剩的残骨的猿人，到跃居食物链顶端的智人，从雪维洞穴壁上的原始人手印，到阿姆斯壮踩上月球的脚印，从认知革命、农业革命，到科学革命、生物科技革命，我们如何登上世界舞台成为万物之灵的？ 这是以色列历史学家尤瓦尔·赫拉利成名作，这本书以不到500页的篇幅，从10万年前一直讲到了21世纪，为我们理清人类的发展脉络提供了一个充满哲思的全局视角。 在历史的路上，有三大重要革命：大约7万年前，“认知革命”（CognitiveRevolution）让历史正式启动。大约12000年前，“农业革命”（AgriculturalRevolution）让历史加速发展。而到了大约不过是500年前，“科学革命”（ScientificRevolution）可以说是让历史画下句点而另创新局。这本书的内容，讲述的就是这三大革命如何改变了人类和其他生物。 认知革命人类是怎么从一种平凡无奇的动物走到食物链顶端的，认知革命带给了我们答案。 大约在240万年前的东非最早的人类开始演化，祖先是一种更早的猿属“Australopithecus”（南方古猿）。大约200万年前，这些远古人类有一部分离开了家园而踏上旅程，足迹遍及北非、欧洲和亚洲的广大地带。北欧的森林白雪皑皑，印度尼西亚的热带丛林湿气蒸腾，想活命显然需要不同的特征，因此人类也开始朝着不同方向进化。于是人类发展出几个不同的物种，除了“智人”以外，还有比如在欧洲和西亚的“尼安德特人”，住在在东方亚洲的“直立人”等等。 如果不出意外，可能在今天我们可以看到多个不同的人种，多种人种共存其实会是常态。但是，意外出现了，大约7万年前，智人从东非扩张到阿拉伯半岛，并且很快席卷整个欧亚大陆，由于不同的人种之间的水火不容，互有反感，于是发生种族灭杀，当地的原生人种很快就会灭绝。大约3万年前尼安德特人退出了世界舞台，而到了12000年前，像小矮人般的人类也从弗洛里斯岛上永远消失，这种残酷的种族屠杀一直持续到了大约1万年前，终于，地球上的人种只剩下了智人一种。 因为智人迁移到其他地区，而造成其他人类物种的灭绝。那么为什么是智人，而不是其他人种呢？那是因为在大约7万年前，智人仿佛脱胎换骨，某次偶然的基因突变，改变了智人的大脑内部连接方式，让他们以前所未有的方式来思考，用完全新式的语言来沟通。他们的认知能力（学习、记忆、沟通）得到了革命性的发展，这时的智人已经和你我同样聪明、有创意、反应灵敏，他们产生了新的思维和沟通方式，这也是所谓的认知革命。 认知革命给智人带来了新的语言，这种新语言带来了最独特的功能–“讨论虚构的事物”。智人的语言并不是世界上的第一种语言。因为许多动物（包括所有的猿类和猴类）都会使用有声语言。例如，青猴（greenmonkey）就有各种不同的喊叫方式，传达不同的信息。不论是人类还是许多动物，都能大喊：“小心！有狮子！”。但在认知革命之后，智人就能够说出：“狮子是我们部落的守护神”。智人能够谈论并不真正存在的事物，相信一些不太可能的事情。于是传说、神话、神以及宗教也应运而生。 “虚构”这件事的重点不只在于让人类能够拥有想象，更重要的是可以“一起”想象，编织出种种共同的虚构故事，不管是《圣经》的《创世记》、澳大利亚原住民的“梦世记”（Dreamtime），甚至连现代所谓的国家其实也是种想象。这样的虚构故事赋予智人前所未有的能力，让我们得以集结大批人力、灵活合作。虽然一群蚂蚁和蜜蜂也会合作，但方式死板，而且其实只限近亲。至于狼或黑猩猩的合作方式，虽然已经比蚂蚁灵活许多，但仍然只能和少数其他十分熟悉的个体合作。智人的合作则是不仅灵活，而且能和无数陌生人合作。正因如此，才会是智人统治世界，蚂蚁只能吃我们的剩饭，而黑猩猩则被关在动物园和实验室里。 于人类共同的想象之外，这个宇宙中根本没有神、没有国家、没有钱、没有人权、没有法律，也没有正义。通过虚构的故事，就算是大批互不相识的人，只要同样相信相信某个故事，就能共同合作。无论是现代国家、中世纪的教堂、古老的城市，或者古老的部落，任何大规模人类合作的根基，都在于某种只存在于集体想象中的虚构故事。而这也使智人最后打破了团体的人数限制，创造出了有数万居民的城市、有上亿人口的帝国，这也是智人成功的关键。 农业革命人类曾有长达250万年的时间靠采集及狩猎维生，并不会特别干预动植物的生长情形。直立人、匠人或是尼安德特人都会采集野无花果、猎捕野绵羊，但不会去管究竟无花果树该长在哪，羊该在哪片草地吃草，又或是哪只公羊该跟母羊交配。 这一切在大约1万年前全然改观，人类开始投入几乎全部的心力，操纵着几种动植物的生命。从日升到日落，人类忙着播种、浇水、除草、牧羊，一心以为这样就能得到更多的水果、谷物和肉类。这是一场关于人类生活方式的革命：农业革命。 农业革命让人类的食物总量增加，但量的增加并不代表吃得更好、过得更悠闲，反而只是造成人口爆炸，而且产生一群养尊处优、娇生惯养的精英分子。普遍来说，农民的工作要比采集者更辛苦，而且到头来的饮食还要更糟。农业革命可说是史上最大的一桩骗局。 正是这些征收来的多余食粮，养活了政治、战争、艺术和哲学，建起了宫殿、堡垒、纪念碑和庙宇。在现代晚期之前，总人口有九成以上都是农民，日出而作、胼手胝足。他们生产出来的多余食粮养活了一小撮的精英分子：国王、官员、战士、牧师、艺术家和思想家，但历史写的几乎全是这些人的故事。于是，历史只告诉了我们极少数的人在做些什么，而其他绝大多数人的生活就是不停挑水耕田。 农业革命后几千年的历史，可以总结为一个问题：如果人类的基因里并没有大规模合作的生物本能，所有的合作网络究竟如何维系？简单的讲法，是人类创造出了由想象建构的秩序、发明了文字，以这两者补足我们基因中的不足。但对许多人来说，这些合作网络究竟是好是坏实在难说。网络背后那些想象的秩序既不中立也不公平，总把人分成一些其实并不存在的分类，并且排出上下等级。上等人享有各种权力和特权，而下等人有的只有歧视和压迫。 人类统一融合农业革命之后，人类社会规模变得更大、更复杂，而维系社会秩序的虚构故事也更为细致完整。人类几乎从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照着这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化”。 每种文化都自成一格、和谐共存，而且都有独特的不变本质。每一群人都会有自己的世界观，和社会、法律及政治系统，而且各自运作顺畅，就像是行星绕着太阳一样。 从实际观点看，全球融合最关键的阶段就是过去这几个世纪。各大帝国成长，全球贸易强化，亚洲、非洲、美洲和大洋洲的人类形成紧密连接，于是印度菜里出现了墨西哥的辣椒，阿根廷的草原上漫步着来自西班牙的牛。 在过去的3000年间，人类有越来越多雄心勃勃的计划，想要实现这种世界一家的概念。他们发明货币、建筑帝国和传播宗教。 商业、帝国和全球性的宗教，最后终于将几乎每个智人都纳入了我们今天的全球世界。这个扩张和统一的过程并不是完全直线发展、一帆风顺。但纵观大局，可以看到从许多小文化到少数大文化再到最后的全球单一文化，应该是人类历史无法避免的结果。 科学革命历史就这样从一个岔路走到下一个岔路，选择走某条道路而非另一条的原因总是神秘而不得而知。大约在公元1500年，历史做出了最重大的选择，改变的不只是人类的命运，而是地球上所有生命的命运。我们将它称为“科学革命”。 将人类带到阿拉莫戈多、带上月球的这段历史进程，称为“科学革命”。在这场革命中，人类因为将资源投入科学研究，取得了巨大的新力量。之所以说这是一场革命，是因为一直到大约公元1500年前，全球人类还不相信自己能在医疗、军事和经济方面再有什么突破。政府和富有的赞助者虽然也会将资金投入教育和作为奖学金，但一般来说只是为了维持现有能力，而不是取得新的能力。典型的前现代统治者会赞助牧师、哲学家和诗人，目的是请他们让他的统治合法化，并且维护社会秩序，而不是要他们发明新的药物、武器，或是刺激经济成长。 但在过去的500年中，人类越来越相信可以靠着投资科学研究提升人类的能力。而且这不只是盲目的信仰，而是经过了反复的证明。随着证据越来越多，手中握有资源的富人和政府也就越来越愿意投入科学。如果没有这些投资，人类永远不可能在月球上漫步，不可能操纵微生物，更不可能分裂原子。 后记历史有太多的可能性，而许多的可能性最后都未成真。我们不难想象，历史其实很有可能就这样一代又一代地过去，而从未发生科学革命，就算没有基督教，没有古罗马帝国，没有金币，历史还是会继续发展下去。 在7万年前，智人还不过是一种微不足道的动物，在非洲的角落自顾自地生活。但就在接下来的几千年间，智人就成了整个地球的主人、生态系统的梦魇。时至今日，智人似乎只要再跨一步就能进入神的境界，不仅有望获得永恒的青春，更拥有创造和毁灭一切的神力。 但遗憾的是，智人在地球上的所作所为，实在没有太多令人自豪。虽然我们主宰了环境、增加了粮食产量、盖起城市、建立帝国，还创造了无远弗届的贸易网络，但全球的痛苦减少了吗？一次又一次，虽然整体人类的能力大幅提升，但却不一定能改善个别人类的福祉，而且常常还让其他动物深受其害。 拥有神的能力，但是不负责任、贪得无厌，而且连想要什么都不知道。天下危险，恐怕莫此为甚。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://veinin.com/categories/读书笔记/"}],"tags":[{"name":"人类简史","slug":"人类简史","permalink":"https://veinin.com/tags/人类简史/"},{"name":"历史","slug":"历史","permalink":"https://veinin.com/tags/历史/"},{"name":"人类学","slug":"人类学","permalink":"https://veinin.com/tags/人类学/"}]},{"title":"《拖延心理学》读书笔记","slug":"reading-notes-procrastination","date":"2017-12-02T08:15:00.000Z","updated":"2017-12-02T08:22:19.080Z","comments":true,"path":"2017/12/02/reading-notes-procrastination/","link":"","permalink":"https://veinin.com/2017/12/02/reading-notes-procrastination/","excerpt":"拖延从根本上来说并不是一个时间管理方面或懒惰的问题，也不是一个道德问题，而是一个复杂的心理问题。根本而言，拖延的问题是一个人跟自身如何相处的问题，它反映的是一个人在自尊上的问题。 本书的第一部分中，我们对产生拖延的形形色色的根源进行了追溯，告诉我们为何会拖延。在第二部分中，给出了一些帮助你采取行动的建议，教导我们如何去应对拖延症。我们的目标并不是消除拖延。很多时候对一些事情弃之不理反而对你最为有利；相反，这本书希望能够让你更加接受自己，由你自己来掌握取舍和得失。","text":"拖延从根本上来说并不是一个时间管理方面或懒惰的问题，也不是一个道德问题，而是一个复杂的心理问题。根本而言，拖延的问题是一个人跟自身如何相处的问题，它反映的是一个人在自尊上的问题。 本书的第一部分中，我们对产生拖延的形形色色的根源进行了追溯，告诉我们为何会拖延。在第二部分中，给出了一些帮助你采取行动的建议，教导我们如何去应对拖延症。我们的目标并不是消除拖延。很多时候对一些事情弃之不理反而对你最为有利；相反，这本书希望能够让你更加接受自己，由你自己来掌握取舍和得失。 我们为何拖延表面上看来，拖延症是因为懒，或者是对时间管理能力不足而造成的。而本书告诉了我们一个真正的原因，拖延症的成因主要是源于内心的恐惧。 由于家庭、性格、以及自己的各种经历，会导致人们产生各种各样的恐惧。很多拖延者并不能识别所有这些活跃于表面现象之下的情绪波动，因为他们利用拖延来逃避不舒服的感受。为了对付这些恐惧，我们产生了一种防卫机制来对抗恐惧，而拖延就是用来避免恐惧的。这样的反应模式一次次循环，让我们一次次的陷入了“拖延怪圈”中。 对于“拖延怪圈”，每个人都有自己不同的体验。你或许在几个星期、几个月，甚至几年时间内都挣扎在这个怪圈当中，或者，你也可能从头到尾只需要几个小时就经历了一个怪圈。 “这次我想早点开始。” “我得马上开始。” “我不开始又怎么样呢？” a.“我应该早点开始。” b.“我可以做任何事，除了这件……” c.“我无法享受任何事情。” d.“我希望没人发现。” “还有时间。” “我这个人有毛病。” 最后的抉择：做还是不做。 道路之一：不做 a.“我无法忍受了！” b.“何必庸人自扰呢？” 道路之二：背水一战 a.“我不能再坐等了。” b.“事情还没有这么糟，为什么当初我不早一点开始做呢？” c.“把它做完就行了！” “我永远不会再拖延！” 人们之所以产生拖延的不良习性，是因为他们害怕。他们害怕如果他们行动了，他们的行为会让他们陷入麻烦。他们担心如果展示了自己真实的一面，会有危险的结果等着他们。在所有无序和拖拉的背后，他们其实在害怕他们不被接受，以至于他们不仅躲开这个世界，甚至还躲开他们自己。虽然要忍受自责、自轻和对自己的反感是相当痛苦的，但是比起去看清真实的自我所带来的脆弱和无地自容，这样的感受或许更能够被承受得起，拖延是保护他们的盾牌。 如何改变拖延做出改变和学会一种新的行为模式是一个渐进的过程，这是一个可以预知的改变顺序，称为为“改变的阶段”。 第一阶段，“前关注”，没有准备做出改变，甚至都没有想过要做改变。 第二阶段，“关注”，通过阅读这本书，你知道了拖延是因为恐惧，你开始思考是否准备采取行动。 第三阶段，“准备”，做了一点尝试，虽然没有完全投入其中。“好吧，我终于要开始锻炼身体了”。 第四阶段，“行动”，“我今天去健身房，感觉还不错”。 当你迟迟不肯记账的时候，你可能是不想面对花费过大而收入过少的事实。当你一直不回短信的时候，你可能在恐惧跟陌生人打交道。当你迟迟不想写论文的时候，你可能是担心论文会占用所有的娱乐时间。 无论你的任何拖延是出于什么奇奇怪怪的原因，我们都应该坦然接受。慢慢来，不管你多么渴望改善自己，也不管你怎样努力，你不可能在第二天，或者下个星期，或者下个月，就一下子停止拖延了。 当我们再一次面对一件难事，大脑依然会收到恐惧信号，焦虑会立刻袭来，此时请提醒自己，不要重蹈覆辙，而是要改变心态，跳出拖延。 当你知道自己花钱太多，收入太少时，你可以提醒你自己，年轻人收入低，没关系，能进步就好。当你害怕和陌生人打交道是，你可以告诉自己，很多人都在做这样的事情。 观察你内心的抵抗情绪，虽然你在处理拖延问题上开始有所进步，但是你可能还是会因为自己努力不够、进步不大或者没有完成自己设定的所有目标而对自己感到失望或者生气。或者，你也可能会觉得我们对你要求太多了。不管抵抗情绪采取什么样的形式表现出来，它会让你停留在原地停滞不前。 通过树立新的行为模式和思维方法，我们就可以舒缓恐惧所带来的焦虑和压力，而不是靠拖延来逃避恐惧。 除此之外，涉及一些具体的改变拖延方法方面，书中还给出了很多实用性的建议，比如： 明确自己的目标与可行性的计划，启动一周试验。 学会更好的判断时间，提升你定是能力的技巧，让自己的时间观念通常跟“钟表时间”同步。 学会接受有益于你的人和事，学会结局那些没有意义的追求。 通过运动来启动你的状态，从拖延的麻痹状态中解救出来。 总结本书指出了人们之所以拖延的很多原因，认为拖延是心理问题。就像书中说的那样，光是认清楚拖延的根源还是不够的，你还必须做一些事情以防止拖延来主导你的生活，采用一些书中的建议，并行动起来。最后去尝试一种新的行为模式，感受自己的拖延，如实的去接受它，不再躲避，打破自己的拖延循环。 参考 《拖延心理学》，豆瓣读书 速读《拖延心理学》，bilibili","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://veinin.com/categories/读书笔记/"}],"tags":[{"name":"拖延症","slug":"拖延症","permalink":"https://veinin.com/tags/拖延症/"},{"name":"心理学","slug":"心理学","permalink":"https://veinin.com/tags/心理学/"}]},{"title":"《Linux 命令行与shell脚本编程大全》读书笔记（命令行部分）","slug":"reading-notes-linux-command-lime","date":"2017-11-24T15:30:00.000Z","updated":"2017-11-26T15:36:17.768Z","comments":true,"path":"2017/11/24/reading-notes-linux-command-lime/","link":"","permalink":"https://veinin.com/2017/11/24/reading-notes-linux-command-lime/","excerpt":"什么是 LinuxLinux可划分为以下四部分： Linux内核 系统内存管理 软件程序管理 硬件设备管理 文件系统管理 GNU工具GNU组织（GNU是GNU’s Not Unix的缩写），模仿Unix操作系统开发一系列标准的计算机系统工具，但没有可以运行它们的内核系统。","text":"什么是 LinuxLinux可划分为以下四部分： Linux内核 系统内存管理 软件程序管理 硬件设备管理 文件系统管理 GNU工具GNU组织（GNU是GNU’s Not Unix的缩写），模仿Unix操作系统开发一系列标准的计算机系统工具，但没有可以运行它们的内核系统。 核心GNU工具该项目移植了很多常见的Unix系统命令行工具。供Linux系统使用的这组核心工具被称为coreutils（coreutilities）软件包。由三部分构成：用以处理文件的工具、用以操作文本的工具、用以管理进程的工具 shellGNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。 shell的核心是命令行提示符。命令行提示符是shell负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中执行。所有Linux发行版默认的shell都是bash shell。 图形化桌面环境 X Window系统 KDE桌面（K Desktop Environment， K桌面环境） GNOME桌面（the GNU Network Object Model Environment， GNU网络对象模型环境） Unity桌面…… 应用软件Linux 发行版不同的Linux发行版通常归类为3种： 完整的核心Linux发行版核心Linux发行版含有内核、一个或多个图形化桌面环境以及预编译好的几乎所有能见到的Linux应用。它提供了一站式的完整Linux安装。 特定用途的发行版它们通常基于某个主流发行版，但仅包含主流发行版中一小部分用于某种特定用途的应用程序。如许多特定用途的Linux发行版都是基于Debian Linux，但仅打包了完整Debian系统中的一小部分。 LiveCD测试发行版它无需安装就可以看到Linux系统是什么样的。多数现代PC都能从CD启动，而不是必须从标准硬盘启动。基于这点，一些Linux发行版创建了含有Linux样本系统（称为Linux LiveCD）的可引导CD。 bash 手册man命令用来访问存储在Linux系统上的手册页面。在想要查找的工具的名称前面输入man命令，就可以找到那个工具相应的手册条目。手册每个内容区域都分配了一个数字，从1开始，一直到9：1：可执行程序或shell命令2：系统调用3：库调用4：特殊文件5：文件格式与约定6：游戏7：概览、约定及杂项8：超级用户和系统管理员命令9：内核例程 过滤输出列表ls命令能够识别标准通配符，并在过滤器中用它们进行模式匹配： 问号（?）代表一个字符； 星号（*）代表零个或多个字符。 在特定位置上可能出现的两种字符，a或i: 1ls -l my_scr[ai]pt 指定字符范围，例如字母范围[a – i]: 1ls -l f[a-i]ll 使用感叹号（!）将不需要的内容排除在外: 1ls -l f[!a]ll 管理文件目录处理文件 创建文件：touch 复制文件：cp 重命名文件：mv 删除文件：rm 链接文件：ln在系统上维护同一文件的两份或多份副本，除了保存多份单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法。这种虚拟的副本就称为链接。 文件链接在Linux中有两种不同类型的文件链接： 符号链接符号链接就是一个实实在在的文件，它指向存放在虚拟目录结构中某个地方的另一个文件。这两个通过符号链接在一起的文件，彼此的内容并不相同。使用ln命令以及-s选项来创建符号链接：1ln -s data_file sl_data_file 硬链接硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件。引用硬链接文件等同于引用了源文件。使用ln命令时不再需要加入额外的参数创建硬链接：1ln code_file hl_code_file 查看文件 显示文本文件中所有数据；cat 显示文本文件的内容，但会在显示每页数据之后停下来：more more命令的升级版：less 显示文件最后几行的内容：tail 显示文件开头那些行的内容：head 处理目录 创建目录：mkdir New_Dir 创建多个目录和子目录，需要加入-p参数：mkdir -p New_Dir/Sub_Dir/Under_Dir 删除目录，只删除空目录：rmdir New_Dir 删除目录及其所有内容：rm -rf Small_Dir 查看文件类型：file my_file 处理数据文件排序、搜索 排序数据：sort [options] [file] 搜索数据：grep [options] pattern [file] 压缩数据Linux上的文件压缩工具： bzip2，采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码，文件扩展名：.bz2 compress，最初的Unix文件压缩工具，已经快没人用了，文件扩展名：.Z gzip，GNU压缩工具，用Lempel-Ziv编码，文件扩展名：.gz zip，Windows上PKZIP工具的Unix实现，文件扩展名：.zip gzip 软件包是GNU项目的产物，意在编写一个能够替代原先Unix中compress工具的免费版本。这个软件包含有下面的工具： gzip：用来压缩文件。 gzcat：用来查看压缩过的文本文件的内容。 gunzip：用来解压文件。 归档数据虽然zip命令能够很好地将数据压缩和归档进单个文件，但它不是Unix和Linux中的标准归档工具。目前，Unix和Linux上最广泛使用的归档工具是tar命令。 tar命令的格式：1tar function [options] object1 object2 ... function参数定义了tar命令应该做什么： -A –concatenate 将一个已有tar归档文件追加到另一个已有tar归档文件 -c –create 创建一个新的tar归档文件 -d –diff 检查归档文件和文件系统的不同之处 –delete 从已有tar归档文件中删除 -r –append 追加文件到已有tar归档文件末尾 -t –list 列出已有tar归档文件的内容 -u –update 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中 -x –extract 从已有tar归档文件中提取文件 每个功能可用选项来针对tar归档文件定义一个特定行为： -C dir 切换到指定目录 -f file 输出结果到文件或设备file -j 将输出重定向给bzip2命令来压缩内容 -p 保留所有文件权限 -v 在处理文件时显示文件 -z 将输出重定向给gzip命令来压缩内容 列出归档内容：tar -tf test.tar提取归档内容：tar -xvf test.tar创建归档文件：tar -cvf test.tar test/ test2 管理进程探查进程当程序运行在系统上时，我们称之为进程（process）。想监测这些进程，需要熟悉ps命令的用法。使用ps命令的关键不在于记住所有可用的参数，而在于记住最有用的那些参数。 123456$ ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 Aug21 ? 00:07:16 /usr/lib/systemd/systemd --system --deserialize 26root 2 0 0 Aug21 ? 00:00:04 [kthreadd]root 3 2 0 Aug21 ? 00:00:28 [ksoftirqd/0]root 7 2 0 Aug21 ? 00:00:00 [migration/0] 常用参数： -e参数指定显示所有运行在系统上的进程； -f参数则扩展了输出，这些扩展的列包含了有用的信息。 -l参数，它会产生一个长格式输出。 这些扩展的列包含了有用的信息： UID：启动这些进程的用户。 PID：进程的进程ID。 PPID：父进程的进程号（如果该进程是由另一个进程启动的）。 C：进程生命周期中的CPU利用率。 STIME：进程启动时的系统时间。 TTY：进程启动时的终端设备。 TIME：运行进程需要的累计CPU时间。 CMD：启动的程序名称。 实时监测进程想观察那些频繁换进换出的内存的进程趋势，top命令刚好适用这种情况。 12345678910111213top - 15:54:00 up 95 days, 10:46, 1 user, load average: 0.14, 0.07, 0.06Tasks: 176 total, 1 running, 175 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 602816 total, 65452 free, 248696 used, 288668 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 177264 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 170 root 20 0 0 0 0 S 0.3 0.0 20:03.70 xfsaild/sda114270 root 20 0 828800 24620 2880 S 0.3 4.1 19:15.48 dockerd16454 systemd+ 20 0 888224 33020 0 S 0.3 5.5 7:18.88 mysqld31990 veining+ 20 0 155620 2216 1500 R 0.3 0.4 0:00.04 top 1 root 20 0 193496 4944 2392 S 0.0 0.8 7:25.59 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:04.07 kthreadd 输出的第一部分显示的是系统的概况： 第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载。 第二行显示了进程概要信息——top命令的输出中将进程叫作任务（task）：有多少进程处在运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）。 第三行显示了CPU的概要信息。 top根据进程的属主（用户还是系统）和进程的状态（运行、空闲还是等待）将CPU利用率分成几类输出。 最后两行说明了系统内存的状态。第一行说的是系统的物理内存：总共有多少内存，当前用了多少，还有多少空闲。后一行说的是同样的信息，不过是针对系统交换空间（如果分配了的话）的状态而言的。 最后一部分显示了当前运行中的进程的详细列表，有些列跟ps命令的输出类似： PID：进程的ID。 USER：进程属主的名字。 PR：进程的优先级。 NI：进程的谦让度值。 VIRT：进程占用的虚拟内存总量。 RES：进程占用的物理内存总量。 SHR：进程和其他进程共享的内存总量。 S：进程的状态（D代表可中断的休眠状态， R代表在运行状态， S代表休眠状态， T代表跟踪状态或停止状态， Z代表僵化状态）。 %CPU：进程使用的CPU时间比例。 %MEM：进程使用的内存占可用内存的比例。 TIME+：自进程启动到目前为止的CPU时间总量。 COMMAND：进程所对应的命令行名称，也就是启动的程序名。 结束进程在Linux中，进程之间通过信号来通信。进程的信号就是预定义好的一个消息，进程能识别它并决定忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。 在Linux上有两个命令可以向运行中的进程发出进程信号。 kill命令：kill 3940kill命令可通过进程ID（PID）给进程发信号。默认情况下，kill命令会向命令行中列出的全部PID发送一个TERM信号。遗憾的是，你只能用进程的PID而不能用命令名，所以kill命令有时并不好用。 killall命令：killall http*killall命令非常强大，它支持通过进程名而不是PID来结束进程。 killall命令也支持通配符，这在系统因负载过大而变得很慢时很有用。 管理磁盘Linux文件系统将所有的磁盘都并入一个虚拟目录下。在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作称为挂载（mounting）。如果用的Linux发行版不支持自动挂载和卸载可移动存储媒体，就必须手动完成。 mount命令Linux上用来挂载媒体的命令叫作mount。默认情况下， mount命令会输出当前系统上挂载的设备列表。12345$ mountsysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=294632k,nr_inodes=73658,mode=755)securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime) mount命令提供如下四部分信息： 媒体的设备文件名 媒体挂载到虚拟目录的挂载点 文件系统类型 已挂载媒体的访问状态 手动挂载媒体设备的基本命令：1mount -t type device directory umount命令从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。umount命令的格式非常简单：1umount [directory | device ] df 命令有时你需要知道在某个设备上还有多少磁盘空间。df命令可以让你很方便地查看所有已挂载磁盘的使用情况常用参数是-h，它会把输出中的磁盘空间按照用户易读的形式显示，通常用M来替代兆字节，用G替代吉字节。12345$ dfFilesystem 1K-blocks Used Available Use% Mounted on/dev/sda1 10474496 8675760 1798736 83% /devtmpfs 294632 0 294632 0% /devtmpfs 301408 0 301408 0% /dev/shm df命令会显示每个有数据的已挂载文件系统。命令输出如下： 设备的设备文件位置； 能容纳多少个1024字节大小的块； 已用了多少个1024字节大小的块； 还有多少个1024字节大小的块可用； 已用空间所占的比例； 设备挂载到了哪个挂载点上。 du 命令du命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这一方法可用来快速判断系统上某个目录下是不是有超大文件。 能让du命令用起来更方便的几个命令行参数： -c：显示所有已列出文件总的大小。 -h：按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节。 -s：显示每个输出参数的总计。 理解Shellshell 的类型系统启动什么样的shell程序取决于你个人的用户ID配置，在/etc/passwd文件中。默认的交互shell会在用户登录某个虚拟控制台终端或在GUI中运行终端仿真器时启动。不过还有另外一个默认shell是/bin/sh，它作为默认的系统shell，用于那些需要在启动时使用的系统shell脚本。 shell 的父子关系用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell，是一个父shell。在CLI提示符后输入/bin/bash命令或其他等效的bash命令时， 会创建一个新的shell程序。这个shell程序被称为子shell（child shell） 。 bash shell程序可使用命令行参数修改shell启动方式： -c string 从string中读取命令并进行处理 -i 启动一个能够接收用户输入的交互shell -l 以登录shell的形式启动 -r 启动一个受限shell，用户会被限制在默认目录中 -s 从标准输入中读取命令 依次运行的一系列命令。这可以通过命令列表来实现，只需要在命令之间加入分号（;）即可：pwd ; ls ; cd /etc ; pwd ; 要想将命令置入后台模式，可以在命令末尾加上字符&amp;：sleep 3000&amp; 协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。使用coproc命令进行协程处理：coproc sleep 10 理解 shell 的内建命令外部命令外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、 /usr/bin、 /sbin或/usr/sbin中。ps就是一个外部命令。你可以使用which和type命令找到它。当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。外部命令ps很方便显示出它的父进程以及自己所对应的衍生子进程。 内建命令内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。cd和exit命令都内建于bash shell。可以利用type命令来了解某个命令是否是内建的：123456$ type psps is hashed (/usr/bin/ps)$$ type -a echoecho is a shell builtinecho is /bin/echo 查看最近用过的命令列表：history 为常用的命令（及其参数）创建另一个名称：alias 要查看当前可用的别名，使用alias命令以及选项-p：alias -p 环境变量Linux环境变量能帮你提升Linux shell体验。很多程序和脚本都通过环境变量来获取系统信息、存储临时数据和配置信息。在Linux系统上有很多地方可以设置环境变量，了解去哪里设置相应的环境变量很重要。在涉及环境变量名时，如果要用到变量，使用$；如果要操作变量，不使用$。 在bash shell中，环境变量分为两类： 全局变量全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的shell可见。这让全局环境变量对那些所创建的子shell需要获取父shell信息的程序来说非常有用。要查看全局变量，可以使用 env 或 printenv 命令。 要显示个别环境变量的值，可以使用 printenv 命令：12$ printenv HOME/home/veininguo 也可以使用 echo 显示变量的值。在变量前面加上一个美元符（$）:12echo $HOME/home/veininguo 局部变量局部环境变量只能在定义它们的进程中可见。在Linux系统并没有一个只显示局部环境变量的命令。 set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。 设置用户定义变量可以在bash shell中直接设置自己的变量。 设置局部用户定义变量创建在shell进程内可见的局部变量，但在子shell中无法使用用户定义变量。可以通过等号给环境变量赋值，值可以是数值或字符串。所有的环境变量名均使用大写字母，如果是你自己创建的局部变量或是shell脚本，请使用小写字母。变量名、等号和值之间没有空格，这一点非常重要。123$ my_variable=&quot;Veinin Guo&quot;$ echo $my_variableVeinin Guo 设置全局环境变量在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。通过export命令来完成，变量名前面不需要加$。子shell无法使用export命令改变父shell中全局环境变量的值。1234567891011121314$ my_variable=&quot;I am Global now&quot;$ export my_variable$$ echo $my_variableI am Global now$$ bash$ echo $my_variableI am Global now$$ exitexit$ echo $my_variableI am Global now 删除环境变量可以用 unset 命令完成这个操作。在命令中引用环境变量时不要使用$。1234$ echo $my_variableI am Global now$ unset my_variable$ echo $my_variable 设置 PATH 环境变量在 shell 命令行界面中输入一个外部命令时， shell 必须搜索系统来找到对应的程序。PATH 环境变量定义了用于进行命令和程序查找的目录。PATH中的目录使用冒号分隔。 12$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/veininguo/.local/bin:/home/veininguo/bin 把新的搜索目录添加到现有的PATH环境变量中，无需从头定义。PATH中各个目录之间是用冒号分隔的。你只需引用原来的PATH值，然后再给这个字符串添加新目录就行了。也将单点符也加入PATH环境变量，单点符代表当前目录。 123456789$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/veininguo/.local/bin:/home/veininguo/bin$$ PATH=$PATH:/usr/games:/usr/local/games$$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/veininguo/.local/bin:/home/veininguo/bin:/usr/games:/usr/local/games$$ PATH=$PATH:. 定位系统环境变量在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作启动文件或环境文件。在大多数发行版中，存储个人用户永久性bash shell变量的地方是$HOME/.bashrc文件。 启动bash shell有3种方式： 登录时作为默认登录shell，登录shell会从5个不同的启动文件里读取命令： /etc/profile，是bash shell默认的的主启动文件。只要你登录了Linux系统， bash就会执行/etc/profile启动文件中的命令。 $HOME目录下的启动文件，剩下的启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环境变量。大多数Linux发行版只用这四个启动文件中的一到两个：$HOME/.bash_profile$HOME/.bashrc$HOME/.bash_login$HOME/.profile 作为非登录shell的交互式shell如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入bash时启动），那么你启动的shell叫作交互式shell。交互式shell启动时，只会检查用户HOME目录中的.bashrc文件。 作为运行脚本的非交互shell系统执行shell脚本时用的就是这种shell。不同的地方在于它没有命令行提示符。但是当你在系统上运行脚本时，也许希望能够运行一些特定启动的命令，为了处理这种情况， bash shell提供了BASH_ENV环境变量。 数组变量要给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔。1$ mytest=(one two three four five) 引用一个单独的数组元素，就必须用代表它在数组中位置的数值索引值。索引值要用方括号括起来。12$ echo $&#123;mytest[2]&#125;three 文件权限缺乏安全性的系统不是完整的系统。系统中必须有一套能够保护文件免遭非授权用户浏览或修改的机制。 Linux沿用了Unix文件权限的办法，即允许用户和组根据每个文件和目录的安全性设置来访问文件。 Linux 的安全性Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。用户对系统中各种对象的访问权限取决于他们登录系统时用的账户。用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是登录名。 /etc/passwd 文件这个文件将用户的登录名匹配到对应的UID值，它包含了一些与用户有关的信息。 1234567$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologin...veininguo:x:1000:1001::/home/veininguo:/bin/bashdockerroot:x:996:993:Docker User:/var/lib/docker:/sbin/nologin /etc/passwd文件的字段包含了如下信息： 登录用户名 用户密码 用户账户的UID（数字形式） 用户账户的组ID（GID）（数字形式） 用户账户的文本描述（称为备注字段） 用户HOME目录的位置 用户的默认shell /etc/shadow 文件/etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow文件，这让它比起/etc/passwd安全许多。etc/shadow文件为系统上的每个用户账户都保存了一条记录。记录就像下面这样：1veininguo:*:17399:0:99999:7::: 每条记录中都有9个字段： 与/etc/passwd文件中的登录名字段对应的登录名 加密后的密码 自上次修改密码后过去的天数密码（自1970年1月1日开始计算） 多少天后才能更改密码 多少天后必须更改密码 密码过期前提前多少天提醒用户更改密码 密码过期后多少天禁用用户账户 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示） 预留字段给将来使用 添加新用户用来向Linux系统添加新用户的主要工具是useradd。系统默认值被设置在/etc/default/useradd文件中。 在创建新用户时，如果你不在命令行中指定具体的值， useradd命令就会使用-D选项所显示的那些默认值。这个例子列出的默认值如下： 新用户会被添加到GID为100的公共组； 新用户的HOME目录将会位于/home/loginname； 新用户账户密码在过期后不会被禁用； 新用户账户未被设置过期日期； 新用户账户将bash shell作为默认shell； 系统会将/etc/skel目录下的内容复制到用户的HOME目录下； 系统为该用户账户在mail目录下创建一个用于接收邮件的文件。 默认情况下，useradd命令不会创建HOME目录，但是-m命令行选项会使其创建HOME目录。 12345678$ sudo useradd -m test$ sudo ls -al /home/test/total 12drwx------. 2 test test 62 Nov 26 13:18 .drwxr-xr-x. 4 root root 35 Nov 26 13:18 ..-rw-r--r--. 1 test test 18 Sep 6 16:25 .bash_logout-rw-r--r--. 1 test test 193 Sep 6 16:25 .bash_profile-rw-r--r--. 1 test test 231 Sep 6 16:25 .bashrc 删除用户userdel可以从系统中删除用户， 加上-r参数， userdel会删除用户的HOME目录以及邮件目录。 1234$sudo userdel -r test$$ sudo ls -al /home/test/ls: cannot access /home/test/: No such file or directory 修改用户Linux提供了一些不同的工具来修改已有用户账户的信息： usermod，修改用户账户的字段，还可以指定主要组以及附加组的所属关系。常用参数如下：-c修改备注字段。-e修改过期日期。-g修改默认的登录组。-l修改用户账户的登录名。-L锁定账户，使用户无法登录。-p修改账户的密码。-U解除锁定，使用户能够登录。 passwd和chpasswd改变用户密码的一个简便方法就是用passwd命令。如果需要为系统中的大量用户修改密码， chpasswd命令可以事半功倍。 chsh、 chfn和chagechsh、 chfn和chage工具专门用来修改特定的账户信息。chsh命令用来快速修改默认的用户登录shell。chfn命令提供了在/etc/passwd文件的备注字段中存储信息的标准方法。chage命令用来帮助管理用户账户的有效期。 Linux 组组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。每个组都有唯一的GID——跟UID类似，在系统上这是个唯一的数值。 /etc/group 文件/etc/group文件包含系统上用到的每个组的信息。 12345$ cat /etc/grouproot:x:0:bin:x:1:daemon:x:2:... /etc/group文件有4个字段： 组名 组密码 ID 属于该组的用户列表 创建新组groupadd命令可在系统上创建新组。1234$ sudo groupadd shared$ tail /etc/groupdocker:x:992:shared:x:1002: usermod命令将用户被分配到该组。12345$ sudo usermod -G shared test$$ tail /etc/groupshared:x:1002:testtest:x:1003: 修改组groupmod命令可以修改已有组的GID（加-g选项）或组名（加-n选项）。12345$ sudo groupmod -n sharering shared$ tail /etc/groupgoogle-sudoers:x:1000:veininguotest:x:1003:sharering:x:1002:test 文件权限文件权限符ls命令可以用来查看Linux系统上的文件、目录和设备的权限。123$ ls -ltotal 1693436drwxrwxr-x. 2 veininguo veininguo 6 Nov 21 16:08 data_file 输出结果的第一个字段就是描述文件和目录权限的编码。第一个字符代表了对象的类型： -代表文件 d代表目录 l代表链接 c代表字符型设备 b代表块设备 n代表网络设备 之后有3组三字符的编码。每一组定义了3种访问权限： r代表对象是可读的 w代表对象是可写的 x代表对象是可执行的 若没有某种权限，在该权限位会出现单破折线。这3组权限分别对应对象的3个安全级别： 对象的属主 对象的属组 系统其他用户 改变权限chmod命令用来改变文件和目录的安全性设置：chmod options mode file chmod命令采用了另一种方法。下面是在符号模式下指定权限的格式：[ugoa…][[+-=][rwxXstugo…]第一组字符定义了权限作用的对象： u代表用户 g代表组 o代表其他 a代表上述所有 现有权限基础上增加权限（+），还是在现有权限基础上移除权限（-），或是将权限设置成后面的值（=）1234567$ chmod o+r newfile$ ls -lF newfile-rwxrw-r-- 1 rich rich 0 Sep 20 19:16 newfile$$ chmod u-x newfile$ ls -lF newfile-rw-rw-r-- 1 rich rich 0 Sep 20 19:16 newfile 改变所属关系chown命令用来改变文件的属主。1234567$ chown dan newfile$ ls -l newfile-rw-rw-r-- 1 dan rich 0 Sep 20 19:16 newfile$$ chown dan.shared newfile$ ls -l newfile-rw-rw-r-- 1 dan shared 0 Sep 20 19:16 newfile chgrp命令可以更改文件或目录的默认属组。123$ chgrp shared newfile$ ls -l newfile-rw-rw-r-- 1 rich shared 0 Sep 20 19:16 newfile 文件系统使用Linux系统时，需要作出的决策之一就是为存储设备选用什么文件系统。大多数Linux发行版在安装时会非常贴心地提供默认的文件系统，了解一下可用的选择有时也会有所帮助。 Linux 文件系统 ext文件系统，最早的文件系统，叫作扩展文件系统 （extended filesystem，简记为ext）。 ext2文件系统，ext文件系统有不少限制，比如文件大小不得超过2 GB。ext文件系统就升级到了第二代扩展文件系统，叫作ext2。 日志文件系统日志文件系统为Linux系统增加了一层安全性。它不再使用之前先将数据直接写入存储设备再更新索引节点表的做法，而是先将文件的更改写入到临时文件（称作日志， journal）中。在数据成功写到存储设备和索引节点表之后，再删除对应的日志条目。 ext3文件系统，它采用和ext2文件系统相同的索引节点表结构，但给每个存储设备增加了一个日志文件，以将准备写入存储设备的数据先记入日志。 ext4文件系统，扩展ext3文件系统功能的结果是ext4文件系统。 Reiser文件系统。 JFS文件系统，最老的日志文件系统之一， 是IBM在1990年为其Unix衍生版AIX开发的。 XFS文件系统，美国硅图公司（SGI）最初在1994年为其商业化的IRIX Unix系统开发的。 写时复制文件系统写时复制（copy-on-write， COW）的技术。COW利用快照兼顾了安全性和性能。如果要修改数据，会使用克隆或可写快照。修改过的数据并不会直接覆盖当前数据，而是被放入文件系统中的另一个位置上。即便是数据修改已经完成，之前的旧数据也不会被重写。 ZFS文件系统，没有使用GPL许可。OpenZFS项目有可能改变这种局面。 Btrf文件系统，被称为B树文件系统。它是由Oracle公司于2007年开始研发的。 操作文件系统创建分区：fdisk工具用来帮助管理安装在系统上的任何存储设备上的分区。创建文件系统：每个文件系统命令都有很多命令行选项，允许你定制如何在分区上创建文件系统。 逻辑卷管理如果硬盘上没有地方了，你就必须弄一个更大的硬盘，然后手动将已有的文件系统移动到新的硬盘上。Linux逻辑卷管理器（logical volume manager， LVM）软件包可以用来做动态地添加存储空间。 安装软件程序Linux开发人员通过把软件打包成更易于安装的预编译包，在Linux上能见到的各种包管理系统（package management system， PMS），以及用来进行软件安装、管理和删除的命令行工具。 基于 Debian 的系统dpkg命令是基于Debian系PMS工具的核心。包含在这个PMS中的其他工具有： apt-get apt-cache aptitude 基于 Red Hat 的系统和基于Debian的发行版类似，基于Red Hat的系统也有几种不同的可用前端工具。常见的有以下3种。 yum：在Red Hat和Fedora中使用。 urpm：在Mandriva中使用。 zypper：在openSUSE中使用。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://veinin.com/categories/读书笔记/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://veinin.com/tags/Linux/"},{"name":"Linux 命令行","slug":"Linux-命令行","permalink":"https://veinin.com/tags/Linux-命令行/"}]},{"title":"《单核工作法》读书笔记","slug":"reading-notes-monotasking","date":"2017-11-12T15:30:00.000Z","updated":"2018-04-01T07:47:18.878Z","comments":true,"path":"2017/11/12/reading-notes-monotasking/","link":"","permalink":"https://veinin.com/2017/11/12/reading-notes-monotasking/","excerpt":"《单核工作法图解》是Staffan先生多年自我管理实践与咨询经验的结晶，阅读这本书让人收获颇多。该书轻松易读，引用了大量前沿研究，也提出了一系列可实践的方法。 自我管理方法不是科学，是技术。脑科学的研究日新月异，但多数人不会去阅读科研文献，就需要有人把这些新发现翻译成可操作的技术，才能运用到生活中，所以自我管理方法也在随着科学的发展而不停前进。 正确的方法是一个方面，另一个重要的方面是，你能不能把正确的方法转化为持续的行动，并且养成长久的习惯。讲方法的书其实用不着贪多求全，关键是看你能不能用起来。","text":"《单核工作法图解》是Staffan先生多年自我管理实践与咨询经验的结晶，阅读这本书让人收获颇多。该书轻松易读，引用了大量前沿研究，也提出了一系列可实践的方法。 自我管理方法不是科学，是技术。脑科学的研究日新月异，但多数人不会去阅读科研文献，就需要有人把这些新发现翻译成可操作的技术，才能运用到生活中，所以自我管理方法也在随着科学的发展而不停前进。 正确的方法是一个方面，另一个重要的方面是，你能不能把正确的方法转化为持续的行动，并且养成长久的习惯。讲方法的书其实用不着贪多求全，关键是看你能不能用起来。 怎样的方法是真正可以帮助我们的方法？两点心得与你分享：一、它应是一套有逻辑的系统方法，而不光是鸡汤；二、这套方法应当易于使用。 果壳中的单核工作法什么是单核工作法？快捷清单 是单核工作法的核心。它最多存放5项当前最重要的任务。如果还要添加更多的任务，就必须删掉原有任务。 单核时段 只用于专心处理快捷清单上的一项任务。以全景闹钟作为单核时段的结束。 全景闹钟 应该设置在分针的下一个竖直位置，例如9:00、9:30、10:00，但距离现在不少于25分钟。在闹钟响铃时，把注意力从单核时段切换到全景时段。 全景时段 期间查看所有的待办任务，并且思考“拉金问题”（Lakein’squestion）：此时此刻，我的时间最好用来做什么？ 颠倒优先级 是指把紧急任务排到重要任务之前，应该避免。完成最重要的任务，我们的长期目标才能实现。 单核工作法的五大原理 原理1：已经开始的任务会无条件地占据我们每天的所思所想，直到被完成或删除。 原理2：多任务切换不仅会拖慢速度，而且注定会耗尽大脑能量。 原理3：我们应该负起区分优先级的责任，选出现在头号重要的事来做。因为会不断有各种事情出现在我们脑海中，值得做的事数不清。 原理4：经常休息、好好睡觉、锻炼身体、吃得健康——我们必须在这些事情上进行投资，才能在日常工作中稳步前进。 原理5：我们的方法必须适应环境；要根据自己最新的个人经验，一点一点调整。没有放之四海皆准的方法。 颠倒优先级“我把问题分成两类：重要的和紧急的。紧急的问题不重要，重要的问题从来不紧急。”把紧急任务放在重要任务之前做，就是颠倒优先级。要事第一。你花在紧急事情上的时间越多，紧急工作就会堆积得越高。那些本来重要但不紧急的任务也会变成紧急任务。 “我没时间”是谎言我们每天都有新的24小时，说“不”的原因并非缺少时间，真实原因是：我们给其他任务排了更高的优先级。因此，别再说“我没时间”了。制定你的优先级顺序，就是要选择把时间用在哪里。一旦定下来就别不好意思。保持透明度，允许其他人直面和质疑你的优先级排序，他们也会尊重和接受你的“不”。千万别说“我没时间”了。 全景闹钟使用计时器。使用单核工作法时，为了在全景模式和单核模式中切换，我们要在单核时段开始之前设置定时响铃的全景闹钟。闹钟响铃提醒我们重新评估优先级。 削减待办任务本周目的 把你的专注点放在“为什么”上。在这一周，你最想取得什么进展、得到什么收获、产出什么成果？把首要目的写入一张索引卡片，贴在工作间隔板上。每当迷茫的时候，本周目的可以提醒你。 快捷清单 包含当前最重要的5项任务。每天早晨把它们写在一张纸上。如果还要添加更多的任务，必须去掉原有的——要么完成一项、要么直接删掉一项。 集草器清单 收集一些未排序的任务和想法，都是你没有拒绝、但也不会马上做的事情。集草器清单则完全没有限制，也不排列优先级。你可以时不时添加内容进去。有什么点子就集中放在这里，免得一转身忘了。表格中的每项任务应该包括“目标、利益关系人、进入清单的日期”这三项属性。 除草 是删掉集草器清单里的内容，每个星期都要做。除草是一项必要工作，以便保持清单可读、及时、可靠。你随时都可以根据需要在集草器清单里增加内容，但应该每周做一次批量清理。 现在专注一件事多任务的误区 误导雇主们到处寻找三头六臂的人才，看谁有同时玩转很多事的本领。我们自以为能多线程处理任务，其实只是在多个任务间切换。任务切换会给手头的工作带来更多错误，拖慢速度。 单核与全景 两种时段帮你建立节奏感。单核工作意味着聚焦放大一项且仅此一项任务；全景总览意味着放眼全局，选择当前最重要的一件事。我们要在这两种模式间互相切换。 戒绝通知 的方法要求在单核工作期间关掉你能听到和看到的通知提醒。看一眼电子邮件之后要重新达到之前的工作状态，所花费的时间超过一分钟。自动推送的通知消息会引发服务生效应的负面作用，妨碍我们对有价值任务的专注。 志愿者小时 是应对中断的一个实用策略。如果同事在上午找你讨论问题，可以引导他的需求，安排一次下午的会议。这样你就有继续工作的余地，也能为同事的问题提前做准备。 时间压力 是自己给自己的。别人可能会说他的事情比较急，但时间压力是我们的内部事务。使用单核工作法，不用担心自己没有尽力，因为我们已将重要的任务排在紧急的任务之前。 永不拖延时间不一致 是指人们在评估自己未来的忙碌程度时，会认为近期超忙，远期不那么忙。这是人类思维的误区。跳出误区的方法是，现在就做最重要的事，对紧急程度不作考虑。 可支配时间 的浪费意味着，你本来有一段受保护的时间来处理最重要的任务，但却花在了其他事情上。我们必须确保足够珍视可支配时间的价值。浪费掉的时间不会再回来。 服务生效应 让我们知道，未完成的任务更容易被记住。正确利用这个效应有助于停止拖延；错误使用则会让拖延更严重。可以动用潜意识思维来促使我们完成最重要的任务，而不是其他任务。 自动坚持任务 是服务生效应的延伸。人类有一种强烈的意愿，想要完成被中断的任务。在下午下班前开始一项任务，这会鼓励你自己明天早晨回来继续做这件事。 内在动力 比奖励和惩罚的影响更大。自主是为自己的选择负起责任。专精是一种不断渴求进步的心态。目的可以激发你成为比自己更伟大事物的一部分。 循序渐进任务分解 可能是战胜拖延最有效的方式。开始做一项小任务，要比开始做一项大任务更容易。但要把大任务的整体目的牢记在心，而且不要提前把所有子任务规划得太详细。 拉金问题 ：“此时此刻我的时间最好用来做什么？”这是我们必须经常问自己的问题。要让工作取得成效，就必须经常检查成果并调整规划。 时间盒子 是要先确定：什么时候开始，什么时候结束，专注在什么任务上。这与工作成果的多少好坏无关，纯粹与注意力有关。当然，良好的专注度会带来更高的产出。 幼鸟先飞 让我们把想法尽早分享给别人，从而获得反馈。这些反馈有助于确定下一步行动的最佳方向：看，这些是已经实现的，接下来怎么做最好？ 虚假紧急 是一个坑人的骗局，让你把力气花在一些次要的任务上。它让你进入来者不拒的响应状态。但是用客观标准衡量，这些任务其实不重要，反而耽误事。它们让你忙来忙去，阻碍了真正的工作。 简化协作富足心态 是把你的时间、知识和人脉分享给同事。这不仅仅是助人为乐，他们也会回过头来分享给你。[1]对自己面前的选项有一个全面认识可以帮你打开局面，得到双赢的解决方案。 相处的责任 我们都应该承担起来。要明白，职场中的每个人都是和你我一样的独立个体。通过认识到他们的强项和弱项所在，我们可以更好地在协作中获益。 高效会议 要求你不仅仅是例行公事地逢会必到。这场会议有没有限定一项会议目的？你的贡献是否无关紧要？你自己组织会议时也要注意，如果没有清晰地描述出唯一的会议目的，就不要发出邀请。 议会场合 着眼于未来、以更有创造性的方式来讨论事情。永远不要为过去的事件责怪任何人，不要为核心价值观争论不休。想想从这里出发该如何往前走，是一种更有建设性的思路。 透明度 要求我们做到言出必践。如果这样还是落入了认知失调的陷阱，就必须后退一步，以开放的心态环顾四周，找出一条让各方共赢的新路径。 给创意充电经常休息 不仅可以让大脑歇口气，还能够激活潜意识思维的创造力。当你休息回来时，经常会有很棒的新想法。 充氧的大脑 是我们散步或运动时得到的效果。研究发现，成人如果每周进行150分钟的身体锻炼，就更不容易在白天昏昏欲睡，也更不容易出现注意力涣散的情况。 健康饮食 会影响到我们思维、创意和正确记忆的能力。那些快速释放葡萄糖的食物会让我们的能量忽高忽低。水果、蔬菜、全麦食品和适量摄入的蛋白质能产生更稳定的输出，给大脑持续提供能量。 充足睡眠 的原则已经被证实可以提高生产力、减少犯错。睡眠不足还意味着失去了快速眼动睡眠时间，导致难以完成记忆编码，无法对新记忆进行删除和整理。 思考的时候拿支铅笔 能够补充我们极度有限的工作记忆。大脑的结构天生不适合同时思考两件事情，而写下来的笔记更有利于前瞻记忆对问题进行处理。 思维导图 对长期记忆很有帮助。一项研究还显示它能提高批判性思维能力。我们的大脑喜欢在概念之间建立连接，可惜顺序结构的笔记和线性思维方式都做不到这一点。 本文大部分内容摘自：《单核工作法》，豆瓣读书、图灵社区","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://veinin.com/categories/读书笔记/"}],"tags":[{"name":"时间管理","slug":"时间管理","permalink":"https://veinin.com/tags/时间管理/"},{"name":"单核工作法","slug":"单核工作法","permalink":"https://veinin.com/tags/单核工作法/"}]},{"title":"Centos 从官方 Yum Repositories 安装 MySQL","slug":"centos-install-mysql","date":"2017-11-08T13:55:49.000Z","updated":"2017-11-08T14:12:47.019Z","comments":true,"path":"2017/11/08/centos-install-mysql/","link":"","permalink":"https://veinin.com/2017/11/08/centos-install-mysql/","excerpt":"介绍2013年10月，MySQL开发团队正式启动了对 Yum 版本库的支持。这意味着您现在可以确保您拥有从源代码直接安装的最新版本的 MySQL！本文将在全新的CentOS 6中安装 MySQL 5.7。5.7是当前默认最新版本，当然你也可以选择直接安装其他版本，可参考本文关于 选择指定版本安装章节。","text":"介绍2013年10月，MySQL开发团队正式启动了对 Yum 版本库的支持。这意味着您现在可以确保您拥有从源代码直接安装的最新版本的 MySQL！本文将在全新的CentOS 6中安装 MySQL 5.7。5.7是当前默认最新版本，当然你也可以选择直接安装其他版本，可参考本文关于 选择指定版本安装章节。 安装Yum 版本库文件需要从 MYSQL 开发者网站下载，安装完成后，使用 yum update 来确保你运行的是最新的MySQL版本，包括其安全更新，Yum 会帮你解决任何依赖关系，这使你安装过程变成很简单。 刚开始，你需要访问 MySQL Repositories ，选择 MySQL Yum Repository，根据你 CentOS 的版本，选择相应的下载链接，然后点击 Download。 右键 “No thanks, just start my download.” ， 点击 “复制链接地址”。 登录到您的服务器，根据复制的连接地址然后下载此文件。以下只是一个示例网址 - 你可能需要检查这个地址是否正确：1wget https://dev.mysql.com/get/mysql57-community-release-el6-11.noarch.rpm 从本地文件中安装下载好的 rpm 文件:1sudo yum localinstall mysql57-community-release-el6-11.noarch.rpm 您现在已经在服务器上从官方存储库安装了，但尚未安装任何软件。存储库包括MySQL服务器，MySQL Workbench管理工具和ODBC驱动程序。让我们安装MySQL服务器：1sudo yum install mysql-community-server 启动 MySQL 服务：1sudo service mysqld start 配置MySQL在重新启动时自动启动：12sudo chkconfig mysqld onchkconfig --list mysqld 到此，你的MySQL服务已经安装完成。 重置 Root 密码如果你安装的是 MySQL 5.7 版本，root 密码会自动生成，并在启动日志 /var/log/mysqld.log 里面输出。 获取初始密码：12grep &quot;password&quot; /var/log/mysqld.log2017-11-08T05:09:31.492454Z 1 [Note] A temporary password is generated for root@localhost: 1!Ta0EEis-yR 12登录 root 账号，如果默认密码为空，请去除 -p 参数：mysql -uroot -p &apos;1!Ta0EEis-yR&apos; 用你的新密码替换字符串 “ your_new_password “，如果你的版本是 5.6 或之前版本，请使用一下命令:123UPDATE mysql.user SET Password=PASSWORD(&apos;your_new_password&apos;) WHERE User=&apos;root&apos;;flush privileges;exit 如果你的版本是 5.7 版本，请使用以下命令：1ALTER USER USER() IDENTIFIED BY &apos; your_new_password &apos;; 如果提示：ERROR 1819 (HY000): Your password does not satisfy the current policy requirements，那是因为默认开启了简单密码检查政策，你可以通过以下命令关闭其功能：1set global validate_password_policy=0; 选择指定版本安装使用 MySQL Yum 存储库时，默认情况下选择最新的 GA 版本（当前为 MySQL 5.7）进行安装。 在 MySQL Yum 存储库中，MySQL社区服务器的不同版本托管在不同的子库中。最新的 GA 系列（目前是 MySQL 5.7）的子库是默认启用的，所有其他系列的子库（例如MySQL 5.6版本）默认是禁用的。可以使用以下命令查看 MySQL Yum 存储库中的所有子存储库，并查看其中哪些被启用或禁用：1yum repolist all | grep mysql 如果要安装最新的版本，不需要配置。如果要选择特定版本，请在运行安装命令之前，禁用最新 GA 版本的子库，并启用特定版本的子库。如果你的平台支持 yum-config-manager，你可以通过以下这些命令来实现，这些命令将禁用 5.7 版本的 subrepository，并启用5.6 版本的 subrepository：12sudo yum-config-manager --disable mysql57-communitysudo yum-config-manager --enable mysql56-community 除了使用 yum-config-manager 命令之外，还可以通过手动编辑 /etc/yum.repos.d/mysql-community.repo 文件来选择发行版，项目是一个典型的文件系列子库的条目信息：123456[mysql57-community]name=MySQL 5.7 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 找到要配置的子库的条目，然后编辑该 enabled 选项。指定 enabled=0 禁用子库，或 enabled=1 启用子库。例如，要安装MySQL 5.6，请确保您拥有 enabled=0 MySQL 5.7版本的上述子目录条目，并且具有 enabled=1 MySQL 5.6版本的条目：1234567# Enable to use MySQL 5.6[mysql56-community]name=MySQL 5.6 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-5.6-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 最后再运行安装命令（mysql-community-server），那么你安装到的是你想要的指定版本的 MySQL。","categories":[],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://veinin.com/tags/CentOS/"},{"name":"MySQL","slug":"MySQL","permalink":"https://veinin.com/tags/MySQL/"}]},{"title":"Lua 表序列化与反序列化","slug":"lua-serialize-table","date":"2017-11-01T14:11:17.000Z","updated":"2017-11-01T14:49:03.749Z","comments":true,"path":"2017/11/01/lua-serialize-table/","link":"","permalink":"https://veinin.com/2017/11/01/lua-serialize-table/","excerpt":"前言今天看了下同事写的关于 Lua 序列化的代码，觉得代码存在几个问题，其主要欠缺以下几点： 1.支持循环引用的 table，反序列后，能正确恢复循环引用状态，如：12local a = &#123;1, 2, 3&#125;a.b = &#123;4, 5, 6, a&#125;","text":"前言今天看了下同事写的关于 Lua 序列化的代码，觉得代码存在几个问题，其主要欠缺以下几点： 1.支持循环引用的 table，反序列后，能正确恢复循环引用状态，如：12local a = &#123;1, 2, 3&#125;a.b = &#123;4, 5, 6, a&#125; 2.字符串内支持内嵌双引号、支持转义字，如一下字符串：1local s = \"ss\\\"aa\\\"bb\\ncc\" 序列化后我希望是这样子：1'ss\"aa\"bb\\ncc' 3.Table 数组部分序列化后隐藏每个值得索引值，如：1local t = &#123;4, 7, 9&#125; 如果保留数组的索引值，会是这样子：1&#123;[1]=4,[2]=7,[3]=9&#125; 为了更加节省空间，我希望的是这样子：1&#123;4,7,9&#125; 实现对于以上几点要求，Google 搜了下，并没有找到满足上面需求的合适版本，于是在前人的基础上做了一些改进。实现部分，序列化函数函数为 table.tostring。反序列化函数相对来说比较简单，可以直接通过函数loadstring进行加载，下面实现为函数 table.loadstring 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function table.tostring(t) local mark = &#123;&#125; local assign = &#123;&#125; local function serialize(tbl, parent) mark[tbl] = parent local tmp = &#123;&#125; for k, v in pairs(tbl) do local typek = type(k) local typev = type(v) local key = typek == \"number\" and \"[\" .. k ..\"]\" or k if typev == \"table\" then local dotkey = parent .. (typek == \"number\" and key or \".\" .. key) if mark[v] then table.insert(assign, dotkey .. \"=\" .. mark[v]) else if typek == \"number\" then table.insert(tmp, serialize(v,dotkey)) else table.insert(tmp, key .. \"=\" .. serialize(v, dotkey)) end end else if typev == \"string\" then v = string.gsub(v, \"\\n\", \"\\\\n\") if string.match( string.gsub(v,\"[^'\\\"]\",\"\"), '^\"+$' ) then v = \"'\" .. v .. \"'\" else v = '\"' .. v .. '\"' end else v = tostring(v) end if typek == \"number\" then table.insert(tmp, v) else table.insert(tmp, key .. \"=\" .. v) end end end return \"&#123;\" .. table.concat(tmp, \",\") .. \"&#125;\" end return serialize(t, \"ret\") .. table.concat(assign,\" \")endfunction table.loadstring(str) local chunk = loadstring(\"do local ret = \" .. str .. \" return ret end\") if chunk then return chunk() endend 测试代码：12345678910111213141516171819local t = &#123;a = 1, b = 2&#125;t.rt = &#123;c = 3, d = 4, t&#125;local s = table.tostring(t)print(s) -- 输出 &#123;b=2,a=1,rt=&#123;c=3,d=4&#125;&#125;ret.rt[1]=retlocal tl = table.loadstring(s)assert(tl.a == t.a)----------------------------------------------local t = &#123;['foo']='bar', 11, 22, 33, \"ss\\\"aa\\\"bb\\ncc\", \"hello\", &#123;'a','b'&#125;&#125;local s = table.tostring(t)print(s) -- 输出 &#123;11,22,33,'ss\"aa\"bb\\ncc',\"hello\",&#123;\"a\",\"b\"&#125;,foo=\"bar\"&#125;local tl = table.loadstring(s)assert(tl.foo == t.foo)assert(tl[4] == 'ss\"aa\"bb\\ncc') 参考 云风的个人空间 lua-users wiki","categories":[{"name":"Lua","slug":"Lua","permalink":"https://veinin.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://veinin.com/tags/Lua/"},{"name":"Lua Serialize Table","slug":"Lua-Serialize-Table","permalink":"https://veinin.com/tags/Lua-Serialize-Table/"}]},{"title":"《番茄工作法图解》读书笔记","slug":"pomodoro-technique","date":"2017-09-24T14:06:59.000Z","updated":"2017-12-04T16:00:40.860Z","comments":true,"path":"2017/09/24/pomodoro-technique/","link":"","permalink":"https://veinin.com/2017/09/24/pomodoro-technique/","excerpt":"这本书以我采用番茄工作法的切身经历，向你传授这一工作法的实施全过程，你能看到它如何提高了我的工作效率。另外书中还加入了一些有关人脑思维的研究成果，用以揭示番茄工作法的原理；还包括采用该工作法的若干影响；以及如何根据需要，对该工作法进行调节和扩充。 番茄工作法能帮你与时间化敌为友，不会再因为还有一小时、一天、一周、一个月的时限而充满焦虑，你要做的就是定好25分钟番茄钟，然后全然专注于手头的任务。如果番茄钟响铃，25分钟结束，而任务还没完成，这并不代表失败。相反，这铃声在为你已连续地工作了一整段时间而喝彩。","text":"这本书以我采用番茄工作法的切身经历，向你传授这一工作法的实施全过程，你能看到它如何提高了我的工作效率。另外书中还加入了一些有关人脑思维的研究成果，用以揭示番茄工作法的原理；还包括采用该工作法的若干影响；以及如何根据需要，对该工作法进行调节和扩充。 番茄工作法能帮你与时间化敌为友，不会再因为还有一小时、一天、一周、一个月的时限而充满焦虑，你要做的就是定好25分钟番茄钟，然后全然专注于手头的任务。如果番茄钟响铃，25分钟结束，而任务还没完成，这并不代表失败。相反，这铃声在为你已连续地工作了一整段时间而喝彩。 什么是番茄工作法？简单说，就是列出你当天要做的事，设置25分钟闹钟，然后从第一件事开始。此外还要有每日回顾、做每日承诺、控制中断、预估要花的工夫等。这本书中我会以自己为例，向你展示如何使用番茄工作法，包括如何记录活动，以及如何挑出最重要的任务。 在番茄工作法中，1个番茄钟等于25分钟的努力。这是一个不可分割的抽象单位，是一段“一视同仁”的时间。你的基本承诺是，花上25分钟，尽可能地努力做好。在这段时间内，关键不在于当前活动是否能在当前番茄钟内完成，关键是在这一刻你尽了全力。 番茄工作者的一天中的5个阶段 计划：在一天的开始，从积压的工作（称为“活动清单”）中提取最重要的活动，填写到“今日待办”表格中。这就是你当天的自我承诺。 跟踪：确定当天活动后，扭启25分钟的番茄钟，从当天活动的第一项开始进行。在每个25分钟的时间段（称为一个番茄钟）内，你要收集一些过程指标，比如计算遇到的中断次数。 记录：在一天结束时，将当天收集的数据归档，写入“记录”表格。如果你跟踪了中断次数，就把中断次数写下来。 处理：从所记录的原始数据中提取有用信息。例如，可以计算在每个25分钟的时间段，平均遇到几次中断。 可视化：最终你要将信息以某种方式组织起来，从中找出改进流程的思路。如果你想获得最适合现实情况的工作习惯，在自我调整过程中，基本上每天都要做这样的回顾。 所需工具 番茄钟一枚 铅笔一支（最好带橡皮） 纸质表格三张（白纸即可，横格纸更好） “今日待办”表格，列出打算在今天进行的活动。每天早上这张表要换新的。 “活动清单”表格，列出最近要进行的活动，随想随填，不用排序。同一张“活动清单”表格可以用很多天，增加新的活动，划掉已完成的。 记录表格，记录所采样的流程指标，以便对流程进行改进。同一张“记录”表格可以用很多天，以便比较每天的跟踪记录。 基本方法将要完成的活动全部填入“活动清单”表格，每天早晨，从其中选出数项要在今天进行的活动，抄入“今日待办”表格。 开始工作 在“今日待办”中选择一项最重要的活动 启动番茄钟，时间设定为25分钟 开始工作，直到番茄钟响铃•在“今日待办”表格该活动右侧标一个× 休息片刻（3～5分钟） 开始下一个番茄钟，继续工作，直到完成这项活动，在“今日待办”表格上划掉它 每四个番茄钟后，多休息一会儿（15～30分钟） 处理中断你将学习如何以合理、有效的方式处理番茄钟时间内的中断和干扰。 番茄钟期间的中断有以下两种形式 内部中断具体地说，是直觉向心智发出信号，告诉自己去做当前专注活动以外的事情。要对付内部中断，最佳策略是可视化、接受，然后纳入计划或删除。 外部中断有人找你询问或请你帮忙，并且等你答复。接下来我们看，对于这两类中断，番茄工作法都有相应的处理策略。外部中断具有互动性。有人正在等你答复。他们试图阻止你画×，而你需要一个策略来减少中断。所以必须“扭转”番茄钟和中断之间的依赖关系。如电子邮件和电话很容易，你可以将其关闭。发电子邮件的人不会期待在25分钟内就收到回信。假如有人找你面谈，在不影响结果的前提下，可以请求对方尽量推迟。对于你的同事来说，你今天答复还是周五答复，结果可能是一样的。在对方接受的范围内，建议他尽量往后安排。用稍后的番茄钟重新计划中断事件，而不要在当时直接处理，这样做好处多多。 处理外部中断的策略 告知：“我手头有事，正忙。” 协商：“周五再帮你做，行吗？” 计划：写下活动名称，稍后为它计划未来的番茄钟。 答复：按照承诺回电或答复，不然的话，下次别人就没法信任你了。 原子性番茄钟具有原子性。不可分割。它是这套流程方法中最小的货币单位。如果任务被放下了，无论是暂时的还是长期的，当前番茄钟都必须作废。它就不能算数了，也不应该画×。你得扭启一个新的25分钟番茄钟代替它。如果需要，可以先休息一下再开始。 预估任务预估和测量在番茄工作法中必不可少。如果没有它们，每天要做计划是很困难的。番茄工作法要求花时间做回顾，这样才能不断改进，继往开来。设法将你“认为自己能做的”与“实际做到的”相对应。跟踪和记录是番茄工作法中的测量方法。你无法预言会出现什么新情况、新问题。但可以通过训练和监控，积累做预估的经验和技巧。 计算预估的“货币”单位是番茄钟。因为番茄钟的原子性，不能使用小数，如1/2或2.2个番茄钟是不行的。 假如一项活动预估超过7个番茄钟，说明它太复杂了。需要拆分这项活动。拆开的每项小活动在“活动清单”表格中单独占一行，各自有预估值。活动越大，预估越不准。 如果一项活动预估不够1个番茄钟，则可以在它旁边标个0。并不是说它要花0个番茄钟来完成，只是表示时间花费小于1个番茄钟。这样的活动在“活动清单”表格中仍然各自占一行。 本来预估这项活动需要若干个番茄钟，但这些番茄钟用完了，这时要做二次预估。猜测要完成这项活动还需要多少个番茄钟。如果二次预估也不合要求，你可以做三次预估，也是最终预估。 如果三次预估的数目还不够完成活动，那真是有点失败了。你得分析一下，为什么一次又一次反复地低估这件事？也许应当将活动拆开，降低复杂度。按照常理，活动越复杂，预估越不准。 应变番茄工作法是守则。它提供简单而具体的最佳实践，容易上手。这可能意味着它不适合所有的人或环境。但番茄工作法也内置了应变能力。 当你了解应用番茄工作法的常规方法之后，可能会有调整它的想法。很好。这就是收集跟踪数据、做每日回顾的目的。但是，请尝试坚持使用常规方法，至少两周内不要做任何改动。你需要亲身经历，以便确切知道哪里适合你、哪里不适合。 刚开始学习使用番茄工作法，简单朴实就是最好的。一段时间后，你可以根据个人情况进行一些优化。比如说，我在一天里要花大量时间来写电子邮件。为了避免每次收到新邮件都会中断我手头的活动，我可以每天分配两个番茄钟，也就是50分钟来写回信。 番茄工作法的默认时间表中，每隔三个短休息就要有一个长休息，但不是强制性的，而要根据你的角色和工作内容而定，包括工作场所和个人状态。 番茄工作法流程示意图 参考 《番茄工作法图解》，豆瓣读书","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://veinin.com/categories/读书笔记/"}],"tags":[{"name":"时间管理","slug":"时间管理","permalink":"https://veinin.com/tags/时间管理/"},{"name":"番茄工作法","slug":"番茄工作法","permalink":"https://veinin.com/tags/番茄工作法/"}]},{"title":"《大教堂与集市》读书笔记","slug":"reading-notes-the-cathedral-the-bazaar","date":"2017-09-11T12:57:54.000Z","updated":"2017-11-24T16:38:12.197Z","comments":true,"path":"2017/09/11/reading-notes-the-cathedral-the-bazaar/","link":"","permalink":"https://veinin.com/2017/09/11/reading-notes-the-cathedral-the-bazaar/","excerpt":"这是一本关于黑客行为与文化的书籍。本书并没有给出基础理论上的创新，只是描述了这样的事实：开源软件系统性地利用开放式开发和分布式同行评审（peerreview），不仅降低了成本，还提高了软件质量。 作者EricS.Raymond作为黑客文化的第一理论家，他通过观察和参与，对黑客这个群体的习俗、信念及关系有着深入而广泛的研究。他极力为“黑客”（hacker）一词正名，强调“黑客”并不是媒体报道中的计算机违法分子，而是那种着迷于计算机技术并通过编程提供极具价值软件的人。 黑客（hacker）一词，原指喜欢通过智力和创造性方法挑战难题的人，尤指那些热衷于计算机技术的编程高手。由于媒体报道中出现的黑客事件往往和计算机犯罪相连，导致人们常常误认为黑客是利用网络入侵他人系统的破坏者。事实上，这些破坏者应该被称为cracker，即“骇客”。","text":"这是一本关于黑客行为与文化的书籍。本书并没有给出基础理论上的创新，只是描述了这样的事实：开源软件系统性地利用开放式开发和分布式同行评审（peerreview），不仅降低了成本，还提高了软件质量。 作者EricS.Raymond作为黑客文化的第一理论家，他通过观察和参与，对黑客这个群体的习俗、信念及关系有着深入而广泛的研究。他极力为“黑客”（hacker）一词正名，强调“黑客”并不是媒体报道中的计算机违法分子，而是那种着迷于计算机技术并通过编程提供极具价值软件的人。 黑客（hacker）一词，原指喜欢通过智力和创造性方法挑战难题的人，尤指那些热衷于计算机技术的编程高手。由于媒体报道中出现的黑客事件往往和计算机犯罪相连，导致人们常常误认为黑客是利用网络入侵他人系统的破坏者。事实上，这些破坏者应该被称为cracker，即“骇客”。 Eric在本书中向大家展示了两种最为经典且截然不同的模式：大教堂模式 和 集市模式。传统大型软件公司的开发模式就像是艰难而缓慢的大教堂建造工程，它有着严密的管理和封闭的集中式结构，但在创新上、生产力上和Bug控制上却落后于集市模式。集市模式是一种并行的、对等的扁平化开发结构，其参与者大多来自于互联网上的志愿者，结构松散，来去自由，就像是一个乱糟糟的集市，但就是这样的组织形式，却取得了像Linux这样令人惊叹的成功。 我们可以看到，互联网和移动智能终端已经日益影响着每个人的日常生活，而你每天访问的互联网网站，绝大部分基于开源的操作系统、Web服务器和数据库，你所使用的智能手机多采用 Andriod 或 iOS 系统，Andriod 源于 Linux，iOS 源于开源的 Darwin（Darwin 则基于开源的 Mach 和 FreeBSD 开发），可以说，只要你上网或使用智能手机，你就在不知不觉中使用了开源软件。开源对软件业和互联网带来了巨大影响，并正在和将会对人们的工作和生活产生更显著的影响，正如Eric在前言中所说的，对于任何一个对计算机有所依赖的人，对于任何一个要在未来工作和生活的人，了解一些开源文化，都是很有意义的。 黑客圈简史真程序员（Real Programmer）通常具备工程学和物理学背景，并常常是业余无线电爱好者。使用机器语言、汇编语言、FORTRAN或者其他一些已经被人们遗忘了的古老的编程语言。 早期的黑客20世纪60年代到70年代期间，第一个横贯美国大陆的高速计算机网络开始出现，使得位于各地的研究者能够以前所未有的速度和灵活性交换信息，这些电子高速公路把散落全美各地的黑客聚集到一起，构成了产生黑客文化的关键力量。 Unix的兴起最开始的操作系统都是用汇编语言精心编写的，目的是充分利用机器的效能。但因为机器的更新换代，用户往往要为那些新机器重新编写软件，也就造成了每次都去做类似发明轮子和钻木取火的事。黑客Ken Thompson，参与了分时操作系统Multics的开发工作，因为其显示出庞大而又无用之物的迹象后，贝尔实验室从这个项目中退出了。出于对Multics的执念，KenThompson开始尝试将Multics的一些理念和自己的一些想法融合起来，准备开发一种新的系统：Unix。与此此时，黑客Dennis Ritchie为还处于雏形阶段的UNIX发明了一种新的语言：C语言。因其设计为好用、限制少和灵活方便的语言，很快在贝尔实验室流行了起来。Thompson和Ritchie是最早意识到当时硬件和编译技术都已经好到能让整个操作系统用C语言编写的那批人之一。于是，Unix和C组合在了一起，并很快因其可移植性、极为广泛的计算作业，很快被数以千计的黑客们接受。 远古时代的终结一群没有组织的微机爱好者决心让普通大众都享受到计算机的威力。很多实验室随着人工智能的首次商业化尝试而四分五裂，受一些新成立公司的高薪职位吸引，实验室里室里最优秀的人才正纷纷出走。RichardM.Stallman（人们更熟悉他的名字缩写RMS，这也是他常用的登录名）离开实验室，创建了自由软件基金会（Free Software Foundation），献身于生产高质量的自由软件。并在1982年用C语言重新构建了整个Unix的克隆，并免费发布，这就是后来广为人知的GNU（Gnu’sNotUNIX，这是一种递归式的缩写）操作系统，GNU迅速成为黑客活动的焦点。 “专有UNIX”时代黑客圈形成了两大阵营，一边是围绕Internet和Usenet而形成的相对有凝聚力的“网络部落”（他们中绝大多数使用运行着UNIX的小型机或工作站级别的机器），一边则是没有网络的分散在各个角落的微机爱好者。这一阶段，一些严重的计算机破坏（cracking）事件开始被主流媒体报道，记者们误用黑客（hacker）一词来形容那些破坏者，这种不幸的误用一直延续至今。随着20世纪90年代的到来，已经有十多年发展的工作站技术，受到了明显的威胁，基于Intel386系列芯片的廉价且高性能的个人计算机出现了，历史上第一次，黑客个人有能力购买一台家用机器，而UNIX则有能力提供运行于其上的整个开发环境，并能连上互联网。但是，动辄数千美元的商业UNIX仍然太贵了，价格也没怎么降下来，人们清楚地看到，十多年来对专有UNIX的商业化努力显然已经失败了。 早起的自由UNIX如果软件复杂到操作系统这样的程度，就必须要有一个精心协作的团队，团队要比较小，而且紧密互动，不管是以前还是现在，这都是很典型的开发模式。FSF一直未能完成的HURD使得Helsinki大学一名叫Linus Torvalds的学生有了施展才能的空间，1991年，他开始为386机器开发自由UNIX内核，使用的正是FSF提供的软件套件。Linus很快获得了成功并吸引了互联网上的黑客们，他们帮助Linus一同开发Linux：一个全功能的UNIX，源代码完全免费，而且可以再发布。 Web大爆发公众发现了互联网。20世纪90年代早期，普通大众一个月花不了多少美元就可以连上互联网，WWW发明以来，互联网本来就很快的增长速度更是加速到了不可思议的地步。1994年，若干种不同版本的自由UNIX（Linux和386BSD的后裔）成为黑客活动的主要焦点。Linux开始被商业公司刻录在CD-ROM上发布，并且非常畅销。互联网成为主流后，黑客文化开始受到尊敬，并有了一定政治影响力。 大教堂与集市两种完全不同的开发模式：绝大多数商业公司所采用的“大教堂”模式和 Linux 世界采用的“集市”模式。 大教堂模式和集市模式最关键的区别在大教堂建筑者看来，bug是棘手的、难以发现的、隐藏在深处的，要经过几个人数月的全心投入和仔细检查，才能有点信心说已经剔除了所有错误。而发布间隔越长，倘若等待已久的发布版本并不完美，人们的失望就越发不可避免。对集市模式而言则完全不同，在上千名合作开发者热切钻研每个新发布版本的情况下，你可以假定bug是浅显易找的，或者至少可以很快变得浅显易找。所以你会频繁发布以获取更多的修正，其副作用是良性的：即便发布中有些小问题，你也不会损失太多。 开发者和测试者对程序有着不匹配的思维模式测试者是从外往内看，程序员是从内往外看。对于不开放源码的软件开发，开发者与测试者往往局限于自己的角色，各说各话，都对对方倍感沮丧。开源开发打破了这种困境，由于大家都有真实的源码，开发者和测试者很容易发展出一个共享的表达模式并进行有效的交流。 集市模式的成功LinusTorvalds的开发风格是：早发布、常发布、委托所有能委托的事、开放到几乎是混乱的程度，这些都令人感到惊讶不已。在Linux社区里，没有建筑大教堂那样的安静和虔诚，倒更像是一个乱糟糟的大集市，充满了各种不同的计划和方法。而既稳定又一致的一个操作系统就这么诞生了。 1.好的软件作品，往往源自于开发者的个人需要。2.优秀的程序员知道写什么，卓越的程序员知道改写（和重用）什么。以LinusTorvalds为例，他并没有尝试从零开始写Linux，而是以重用Minix（一个用于PC机的迷你型UNIX类操作系统）的代码和理念作为开始，虽然Linux中所有Minix代码最终都被移除或重写，但它在Linux成长初期确实起到了类似脚手架的作用。3.在你第一次把问题解决的时候，你往往并不了解这个问题，第二次你才可能知道怎么把事情做好。所以，如果你想做对事情，至少要再做一次。4.如果你有正确的态度，有趣的事情自然会找到你。5.当你对一个程序不再感兴趣时，你最后的责任就是把它交给一个可以胜任的接棒者。6.把你的用户当成开发合作者对待，如果想让代码质量快速提升并有效排错，这是最省心的途径。7.早发布，常发布，倾听用户的反馈。8.如果有足够多的beta测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。或者说得更通俗一些：“只要眼睛多，bug容易捉。”9.聪明的数据结构配上愚笨的代码，远比反过来要好得多。10.如果你把beta测试者当做最珍贵的资源对待，他们就会成为你最珍贵的资源。11.仅次于拥有好主意的是，识别来自用户的好主意，有时后者会更好。12.通常，那些最有突破性和最有创新力的解决方案来自于你认识到你对问题的基本观念是错的。13.“设计上的完美不是没有东西可以再加，而是没有东西可以再减。”14.任何工具都应具备预期内的功能，但一个伟大的工具能给你带来预期外的功能。15.写网关类软件时，尽可能不要干扰数据流，而且绝不要扔掉信息，除非接收方强迫你这么做。16.当你的语言还远不是图灵完备（Turing-complete）的时候，语法糖[4]会让你受益良多。17.系统的安全性只取决于它所拥有的秘密。谨防虚假的秘密。18.想要解决一个有趣的问题，先去找一个让你感兴趣的问题。在某些工作场所，开发人员不将代码看作是自己的“领土”，而是鼓励别人发现其中的bug和潜在改进点，这些场所中软件改善速度之快，与别处相比是不可同日而语的。19.如果开发协调者有一个至少像Internet这样好的沟通媒介，并且知道如何不靠强制来领导，那么多人合作必然强于单兵作战。 集市模式的必要条件不可能从零开始实施集市模式。需要拿出一个像样的承诺。程序此时并不需要特别好，它可以简陋、有错、不完整，文档可以少得可怜。但它至少要做到：(a)能运行，(b)让潜在的合作开发者相信，这个软件在可预见的未来，能演变成一个非常棒的东西。项目领导人必须要有高度的设计直觉和聪明才智。一定水准的设计和编码能力。集市项目的协调人或领导人必须要有很好的人际交往和沟通能力。 开源项目如果失败了，根本不会是因为机器、网络或办公场地，它们死掉的唯一原因就是开发者们不再感兴趣了。开源成功的一个最重要成果，就是告诉我们，“玩”是创造性活动中最具经济效能的工作模式。 开垦心智层所谓黑客，是一个通过贡献礼物表现出他（或她）既拥有技术能力又懂得声誉竞争如何运转的人。对是否为黑客的判断是一种感知和认同，只能由那在文化中已经做得很好的人给出。 黑客意识形态的多样性差异可以体现在热忱度上：开源仅仅是一个便利的手段（好工具、有趣的玩具、有意思的游戏），还是说其本身就是目的？差异还体现在敌对性上：反对商业软件，以及反对那些试图支配商业软件市场的公司。 文化中的禁忌： 分化一个项目会遇到强大的社会压力，只有在极为必要的情况下才使用，而且要重新命名和做出大量的公开解释。 在没有项目主持人认可的情况下发布更新是令人不悦的，除非是特殊情况（如本质上不重要的移植bug修复）。 在项目历史、致谢表或维护列表中移除某个人的名字是绝对不可以的，除非当事人明确表示同意。 所有权和开放源码一个软件项目的“所有者”就是在社区中众所周知的对软件版本改动有唯一发布权的那个人。 通常有三种方式获得开源项目的所有权： 第一种也是最显然的，就是去创建这个项目，当这个项目在开始时就只有一个维护者而且这个维护者仍然起作用的时候，所有权问题是连提都不该提的。 第二种方式是获取前任对所有权的移交（有点像“接力棒传递”）。这在社区中很容易理解，当项目“所有者”不愿意或者不能在开发和维护中投入必要的时间时，他（她）有义务将项目移交给一个有能力的继任者。 第三种方式是一个项目需要维护但项目所有者已经消失或失去兴趣了。如果你想维护该项目，你的责任是努力找到这个“所有者”，如果找不到，你可以在相关场所（比如Usenet上专注于该应用领域的新闻组）声明该项目似乎是一个“孤儿”，而你想为之负责。 声誉的多面性追求同侪中声誉（声望）的意义何在？ 首先，也是最明显的一点，在同侪中拥有好名声是一种最基本的激励，出于前面提到的进化上的原因，我们都渴望体验它。（一些人试着将这种对声誉的内驱力做各种升华，使其看起来和同侪没有那么明显的关联性， 第二，声誉是很好的吸引他人注意和合作的途径（在纯礼物经济中，这是唯一的途径）。如果一个人慷慨、智慧、公平交易、有领导能力，或者有其他优秀品质，就更容易让人相信和他合作能获得好处。 第三，如果你所处的礼物经济和交换经济或命令体系互相关联交织，你的名声就可能传播到后两种环境中，使你在那里获得更高的地位。 冲突的起因把开源软件中的冲突辨识为以下主要四类： 谁来做有约束力的决定？ 谁该得到荣誉或责备，因为什么？ 如何防范劳动成果被复制？如何防范流氓版本使bug跟踪变得更复杂？·从技术上讲，什么是正确的事？ 从技术上讲，什么是正确的事情？ 任何一种项目冲突解决理论，必须要解决三个问题： 谁来负责做设计决策？ 如何决定哪个贡献者应该被授予荣誉，如何授予？ 如何保持项目团队和产品不被分裂为多个分支？ 本书这几篇文章仅仅是个开端而非定论，开源软件还有太多的问题没有解决。开源现象引发了其他创造性工作领域以及知识产权相关的许多问题，但未能真正给出较好的答案。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://veinin.com/categories/读书笔记/"}],"tags":[{"name":"开源","slug":"开源","permalink":"https://veinin.com/tags/开源/"}]},{"title":"《时间管理》读书笔记","slug":"reading-notes-time-management","date":"2017-09-02T07:39:00.000Z","updated":"2017-09-02T08:30:36.891Z","comments":true,"path":"2017/09/02/reading-notes-time-management/","link":"","permalink":"https://veinin.com/2017/09/02/reading-notes-time-management/","excerpt":"市面上很多关于时间管理的书籍和文字，但几乎很多著作都大同小异，在读这类书籍或文章时大部分反而是在浪费时间。事实上，有关时间管理的原则，你需要知道的大约只有50条，一旦你了解了这些原则，你就了解了关于这一主题你所需要了解的一切。所有50条原则，都囊括在了这本书上，而你只需要向这本书投资1小时的时间，就能带来不错的回报。","text":"市面上很多关于时间管理的书籍和文字，但几乎很多著作都大同小异，在读这类书籍或文章时大部分反而是在浪费时间。事实上，有关时间管理的原则，你需要知道的大约只有50条，一旦你了解了这些原则，你就了解了关于这一主题你所需要了解的一切。所有50条原则，都囊括在了这本书上，而你只需要向这本书投资1小时的时间，就能带来不错的回报。 作者关于时间管理的十个重要观点1.自我意识是先决条件意识到自己对时间的感觉，可以使你更加了解自己。如果你不了解你是如何花费时间的，你便没有能力有效地管理你的时间。自己欺骗自己毫无意义。我们对时间的感觉取决于我们做什么，当我们上网、看视频节目时，我们对时间失去了控制住。时间飞逝而过。然而如果我们到家的时候，因为饥饿难耐，随意将什么东西扔进微波炉加热，而那五分钟的等待仿佛无穷无尽。记时间日志会使你对自己不断贬值的资产–生命时光–保持敏感。 每个人每周有168个小时，或者每个月大约有720小时的时间。每个小时都很重要，你应该认真回顾你目前是如何利用你的时间的。 比如我一周168小时是这样度过的：睡觉 - 56小时吃饭 - 3.5小时学习、阅读 - 7小时上网、看视频、玩游戏 - 45小时打电话、发短信 - 5小时运动 - 7小时工作时间 - 37.5小时其他杂物 - 17小时总计 - 168小时 总结过后，你会发现，天哪，我居然用接近30% 时间用来上网、看视频、玩游戏！！！如果能在这方面做出一些优化，多利用一些时间去做更多其他更有意义的事情，那将会更好。 2.设定目标，提供线路图只有当你确定了努力的方向和目标时，你才能决定一个如何安排你的时间。目标设定决定了你6个月、一年或者5年后，你想要在哪里，想要做什么。一旦你确定了目标，就需要采取步骤，对时间做出承诺。 比如，我需要在一年内实现看完100本书的目标。这个目标应具备了四个最重要的标准：具体、有时间范围、很现实、对于目标制定者来说，它很重要。如果说看完一本书平均要花 3.5小时，那么看完100本就需要350小时，也就是每周需要7小时来阅读才能保证完成，而这就是你设定的一个目标。 3.选择是艰难的时间管理最终就是关于如何做出选择的。梦想的实现绝非轻而易举，有了目标后，你就必须做出选择。彻底的反省，你到底想要得过且过，做你现在马上想做的事情，还是为了未来着想，做哪些能让你今后过上自己想要的生活的事情呢？生活是不公平的，不是说你努力奋斗就一定能得到想要的东西。但你可以通过正确的选择，保持一种成功的姿态，获得更大的机会，去实现想要达成的目标。时间管理的选择也是如此，只有你自己能够做出选择，没人代替你。 4.创造时间匹配时间和精力有效地时间管理不仅仅是寻找一天中额外时间，还要将你的有效时间和你的有效精力匹配起来。尝试在感觉最清醒的啥时候去从事最艰巨的任务。 空闲时间利用你一天中的空隙时间来减少不必要的浪费，在你慢条斯理、无所事事的时，尝试做一些更加有意义的事情。比如利用你排队打饭来进行快速阅读、记单词啥的。 5.不要拖延时间管理的大敌之一，梦想的杀手。很多人都有良好的愿望，他们“总有一天”要去做什么。但“总有一天”从未变成“今天”。拖延源自一种非常强大的物理法则—-惯性。物体，包括人，倾向于呆在原地不动。为了实现向前移动，则需要推动自己。 战胜拖延策略： 在口袋里放一张纸片或索引卡，用粗体字写上你要达成的目标。 将大项目分解成易管理的小块。 教会自己的头脑（意识）识别懒惰或拖延最初的蛛丝马迹。 坚持通过某种方式做好笔记。 那些培养强大精神力量的人更有可能： 按时间表、计划行事 做出正确的选择 保持良好的注意力 战胜拖延 6.杂乱不堪是大敌杂乱会引起情绪紧张，导致无所作为，降低效率。如果你能够清理你的工作区域、你的生活，你将显著增加你的工作成效。 7.计划和准备是值得花精力去做的提前决定某一给定的时期内，你要做的具体事情是什么。很多人都不喜欢做计划。我们生活中这样一个充满行动的社会，以至于我们每日总是忙忙碌碌，很少有时间停下来思考我们正在做什么，以及我们为何而做。做好计划意味着：每一个小时的计划抵得上五小时的执行。 每天花10分钟来规划你这一天该如何度过，通过思考来提高实现你想达到之事的几率。比如为制定这些问题： 要完成哪些工作？ 有多少时间可以用来完成这些工作？ 需要完成的工作之间存在逻辑顺序吗？ 8.制定任务清单，确定优先次序现你所有计划和准备的实物是任务清单。通过任务清单体确认你所要做的事情是什么，以及你将如何和合适去做每一件事。 制作任务清单理由: 便于组织你的时间，为你的每一天创建一个时间框架。 减轻你的压力。 让你去考虑该如何使用你的时间以及为何这样使用。 制作任务清单的过程就像在写一部微型小书，主题就是你自己，而且你永远不知道，在制作任务清单的执行过程中，会迸发出什么样的想法和观点。 任务清单四个象限： 重要而紧急 重要但不紧急 紧急但不重要 既不紧急也不重要可以按照 1 -&gt; 3 -&gt; 2 -&gt; 4顺序完成不同象限工作。 9.专心致志是问题的关键所在二八定律你的80%的成就来自于你20%的行为。如销售人员80%的收入往往来自于他们20%的客户。投资者知道，80%的收益来自于他们20%的投资。如果你正从一个或两个活动（“20%”）中获得大部分成果（“80%”），那么这一两个活动就是你应该集中精力去做的。把大部分精力都投入到那些真正能够给你带来“最大收益”的项目上去。 集中精力分心和干扰是专注的大敌。学会如何集中精力，即通过训练在同一时间将你的思维专注于某一件事情上，来强化你的思想力量。当你试图同时做不止一件事情时，你便削弱了你正在做的每一件事情的有效性。那些一心二用，并认为每一件事他们都做的好的人，不过是在自欺欺人而已。 减少分心，排除干扰。 对于分心的因素： 远离互联网。 关掉手机。 关掉所有电子邮件提示。 拔掉电视机插头。 将一切电子产品（如视频游戏）移出工作区域。 对于干扰因素： 如有可能，把工作时房门关上。 如果不可能，而且周围有其他人，那么你便：A) 戴上一顶棒球帽，将帽舌下拉，表现出不友善的样子。B) 避免同经过的人进行目光接触。C) 戴耳机（即使什么都不播放）D) 把一盒面巾纸放旁边，把其中几张弄的皱巴巴的放在一旁，表明你感冒了。 10.选择对你来说行之有效的时间管理技巧上面一些时间管理技巧，有一些可能让你感到有意义，有些则不然。你可以对不同的方法进行试验和尝试。关键是努力把你每小时使用的尽可能合理有效。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://veinin.com/categories/读书笔记/"}],"tags":[{"name":"时间管理","slug":"时间管理","permalink":"https://veinin.com/tags/时间管理/"}]},{"title":"《如何阅读一本书》读书笔记","slug":"how-to-read-a-book","date":"2017-08-25T16:09:37.000Z","updated":"2018-03-05T15:17:36.746Z","comments":true,"path":"2017/08/26/how-to-read-a-book/","link":"","permalink":"https://veinin.com/2017/08/26/how-to-read-a-book/","excerpt":"这是一本为阅读的人，或是想要成为阅读的人而写的工具书。尤其是想要阅读书的人。说得更具体点，这本书是为那些想把读书的主要目的当作是增进理解能力的人而写。这本说针对的不是虚构的作品，如小书、戏、史诗剧，而是一些的论说性的书籍，如社会、人文、工具书的这类，而后者是大部分人的兴趣所在。阅读的目标是为获得资讯而读，以及为求得理解而读。如果你想读一本有助于增进理解力的好书，那这本书可以帮忙，这本书的主题就是阅读好书的艺术。","text":"这是一本为阅读的人，或是想要成为阅读的人而写的工具书。尤其是想要阅读书的人。说得更具体点，这本书是为那些想把读书的主要目的当作是增进理解能力的人而写。这本说针对的不是虚构的作品，如小书、戏、史诗剧，而是一些的论说性的书籍，如社会、人文、工具书的这类，而后者是大部分人的兴趣所在。阅读的目标是为获得资讯而读，以及为求得理解而读。如果你想读一本有助于增进理解力的好书，那这本书可以帮忙，这本书的主题就是阅读好书的艺术。 阅读的分类第一种阅读，也就如我们平时看报纸、看电视新闻、刷微信公众号，甚至看电影等等。这种是阅读只是为了获得咨询，此时你的阅读技巧、理解能力完全能与作者相当，这种读物只能增加你的资讯，并不能提升你的理解能力。这在这本书的作者眼里，这种阅读其实不算真正的阅读。 第二种阅读，主动的阅读，其实就是一个人面对他本身并不理解的东西，书本的内容超出了你的理解。既然我们想提升自己，获得更深层次的理解，就必须向比你更厉害的人学习。而面对这种阅读，是没有任何外力可以帮助你的，你就是要读这本书，你什么都没有，只凭内心的力量，玩味着眼前的字句，慢慢提升自己，从只有模糊的概念到更清楚地理解为止。这样的一种提升，是在阅读时的一种脑力活动，也就更高的阅读技巧。这种阅读就是让一本书向你既有的理解力做挑战。只有这种方式是真正的阅读。 阅读的层次作者把阅读分为四种层次，阅读的层次是渐进的，更高的层次包含了较低层次的特性。 基础阅读第一层阅读，只要熟练了这个层次的阅读，也就摆脱了文盲的状态。在熟练这个层次的过程中，一个人可以学习到阅读的基本艺术，接受基础的训练，获得初步的阅读技巧。这个阶段是一个学习如何阅读的阶段，对我们来说，如果已经完成九年义务教育，应该都能完成这一层次的阅读，也就是说能结合语境理解字面上的意思。 在儿童具备纯熟的阅读能力之前，至少需要四个截然不同的阶段。第一个阶段，阅读准备阶段，相当于学前将于的或幼稚园的学习经验。第二个阶段，认字，相当于一年级学生典型的学习经验。第三个阶段，字汇的增长及对课文的运用，有能力阅读一些交通标志，或图片说明，填写政府有关的简单表格等等 。第四个阶段，这个阶段，学生要从小学到初中毕业。有一定的读写能力，几乎可以阅读所有读物，但还不够老练。 检视阅读（略读）特点在于强调时间。在这个层次，必须在规定的时间完成一项阅读。譬如用十五分钟读完一本书，或是同样的时间念完两倍数量的书。与基础阅读相比，检视阅读才算进入了阅读的层次，这是一种让你在有限的时间内尽量抓住一本书的重点的阅读方法。而这一层次，恰恰是很多人所没有掌握的。进行检视阅读的情况大概有两种，一种是让你想在有限的时间当中，对一本书有个基础的了解，然后再决定你是否继续精读下去。而另外一种是，有很多书其实并不适合花大量精力在上面，也就不适合精读，通常面对这类书籍的时候，检视阅读往往是了解一本书的最好方式。 检视阅读分两种： 第一，有系统化的略读和粗读略读和粗读可以让我们发现这本书值不值得多花时间去仔细阅读，并且，略读也能告诉你许多这本书有关的事。略读的习惯有关用不着花太多时间，下面是一些建议：（1）先看书名页，然后如果有序就先看序。要很快的看过去，特别注意副标题，或其他相关说明或宗旨，或是作者写作本书的特殊角度。（2）研究目录页，对这本书的基本架构做概括性的理解。这就像出发旅行前，先看下地图一样。（3）如果书中附有索引，也要检阅一下，大多数论说类的书籍都有有索引。这样能款苏评估这本书涵盖了那些议题的范围。（4）如果输有包着书衣，不妨读一下出版者的介绍，这应该有作者对本书的主旨描述，这可以让你快速判断这本书是否有可取的内容，而不是根本没任何重要的东西。（5）从本书的目录概的初步印象中，挑几个看起来跟主题息息相关的篇章来看。特别是看看这些篇章的开头或结尾的摘要说明。（6）最后一步，把书打开，东翻翻西翻翻，念个一两段，有时候连续读几页，但不要太多。，就用这样的方法把全书翻过一遍，随时寻找主要论点的讯号，留意主题的基本脉动。通过以上几个步骤，你可以在不到一小时的时间里，对这本书已经了解了很多。尤其，你应该了解这本书是否包含想继续挖掘下去的内容，是否值得你继续投下时间与注意？你应该比以前更清楚这本书该归类为哪一个种类，以便将来有需要时好作参考。 第二，粗浅的阅读每个人都有这样的经验：对一本难书包着高度的期望，结果却只是在徒劳无益的挣扎而已。最后得出一个结论：一开始读这本书就是个错误。但这只是对阅读一本难书的期望过高而已。头一次面对一本难读的书的时候，从头到尾先读一遍，碰到不懂的地方不要停下来查询或思索。只注意你能理解的部分，不要为一些设法立即了解的东西而停顿。略过不懂的部分，集中精力去了解你看得懂的部分。从头到尾了解一遍之后，就算只有50%或更少，都能帮助你后来重读第一次略过的部分，增进理解。就算不重读，这本难度很高的书你也理解了一半，比什么都不了解来的更好些。 - 分析阅读（精读）这个层次更复杂，更系统化。如果你的目标只是获得资讯或消遣，就没有必要用到分析阅读。如果说检视阅读是在有限的时间内，最好也最完整的阅读，那么分析阅读就是在无限的时间里，最好也最完整的阅读。在这个层次，我们需要在略读的基础上，更加主动的去提出问题，并且用自己的语言尝试解释这本书的内容。也就是在精读的时候，我怎么样用自己的话把这一段、这一章、甚至整本书的内容说出来。分析阅读的规则是一个理想化的阅读。没有多少人用过这样的方法来阅读一本书。而使用过这些方法的人，可能也没办法用这些规则来阅读许多本书。无论如何，这些规则只是衡量阅读层次的理想标准。如果你是个好读者，也就能达到你应该达到的阅读层次。一个读得很广泛，却读不精的人，与其值得赞美，不如值得同情。就像霍布斯所说：“如果我像一般人一样读那么多书，我就跟他们一样愚蠢了。”当然，许多书都值得精读。但有更多的书只要浏览一下就行了。要成为一个好读者，就要懂得依照一本书的特质，运用不同的阅读技巧来阅读。 分析阅读分为三个阶段： 第一个阶段（找出一本书在谈些什么规则） 规则一，依照书本的种类与主题作分类。你一定要知道自己在读的是哪一类书，而且要越早知道越好。最好早在你开始阅读之前就先知道。主要分类法，一种是虚构的小说类，另一种是传达知识，说明性的论说类。论说性作品又区分为理论性和实用性作品。 规则二，用最简短的句子说出整本书在谈些什么。如对亚当斯密的《国富论》，可以缩减为一下篇幅：本书在探讨国家财富的资源。任何一个以劳力为主的经济体制，都要考虑到薪资的给付，资本利润的回收，积欠地主的租金等关系，这些就是物品价格的基本因素。本书探讨到如何更多元化的有效运用资本，并从金钱的起源与使用，谈到积累资本及使用资本。本书接着经验不同的国家在不同状况下的富裕发展，比较了不同财经系统，讨论了自由贸易的好处。 规则三，按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。这个规则是可以有一套运用的公式的，比如大纲排列如下：（1）作者将全书分为五个部分，第一部分谈的是什么，第二部分谈的是什么，第三部分谈的是别的事，第四部分则是另外的观点，第五部分优势另一些事。（2）第一个主要部分又分为三个段落，第一段落为X，第二段了为Y，第三段了为Z。（3）在第一部分的第一个阶段，这种有四个重点，第一个重点是A，第二个重点是B，第三个重点是C，第四个重点是D等等。 规则四，找出作者在问的问题，或作者想要解决的问题。可以列出简短的公式：某件事存在吗？是什么样的事？发生的原因是什么？或是在什么样的情况下存在？或为什么会有这件事的存在？这件事的目的是什么？造成的影响是什么？特性及特征是什么？与其他类似事件，或不相同事件的关联是什么？这件事是如何进行的？以上这些都是理论性的问题。有哪些结果可以选择？应该采取什么样的手段才能获得某种结果？要达到某个目的，应该采取哪些行动？以什么顺序？在这些条件下，什么事是对的，或怎样才会更好，而不是更糟？在什么样的条件下，这样做会比那样做好一些？以上这些都是实用的问题。 第二个阶段（找出一本书到底在说什么的规则） 规则五，诠释作者使用的关键字，与作者达成共识。这个规则共分两个部分，第一个部分是找出重要单字，那些举足轻重的单字。第二部分是确认这些单字在使用时的最精确的意义。 规则六，从最重要的句子中抓出作者的重要主旨。 规则七，找出作者的论述，重新架构这些论述的前因后果，以明白作者的主张。如果可以，找出书中说明重要论述的段落。但是，如果这个论述并没有这样表达出来，你就要去架构出来。你要从这一段或那一段中挑选句子出来，然后整理出前后顺序的主旨，以及其组成的论述。规则八，确定作者已经解决了哪些问题，还有哪些是未解决的。在未解决的问题中，确定哪些是作者认为自己无法解决的问题。 第三阶段（公正的评断一本书） A.智慧礼节的一般规则 规则九，在你说出“我同意”，“我不同意”，或“我暂缓评论”之前，你一定要能肯定地说：“我了解了。”除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。 规则十，不要争强好胜，非辩到底不可。当你不同意作者的观点时，要理性地表达自己的意见，不要无理地辩驳或争论。如果你知道或怀疑自己是错的，就没有必要去赢得那场争辩。 规则十一，尊重知识与个人观点的不同，在作任何评断之前，都要找出理论基础。 B.批评观点的特别标准 规则十二，证明作者的知识不足（uninformed），缺少某些与他想要解决的问题相关的知识。 规则十三，证明作者的知识有错误（misinformed），理念不正确。 规则十四，证明作者不合逻辑，推论无法令人信服。 规则十五，证明作者的分析不完整，并没有解决他一开始提出来的所有问题，或是他并没有尽可能善用他手边的资料，或是他并没有看出其间的含意与纵横交错的关系，或是他没法让自己的想法与众不同。 主题阅读也是最高层次的阅读。这是最复杂、最系统化的阅读。虽然它要求非常多，也不被人熟知，但却是所有阅读活动中最有收获、最能获益良多的阅读方式。这个阅读层次已经不仅仅局限于一本书了，而是针对一个主题问题，找出与主题相关的书籍以及这些书籍当中与主题相关的章节，针对这些进行检视阅读或分析阅读。在主题阅读中，你关心的主题才是你的重点，而不是你阅读的书。在这个阶段，检视阅读已经是读者在阅读时主要的工具或手段了。 在主题阅读中有两个阶段。准备阶段，另一个是主题阅读本身。 第一阶段，观察研究范围：主题阅读的准备阶段（1）针对你要研究的主题，设计一份试验性的书目。你可以参考图书馆目录、专家的建议与书中的书目索引。（2）浏览这份书目上所有的书，整体进行检视阅读一遍，确定哪些与你的主题相关，并就你的主题建立起清楚的概念。 第二阶段主题阅读：阅读所有第一阶段收集到的书籍（1）浏览所有在第一阶段被认定与你主题相关的书，找出最相关的章节。（2）根据主题创造出一套中立的词汇，带引作者与你达成共识——无论作者是否实际用到这些词汇，所有的作者，或至少绝大部分的作者都可以用这套词汇来诠释。（3）建立一个中立的主旨，列出一连串的问题——无论作者是否明白谈过这些问题，所有的作者，或者至少大多数的作者都要能解读为针对这些问题提供了他们的回答。（4）界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。你要记住，各个作者之间或之中，不见得一定存在着某个议题。有时候，你需要针对一些不是作者主要关心范围的事情，把他的观点解读，才能建构出这种议题。（5）分析这些讨论。这得把问题和议题按顺序排列，以求突显主题。比较有共通性的议题，要放在比较没有共通性的议题之前。各个议题之间的关系也要清楚地界定出来。注意：理想上，要一直保持对话式的疏离与客观。要做到这一点，每当你要解读某个作家对一个议题的观点时，必须从他自己的文章中引一段话来并列。 最后，虽然这本说提到的这些阅读方法对于论说性书籍普遍比较适用，但并说是说这些方法适合所有人，只有真是你觉得最适合你自己的读书方法才是好方法。如果你已经有了自己觉得比较合适的阅读方法，其实没必要去强求，用自己的方法就好。 本文大部分内容摘自： 《如何阅读一本书》，豆瓣读书 【Simple Read】如何阅读一本书？，bilibili","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://veinin.com/categories/读书笔记/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://veinin.com/tags/读书/"},{"name":"如何阅读一本书","slug":"如何阅读一本书","permalink":"https://veinin.com/tags/如何阅读一本书/"}]},{"title":"Lua C API 教程 - 从 C 程序调用 Lua","slug":"lua-c-api-02","date":"2017-08-06T14:15:58.000Z","updated":"2018-07-24T15:02:44.351Z","comments":true,"path":"2017/08/06/lua-c-api-02/","link":"","permalink":"https://veinin.com/2017/08/06/lua-c-api-02/","excerpt":"从正在运行的 C 程序中，你可以调用 Lua 脚本。C 程序可以将参数传递给 Lua 脚本，而Lua脚本也可以向 C 程序传回一个返回值。Lua脚本可以用来初始化C程序，或者Lua脚本也可以在 C 程序中注册一个回调。 错误处理如果没有正确的信息，从C程序调用Lua脚本可能会令人望而生畏。不同的计算机对库和包含文件有不同的名称和位置，很难找出导致编译/链接问题的原因。在有错误的情况下，应该程序将错误信息输出到标准错误流中，而 Lua 核心绝不会直接输出任何东西到错误输出流上，它通过返回错误代码和信息来发出错误信号。每个应用程序都可以适当的用最适合它们自己的方式来处理这些错误信息。","text":"从正在运行的 C 程序中，你可以调用 Lua 脚本。C 程序可以将参数传递给 Lua 脚本，而Lua脚本也可以向 C 程序传回一个返回值。Lua脚本可以用来初始化C程序，或者Lua脚本也可以在 C 程序中注册一个回调。 错误处理如果没有正确的信息，从C程序调用Lua脚本可能会令人望而生畏。不同的计算机对库和包含文件有不同的名称和位置，很难找出导致编译/链接问题的原因。在有错误的情况下，应该程序将错误信息输出到标准错误流中，而 Lua 核心绝不会直接输出任何东西到错误输出流上，它通过返回错误代码和信息来发出错误信号。每个应用程序都可以适当的用最适合它们自己的方式来处理这些错误信息。 下面是一段处理 Lua 错误的方案，它只是输出一条错误信息，关闭 lua_State，并退出整个应用程序： 12345678910111213141516171819#ifndef ERRORS_H#define ERRORS_H#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"lua.h\"void err_exit(lua_State *L, const char *fmt, ...) &#123; va_list argp; va_start(argp, fmt); vfprintf(stderr, fmt, argp); va_end(argp); lua_close(L); exit(EXIT_FAILURE);&#125;#endif //ERRORS_H 剖析一个 C 程序对 Lua 的调用从 C 程序到 Lua 脚本的典型交互流程看起来像这样： 创建一个 Lua 状态变量 加载 Lua 库 加载但不运行 Lua 脚本文件 启动脚本运行以创建脚本的全局变量 将所有参数传递给堆栈上的 Lua 脚本 运行加载的 Lua 脚本 从 Lua 脚本中检索返回 关闭 Lua 状态变量 实现一个调用 Lua 简单脚本 C 程序我们需要编写一个简单的 C 程序调用 Lua 脚本的实例，它需要实现以下功能： 加载的 Lua 脚本启动运行 将参数传递给 Lua 脚本 从 Lua 脚本中检索返回 首先，编写一个 Lua 脚本文件代码，文件名为 call_lua_script ： 1io.write(\"This is comming from lua\\n\") 然后，编写一个 C 程序代码，加载前面编写好的脚本文件： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"errors.h\"#include \"lua.h\"#include \"lauxlib.h\"#include \"lualib.h\"int main()&#123; lua_State *L = luaL_newstate(); luaL_openlibs(L); if(luaL_loadfile(L, \"call_lua_script.lua\")) err_exit(L, \"luaL_loadfile failed.\\n\"); printf(\"In C, calling Lua\\n\"); if(lua_pcall(L, 0, 0, 0)) err_exit(L, \"lua_pcall() failed.\", lua_tostring(L, -1)); printf(\"Back in C again\\n\"); lua_close(L); return 0;&#125; 相关函数解析1.luaL_loadfile(L, &quot;call_lua_script.lua&quot;); 加载一个 Lua 脚本文件。此函数的返回值和 lua_load 相同，不过它还可能产生一个叫做 LUA_ERRFILE 的出错码。这种错误发生于无法打开或读入文件时，或是文件的模式错误。和 lua_load 一样，这个函数仅加载代码块，并不会直接运行脚本内容。 2.lua_pcall(L, number_of_args, number_of_returns, errfunc_idx); 运行加载的 Lua 脚本函数，第二个参数位传入参数数量; 第三个参数为调用函数返回值数量。 编译、运行：12345$ cc -o call_lua_script call_lua_script.c -I /usr/local/include/ -L /usr/local/lib/ -llua$ ./call_lua_scriptIn C, calling LuaThis is comming from luaBack in C again 调用Lua函数，传递参数，接受返回值实际上，很多时候，我们需要调用的是指定的 Lua 脚本函数，它的运行步骤看起来是这样的： 加载的 Lua 脚本启动运行 将参数传递给 Lua 脚本的指定函数 从 Lua 脚本中检索返回值 然后，让我们开始在 Lua 脚本中编写一个待调用的特定函数，创建 call_lua_func.lua 文件： 12345678function sayHello() io.write(\"This is comming from lua.sayHello.\\n\")endfunction add(a, b) print(\"This is comming from lua.add. arg.a =\", a, \" arg.b =\", b) return a + bend 创建并编写一个 call_lua_func.c 文件，调用上面创建的 Lua 文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"errors.h\"#include \"lua.h\"#include \"lauxlib.h\"#include \"lualib.h\"int main()&#123; lua_State *L = luaL_newstate(); luaL_openlibs(L); if(luaL_loadfile(L, \"call_lua_func.lua\")) error_exit(L, \"luaL_loadfile failed.\\n\"); if(lua_pcall(L, 0, 0, 0)) error_exit(L, \"lua_pcall failed.\\n\"); printf(\"In C, calling Lua-&gt;sayHello()\\n\"); lua_getglobal(L, \"sayHello\"); //Tell it to run test2.lua -&gt; sayHello() if(lua_pcall(L, 0, 0, 0)) error_exit(L, \"lua_pcall failed.\\n\"); printf(\"Back in C again\\n\"); printf(\"\\nIn C, calling Lua-&gt;add()\\n\"); lua_getglobal(L, \"add\"); //Tell it to run test2.lua -&gt; add() lua_pushnumber(L, 1); lua_pushnumber(L, 5); if(lua_pcall(L, 2, 1, 0)) error_exit(L, \"lua_pcall failed.\\n\"); printf(\"Back in C again\\n\"); int returnNum = lua_tonumber(L, -1); printf(\"Returned number : %d\\n\", returnNum); lua_close(L); return 0;&#125; 相关函数解析在 Lua 脚本中， sayHello 函数只做输出操作，而 add 函数则需要传入两值，并进行加法操作并返回结果。 从 C 层在调用 Lua 脚本层时，首先要把被调用的函数压入栈中，可以通过 lua_getglobal 函数把调用函数入栈。 把需要传递给被调用函数的参数用 lua_push* 函数按正序压栈。 最后调用一下 lua_call，把要传入的参数个数及返回值个数一起传进去。 当函数调用完毕后，所有的参数以及函数本身都会出栈。紧接着函数的所有返回值这时则被压栈。Lua 会保证返回值都放入栈空间中。函数返回值将按正序压栈（第一个返回值首先压栈），因此在调用结束后，最后一个返回值将被放在栈顶。 编译、运行123456789101112131415$ cc -o call_lua_func call_lua_func.c -I /usr/local/include/ -L /usr/local/lib -llua$ ./call_lua_funcIn C, calling Lua-&gt;sayHello()This is comming from lua.sayHello.Back in C againIn C, calling Lua-&gt;add()This is comming from lua.add. arg.a = 1.0 arg.b = 5.0Back in C againReturned number : 6 将 table 传递给函数在对 Lua 函数调用参数传值时经常涉及到复杂的数据类型，而 Lua 中，复杂数据类型通常用 table 来表示。通过下面代码我们来讨论如何实现表的传递： 创建文件名为 call_lua_table.lua 的脚本文件，定义一个接受一个 table 的函数，并且新建一个 talbe，将传入的 table 键值都插入新建的 table 中，并记录数据长度，最后返回新建立的 table： 1234567891011function tablehandler(t) local returnedt = &#123;numfields = 1&#125; for i, v in pairs(t) do returnedt.numfields = returnedt.numfields + 1 returnedt[tostring(i)] = tostring(v) end io.write(\"this is comming from table handler. table num fields : \", returnedt.numfields, \"\\n\") return returnedtend 编写 C 程序代码，调用函数，传递一个 table 参数，并解析返回值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"errors.h\"#include \"lua.h\"#include \"lauxlib.h\"#include \"lualib.h\"int main(void)&#123; lua_State *L = luaL_newstate(); luaL_openlibs(L); if(luaL_loadfile(L, \"call_lua_table.lua\")) error_exit(L, \"luaL_loadfile failed.\\n\"); if (lua_pcall(L, 0, 0, 0)) error_exit(L, \"lua_pcall failed\"); printf(\"In C, calling Lua-&gt;tablehandler()\\n\"); lua_getglobal(L, \"tablehandler\"); lua_newtable(L); // Push empty table onto stack, table now at -1 lua_pushliteral(L, \"firstname\"); // Puah a key onto stack, table now at -2 lua_pushliteral(L, \"Veinin\"); // Puash a value onto stack, table now at -3 lua_settable(L, -3); // Take key and value, put into table at -3, then pop key and value so table again at -1 lua_pushliteral(L, \"lastname\"); lua_pushliteral(L, \"Guo\"); lua_settable(L, -3); if(lua_pcall(L, 1, 1, 0)) // Run function. error_exit(L, \"lua_pcall failed\"); printf(\"============ Back in C again, Iterating thru returned table ============\\n\"); lua_pushnil(L); // Make sure lua_next starts at beginning const char *k, *v; while(lua_next(L, -2)) &#123; // Table location at -2 in stack v = lua_tostring(L, -1); k = lua_tostring(L, -2); lua_pop(L, 1); // Remove value, leave in place to guide next lua_next(). printf(\"%s = %s\\n\", k, v); &#125; lua_close(L); return 0;&#125; 相关函数解析1.表参数传递惯用手段 1234lua_newtable(L); // Push empty table onto stack, table now at -1lua_pushliteral(L, \"firstname\"); // Puah a key onto stack, table now at -2lua_pushliteral(L, \"Veinin\"); // Puash a value onto stack, table now at -3lua_settable(L, -3); // Take key and value, put into table at -3, then pop key and value so table again at -1 对于 C 层代码，可以通过 lua_newtable 函数创建一张空表，并将其压栈，该函数它等价于 lua_createtable(L, 0, 0)。然后调用 lua_pushliteral 把键和值分别压入栈中，并通过 lua_settable 把 key 和 value 放入 table 中，做一个等价于 t[k] = v 的操作，在操作完成后，这个函数会将键和值都弹出栈。 2.表返回值处理 当 C 调用 Lua 函数返回结束时，它把返回值放在了栈上。当返回值是一个 table 时，索引表格的元素就不那么容易了。对于 table ，在返回 C 时，这个 table 在堆栈的顶部，下面的是访问这个 table 的惯用方法： 12345678910lua_pushnil(L); // Make sure lua_next starts at beginningconst char *k, *v;while(lua_next(L, -2)) &#123; // Table location at -2 in stack v = lua_tostring(L, -1); k = lua_tostring(L, -2); lua_pop(L, 1); // Remove value, leave in place to guide next lua_next(). printf(\"%s = %s\\n\", k, v);&#125; 为了迭代获取 table 中的值，需要使用 lua_next 函数从栈顶弹出一个键，然后通过索引指定表中的一个键值对，对其压栈，在这一步开始之前我们需要调用 lua_pushnil(L) 设置第一个键为缺省值，然后再调用 lua_next 。通常，我们会在下一个迭代到来之前，把‘值’出栈，但会保留‘键’做下一次迭代操作。 编译、运行123456789101112$ cc -o 05_call_lua_table 05_call_lua_table.c -I /usr/local/include/ -L /usr/local/lib/ -llua$ ./05_call_lua_tableIn C, calling Lua-&gt;tablehandler()this is comming from table handler. table num fields : 3============ Back in C again, Iterating thru returned table ============lastname = Guofirstname = Veininnumfields = 3 总结你已经能使用 Lua C API 完成对 Lua 脚本的调用工作了，并且可以对函数调用传递参数，在函数返回后，处理函数的返回值。下一步，将介绍最后一节内容，如何从 Lua 中调用 C 代码，并为 Lua 编写可拓展的 C 程序库。","categories":[{"name":"Lua","slug":"Lua","permalink":"https://veinin.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://veinin.com/tags/Lua/"},{"name":"Lua C API","slug":"Lua-C-API","permalink":"https://veinin.com/tags/Lua-C-API/"}]},{"title":"Lua C API 教程 - 从 Lua 调用 C 函数","slug":"lua-c-api-03","date":"2017-08-06T14:15:58.000Z","updated":"2018-07-24T15:50:48.487Z","comments":true,"path":"2017/08/06/lua-c-api-03/","link":"","permalink":"https://veinin.com/2017/08/06/lua-c-api-03/","excerpt":"前一篇文章介绍了怎么从 C 程序中调用 Lua 代码。但内容并没有深入，还有很多东西需要反复去尝试，并且需要通过 Lua 辅助来调用 C 程序。 本章将着重介绍如何继续扩展你的 Lua 程序 - 在Lua中调用C函数。 剖析一个 Lua 程序对 C 的调用从 Lua 的角度来看，调用 C 程序其实就是调用一个模块，在Lua中一个代码块称为chunk，一个chunk里面通常有若干函数，这些函数用table存储。而Lua的C扩展模块也是可以这样实现的，Lua调用C函数时，并不依赖于函数名、包的位置，而只依赖于注册函数时传入的函数地址。 一个简单的 Lua 程序，调用一个包含了 foo 和 bar 函数的 mylib 模块： 123local mylib = require \"mylib\"print(mylib.foo())print(mylib.bar())","text":"前一篇文章介绍了怎么从 C 程序中调用 Lua 代码。但内容并没有深入，还有很多东西需要反复去尝试，并且需要通过 Lua 辅助来调用 C 程序。 本章将着重介绍如何继续扩展你的 Lua 程序 - 在Lua中调用C函数。 剖析一个 Lua 程序对 C 的调用从 Lua 的角度来看，调用 C 程序其实就是调用一个模块，在Lua中一个代码块称为chunk，一个chunk里面通常有若干函数，这些函数用table存储。而Lua的C扩展模块也是可以这样实现的，Lua调用C函数时，并不依赖于函数名、包的位置，而只依赖于注册函数时传入的函数地址。 一个简单的 Lua 程序，调用一个包含了 foo 和 bar 函数的 mylib 模块： 123local mylib = require \"mylib\"print(mylib.foo())print(mylib.bar()) 上面的代码 require &quot;mylib&quot; 语句加载了一个名为 mylib 的模块，显然模块具有函数 foo 和 bar。所以 C 程序不仅需要定义 foo() 和 bar() 函数，还需要将自己注册为一个模块，并将函数注入模块当中。 require &quot;mylib&quot; 做了两件事： 寻找一个叫做 mylib.so (windows 一个是 mylib.dll) 的动态库文件。 一旦发现 mylib.so , 就会去查找一个名为 luaopen_mylib 的函数来运行。 通常，创建 C 模块时，函数都是私有的，都声明为static。一个模块函数定义大概是这样子： 1234567891011static int foo(lua_State *L)&#123; lua_pushstring(L, \"foo...\") return 1;&#125;static int bar(lua_State *L)&#123; lua_pushstring(L, \"bar...\"); return 1;&#125; 为了让模块函数注册到 Lua 中去，我们需要声明一个 luaL_Reg 的数组，来包含模块中的所有函数及名称。任何 luaL_Reg 数组都必须以一对为 NULL 的 name 与 func 结束： 12345static const struct luaL_Reg mylib[] = &#123; &#123;\"foo\", foo&#125;, &#123;\"bar\", bar&#125;, &#123;NULL, NULL&#125;&#125;; 最后，声明一个打开模块的主函数，该函数名称必须以 luaopen_ 开头，后面跟着的是你编写的模块名称，它唯一的参数就是 Lua 状态机。并使用 luaL_newlib 创建一张新表，并把 luaL_Reg 中的函数注册进去： 1234int luaopen_mylib(lua_State *L) &#123; luaL_newlib(L, mylib); return 1;&#125; 最棘手的莫过于编译一个写好的新模块，它看起来是这样子： 在 Mac OS 中： 1$ cc -o mylib.so mylib.c -I /usr/local/include -L /usr/local/lib -bundle -undefined dynamic_lookup 在 Linux 中： 1$ gcc -o mylib.so mylib.c -I/usr/include/lua5.1 -llua5.1 -Wall -shared -fPIC 做的更好一些下面我们模拟编写一个名为 power 的模块，并实现两个名为 square 和 cube 的函数来进行计算任务，并把计算结果返回 Lua。 首先，编写模块 C 程序： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include \"lua.h\"#include \"lauxlib.h\"#include \"lualib.h\"static int square(lua_State *L)&#123; float num = lua_tonumber(L, -1); printf(\"square(), num = %f\\n\", num); lua_pushnumber(L, num * num); return 1;&#125;static int cube(lua_State *L)&#123; float num = lua_tonumber(L, -1); printf(\"cube(), num = %f\\n\", num); lua_pushnumber(L, num * num * num); return 1;&#125;static const struct luaL_Reg libs [] = &#123; &#123;\"square\", square&#125;, &#123;\"cube\", cube&#125;, &#123;NULL, NULL&#125;&#125;;int luaopen_power(lua_State *L)&#123; luaL_newlib(L, libs); return 1;&#125; 然后，把c程序编译成动态库 pwer.so。ps:MAC OSX中编译时需要加入-bundle -undefined dynamic_lookup 选项，不然会引起”multiple lua vms detected” 错误。 1$ cc -o power.so power.c -I /usr/local/include -L /usr/local/lib -bundle -undefined dynamic_lookup 别写测试 Lua 脚本： 123local power = require(\"power\")print(power.square(2.5))print(power.cube(2.5)) 运行： 12345$ lua test_power.luasquare(), num = 2.5000006.25cube(), num = 2.50000015.625 更进一步如果你已经和 Lua 一起工作过一段时间后，你一个会注意到 Lua 没有内置 sleep() 延迟函数。一种解决方案是调用 C 的 sleep() 函数。我们做的是需要实现两个名为 sleep() 和 msleep 和函数来让 Lua 代码延迟指定多少秒、多少毫秒。","categories":[{"name":"Lua","slug":"Lua","permalink":"https://veinin.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://veinin.com/tags/Lua/"},{"name":"Lua C API","slug":"Lua-C-API","permalink":"https://veinin.com/tags/Lua-C-API/"}]},{"title":"Lua C API 教程 - 入门","slug":"lua-c-api-01","date":"2017-08-05T08:14:27.000Z","updated":"2018-07-24T15:02:50.910Z","comments":true,"path":"2017/08/05/lua-c-api-01/","link":"","permalink":"https://veinin.com/2017/08/05/lua-c-api-01/","excerpt":"Lua 的 C API 是一个 C 代码与 Lua 进行交互的函数集，也就是宿主程序跟 Lua 通讯用的一组 C 函数。它由以下部分组成：读写Lua全局变量的函数，调用Lua函数的函数，运行 Lua 代码片段的函数，注册 C 函数然后可以在 Lua 中被调用的函数，等等。 头文件在任何调用Lua的 C程序中都必选包含以下3个文件 ： 123#include &lt;lua.h&gt;#include &lt;lauxlib.h&gt;#include &lt;lualib.h&gt;","text":"Lua 的 C API 是一个 C 代码与 Lua 进行交互的函数集，也就是宿主程序跟 Lua 通讯用的一组 C 函数。它由以下部分组成：读写Lua全局变量的函数，调用Lua函数的函数，运行 Lua 代码片段的函数，注册 C 函数然后可以在 Lua 中被调用的函数，等等。 头文件在任何调用Lua的 C程序中都必选包含以下3个文件 ： 123#include &lt;lua.h&gt;#include &lt;lauxlib.h&gt;#include &lt;lualib.h&gt; 如果是 C++ 程序，请包含头文件 lua.hpp, 这个文件实际上也是引入了上面 3 头文件，它看起来是这样的： 12345extern \"C\" &#123;#include \"lua.h\"#include \"lualib.h\"#include \"lauxlib.h\"&#125; 在上面的头文件中其中，所有的 API 函数按相关的类型以及常量都声明在头文件 lua.h 中。而另一个相关头文件 lauxlib.h 则是API接口的一个辅助库（auxlib），其中定义的函数都以luaL_开头（如lual_loadbuffer），辅助库利用了lua.h中提供的基础函数提供了更高层次的抽象。auxlib 没有存取 Lua 内部的权限，它所完成的所有工作都是通过正式的基本 API。 编译和连接没有比编译和连接你的第一个 C 程序更难的事情了。在编译之前你需要了解一些编译选项，下面是一些典型的编译命令： cc，你系统里面的 C 代码编译器，它可以是 cc 、 gcc 或其他的编译器。 -Wall，显示所有警告，直到所有错误和警告已修复之前，你都可以选择不插入这个选项。 -o hello，编程后的执行程序名称，这里会得到一个名为 hello 的可执行程序。 hello.c，需要编译的 C 程序名称。 -I/path/to/Lua/include，每个 C 编译器都会在某个地方检察程序包含的头文件信息，但大部分情况下，Lua C API 的头文件并不在你程序所处的目录，所以需要你告诉编译器去哪个地方找到这些头文件。 -L/path/to/lua/libraries，每个 C 编译器都会在特定的地方进行连接，但通常 Lua 的库并不会在你自己编写的 C 程序目录下，所以你需要告诉编译器去哪里找到它们。 -llibLuaName，告诉 C 编译器链接 Lua 库的名称。 -lm，数学库的链接。 第一个示例程序实现一个独立的 Lua 解释器。 1234567891011121314151617181920212223242526#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include \"lua.h\"#include \"lauxlib.h\"#include \"lualib.h\"int main(void)&#123; char buff[256]; int error; lua_State *L = luaL_newstate(); //opens lua luaL_openlibs(L); //open the standar libraries while(fgets(buff, sizeof(buff), stdin) != NULL) &#123; error = luaL_loadstring(L, buff) || lua_pcall(L, 0, 0, 0); if(error) &#123; fprintf(stderr, \"%s\\n\", lua_tostring(L, -1)); lua_pop(L, 1); &#125; &#125; lua_close(L); return 0;&#125; luaL_newstate 函数创建一个新的 Lua 状态机。它以一个基于标准 C 的 realloc 函数实现的内存分配器调用 lua_newstate 。Lua 中没用定义任何全局变量，它所有状态都保存在动态结构lua_State中，而指向这个函数的指针做为所有Lua函数的第一个参数，这样的实现方式使得Lua能够重入且在多线程中的使用做好准备。 函数 luaL_openlibs 打开指定状态机中的所有 Lua 标准库。 当状态机标准库载入后，对于用户输入的每一行，C 程序首先调用 luaL_loadstring 将字符串加载为 Lua 代码块，并通过 lua_pcall 以保护模式运行从chunk中调用返回的代码。lua_pcall 在没有错误的情况下返回0，如有错误发送，错误信息将被压入栈中，我们可以通过 lua_tostring 来得到这条信息，输出它，最后调用 lua_pop 将它从栈中删除。 编译、运行1234567$ cc -o first first.c -I/usr/local/include -L/usr/local/lib -llua -lm$ ./firstprint(\"hello\")hellohehe[string \"hehe...\"]:2: syntax error near 栈当 Lua 与 C 之间交换数据时我们面临两个问题，一个是动态与静态类型系统的不匹配，另一个则是自动和手动内存管理的不一致。Lua 使用一个虚拟栈来与 C 互相传值，栈上的的每个元素都是一个 Lua 值。第一次调用 Lua 时，首先值会压入栈中，然后调用 Lua （这个值会被弹出），我们要做的就是把值按类型用不同的函数压入栈中，然后再用相应的函数把值从栈中取出。当然，对于栈来说，它始终遵循 LIFO 规则，你可以自由的查询栈上的任何元素，也可以在任何位置插入和删除元素。 压入元素API 有一系列的压入函数，如空值: lua_pushnil()、整数 lua_pushnumber()、任意字符串 lua_pushlstring()、C风格字符串 lua_pushstring() … 1234567void lua_pushnil(lua_State *L);void lua_pushboolean(lua_State *L, int bool);void lua_pushnumber(lua_State *L, lua_Number n);void lua_pushinteger(lua_State *L, lua_Integer n);void lua_pushunsigned(lua_State *L, lua_Unsigned n);void lua_pushlstring(lua_State *L, const char *s, size_t len);void lua_pushstring(lua_State *L, const char * s); 当你使用 Lua API 时， 就有责任保证做恰当的调用。 特别需要注意的是， 你有责任控制不要堆栈溢出。 你可以使用 lua_checkstack 这个函数来扩大可用堆栈的尺寸。无论你何时从 C 调用 Lua，都要保证栈空间至少有 LUA_MINSTACK 大小的空闲，这个值定义在了 lua.h 中，通常位20。因此，只要你不是不断的把数据压栈， 通常你不用关心堆栈大小。 1int lua_checkstack(lua_State *L, int sz); 查询元素栈中的元素通过索引值查询，第一个元素索引为 1，最后一个元素位 n。当索引值为负时，从栈顶开始找，如 -1 也可以表示最后一个元素，-2 指栈顶的前一个元素。例如可以调用 lua_tostring(L, -1) 来调用栈顶元素。Lua C API 提供了一套 lua_is* 函数来检查指定类型的值，如 lua_isnumber，lua_isstring 等，这些函数只检查是否能转换成指定类型。 1int lua_is...(lua_State *L, int index); 最后，还有一个的 lua_type 函数，它返回栈中元素的类型。在 lua.h 中，每种类型都定义了一个常量 LUA_TNIL 、LUA_TBOOLEAN 、LUA_TNUMBER 、LUA_TSTRING 、LUA_TTABLE 、LUA_TFUNCTION 、LUA_TUSERDATA 。为了从栈中获取值，还提供了每种类值相对的 lua_to* 函数。如给定元素不正确则返回 0 或 NULL。 123456int lua_toboolean(lua_State *L, int index);lua_Number lua_tonumber(lua_State *L, int index);lua_Integer lua_tointeger(lua_State *L, int index);lua_Unsigned lua_tounsigned(lua_State *L, int index);const char * lua_tostring(lua_State *L, int index);size_t lua_strlen(lua_State *L, int index); 在检查一个类型值时，通常你需要用 lua_is* 函数来检查，但在Lua 5.2 中新增了如下 lua_to* 函数，在传入值 isnum，如果 isnum 不是 NULL ， *isnum 会被设为操作是否成功。 123lua_Number lua_tonumberx(lua_State *L, int index, int *isnum);lua_Integer lua_tointegerx(lua_State *L, int index, int *isnum);lua_Unsigned lua_tounsignedx(lua_State *L, int index, int *isnum); 其他栈操作除了上面所列的栈操作函数，在 C 和 Lua 交换值时，我们还可以通过以下 API 来对栈进行操作： 12345678int lua_gettop(lua_State *L);void lua_settop(lua_State *L, int index);void lua_pushvalue(lua_State *L, int index);void lua_remove(lua_State *L, int index);void lua_insert(lua_State *L, int index);void lua_replace(lua_State *L, int index);void lua_copy(la_State *L, int formidx, int toidx);void lua_pop(lua_State *L, int n); lua_gettop 返回栈顶的索引值；lua_settop 它将把堆栈的栈顶设为这个索引。如果新的栈顶比原来的大，超出部分的新元素将被填为nil，如果index为0，把栈上所有元素移除；lua_pushvalue 把栈上给定索引处的元素作一个副本压栈；lua_remove 删除指定索引位置的值；lua_insert 将栈顶值移动到指定位置；lua_replace 把栈顶元素放置到给定位置而不移动其它元素 （因此覆盖了那个位置处的值），然后将栈顶元素弹出。lua_copy 从索引 fromidx 处复制一个值到一个有效索引 toidx 处，覆盖那里的原有值。 不会影响其它位置的值。lua_pop从栈中弹出 n 个元素。lua_settop(L,0) 可以清空栈顶，而 lua_pop 真是利用了这一技巧: 1#define lua_pop(L,n) lua_settop(L, -(n)-1) 栈操作实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include \"lua.h\"#include \"lauxlib.h\"static void stackDump(lua_State *L)&#123; int i; int top = lua_gettop(L); for(i = 1; i &lt;= top; i++) &#123; int t = lua_type(L, i); switch(t) &#123; case LUA_TNIL: printf(\"nil\"); break; case LUA_TBOOLEAN: printf(lua_toboolean(L, i) ? \"true\" : \"false\"); break; case LUA_TNUMBER: printf(\"%g\", lua_tonumber(L, i)); break; case LUA_TSTRING: printf(\"%s\", lua_tostring(L, i)); break; default: printf(\"%s\", lua_typename(L, t)); &#125; printf(\" \"); &#125; printf(\"\\n\\n\");&#125;int main(void)&#123; lua_State *L = luaL_newstate(); lua_pushboolean(L, 1); lua_pushinteger(L, 100); lua_pushnumber(L, 10.011); lua_pushstring(L, \"hello\"); lua_pushnil(L); stackDump(L); lua_pushvalue(L, 1); //将索引为1的元素压入栈顶 stackDump(L); lua_settop(L, 4); //设置栈顶为4 stackDump(L); lua_insert(L, 3); //移动栈顶元素到3 stackDump(L); lua_replace(L, 3); //将栈顶元素移动到3位置，弹出栈顶元素 stackDump(L); lua_copy(L, 2, 3); //将索引为2的元素复制到3位置 stackDump(L); lua_pop(L, 3); //剩余3个元素出栈 stackDump(L); lua_close(L); return 0;&#125; 编译、运行： 12345678910111213$ cc -o stack_test stack_test.c -I /usr/local/include/ -L /usr/local/lib/ -llua$ ./stack_testtrue 100 10.011 hello niltrue 100 10.011 hello nil truetrue 100 10.011 hellotrue 100 hello 10.011true 100 10.011true 100 100 总结现在，你可以完成一个独立的 Lua 解释器编写工作，并在解释器程序中，运行一些基础的 Lua 脚本程序。你还需要了解 Lua 的栈是什么，如何使用堆栈操作来实现数据操作。下一步，将介绍如何在 C 程序中调用 Lua 脚本。","categories":[{"name":"Lua","slug":"Lua","permalink":"https://veinin.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://veinin.com/tags/Lua/"},{"name":"Lua C API","slug":"Lua-C-API","permalink":"https://veinin.com/tags/Lua-C-API/"}]},{"title":"Java8编程：Streams API","slug":"java-8-streams-api","date":"2017-05-25T16:32:05.000Z","updated":"2017-11-24T16:33:32.406Z","comments":true,"path":"2017/05/26/java-8-streams-api/","link":"","permalink":"https://veinin.com/2017/05/26/java-8-streams-api/","excerpt":"在Java日常编程中，我们使用的最多的API可能是集合了，集合几乎在所有的单元模块中都会出现。而如果使用集合就必须对集合进行处理，往往开发人员可能需要使用循环去进行重复检查处理。为了简化流程，我们使用SQL查询语句进行数据分组来的更加简单。例如： 1SELECT name FROM person WHERE age &gt; 20; 上诉表达式可以快速的帮你找出年龄大于20的人，但当数据量大的时候，类似的处理效率又成了问题，有些开发人员会想到使用多核进行数据处理，缺乏相关经验的Java开发人员却是非常容易编写出错百出的并行处理代码的。流是Java 8引入的一组新API，我们可以使用流像使用SQL语句一样声明性的方式的进行数据处理。此外，使用流还可以在无须编写额外多线程代码的情况下透明的并行处理。","text":"在Java日常编程中，我们使用的最多的API可能是集合了，集合几乎在所有的单元模块中都会出现。而如果使用集合就必须对集合进行处理，往往开发人员可能需要使用循环去进行重复检查处理。为了简化流程，我们使用SQL查询语句进行数据分组来的更加简单。例如： 1SELECT name FROM person WHERE age &gt; 20; 上诉表达式可以快速的帮你找出年龄大于20的人，但当数据量大的时候，类似的处理效率又成了问题，有些开发人员会想到使用多核进行数据处理，缺乏相关经验的Java开发人员却是非常容易编写出错百出的并行处理代码的。流是Java 8引入的一组新API，我们可以使用流像使用SQL语句一样声明性的方式的进行数据处理。此外，使用流还可以在无须编写额外多线程代码的情况下透明的并行处理。 简介什么是流？流不是数据结构，也不保存数据，流只是一些了的算法和计算的操作序列。其定义包含以下几种元素： 元素序列，以顺序方式提供给流的一组数据，流通过这组数据进行处理计算。 源，提供给流的一个数据源，如集合、数组或I/O资源。 聚合操作，流支持使用顺序或并行进行一系列诸如筛选、查找、匹配、分组、截取的聚合元素操作。 流水线，很多流操作会返回另外一个流，这些操作组合起来形成一个流水线。 自动迭代，流在元素上面的迭代操作是内部迭代进行的，流只能被遍历一次。与其相反，我们常用的如for-each操作被称为外部迭代。 本文大部分例子都是一系列的Person类集合操作，代码清单如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Person &#123; private final String name; private final boolean married; private final int age; private final Sex sex; public Person(String name, boolean married, int age, Sex sex) &#123; this.name = name; this.married = married; this.age = age; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public boolean isMarried() &#123; return married; &#125; public int getAge() &#123; return age; &#125; public Sex getSex() &#123; return sex; &#125; public enum Sex &#123;MALE, FEMALE&#125; public enum AgeDistribution &#123;YOUTH, MIDDLE, ELDERLY&#125;&#125;List&lt;Person&gt; persons = Arrays.asList( new Person(&quot;Mathews&quot;, false, 10, Sex.Male), new Person(&quot;Silvia&quot;, true, 30, Sex.FEMALE), new Person(&quot;Veinin&quot;, false, 25, Sex.Male), new Person(&quot;Bales&quot;, true, 60, Sex.FEMALE), new Person(&quot;Baldry&quot;, true, 40, Sex.FEMALE), new Person(&quot;Sims&quot;, true, 55, Sex.Male),); 流操作java.util.stream.Stream接口定义了许多流操作方法，我们把他们分为两大类： 中间操作流，操作完后会返回另一个流Stream&lt;T&gt;，可以跟其他流处理操作连接起来。连接起来的中间操作不会立即执行。| 操作 | 操作参数 | 函数描述符 || :–: | :: | :–: || filter | Predicate | T -&gt; boolean || distinct | | || limit | | || skip | | || map | Function&lt;T, R&gt; | T -&gt; R || sorted | Comparator | (T, T) -&gt; int| 终端操作流，执行所有流水线操作，并关闭流操作生成结果，其结果不是任何流的值，比如Integer、List、Map、Void等。| 操作 | 目的 || :-: | :: || forEach | 消费流中的元素，应用于制定Lambda操作，返回void || count | 返回流操作结果的个数 || collect | 把流操作结果归纳成一个集合 | 中间操作与终端操作结合后，看起来会是这样子： 1234long count = persons.stream() .filter(Person::isMarried) // 中间操作 .limit(3) // 中间操作 .count(); // 终端操作 上面的流操作包含以下元素： 数据源，persons集合 中间操作链，filter与limit构成一条流水线 终端操作, 执行流水线，并调用count生成结果。 构建流创建一个流有许多种方式，大部分需要流操作的对象都有提供构建流的API。但总体来说可以归纳成以下几种： 通过集合生成流，Collection接口提供了一个默认方法 stream() 用来返回一个流对象 Stream&lt;T&gt; ,如果需要并行处理数据，可以通过 paralleStream() 返回一个并行流。 通过值创建流，Stream 接口中提供了 Stream.of(T) 静态方法，也可以通过 Stream.empty() 返回一个空的流对象。 通过数组创建流，静态方法 java.util.Arrays.stream() 可以从数组中创建一个流。如 IntStream stream = Arrays.stream(new int[]{1, 2, 3}) 。 通过文件生成流， java.nio.file.Files 中提供了多个静态方法可以从文件中生成一个流。 创建无限流，所谓无限流，是指不像上面的流创建方法从指定大小的数据源中得到一个流，它通过给定函数创建一个值，并可以永久的执行下去不断产生新值，一般来说我们通过 limit(n) 来限制这种流。Stream 提供了两个静态方法： Stream.iterate 和 Stream.generate 来产生一个无限流。 123456789// 迭代，从0开始，对每次生产的整数n做加1运算，生产10个数后输出。Stream.iterate(0, n -&gt; n + 1) .limit(10) .forEach(System.out::println);// 生成，接受一个Supplier&lt;T&gt;类型的Lambda表达式来提供新值，生产5个值后打印输出Stream.generate(Math::random) .limit(5) .forEach(System.out::println); 使用流筛选Stream 接口提供了 filter() 方法接受一个谓词参数 Predicate&lt;T&gt; ，返回一个包含所有符合谓词筛选条件的元素的流。例如，我们需要筛选所有已婚人士： 123List&lt;Person&gt; marriedPersons = persons.stream() .filter(Person::isMarried) .collect(toList()); 筛选各异元素Stream 还提供了一个 distinct() 的方法，通过调用元素的 hashCode() 和 equals() 方法来实现元素各异的对比，产生一个没有重复值的流。例如，筛选列表中不重复的值： 1234List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 1, 2, 3);numbers.stream() .distinct() .forEach(System.out::println); // 输出 1, 2, 3 截短流Stream.limit(n)、 Stream.skip(n) 可以对筛选过的流元素进行截短， limit 和 skip 是互补的， limit 截取前n个元素，而skip则是跳过前n个元素，如果元素不足，会返回一个空流。 12345678List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);numbers.stream() .limit(2) .forEach(System.out::println); // 输出 1, 2 numbers.stream() .skip(2) .forEach(System.out::println); // 输出 3, 4, 5 映射有时候我们可能需要从某组元素中提取一组特定对象，比如上Person列表中提取每个人的名字。 Stream.map() 方法能满足我们的需求。 map 方法接受一个 Function&lt;T, R&gt; Lambda表达式作为参数。 123List&lt;String&gt; personNames = persons.stream() .map(Person::getName) .collect(toList()); 扁平化流流的扁平化与映射采用一对一映射关系不同，使用 flatMap 会将map映射时生成的单个流都合并起来。假如给你一个 Stream&lt;List&lt;String&gt;&gt; 流，需要生成一个 Stream&lt;String&gt; 流，并且去除重复的 String 元素时， flatMap 就能派上用场。 12345678Stream&lt;List&lt;String&gt;&gt; integerListStream = Stream.of( Arrays.asList(&quot;Mathews&quot;, &quot;Veinin&quot;), Arrays.asList(&quot;Veinin&quot;, &quot;Baldry&quot;), Arrays.asList(&quot;Sims&quot;));Stream&lt;Integer&gt; stringStream = integerListStream .flatMap(Collection::stream).distinct();stringStream.forEach(System.out::println); 输出： 1234Mathews Veinin Baldry Sims 流的查找与匹配对数据处理的常用功能离不开查找与匹配，Stream API提供了对流的查找匹配相关函数： anyMatch，流中是否有一个元素匹配，返回一个boolean值 allMatch，流中的所有元素是否都匹配，返回一个boolean值 noneMatch， 流中没有任何一个匹配的元素，返回一个boolean值 findAny，返回流中的任一一个元素，返回一个Optional对象。 findFirst，返回流中的第一个出现的元素，返回一个Optional对象。 1234567891011121314persons.stream().anyMatch(Person::isMarried); // 是否有已婚人士persons.stream().allMatch(p -&gt; p.getAge() &lt; 20); // 是否所有人都小于20岁persons.stream().noneMatch(p -&gt; p.getAge() &gt; 30); // 是否没有一个大于30岁的人// 找出任一一个已婚人士，如果有则输出persons.stream() .filter(Person::isMarried) .findAny() .ifPresent(System.out::println); // 找出元素序列中的第一个人，如果找到则输出persons.stream() .findFirst() .ifPresent(System.out::println); 关于Optional类Optional 是Java8新引入的一个类，它是一个可以为null值的容器对象。如果值存在， isPresent() 将会返回 true，并可以通过 get() 方法获取到这个值。关于 Optional的设计思想在 Google Guava 代码库中其实早就已经存在了。当我们在调用函数后，其返回值我们无法判断是否为null时，就可以返回一个 Optional&lt;T&gt; 对象，来代替你的返回值，提示调用者，此返回值可能为空。其使用语法大致为这样：1234Optional&lt;String&gt; name = person.getName();if (name.isPresent()) &#123; System.out.println(name.get());&#125; 归纳map 操作是将一组元素映射成一组新的值，而 reduce 操作则是把这些映射过的元素进行组合操作，通过指定运算规则产生另一个结果。如计算一组数值的平均值、最大、最小值，这些操作都可以归类的归纳操作。常用的 归纳 操作包括：sum、min、max、average、count。比如，我们需要对所有人计算年龄和、最大年龄、最小年龄： 1234567891011int totolAge = persons.stream() .map(Person::getAge) .reduce(0, Integer::sum); Optional&lt;Integer&gt; maxAge = persons.stream() .map(Person::getAge) .reduce(Integer::max);Optional&lt;Integer&gt; minAge = persons.stream() .map(Person::getAge) .reduce(Integer::min); reduce 接受两个参数： 初始值 计算用的lambda表达式，类型为BinaryOperator，讲两个元素结合起来，产生一个新值。 数值流基本数据类型操作流对基本数据类型的装箱、拆箱操作是非常耗时的操作。Stream API提供了3种流接口来解决这个问题：IntStream、LongStream、DoubleStream。上面的归纳操作我们可以使用原始数据类型流来优化： 1234567int totalAge = persons.stream() .mapToInt(Person::getAge) // 返回一个 IntStream .sum();OptionalInt maxAge = persons.stream() .mapToInt(Person::getAge) .max(); 数值范围生成流有时我们需要生成一窜制定范围内的数值，并进行相关操作，比如对1-100范围内的数求和，对于这种操作我们可以使用 range 和 rangeClosed， range 对于 rangeClosed 来说， 前者的结束值将不被包含。 12int total = IntStream.range(1, 100).sum(); // 1-99 数值求和int total = IntStream.rangeClosed(1, 100).sum(); // 1-100 数值求和 分组分组是一个常见的数据库操作，在Java 8之前，我们用代码对数据分组很麻烦，并且容易出错。但如果使用Java 8提供的函数式接口 Collectors.groupingBy 这将变得很简单。如我们将人的性别进行分组，传统的Java操作看起来是这样的： 123456789Map&lt;Sex, List&lt;Person&gt;&gt; personBySex = new HashMap&lt;&gt;();for (Person person : persons) &#123; List&lt;Person&gt; personByList = personBySex.get(person.getSex()); if (personByList == null) &#123; personByList = new ArrayList&lt;&gt;(); personBySex.put(person.getSex(), personByList); &#125; personByList.add(person);&#125; 使用 Collectors.groupingBy 后，我们的代码将大大简化： 1Map&lt;Sex, List&lt;Person&gt;&gt; personBySex = persons.stream().collect(groupingBy(Person::getSex)); 有时候，还需要进一步进行多级分组，如除了性别外，我们还需要对年龄分布进行分组，把人分为年轻组、中年组和老年组： 123456789101112Map&lt;Sex, Map&lt;AgeDistribution, List&lt;Person&gt;&gt; personBySex = persons.stream().collect( groupingBy(Person::getSex), groupingBy(person -&gt; &#123; if (person.getAge &lt;= 30) &#123; return AgeDistribution.YOUTH; &#125; else if (person.getAge &lt;= 50) &#123; return AgeDistribution.MIDDLE; &#125; else &#123; return AgeDistribution.ELDERLY; &#125; &#125;) ); 分区分区是分组的一种特殊处理方式，分区函数讲返回一个boolean值，并把元素分为两类（true or false），存储于 Map&lt;Boolean, T&gt; 当中。Collectors.partitioningBy 提供了这种分区功能，如我们需要对已婚、未婚人士分区时： 1234Map&lt;Boolean, List&lt;Person&gt;&gt; partitionedPerson = persons.stream() .collect(partitioningBy(Person::isMarried)); List&lt;Person&gt; marriedPersons = partitionedPerson.get(true); // 获得已婚组 并行流并行流是把一个问题分解成多个子问题，通过多个线程分别处理每个子问题的流。在处理问题的时候，使用并行流，可以充分利用多核CPU的优势，让任务分摊到每个CPU，让所有CPU都忙起来。 求和运算就是个很好的利用并行处理的例子，传统的Java代码看起来是这样的： 1234567public static long sum(long n) &#123; long result = 0; for (int i = 1; i &lt;= n; i++) &#123; result += i; &#125; return result;&#125; 通过流，我们可以简化其操作： 1234public static long sequentialSum(long n) &#123; return LongStream.rangeClose(1L, n) .reduce(0L, Long::sum);&#125; 使用parallel()方法，我们可以把上面的顺序计算的流转换成并行计算的流： 12345public static long parallelSum(long n) &#123; return LongStream.rangeClose(1L, n) .parallel() .reduce(0L, Long::sum);&#125; 高效的使用并行流并不是说任何流操作，当使用并行的时候都会提升性能的，相反，如果使用不当，并行流效率将会大打折扣，甚至效率也会更加底下。例如如果我们使用 Stream.iterator 进行累计并行计算： 123456public static long parallelSum(long n) &#123; return Stream.iterate(1L, i -&gt; i + 1) .limit(n) .parallel() .reduce(0L, Long::sum);&#125; 上面代码运行效率和传统的for循环对比，运行时间可能要慢上几倍，究其原因是因为 iterate 生成的是进行过装箱操作的对象，iterate 操作原理也很难使其分成多个子任务来单独运行。 对于是否并行流操作，可以先考虑一下几个问题： 留意装箱操作，自动装箱、拆箱操作性能将大大降低。 有些操作顺序流天生就比并行流要快，如limit和findFirst操作都依赖于元素顺序。 对于较小的数据量，并行流不是一个好的方式。 考虑流背后的数据结构是否利于分解，如ArrayList拆分效率比LinkedList要高很多。 考虑流水线的中间操作改变分解、合并过程后是否会降低性能。 总结 一个流操作包含数据源、中间操作链和终端操作。 我们可以通过值、集合、数组、文件以及 iterate 和 generate 生成一个流。 使用 filter 、 distinct 、 limit 、 skip 对流进行筛选和切片。 使用 map 和 reduce 进行映射和归纳操作。 使用 anyMatch 、 allMatch 、 noneMatch 进行流匹配操作，使用 findAny 和 findFirst 进行流查找操作。 对于需要装箱、拆箱的流操作，我们可以使用 IntStream 、 DoubleStream 、 LongStream 。 可以用 groupingBy 对流元素进行分组、用 partitioningBy 进行分区。 通过 parallel 我们可以很容易让一个流操作并行化，但是否选择并行流，我们需要考虑很多因素。 参考 Java 8 in Action java2s stackoverflow","categories":[{"name":"Java","slug":"Java","permalink":"https://veinin.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://veinin.com/tags/Java/"},{"name":"Streams API","slug":"Streams-API","permalink":"https://veinin.com/tags/Streams-API/"}]},{"title":"Java 8编程：Lambda表达式","slug":"java-8-lambda","date":"2017-05-20T10:10:23.000Z","updated":"2017-08-25T16:32:39.334Z","comments":true,"path":"2017/05/20/java-8-lambda/","link":"","permalink":"https://veinin.com/2017/05/20/java-8-lambda/","excerpt":"简介Lambda表达式是Java 8中包含的一个新的重要功能。它们提供了一种更加清晰简明的方法通过使用表达式来表示一个方法接口。将代码行为参数化，让代码更好的适应不断变化的需求，减轻程序员的工作量。它完全取代以往的匿名内部类功能，使代码更加简洁、灵活、易懂。此外，新的并发功能能让我们的代码充分利用多核优势。","text":"简介Lambda表达式是Java 8中包含的一个新的重要功能。它们提供了一种更加清晰简明的方法通过使用表达式来表示一个方法接口。将代码行为参数化，让代码更好的适应不断变化的需求，减轻程序员的工作量。它完全取代以往的匿名内部类功能，使代码更加简洁、灵活、易懂。此外，新的并发功能能让我们的代码充分利用多核优势。 匿名内部类简化匿名内部类表达式可以简单的理解为传递匿名函数的一种方式：它没有名称，只有参数列表、函数主体和返回类型。最常见的GUI编程中匿名内部类就经常出现，如使用一个EventHandler来处理Button的响应事件： 123456Button button = new Button(&quot;Send&quot;);button.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; public void handle(ActionEvent event) &#123; label.setText(&quot;Click!&quot;); &#125;&#125;); 使用Lambda表达式取代匿名内部类的话，它看起来会变成这样： 1button.setOnAction((ActionEvent event) -&gt; label.setText(&quot;Click!&quot;)); Lambda表达式语法Lambda表达式通过一行代码来解决了匿名内部类的庞大性，我们可以理解为它解决了匿名内部类的“垂直为题”。 Lambda表达式由三部分组成： 12 参数 箭头 主体(int x, int y) -&gt; x + y 参数列表 ：这里有类型为int的x和y组成 箭头 ：箭头把参数与Lambda主体分隔开 Lambda主体 ：对x和y进行加法运算，并作为返回值返回 Lambda基本语法可以理解为： 123(parameters) -&gt; expression或(parameters) -&gt; &#123;statements;&#125; 使用实例： 12345(int a, int b) -&gt; a * b // 组合两个值 () -&gt; &quot;Veinin&quot; // 返回一个值() -&gt; &#123; return &quot;Veinin&quot;; &#125; // 使用return() -&gt; new Object() // 创建对象 (String name) -&gt; System.out.println(name); // 消费一个对象 在哪里以及如何使用Lambda我们可以在函数式接口中使用Lambda表达式，那么什么是函数式接口呢？函数式接口其实就是定义一个抽象方法的接口。如我们常用的Java API中的Comparator和Runnable接口: 1234567public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125;public interface Runnable &#123; void run();&#125; Lambda允许你直接以内联的形式为函数接口的抽象提供实现，并把整个表达式作为函数式接口的一个实例。我们也可以用匿名内部类来实现相同的功能，但那相对来说说比较笨拙。 Lambda使用函数式接口为了应用不同的Lambda表达式，Java API已经为我们提供了几个函数式接口。比如我们之前熟悉的Comparable、Runnable和Callable。Java 8中也引入了几个新的函数式接口，他们都定义在了java.util.function中。 Functionalinterface注解如果我们去查询新的Java AP，会发现函数式接口通常都会带有@Functionalinterface标注。这个标注表示该接口被设计成了一个函数式接口。如果你使用@Functionalinterface定义一个接口，而它却不是函数式接口的话，编译器将会返回一个提示错误。 Predicatejava.util.function.Predicate 定义了一个test的抽象方法，它接收一个泛型T对象，并返回一个boolean值。在设计需要使用类型T对象的布尔值表达式时，我们可以使用这个接口。如判断String对象是否为空： 1234567891011@(Blog)FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125;Predicate&lt;String&gt; nonEmptyPredicate = (String s) -&gt; s.isEmpty();List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;, &quot;&quot;, &quot;bbb&quot;);for (String str : list) &#123; System.out.println(nonEmptyPredicate.test(str));&#125; Consumerjava.util.function.Consumer 定义了一个accept的抽象方法，返回值为void，顾名思义，该接口可以接受一个对象，消费对象，对其进行某些操作。如打印List里面的所有对象： 1234567891011@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125;Consumer&lt;Integer&gt; forEach = (Integer i) -&gt; System.out.println(i);List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3);for (Integer number : numbers) &#123; forEach.accept(number);&#125; Functionjava.util.function.Function&lt;T, R&gt; 接口定义了一个apply抽象方法，它接收一个参数T，并返回一个R对象。如果你输入了一个对象，并需要把对象映射到其他对象上去，则可以使用该函数接口定义一个Lambda表达式来实现你的功能。 123456789101112131415@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t);&#125;public static &lt;T, R&gt; List&lt;R&gt; map(List&lt;T&gt; list, Function&lt;T, R&gt; f) &#123; List&lt;R&gt; result = new ArrayList&lt;&gt;(); for (T s : list) &#123; result.add(f.apply(s)); &#125; return result;&#125;List&lt;String&gt; strings = Arrays.asList(&quot;aaa&quot;, &quot;bb&quot;);List&lt;Integer&gt; result = map(strings, (String s) -&gt; s.length()); Supplierjava.util.function.Supplier 接口定义了一个get抽象方法，不接受参数，但会返回一个T对象，我们可以把它当做一个工厂方法，返回特定对象。 1234567891011@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; T get();&#125;public static Person produce(Supplier&lt;Person&gt; supp) &#123; return supp.get();&#125; Person person = new Person();Person sPerson = produce(() -&gt; person); 其他函数式接口 UnaryOperator，接收一种类型参数对象，并返回相同的类型的值。描述符为: T -&gt; T BinaryOperator，接收两个相同类型的参数对象，并返回一个同类型的值。描述符为：(T, T) -&gt; T BiPredicate，接收两个类型参数对象，并返回一个boolean值。描述符为：(T, U) -&gt; boolean BiConsumer，接收两个输入参数，没有返回值。描述符为：(T, U) -&gt; void BiFunction，接收两个输入参数，产生一个结果。描述符为：(T, U) -&gt; R 原始数据类型特化Java类型分为两类，一种是引用类型（如Integer、String、List），另外一种是原始数据类型（如int、double、float、byte等）。涉及原始数据类型对引用数据类型的转换时，Java有一个自动装箱机制，比如自动将int类型转换成Integer，反之亦然。 Java 8也特地提供了避免自动装箱操作的相应的类型函数版本。如IntPredicate可以来解决Integer的自动装箱操作： 123456789@FunctionalInterfacepublic interface IntPredicate &#123; boolean test(int value);&#125;IntPredicate evenNumbers = (int i) -&gt; i % 2 == 0;for (int i = 0; i &lt; 1000; i++) &#123; // 避免1000此自动装箱操作 evenNumbers.test(i);&#125; 方法引用方法引用可以重复使用现有的方法，并可以像Lambda一样传递他们。在某些情况下，它比起Lambda表达式来说更加易读，也更加易懂。如下面对人的年龄排序例子： 12persons.sort((Person p1, Person p2) -&gt; p1.getAge().compareTo(p2.getAge())); 使用方法引用和java.util.Comparator.comparing，我们可以进一步简化为： 1persons.sort(comparing(Person::getAge)); 方法引用可以看作为调用特定方法的Lambda的快捷写法。它的基本思想是：如果你使用一个Lambda是直接去调用一个方法，那么最好是用名称来调用，而不是去描述如何调用。使用方法引用，将使你的代码可读性更好。如Person::getAge (注意:不需要括号，因为没有调用此方法) 就是指明引用了Person类中定义的getAge()方法，它实际上是Lambda表达式(Person person) -&gt; person.getAge()的快捷写法。 方法引用分类 静态方法的方法引用 : 如Long::parseLong 任意类型实例方法的方法引用 : 如Stirng::length 现有对象的实例方法的方法引用 : 如person对象的一个getValue方法，写作：person::getValue 构造函数引用对于构造函数，我们可以通过类名称和关键字new来指明一个构造函数引用，如Person::new。如通过一个无参构造函数构造一个Person对象： 12Supplier&lt;Person&gt; sup = Person::new;Person p1 = sup.get(); 等价于 12Supplier&lt;Person&gt; sup = new Person();Person p1 = sup.get(); 如果你的构造函数是Person(Integer age)，那么Funciton函数接口适合它： 12Funciton&lt;Integer, Person&gt; sup = Person::new;Person p1 = sup.get(12); 相应的如果是三个参数，我们还可以使用BiFunciton函数接口。 方法引用例子123(Person person) -&gt; person.getAge() 简化 Person::getAge(String s) -&gt; s.length() 简化 String::length(String s) -&gt; System.out.println(s) 简化 System.out::println 复合使用Lambda表达式Java8中提供的很多函数式接口都提供了允许复合使用Lambda表达式的方法，其复合方法都使用了default关键字标识。 比较器复合在进行排序功能时，如我们需要进行逆序排序，那么我们可使用Comparator函数中提供的reversed来排序： 12345default Comparator&lt;T&gt; reversed() &#123; return Collections.reverseOrder(this);&#125;persons.sort(comparing(Person::getAge).reversed()); 在我们进行排序的同时，如果发现相同的值时，可能需要比较第二个值来进行排序，比如人的年龄相同的话则按身高排序，我们就可以使用符合语句thenComparing来进一步操作： 123persons.sort(comparing(Person::getAge) .reversed() .thenComparing(Person::getHeight)); 谓词复合谓词复合Predicate提供了and、or和negate三个方法，这其实是我们常用的与、或、非操作。如我们需要判断一个人：未婚、年龄在20-25岁之间且职业是程序狗或教师。 123456789Predicate&lt;Person&gt; married = Person::isMarried;Predicate&lt;Person&gt; condition = married.negate() .and((s) -&gt; s.getAge() &gt;= 20) .and((s) -&gt; s.getAge() &lt;= 25) .and((s) -&gt; s.getProfession().equeas(&quot;programmer&quot;)) .or((s) -&gt; s.getProfession().equeas(&quot;teacher&quot;));Person person = new Person(20, false, &quot;programmer&quot;);condition.test(person) 函数复合Funciton接口提供了andThean和compose两个默认方法，可以把Function相关的Lambda表达式复合起来。 1234567Function&lt;Integer, Integer&gt; f = x -&gt; x * x;Function&lt;Integer, Integer&gt; g = x -&gt; x - 1;Function&lt;Integer, Integer&gt; t = f.andThen(g);Function&lt;Integer, Integer&gt; c = f.compose(g);int result = t.apply(2); // 先调用f，然后调用g，输出3int result = c.apply(2); // 先调用c，然后调用f，输出1 总结 Lambda表达式可以理解为一种匿名内部类，它没有名称，只有参数列表、函数主体和返回类型。 只有一个抽象方法的接口我们称之为函数式接口，Lambda表达式与函数式接口配合使用。 Java 8自带了很多函数式编程接口，能满足我们大部分需求，这些函数定义在java.util.function包里面。为了避免Java的装箱操作，大部分通用的函数接口都提供了针对原始数据类型的特定接口。 Lambda表达式可以把行为参数化，我们可以通过参数传递方法引用。 函数式接口很多默认的方法促使我们可以组合Lambda表达式，进行流水线式的操作。 参考 Java 8 in Action java2s Lambda Expressions","categories":[{"name":"Java","slug":"Java","permalink":"https://veinin.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://veinin.com/tags/Java/"},{"name":"Lambda","slug":"Lambda","permalink":"https://veinin.com/tags/Lambda/"}]},{"title":"《代码整洁之道》读书笔记","slug":"reading-notes-clean-code","date":"2017-02-19T03:29:48.000Z","updated":"2017-11-24T16:32:22.255Z","comments":true,"path":"2017/02/19/reading-notes-clean-code/","link":"","permalink":"https://veinin.com/2017/02/19/reading-notes-clean-code/","excerpt":"什么是代码整洁？有多少程序员，可能就会就有多少定义。本书以详细到吓死人的程序告诉你对代码整洁的看法。它会告诉你关于整洁变量名的想法，关于整洁函数的想法，如此等等。它是一本教你如何编出写好程序的书籍。读完后，我们能知道许多关于代码的事，而且，我们还能说出好代码和糟糕代码之间的差异。我们将了解如何写出好代码。我们也会知道，如何将糟糕的代码改写成好代码。","text":"什么是代码整洁？有多少程序员，可能就会就有多少定义。本书以详细到吓死人的程序告诉你对代码整洁的看法。它会告诉你关于整洁变量名的想法，关于整洁函数的想法，如此等等。它是一本教你如何编出写好程序的书籍。读完后，我们能知道许多关于代码的事，而且，我们还能说出好代码和糟糕代码之间的差异。我们将了解如何写出好代码。我们也会知道，如何将糟糕的代码改写成好代码。 有意义的命名取名字最难的地方在于需要良好的描述技巧和共有的文化背景，与其说这是一种技术、商业或管理问题，倒不如说这是一种教学问题。好名字可以提升你的代码可读性，可以让你代码更易维护和重构。 名副其实选好名字要花时间，但省下来的时间比花掉的时间多。注意命名，一旦发现更好的名称，就换掉旧的。这样做，读你代码的人（包括你自己）都会开心。 变量、函数或类名应该能答复所有大问题，它该告诉你，它为什么存在，它做什么事，应该怎么用。如果名称需要用注释来补充，那就不算名副其实。如： 1int d; //消失的时间，以日记 名称d什么都没说嘛，我们应该指明对象和计量单位的名称： 123int elspedTimeInDays;int daysSinceCreation;int fileAgeInDays; 选择体现本意的名称能让人更容易理解和修改。 1234567public List&lt;int[]&gt; getThem() &#123; List&lt;int[]&gt; list1 = new ArrayList&lt;&gt;(); for (int[] x : theList) if (x[0] == 4) list1.add(x); return list1;&#125; 看完上面代码，我们可以产生以下问题： 它是什么东西？ 它有什么意义？ 值4是什么东西？ 它返回列表用来干嘛？ 问问开发它得程序员，程序员可能会说：我们正在开发扫雷游戏，theList是单元格列表，4是一种状态，我们需要从这里获取到关于这种状态的所有值。 当然，我们可以通过询问来读懂代码，但这不值得提倡，我们可以做的更好，只需要简单改下名字，就能轻易知道发生了什么。 1234567public List&lt;int[]&gt; getFlaggedCells() &#123; List&lt;int[]&gt; flaggedCells = new ArrayList&lt;&gt;(); for (int[] cell : gameBoard) if (cell[STATUS_VALUE] == FLAGGED) flaggedCells.add(x); return flaggedCells;&#125; 做有意义的区分如果程序员只是为了满足编译器或解释器两样不同的东西，从而写代码，那就会制造麻烦。以数字系列命名（a1、a2，…aN），这样纯属误导，完全可以提供更加正确信息。 1copyChars(char a1[], char a2[]) 上面函数的参数名称，如果改名为source和distination，这个函数会像样很多。 使用可搜索的名称单字母名称和数字常量有个问题，就是很难在一大片文字中找出来。找MAX_LASSES_PER_STUDEN很容易，但找数字7很难。同样“e”也不是一个便于搜索的好变量名，它是英文中最常用的字母，每个程序、每段代码都可能出现。由此可见，长名称胜于短名称。搜索可得到的名称胜于胡编乱造的名称。 类名和方法名类名和对象一个是名词或短语，如Customer、WikiPage。类名不应该是动词。方法名应当是动词或动词短语，如postPayment、deletePage。属性访问、修改和断言都应根据其值命名，如前缀加上get、set或is。 函数短小函数的第一规则是短小，第二条规则是还要更短小。应该有多短小？它看起来应该是这样子： 123456public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) &#123; if (isTestPage(pageData)) includeSeteupAndTeardownPage(pageData, isSuite); return pageData.getHtml();&#125; 只做一件事一个函数应该做一件事，做好这件事，只做一件事。函数遵循单一权责原则、开放闭合原则。如果函数只做该函数名下的同一抽象层上的步骤，则函数就是只做了一件事。 每个函数一个抽象层级要确保函数只做一件事，那么函数语句都必须在同一抽象层级上。让代码拥有自顶向下的阅读顺序，每个函数后面都跟着下一抽象层级的函数。把函数分为： 高级抽象层 中级抽象层 还有低等抽象层 123getHtml() // 高String pageName = PathParser.render(pagePath)。 // 中.append(\"\\n\") // 低 函数中的语句都要在同一抽象层级上。 函数参数函数参数最理想的数量是零，其次是一，再次是二，应尽量避免三，有足够的特殊理由才能用三个以上参数（所以无论如何都不要这么做）。 一元函数普遍形式单个参数有两种普遍理由，你也许会为关于那个参数的问题，就像： 1boolean fileExists(\"MyFile\") 也可能是操作该参数，将其转换成其他什么东西，再输出之，例如： 1InputStream fileOpen(\"MyFile\") 标识参数标识参数丑陋不堪，向函数传入布尔值简直骇人听闻的做法。比如: render(true)对于可怜的读者来说仍然摸不着头脑，看到 render(Boolean isSuite) 也许稍有帮助，但仍不够，应该一分为二：reanderForSuite() 和 renderForSingleTest() 二元函数两个参数的函数比一元函数难懂。例如writeField(name比writeField(outputStream, name好懂。尽管两种意义都很清楚，但扫一眼就明白还是第一种。应尽量利用一些机制将二元函数转成一元函数，例如 writeField 方法写成 outputStream 的成员之一，比如这样： outputStream.writeField(name。当然，有些时候两个参数刚好。如 Point(0, 0) 笛卡尔点天生就拥有两个参数。 三元函数比二元函数难懂的多，写三元函数前一定要想清楚。设想 assertEquals(message, expected, actual) 有多少次你读到message时错以为expected呢？ 参数对象如果函数看来需要两个、三个或三个以上的参数，就说明其中一些参数应该封装成类了。如: 12Circle makeCircle(double x, double y, double radius);Circle makeCircle(Point center, double radius); 分隔指令与询问函数要么做什么事，要么回答什么事，但二者不可兼得。下面是设置某个属性，返回是否成功的代码语句： 123boolean set(String attribute, String value);if (set(\"username\", \"unclebob\"))... 从读者的角度来说，并不一定能明白set的含义，你可以改名命名为 setAndCheckIfExists，但对if帮助也不大。解决方案是把指令与询问分隔开来： 123if (attributeExists(\"username\")) &#123; setAttribute(\"username\", \"unclebob\");&#125; 抽离try/cache代码块try/cache代码块丑陋不堪，它搞乱了代码结构，把错误处理与正常的流程混为一谈。最好把try和cache代码块的主题部分抽离出来。 函数只做一件事，而错误处理就是一件事。 12345678910public void delete(Page page) &#123; try &#123; deletePageAndAllRefreces(page) &#125; cache (Exception e) &#123; logError(e); &#125;&#125;private void deletePageAndRefrences(Page page) throws Exceptio &#123;&#125; Don’t repeat yourself一次且仅一次（once and only once，简称OAOO）又称为Don’t repeat yourself（不要重复你自己，简称DRY）或一个规则，实现一次（one rule, one place）是面向对象编程中的基本原则，程序员的行事准则。旨在软件开发中，减少重复的信息。DRY的原则是──系统中的每一部分，都必须有一个单一的、明确的、权威的代表──指的是（由人编写而非机器生成的）代码和测试所构成的系统，必须能够表达所应表达的内容，但是不能含有任何重复代码。当DRY原则被成功应用时，一个系统中任何单个元素的修改都不需要与其逻辑无关的其他元素发生改变。此外，与之逻辑上相关的其他元素的变化均爲可预见的、均匀的，并如此保持同步。 – 摘录维基百科 注释请记住，唯一真正好的注释就是你想办法不去写注释。注释的恰当用法是弥补我们用代码表达意图时遭遇的失败。注意，用了“失败”一词。注释总是一种失败。我们总无法找到不用注释就能表达自我的方法。所以要有注释，这并不值得庆贺。 注释不能美化糟糕的代码写注释的动机之一是糟糕的代码存在。我们编写一个模块，发现它令人困扰、乱起八糟，它烂透了！我们告诉自己：“喔，最好写点注释”。与其花时间编写解释你搞出来的糟糕代码的注释，还不如花时间清洁那堆糟糕的代码。 用代码来阐述能用函数或变量时，就别用注释。你愿意看到： 12// Check to see if the employee is eligible for full benifitsif (employee.flags &amp; HOURLY_FLAG &amp;&amp;employee.age &gt; 65) 还是这个？ 1if (employee.isEligibleForFullBenefits()) 只要你想上几秒钟，就能用代码解释你大部分的意图。很多时候，简单到需要创建一个描述与注释所言同一事物的函数即可。 好注释 法律信息，例如版权及著作权。 提供信息的注释，例如描述抽象方法的返回值。 警告，警告其他情况会出现某种后果的注释。 // TODO 注释，解释为什么该函数现在无所作为，将来会怎么用。 公共AIP注释，标准Java库中的javadoc就是一例。 坏注释 多余的注释，如读注释的时间比读代码花的时间还长的注释。 循环式注释，所谓每个函数、每个变量都要有个注释是愚蠢可笑的。这类注释徒然让代码变得散乱，满口胡言，让人迷糊不接。 注释掉的注释，其他人不敢删除注释掉的代码，他们会想，代码依然放在那儿，一定有其原因，而且这段代码很重要，不能删除。注释掉的对堆积在一起，就像破酒瓶底的残渣一样。 日志式注释，冗长的日志式记录只会让模块变得凌乱不堪，版本管理软件完全可以解决。 废话注释，这类注释废话连篇，当代码修改后，这类注释边做了谎言一堆。如果你在写（或粘贴）注释时都没心思，怎么指望读者从中受益。 12345678910111213141516/** The name. */private String name;/** The version. */private String name;/** The name. */ private String info;/** Returns the day of the month* @return the day of the month*/public int getDayOfMonth() &#123; return dayOfMonth;&#125; 格式代码格式很重要，代码格式不可忽略，必须严肃对待。代码格式关乎沟通，而沟通是专业开发者的头等大事。原始代码修改很久之后，其代码风格和可读性仍会影响到可维护性和拓展性。 垂直格式源代码当个文件应该有多大？例举了市面上常见的8个开源项目，其中大多数文件为200行，最长的500行单个文件组合起来就构建了出色的系统。 垂直方向区隔几乎所有代码都是从上往下读，从左往右读。每行展示一个表达式或一个子句，每组代码行展示一条完整的思路。这些思路用个空白行区间隔开。在封包声明、导入声明和每个函数直接用空白行隔开，没一个空白行都是一条线索，标识出新的独立概念。 垂直距离变量声明应该尽可能的靠近其使用位置。实体变量应该房子类的顶部或底部声明。若一个函数调用了另外一个函数，就应该把他们放在一起，而且调用者应该尽可能的放在被调用者上面。这样，程序就自然有序了。你是否曾经在某个类中摸索，从一个函数跳到另外一个函数，上下求索，想要搞清楚他们的关系，最后却被搞糊涂了？ 关系密切的概念应该相互靠近。 变量声明应该尽可能的靠近其使用位置。本地变量应该在函数顶部出现，实体变量一个在类顶部声明。 横向格式遵循无需拖动滚动条到右边原则。虽然近年来显示器屏幕越来越宽，但并不是所以人的显示器都和你一样，普遍来说推荐屏幕单行代码长度为80上限，当然也不用死守这个数值，推荐上限不超过120个字符。 水平方向空格使用使用空格字符将彼此紧密相关的事物联系到一起，也用空格字符把相关性较弱的事物分割开。 赋值操作符左右边、每一个函数参数右边加上空格 不在函数名与左圆括号之间加空格，因为函数与其参数密切相关 算数运算符优先级高的不用空格，优先级低的加空格 123public static double determinant(double a, double b, double c) &#123; return b*b - 4*a*c;&#125; 水平对其应该对其一组声明中的变量名，或一组复制语句中的右值： 1234private Socket socket;private InputStream output;private FileNesseContext context;private boolean hasError; 团队规则每个程序员都有自己喜欢的规则，但如果在一个团队中的工作，就是团队说了算。一组开发者应当认同一种格式风格，每个成员都应该采用那种风格。我们想要软件拥有一以贯之的风格。我们不想让它显得是由一大票意见相左的个人所写成。好的软件系统是由一些列读起来不错的代码文件组成的。它们拥有一致和顺畅的风格。读者要能确信它们在一个源文件中看到的风格在其他文件中也是同样的用法。绝对不要用各种不同的风格来编写源代码，这样会增加其复杂度。 对象和数据结构将变量设置为私有（private）有一个理由：我们不想其他人依赖这些变量。我们还想在心血来潮时能自由修改其类型或实现。 数据抽象隐藏实现并不只是在变量之间放上一个函数层那么简单。隐藏实现关乎抽象！ 类并不简单的用取值器将其变量推向外间，而是暴露抽象接口，以便用户无需了解数据结构的实现就可以操作数据本地。 1234567891011// 具体点public class Point &#123; public double x; public double y;&#125;// 抽象点public interface Point &#123; double getX(); double getY();&#125; 后者代码更佳，抽象的数据存取策略让你不知道该实现是在矩形坐标系中还是在极坐标系中。我们不愿意暴露数据细节，更愿意以抽象形态表述数据。 数据、对象的反对称性过程式代码： 1234567891011121314151617181920public class Square &#123; public Point topLeft; public double side;&#125;public class Rectangle &#123; public Point topLeft; public double height; public double width;&#125;public static double area(Object object) &#123; if (object instanceof Square) &#123; Square S = (Square) object; return s.side * s.side; &#125; else if (shape instanceOf Rectangle) &#123; Rectangle r = (Rectangle) object; return r.height * r.width; &#125;&#125; 在面向对象方案中我们只需要一个area()多态方法，如果添加新形状只需要重新实现指定接口的一个类。 123public interface Shape &#123; double area();&#125; 过程式代码难以添加新数据结构，因为必须修改所有函数。面向对象代码难以添加新函数，因为必须修改所有类。在任何一个复杂的系统中，有需要添加新数据类型而不是新函数的时候，这时对象和面向对象就比较合适。另一方面，当想添加新函数而不是新数据类型的时候，过程式代码更合适。 数据传送对象最为精炼的数据结构，是一个只有公共变量，没有函数的类。这种数据结构对于数据通信传送、解析是非常有用的。在应用程序代码中“豆”（bean）结构对半封装可能会对某些OO纯化论者感觉舒服些，不过通常没有其他好处。 1234567891011public class Address &#123; private String street; public void Address(String street) &#123; this.street = street; &#125; public String getStreet() &#123; return street; &#125;&#125; 往往我们会看到开发者往这类数据结构中塞进业务规则方法，把这类数据结构当做对象来用。这不是理智的行为，业务它导致了数据结构和对象的混杂体。 错误处理别返回null值你是否见过几乎每行代码都在检查null值得应用程序： 123456789public void registerItem(Item item) &#123; if (item != null) &#123; ItemRgister registry = peristentStore.getItemRegistry(); if (registry != null) &#123; Item existing = registry.getItem(item.getId); // ... &#125; &#125;&#125; 这种代码看似不坏，其实糟糕透了！返回null值基本在给自己增加工作量，也是在给调用者添乱。只要有一处没有检查null值，应用程序就会失控。例如对于空指针异常，我们可能在运行时的得到异常，也许有人在代码顶端捕获异常，也可能没有捕获。如果你打算在代码中返回null值，不如抛出异常，或返回特定对象，如Java 8 引入的Optional对象。 别传递null值返回null值是很糟糕的做法，但将null值传递给其他方法就更糟糕。 123public double xProjection(Point p1, Point p2) &#123; return (p2.x - p1.x) * 1.5;&#125; 上面代码如果我们传入null值，将得到一个空指针异常。当然我们也可以在函数里面进行错误处理： 12345public double xProjection(Point p1, Point p2) &#123; assert p1 != null : \"p1 should not be null\"; assert p2 != null : \"p2 should not be null\"; return (p2.x - p1.x) * 1.5;&#125; 看上去很美，但认为解决问题，因为还是会得到运行时异常。最恰当的做法就是禁止传入null值。 单元测试TDD关于TDD相关可以参考文章《TDD并不是看上去的那么美》以及文章中的相关讨论。 整洁的测试有三个要素：可读性、可读性、可读性。单元测试应该和其他代码中一样：明确、简介，还有足够的表达力。测试代码应该竟可能时候的位子表达大量内容。 每一个测试一个断言，或者是单个测试中断言的数量应该最小化。 每个测试一个概念，好测试应该每个测试一个概念，而不是把所有事情都混在一起。 类类的组织类应该从一组变量列表开始，如果有静态变量，一个先出现。然后是私有静态变量，以及私有实体变量。很少会有公共变量。函数紧跟变量列表之后。公共函数调用的私有工具函数紧随该调用函数后面（自顶向下原则）。 类应该短小与函数一样，类的第一原则是应该短小。第二条原则是还要更短小。多小合适呢？对于类来说，采用不同的衡量方法，计算权责。类名应该描述其权责。命名可以用来帮助判断类的长度。类名越含混，该类拥有的权责就越多。 单一权责原则参考维基百科 内聚参考维基百科 Kent Beck关于简单设计的四条原则 运行所有测试 不可重复 表达了程序员的意图 尽可能减少类和方法的数量 以上规则按其重要程度排列 总结习艺只要有二：知和行。你一个学习得到有关原则、模式和实践的知识，穷尽应知之事，并且要对其了如指掌，通过刻苦实践掌握它。学写整洁代码很难。它可不止要求掌握原则和模式。你得在这上面花功夫。你须自行实践，且体验自己的失败。你须观察他人的实践与失败。你须看看别人是怎样蹒跚学步，再转头研究他们的路数。你须看看别人是如何绞尽脑汁做出决策，又是如何为错误决策付出代码。如果你是一个程序员，或你想成为更好的程序员，都推荐你阅读这本书。能编写整洁代码的程序员就像艺术家，他能用一系列变换把一块白板变作由优雅代码构成的系统。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://veinin.com/categories/读书笔记/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://veinin.com/tags/编程/"},{"name":"代码整洁","slug":"代码整洁","permalink":"https://veinin.com/tags/代码整洁/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-02-17T10:10:23.000Z","updated":"2017-03-01T16:07:31.003Z","comments":true,"path":"2017/02/17/hello-world/","link":"","permalink":"https://veinin.com/2017/02/17/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://veinin.com/categories/Hexo/"}],"tags":[]}]}